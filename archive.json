{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2025-01-07T00:12:41.204439+00:00",
  "repo": "decentralized-identity/bbs-signature",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    },
    {
      "name": "current-signature-specification",
      "description": "Issues associated to the current BBS signature specification that previous implementations used",
      "color": "185E2C"
    },
    {
      "name": "ready-for-pr",
      "description": "",
      "color": "CD2B82"
    },
    {
      "name": "dont-merge-yet",
      "description": "",
      "color": "24BAA2"
    },
    {
      "name": "pending-close",
      "description": "",
      "color": "829ED9"
    },
    {
      "name": "core",
      "description": "Associated to the core spec",
      "color": "c5def5"
    },
    {
      "name": "blind-sign-extension",
      "description": "",
      "color": "A46C77"
    },
    {
      "name": "editorial",
      "description": "",
      "color": "E0A022"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "MDU6SXNzdWU5OTUxOTA5Mzg=",
      "title": "Update specification to document the usage of hash 2 curve draft 6",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/1",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "current-signature-specification"
      ],
      "body": "Current implementations of BBS signatures are using hash 2 curve draft 6, this should be noted in the document for those wanting to build interoperable implementations as subsequent revisions of the hash 2 curve draft have been breaking.",
      "createdAt": "2021-09-13T18:20:38Z",
      "updatedAt": "2022-03-21T02:31:36Z",
      "closedAt": "2022-03-21T02:31:35Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@andrewwhitehead",
          "createdAt": "2021-09-13T18:20:54Z",
          "updatedAt": "2021-09-13T18:20:54Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Closing this issue as the draft has moved to documenting the most recent version of the signature scheme rather than the current state of implementations",
          "createdAt": "2022-03-21T02:31:35Z",
          "updatedAt": "2022-03-21T02:31:35Z"
        }
      ]
    },
    {
      "number": 2,
      "id": "MDU6SXNzdWU5OTUxOTM5OTg=",
      "title": "Document the binary formats for cryptographic structures defined by the specification",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/2",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "core"
      ],
      "body": "Within the draft there are several new cryptographic structures that are encoded in binary, their format should be documented to support interoperable implementations, these include\r\n\r\n- ProofOfKnowledge (signature proof)\r\n- Commitment\r\n- Commitment ProofOfKnowledge\r\n- BBS Signature",
      "createdAt": "2021-09-13T18:24:25Z",
      "updatedAt": "2022-05-23T19:56:23Z",
      "closedAt": "2022-05-23T19:56:23Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@andrewwhitehead",
          "createdAt": "2021-09-13T18:24:44Z",
          "updatedAt": "2021-09-13T18:24:44Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "A topic for future discussion is whether to use a structured (e.g CBOR) vs custom binary format, current implementations use a custom binary format however structured solutions like CBOR could be considered for future revisions.",
          "createdAt": "2021-09-13T18:28:59Z",
          "updatedAt": "2021-09-13T18:28:59Z"
        },
        {
          "author": "ChristopherA",
          "authorAssociation": "NONE",
          "body": "I\u2019m hoping you document CBOR versions of these (and not the IPFS version of CBOR). We are increasingly using CBOR in wallet interoperability standards as it allows airgap solutions like UR: \r\n\r\n* https://github.com/BlockchainCommons/crypto-commons#urs\r\n* https://github.com/BlockchainCommons/Research/blob/master/papers/bcr-2020-005-ur.md",
          "createdAt": "2021-10-05T03:12:53Z",
          "updatedAt": "2021-10-05T03:12:53Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think we will want to reference the [pairing-friendly curves](https://www.ietf.org/archive/id/draft-irtf-cfrg-pairing-friendly-curves-10.html#name-zcash-serialization-format-) RFC at least for BLS12-381. It is supposedly undergoing changes to make the draft more normative (and hopefully move beyond a draft). We would probably want to have each profile specify the binary encoding for scalars and group elements for its related pairing-friendly curve, and then define things like the signature binary format on top of that.",
          "createdAt": "2022-01-26T17:29:42Z",
          "updatedAt": "2022-01-26T17:30:04Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "#66 adds a preliminary serialisation format for the signature, however the proof representation is still un-documented",
          "createdAt": "2022-03-21T02:37:47Z",
          "updatedAt": "2022-03-21T02:37:47Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Signatures have been addressed in #66 only outstanding rules are for proofs therefore closing this issue in favour of #153",
          "createdAt": "2022-05-23T19:56:23Z",
          "updatedAt": "2022-05-23T19:56:23Z"
        }
      ]
    },
    {
      "number": 3,
      "id": "MDU6SXNzdWU5OTUyMDE3MDM=",
      "title": "Seperate the message generators from the public key",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/3",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "current-signature-specification"
      ],
      "body": "Currently the specification uses the term \"deterministic public key\" to refer to the underlying public key + message generators required to commit a series of messages to in order to construct a BBS signature signed by an issuer. This association has been found to be confusing and the suggested clarification is to remove the concept of a \"deterministic public key\" and instead just have a public key and a set of message generators with a defined process under which they are generated.",
      "createdAt": "2021-09-13T18:34:21Z",
      "updatedAt": "2022-01-13T01:28:38Z",
      "closedAt": "2022-01-13T01:28:38Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Closing in favour of #19 which has more elaboration on the alternatives to explore",
          "createdAt": "2022-01-13T01:28:31Z",
          "updatedAt": "2022-01-13T01:28:31Z"
        }
      ]
    },
    {
      "number": 4,
      "id": "MDU6SXNzdWU5OTUyMDYxNjM=",
      "title": "Elaborate on background around group signatures",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/4",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Because the concept of a \"group signature\" is a lesser known term in the wider community that uses digital signature technology it would provide a good opportunity for education around some of the novel features of these types of cryptographic schemes provide if the spec included some of this background",
      "createdAt": "2021-09-13T18:40:14Z",
      "updatedAt": "2022-05-23T19:59:19Z",
      "closedAt": "2022-05-23T19:59:18Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@mikelodder7",
          "createdAt": "2021-09-13T18:40:41Z",
          "updatedAt": "2021-09-13T18:40:41Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "There is now sufficient elaboration around the schemes unique properties in the [introduction](https://identity.foundation/bbs-signature/draft-bbs-signatures.html) therefore closing this issue.",
          "createdAt": "2022-05-23T19:59:18Z",
          "updatedAt": "2022-05-23T19:59:18Z"
        }
      ]
    },
    {
      "number": 5,
      "id": "MDU6SXNzdWU5OTUyMDkwMDI=",
      "title": "Change digest algorithm used to SHAKE256",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/5",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "There are three different ways a digest algorithm is used in a BBS Signature\r\n\r\n1. Message generators\r\n2. Doing deterministic signature generation\r\n3. Proof - for the fiat shamir heuristic\r\n\r\nCurrent implementations use BLAKE2B however this is a non-NIST approved digest algorithm making alignment more difficult the suggestion is to shift to using SHAKE256 for the above applications",
      "createdAt": "2021-09-13T18:44:02Z",
      "updatedAt": "2022-02-23T09:32:58Z",
      "closedAt": "2022-02-23T09:32:58Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Addressed via #65 ",
          "createdAt": "2022-02-23T09:32:58Z",
          "updatedAt": "2022-02-23T09:32:58Z"
        }
      ]
    },
    {
      "number": 6,
      "id": "MDU6SXNzdWU5OTUyMTYxMzU=",
      "title": "How to map data to be cryptographically signable",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/6",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Describe the process for how to map abitrary data to be in a sign-able form.\r\n\r\nThe current way in which this is done is the data is hashed and the first 48 bytes are used, this is then reduced to the first sub-group order, _mod Q_.\r\n\r\nIn future there may be new options for this process:\r\n\r\n1. Hash the data (approach depended on #5) take the 64 byte output and then reduce the data to the first sub-group order, _mod Q_.\r\n2. Mapping integers - provides the basis for range proofs\r\n3. Mapping floating point numbers\r\n4. Sortable data, e.g anything that has lexiographical ordering\r\n\r\n@mikelodder7 can provide further details",
      "createdAt": "2021-09-13T18:53:57Z",
      "updatedAt": "2022-02-16T04:42:17Z",
      "closedAt": "2022-02-16T04:42:16Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Closing in favour of #40 which has more details thanks to @mikelodder7 ",
          "createdAt": "2022-02-16T04:42:16Z",
          "updatedAt": "2022-02-16T04:42:16Z"
        }
      ]
    },
    {
      "number": 7,
      "id": "I_kwDOF8lax84781G5",
      "title": "Test vectors",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/7",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "ready-for-pr",
        "core"
      ],
      "body": "In order to facilitate interoperability this specification should contain a set of test vectors for the cryptographic structures defined",
      "createdAt": "2021-09-23T20:06:50Z",
      "updatedAt": "2023-02-24T04:26:17Z",
      "closedAt": "2023-02-24T04:26:17Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Initial test vectors for the signature have been contributed in #67, the remaining will be contributed once the proof serialization is settled.",
          "createdAt": "2022-02-23T21:50:11Z",
          "updatedAt": "2022-02-23T21:50:11Z"
        },
        {
          "author": "tmarkovski",
          "authorAssociation": "MEMBER",
          "body": "Will be fixed with #221 ",
          "createdAt": "2022-10-19T00:20:28Z",
          "updatedAt": "2022-10-19T00:20:28Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Adding a couple of comments here raised from #221 \r\n\r\n- Form of messages in the test vectors is unclear, you must map these to scalar first as they are raw byte strings\r\n- Disclosed message syntax for uses a zero based index which isn't described, other option is to use a 1 based counter as suggested by @christianpaquin ",
          "createdAt": "2022-10-23T19:52:25Z",
          "updatedAt": "2022-10-23T19:52:25Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "The residual work here is to add test vectors for the proof protocol.",
          "createdAt": "2022-12-05T19:31:03Z",
          "updatedAt": "2022-12-05T19:31:03Z"
        }
      ]
    },
    {
      "number": 8,
      "id": "I_kwDOF8lax848HfxV",
      "title": "Crypto agility",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/8",
      "state": "CLOSED",
      "author": "schanzen",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The current draft is partially agnostic to the cryptographic details and in other parts very specific.\r\nFor example, the choice of curve is left open: https://github.com/schanzen/bbs-signature/blob/main/spec.md#choice-of-signature-primitive\r\nBut, the curve is implicitly enforced in https://github.com/schanzen/bbs-signature/blob/main/spec.md#terminology along with other primitives such as the hash functions.\r\nThis will make #7 a bit awkward to fix.\r\n\r\nI guess the specification could be very specific to only define a concrete instantiation or abstract to allow crypto agility.\r\nThe latter may require additional metadata in the objects.\r\n\r\nRelated to #5 as well. Maybe hashfunctions should be harmonized for the initial recommendation/instantiation?",
      "createdAt": "2021-09-27T20:54:15Z",
      "updatedAt": "2022-02-23T09:35:08Z",
      "closedAt": "2022-02-23T09:34:56Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Thanks for raising, I agree along side the hashing algorithm as we discussed on the most recent call the underlying curve used should be left open. Could you elaborate on where in the terminology section this is currently not the case?",
          "createdAt": "2021-09-30T19:45:33Z",
          "updatedAt": "2021-09-30T19:45:33Z"
        },
        {
          "author": "schanzen",
          "authorAssociation": "NONE",
          "body": "Under  https://github.com/schanzen/bbs-signature/blob/main/spec.md#terminology you are defining ```dst```,  ```hash_to_curve_g1```, and ```hash_to_curve_g2``` with a parameter which is tied to BLS12-381: BLS12381G1_XMD:BLAKE2B_SSWU_RO_BBS_SIGNATURES:1_0_0 and BLS12381G1_XMD:BLAKE2B_SSWU_RO, respectively.\r\n\r\nThe ```dst``` parameter should probably be different depending on the used hash and curve and so should the algo for the hash_to_curve.",
          "createdAt": "2021-09-30T20:04:09Z",
          "updatedAt": "2021-09-30T20:04:09Z"
        },
        {
          "author": "schanzen",
          "authorAssociation": "NONE",
          "body": "I guess the question is if the \"BBS+ Signature Scheme\" is supposed look like https://datatracker.ietf.org/doc/html/rfc6979 where you then have specific instantiations in the test vectors: https://datatracker.ietf.org/doc/html/rfc6979#appendix-A.2.5\r\nOr if it should be more like https://www.rfc-editor.org/rfc/rfc8032 where the choice of primitives is taken away (on purpose).\r\nOne could make the argument that the approach of EdDSA is more sensible as implementors will make less errors, but maybe the scheme itself should then also be qualified. Ex: \"The BLS12-381-SHAKE-BBS+ signature scheme\" or similar.",
          "createdAt": "2021-09-30T20:17:57Z",
          "updatedAt": "2021-09-30T20:20:39Z"
        },
        {
          "author": "dlongley",
          "authorAssociation": "NONE",
          "body": "> One could make the argument that the approach of EdDSA is more sensible as implementors will make less errors...\r\n\r\n+1 to this approach.",
          "createdAt": "2021-10-04T21:27:57Z",
          "updatedAt": "2021-10-04T21:27:57Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Yeah +1 being overly cryptographically agile is a security and implementation risk, I would suggest the best middle ground is to position the draft with a single definition of DIGEST_ALGORITHM / HASH_ALGORITHM rather than having the concrete algorithm repeated throughout as it is currently.",
          "createdAt": "2021-10-07T20:09:57Z",
          "updatedAt": "2021-10-07T20:09:57Z"
        },
        {
          "author": "dlongley",
          "authorAssociation": "NONE",
          "body": "Yeah, it's one thing to make sure your core design is flexible and pluggable. It's another thing to surface that flexibility all the way up your stack to implementers/users that can make bad mistakes with the wrong choices. Eliminate choice at those top layers to help protect implementers/users.",
          "createdAt": "2021-10-07T22:15:28Z",
          "updatedAt": "2021-10-07T22:15:28Z"
        },
        {
          "author": "schanzen",
          "authorAssociation": "NONE",
          "body": "The other point I was trying to make is that the \"name\" of the draft is currently very generic \"BBS Signature Scheme\" while what is proposed is actually much more specific. It may be time to give the proposed scheme a dedicated (new) name? My reasoning is that it basically squats the concept of \"BBS+ Signature Schemes\" which may lead to confusion in the future especially of schemes based on other curves pop up.",
          "createdAt": "2021-10-08T08:16:25Z",
          "updatedAt": "2021-10-08T08:16:25Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "> My reasoning is that it basically squats the concept of \"BBS+ Signature Schemes\" which may lead to confusion in the future especially of schemes based on other curves pop up\r\n\r\nI think this is asking another cryptographic agility question here seperate from the selection of the digest algorithm, which is should the draft couple itself to a particular pairing based curve (e.g BLS 12-381). The decision to mandate a particular digest algorithm does not necessarily mean we have to do the same in regards to the curve. Leaving the draft open to new curves makes it more like ECDSA rather than EdDSA in this respect. ",
          "createdAt": "2021-10-10T20:44:14Z",
          "updatedAt": "2021-10-10T20:44:14Z"
        },
        {
          "author": "schanzen",
          "authorAssociation": "NONE",
          "body": "> > My reasoning is that it basically squats the concept of \"BBS+ Signature Schemes\" which may lead to confusion in the future especially of schemes based on other curves pop up\r\n> \r\n> I think this is asking another cryptographic agility question here seperate from the selection of the digest algorithm, which is should the draft couple itself to a particular pairing based curve (e.g BLS 12-381). The decision to mandate a particular digest algorithm does not necessarily mean we have to do the same in regards to the curve. Leaving the draft open to new curves makes it more like ECDSA rather than EdDSA in this respect.\r\n\r\nThe (albeit theoretical) issue I have with \"BBS Signature Scheme\" is that this specifier existed before this (more specific) draft. So if anybody ever writes down \"We are using the BBS Signature Scheme\" it is ambiguous if this refers to any implementation of the proposed scheme from a paper or this specific proposal. On the other hand is is 100% unambiguous if somebody writes ECDSA or EdDSA, respectively. There is only one way to do those, and they can be found in RFCs. The issue is that the draft is using a name which is, essentially, already \"taken\" and that may lead to issues unless this becomes **the** de-facto standard and \"overtaking\" the meaning of \"BBS Signatures\" which cannot be guaranteed.\r\n\r\nTo be more specific:\r\n1. \"BBS Signature\" is defined here: D. Boneh, X. Boyen, and H. Shacham. Short Group Signatures.\r\n2. \"BBS+ Signature\" is defined here: Man Ho Au, Willy Susilo, and Yi Mu. Constant-Size Dynamic k-TAA.\r\n\r\nWhat is written in the draft/specification in this repos is \"XYZ Signature Scheme\" which is _based on a_ BBS (1) or BBS+ (2) signature.\r\n",
          "createdAt": "2021-10-11T10:36:36Z",
          "updatedAt": "2021-10-11T10:56:37Z"
        },
        {
          "author": "schanzen",
          "authorAssociation": "NONE",
          "body": "Just adding here a point raised by @tplooker in today's meeting: The wip draft (#3) conceptually deviates from the one proposed in the papers with respect to the deterministic generation of message commitments. Which makes the draft even more a variation of BBS which uses/proposes the use of nonce values.",
          "createdAt": "2021-10-11T20:31:24Z",
          "updatedAt": "2021-10-11T20:32:36Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "During the delayed call today we discussed taking this draft in the direction of supporting several key cryptographic extension points, e.g \"agile\". And then defining profiles on top which promote interoperable implementations. \r\n\r\nSome of the rational for this was noted through how elliptic curve cryptography was developed, essentially ECDSA when it was developed preceded formal standardisation of particular elliptic curves, hence the need to remain agnostic. Within the sub-field of pairing cryptography we find a similar situation where by multiple curves are showing promise and adoption however innovation and development continue to occur here. Therefore rather than the draft picking one winner, a set of security criteria could be defined that allows different pairing friendly curves to be used.\r\n\r\nGoing in this direction with the draft would mean the follow elements would be abstractly defined\r\n- The hash algorithm\r\n- The pairing friendly curve",
          "createdAt": "2021-11-02T01:40:06Z",
          "updatedAt": "2021-11-02T01:40:06Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@schanzen the direction this draft has taken is to define [ciphersuites](https://identity.foundation/bbs-signature/draft-bbs-signatures.html#name-ciphersuites), the exact format is still a W.I.P, but do you feel this is addressing this issue?",
          "createdAt": "2022-02-15T08:50:29Z",
          "updatedAt": "2022-02-15T08:50:29Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Assuming this issue has now been addressed given an approach has been agreed by the working group as described above, please re-open if you do not feel it has been.",
          "createdAt": "2022-02-23T09:34:55Z",
          "updatedAt": "2022-02-23T09:35:08Z"
        }
      ]
    },
    {
      "number": 10,
      "id": "I_kwDOF8lax8480yF_",
      "title": "Proof of knowledge revealed message structure",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/10",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "pending-close"
      ],
      "body": "Related to #2 \r\n\r\nCurrently the implementations of a BBS proof of knowledge signature includes the encoding of a binary structure at the start of the proof which captures which of the messages being verified and how they correspond to the original ordering of the message set signed. Currently this structure takes the form of a bit array.\r\n\r\nFor example assume the following set of messages were originally signed\r\n\r\n```\r\n[\r\n  \"message1\"\r\n  \"message2\",\r\n  \"message3\",\r\n  \"message4\",\r\n  \"message5\"\r\n]\r\n```\r\n\r\nAnd a proof revealing only the 1st 4th and 5th message was generated, meaning the revealed messages supplied during the verify proof operation would appear in the following order\r\n\r\n```\r\n[\r\n  \"message1\",\r\n  \"message4\",\r\n  \"message5\"\r\n]\r\n```\r\n\r\nThe resulting bit array in the proof would take the following form\r\n\r\n```\r\n+-----------------------------+-----------------------------+---------------------------------+\r\n| Total messages length (16bit)| Revealed messages bit array |..... remaining proof structure |\r\n+-----------------------------+-----------------------------+---------------------------------+\r\n\r\n+-----------+--------------+-----------------------------------+\r\n| 5 (integer) | 1 | 0 | 0 | 1 | 1  | ..... remaining proof structure |\r\n+-----------+--------------+-----------------------------------+\r\n```\r\n\r\nHowever, this mechanism of expression does limit options around the data canonicalisation algorithm that is used on top of the cryptographic scheme. Namely it does not support a re-ordering of the revealed messages away from the order in which they were originally signed. To accomodate this we could instead elect to change the expression of this aspect of the proof from a bit array to a byte/multi-byte array, where instead the array contents is a set of un-signer integers (16bit each) where each integer corresponds to the index the message occupied in the original ordering of the signed message set\r\n\r\nFor example assume the following set of messages were originally signed\r\n\r\n```\r\n[\r\n  \"message1\",\r\n  \"message2\",\r\n  \"message3\",\r\n  \"message4\",\r\n  \"message5\"\r\n]\r\n```\r\n\r\nAnd a proof revealing only the 1st 4th and 5th message was generated, **BUT** the messages in the resulting proof are re-ordered so that they present as 4, 5, 1 \r\n\r\n```\r\n[\r\n  \"message4\",\r\n  \"message5\",\r\n  \"message1\"\r\n]\r\n```\r\n\r\nThe resulting bit array in the proof would take the following form\r\n\r\n```\r\n+-----------------------------+----------------------------------------+-------------------------------+----------------+\r\n| Total messages length (16bit)| Revealed messages array length (16bit) | Revealed messages byte array | remaining proof |\r\n+-----------------------------+----------------------------------------+-------------------------------+----------------+\r\n\r\n+--+--+--------+------------------------------+\r\n| 5  | 3 | 4 | 5 | 1 | ..... remaining proof structure |\r\n+--+--+--------+------------------------------+\r\n```\r\n\r\nThe tradeoff here is that the overhead of this structure is more than in the simpler case with the bit array.\r\n\r\n**NOTE** It is probably also worth considering a more standard structured binary format like CBOR rather than a custom structure ",
      "createdAt": "2021-10-07T21:15:45Z",
      "updatedAt": "2022-05-13T21:56:25Z",
      "closedAt": "2022-05-13T21:56:25Z",
      "comments": [
        {
          "author": "quartzjer",
          "authorAssociation": "NONE",
          "body": "> Namely it does not support a re-ordering of the revealed messages away from the order in which they were originally signed.\r\n\r\nCould you expand on this some? I'm missing the context of why canonicalization would force the messages to be ordered differently, in any approach the original index must be preserved so why can't they be correctly re-ordered before being serialized?",
          "createdAt": "2021-10-07T21:29:33Z",
          "updatedAt": "2021-10-07T21:29:33Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@quartzjer good question, An example is RDF Dataset normalisation, when you have a graph that features several blank nodes, and then you create a sub-graph from this (e.g your sub-set of revealed messages). The ordering of the \"statements\" in the canonical form of the sub-graph can be different to that of the original graph.",
          "createdAt": "2021-10-07T21:47:45Z",
          "updatedAt": "2021-10-07T21:47:45Z"
        },
        {
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@quartzjer its related to graph isomorphism and canonicalization of derived subgraphs... basically, the derive operation is an object transformation... (graph 1 -> graph 2).\r\n\r\n```\r\ngraph 1 -> [messages order that is signed over]\r\ngraph 2 -> [messages order can be different]\r\n```\r\n\r\nThis a problem because of the compact use of hash to point... the order is exploited to make the proof compact... we can't do that with merkle proofs, which is part of why the proof size is so much larger... ",
          "createdAt": "2021-10-07T21:52:20Z",
          "updatedAt": "2021-10-07T21:52:20Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "NONE",
          "body": "That context is helpful and makes sense.  It does still seem a bit odd to me though, adding metadata that doesn't directly impact/support the crypto methods and is intended to work around a limitation of a higher layer.\r\n\r\nMore troublesome though, it also exposes a correlation vector.  How the revealed messages are re-ordered by the canonicalization leaks some information about the original ordering of the non-revealed messages.  It may seem like a small leak, but all leaks can be exploited once you have enough data.",
          "createdAt": "2021-10-07T22:12:15Z",
          "updatedAt": "2021-10-07T22:12:15Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "I think the meta-question here is what constraints does the cryptographic layer impose around what canonicalisation algorithms can be used above it.\r\n\r\n> More troublesome though, it also exposes a correlation vector. How the revealed messages are re-ordered by the canonicalization leaks some information about the original ordering of the non-revealed messages. It may seem like a small leak, but all leaks can be exploited once you have enough data.\r\n\r\nYes this is a valid point, however its important to note its not guaranteed that the algorithm for re-ordering the revealed messages will actually leak information, that aspect IMO could be addressed via privacy/security considerations. ",
          "createdAt": "2021-10-08T01:24:58Z",
          "updatedAt": "2021-10-08T01:24:58Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "NONE",
          "body": "> its not guaranteed that the algorithm for re-ordering the revealed messages will actually leak information\r\n\r\nIt is actually guaranteed, even just simply the fact that they are re-ordered is a leak having nothing to do with the algorithm that does it.  If the issuer and the holder use different ordering, it's a vector to exploit.\r\n\r\n> that aspect IMO could be addressed via privacy/security considerations.\r\n\r\nSure, I just get uncomfortable seeing that adding built-in support for re-ordered indexes increases linkability (if used). ",
          "createdAt": "2021-10-08T15:51:37Z",
          "updatedAt": "2021-10-08T15:51:37Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This issue is only coming about because the input to the signature in this situation is a set of statements with their own independent ordering (the n-quads). To me that seems outside of the scope of the signature method itself, in that it could easily be handled at a higher layer by providing additional input mapping the statement order to the signed message order, or by manually reordering the statements. In fact I did not expect us to define an encoding for the revealed message indices at all, again leaving that up to concrete implementations (the LD-proof in this case).",
          "createdAt": "2021-10-08T16:02:57Z",
          "updatedAt": "2021-10-08T16:02:57Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "This conversation has been great to draw out the different possible design options we can accomodate at the cryptographic layer for BBS signatures.\r\n\r\n1. The structure for a BBS proof of knowledge is defined in a way that it features no information about which of the revealed messages correspond to in the order in which they were originally signed (required to be able to do a verify proof operation). This would mean verify proof would require a new seperate argument to be supplied alongside the public key proof and revealed message set.\r\n2. The structure for a BBS proof of knowledge is defined in a way that features a preceding bit array where each bit of the array indicates where the message was revealed or not. This means the revealed message set MUST be ordered in the same order as it was originally signed (with un-revealed messages simply removed).\r\n3.  The structure for a BBS proof of knowledge is defined in a way that features a preceding byte array, which is essentially the proposal at the start of this issue.",
          "createdAt": "2021-10-10T20:18:07Z",
          "updatedAt": "2021-10-10T20:18:07Z"
        },
        {
          "author": "dlongley",
          "authorAssociation": "NONE",
          "body": "@tplooker,\r\n\r\nIs this issue related at all to a discussion we had about introducing the use of an HMAC key (that remains secret to both the issuer and holder, i.e., never shared with any verifier) that is used to generate blank node IDs prior to signing -- to fully obscure any information about how those IDs were chosen (i.e., no matter how the canonicalization algorithm works, the IDs would appear random to verifiers)?",
          "createdAt": "2021-10-18T15:42:30Z",
          "updatedAt": "2021-10-18T15:42:30Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@dlongley yes more specifically my comment here\r\n\r\n> Yes this is a valid point, however its important to note its not guaranteed that the algorithm for re-ordering the revealed messages will actually leak information, that aspect IMO could be addressed via privacy/security considerations.\r\n\r\nOtherwise in general the issue is discussing more broadly what mechanisms should be at the cryptographic layer vs deferred to higher layers.",
          "createdAt": "2021-10-20T19:06:33Z",
          "updatedAt": "2021-10-20T19:06:33Z"
        },
        {
          "author": "swcurran",
          "authorAssociation": "NONE",
          "body": "Could someone (perhaps @tplooker or @brianorwhatever?) provide an example (the simplest possible) of a JSON-LD VC that cannot be verified using BBS+, annotating it with how the problem manifests? I'm trying to understand the scope of the issue, and especially, the scope in real world use cases.  Is it anytime that nesting is used, or is it a certain pattern of nesting?  How can a non-JSON-LD person understand the impact?\r\n\r\nThanks!",
          "createdAt": "2021-11-17T19:48:44Z",
          "updatedAt": "2021-11-17T19:48:44Z"
        },
        {
          "author": "brianorwhatever",
          "authorAssociation": "NONE",
          "body": "@swcurran I would take a look at @tplooker comment here https://github.com/mattrglobal/jsonld-signatures-bbs/issues/158#issuecomment-945238151 for the most succint description of the problem. My impression is that it is basically going to happen whenever there is nested objects (unsure how many will trigger it) within the `credentialSubject` that don't have an `id` attribute",
          "createdAt": "2021-11-18T00:59:26Z",
          "updatedAt": "2021-11-18T00:59:26Z"
        },
        {
          "author": "swcurran",
          "authorAssociation": "NONE",
          "body": "It's helpful but not an example of the JSON-LD that triggers the issue. However, [your comment in that same issue](https://github.com/mattrglobal/jsonld-signatures-bbs/issues/158#issue-1005912071) has an example.\r\n\r\nAs I understand @tplooker's explanation that [you reference](https://github.com/mattrglobal/jsonld-signatures-bbs/issues/158#issuecomment-945238151), the issue manifests in your credential by the existence of the `recipient` and `vaccine` items with no `id` below them.  Presumably, if you had just one item, or all (or all but one) had an `id`, life would be good. And presumably, anytime there is more than one such item anywhere in the JSON will trigger the problem.\r\n\r\nThat's going to be pretty rough for anyone that wants to use an existing structure as a VC.\r\n\r\n",
          "createdAt": "2021-11-18T01:29:21Z",
          "updatedAt": "2021-11-18T01:29:21Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@swcurran The problem is related to, but not directly caused, by the serialization algorithm (i.e., URDNA). The problem in the example is caused by the way the Holder communicated the indexes of the revealed messages to the Verifier, because it does not account for the fact that the messages received by the Verifier may not be in the same order that the Holder has them (because of URDNA).\r\n\r\nAs an example, let\u2019s say that the Holder has messages `m1`, `m2` and `m3` and creates a proof disclosing only `m2` and `m3`. What was proposed to let the Verifier know what messages are disclosed, is that the Holder will also send the bit array `011` indicating that they have 3 messages and that they disclosed the 2nd and the 3rd one. However, if the Verifier gets the messages as `[m3, m2]` (correct messages, wrong order) they will use `m3` like it was the 2nd Holder\u2019s message and `m2` like it was the third. That miss-match will make the verification fail. \r\n\r\nThe solution however is not to put `id's` to every nested object in the VC (although that could also work). The simple solution is to communicate the indexes of the revealed messages in a way that will account for the case above. One way to do that is instead of the Holder sending the bit array `011` to send the integers list `[3, 2]` which solves that problem.",
          "createdAt": "2021-12-02T11:20:46Z",
          "updatedAt": "2021-12-02T11:20:46Z"
        },
        {
          "author": "swcurran",
          "authorAssociation": "NONE",
          "body": "Thanks.  Agree that what you state is the \"simple solution\", but in reality that means agreeing on the exact simple solution, publishing it as a new signature scheme, updating libraries and then updating the existing applications that use those libraries so that arbitrary JSON-LD can be used. That would suggest a long delay in being able to use of BBS+ credentials for general use cases.  Thus, I agree that adding in IDs is not the correct solution, it is a practical hack that will work for the existing scheme.\r\n\r\nI noticed, for example, that in publishing the BBS+ version of the mDL schema, that approach was used throughout.",
          "createdAt": "2021-12-02T17:41:28Z",
          "updatedAt": "2021-12-02T17:41:28Z"
        },
        {
          "author": "brianorwhatever",
          "authorAssociation": "NONE",
          "body": "do you have a link to the bbs+ mdl schema @swcurran? sounds interesting!",
          "createdAt": "2021-12-02T18:45:51Z",
          "updatedAt": "2021-12-02T18:45:51Z"
        },
        {
          "author": "swcurran",
          "authorAssociation": "NONE",
          "body": "You can follow the chain to see the approach.  Start here: https://digitalbazaar.github.io/vdl-test-suite/ (Manu posted about this in the W3C CCG).  From the examples, the context for a \"vDL\" is https://w3id.org/vdl/v1, which resolves to a chunk of JSON that has just has an id for each attribute in the form of:\r\n\r\n``` jsonc\r\n       ...\r\n        \"family_name\": {\r\n          \"@id\": \"https://w3id.org/vdl#family_name\"\r\n        },\r\n        \"given_name\": {\r\n          \"@id\": \"https://w3id.org/vdl#given_name\"\r\n        },\r\n        \"birth_date\": {\r\n          \"@id\": \"https://w3id.org/vdl#birth_date\"\r\n        },\r\n        ...\r\n```\r\n\r\nI don't know a lot about JSON-LD and perhaps those @id's per attribute are normal.  But I would image they don't contribute much to the semantic understanding (human or machine) of the attributes -- but they do provide an ID.\r\n\r\n",
          "createdAt": "2021-12-02T19:29:18Z",
          "updatedAt": "2021-12-02T19:29:18Z"
        },
        {
          "author": "brianorwhatever",
          "authorAssociation": "NONE",
          "body": "Cool, thanks for the link. I'm also not a JSON-LD expert but I believe an `@id` is more about what the node is semantically vs an identifier (`id`) for the node which is the issue in this instance. See this example https://www.w3.org/TR/json-ld/#example-4-context-for-the-sample-document-in-the-previous-section\r\n\r\nThere's also the `\"@type\": \"@id\"` line which is often seen in contexts and I don't totally understand..",
          "createdAt": "2021-12-02T21:17:44Z",
          "updatedAt": "2021-12-02T21:17:44Z"
        },
        {
          "author": "tmarkovski",
          "authorAssociation": "MEMBER",
          "body": "What are the consequences if the signature specification didn't include any revealed message indexes or how they're encoded, and surrendered that responsibility to higher level application suites, like Linked Data and Jose processors. This neither adds nor removes any (more) leaks from the signature format, it's just makes it less opinionated about attaching information to the signature that isn't signed over anyway. This means each application will have to define how to handle index information and not be constrained by the signature format. I believe this is how the BBS+ LD was initially implemented, but then things got moved into the crypto encoding of the signature mostly for convenience and API design style.",
          "createdAt": "2022-01-20T20:58:51Z",
          "updatedAt": "2022-01-20T21:00:24Z"
        },
        {
          "author": "dlongley",
          "authorAssociation": "NONE",
          "body": "+1 to making the low-level signature specification (RFC dealing with the crypto specifically) not be opinionated about message indexes or how the data is encoded but instead just receive appropriately atomized / ordered data for signing. The next layer up (e.g., Data Integrity BBS+ Signature spec / JWP spec) can define how to consume / transform / canonize / order / atomize / etc. the data that is to be passed to the crypto layer.",
          "createdAt": "2022-01-20T21:54:11Z",
          "updatedAt": "2022-01-20T21:54:11Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Thanks @tmarkovski @dlongley for adding to the conversation I agree with much of the sentiment shared. In an effort to clarify further, listed below are the most relevant hard requirements BBS Signatures as a crypto scheme has that is influential in designing the contract/interface and related data structures for a derived BBS proof.\r\n\r\n- When verifying a derived BBS proof, the verifying party must know the total number of messages that were originally signed when the signature was created.\r\n- When verifying a derived BBS proof, for any revealed messages (messages that the holder or prover wishes to prove were signed by an issuer), the verifying party must know the placement each revealed message occupied in the original set of messages that were signed.\r\n\r\nFrom my understanding of the opinions shared in this issue and also via DIF slack, is that most people are supportive of a proposal where the cryptographic layer has no opinion about the message indexes leaving it to upstream technologies (e.g LD-Proof or JWP) to make this definition. This means the derived BBS proof structure defined by this draft will only describe the direct cryptographic information of the proof.\r\n\r\nGiven that proposal we still need to decide how the contract for verifying a deriveProof should change, for instance the current draft defines\r\n\r\n```\r\nresult = SpkVerify(spk, PK, (msg[i],...,msg[D]), nonce)\r\n```\r\n\r\nwhere D is the number of revealed messages makes the following invalid assumptions\r\n\r\n- spk contains information on the total number of messages originally signed\r\n- spk contains some form of mapping that maps the revealed messages (msg) to their original position in the originally signed message set.\r\n\r\nOne potential proposal would be to change the contract for verifying a derivedProof to something like\r\n\r\n```\r\nresult = SpkVerify(spk, PK, revealedMessages, totalSignedMessages, nonce)\r\n```\r\n\r\nWhere revealed messages is a map of the following structure\r\n\r\n```\r\n{\r\n  1: octet_string_msg_1,\r\n  5: octet_string_msg_5,\r\n  9: octet_string_msg_9,\r\n}\r\n```\r\n",
          "createdAt": "2022-01-21T00:18:18Z",
          "updatedAt": "2022-01-21T00:18:18Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Another option is to retain the total signed messages as a value encoded in to `spk` to reduce the need to manage it externally, however still handle the ordering of the revealed messages in the way described above, meaning the contract would look something more like \r\n\r\n```\r\nresult = SpkVerify(spk, PK, revealedMessages, nonce)\r\n```",
          "createdAt": "2022-01-21T00:22:15Z",
          "updatedAt": "2022-01-21T00:23:01Z"
        },
        {
          "author": "tmarkovski",
          "authorAssociation": "MEMBER",
          "body": "Is `PK` already a function of `totalSignedMessages (L)` (via `PK = DpkToPk(DPK, L)` or `PK = SkToPk(Sk, L)`)? If yes, then encoding it doesn't save much work, since the information would be needed prior to that to construct `PK`.\r\nI like your proposal with `result = SpkVerify(spk, PK, revealedMessages, totalSignedMessages, nonce)` and using a map to unambiguously describe the message input.\r\n\r\nImplementation wise, I think application suites can choose to continue to encode the signature as it is currently, by encoding the total, indexes and proof into a single field, as long as their spec is clear this is the case. That said, we may end up with `signatureValue` in LD proof having different format than signature in JWT, because one chose to encode additional data into the signature. Is this a problem overall?",
          "createdAt": "2022-01-21T13:17:49Z",
          "updatedAt": "2022-01-21T13:18:31Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": ">  That said, we may end up with signatureValue in LD proof having different format than signature in JWT, because one chose to encode additional data into the signature. Is this a problem overall?\r\n\r\nUpon further investigation, the revealed messages re-ordering issue seems to be caused by IDs that are of similar format as the blank node labels IDs. This could have a simple solution (re-sorting after transforming back to blank node labels) that will allow the LD proofs to use a bit array appended to the proof value, as originally proposed [here](https://github.com/w3c-ccg/ldp-bbs2020/issues/22). This can also eliminate the dangers of a correlation because of the re-ordering of the revealed messages.\r\n\r\nThat been said, IMO the bbs+ spec should remain agnostic to the way the indexes of the revealed messages are encoded. This could lead to the proofValue having different formats between implementations; however, IMO this is not a problem. Higher level specs like JWP and LD-proofs will most likely want to use different formats for the revealed message indexes either way, because of the way they work.\r\n",
          "createdAt": "2022-01-21T23:16:40Z",
          "updatedAt": "2022-01-21T23:16:40Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "> Is PK already a function of totalSignedMessages (L) (via PK = DpkToPk(DPK, L) or PK = SkToPk(Sk, L))?\r\n\r\nThanks thats a good call out, which reminded me to file #26 given the resolution to that issue I am suggesting does my proposal make more sense? e.g PK would be an ordinary public key (Note - I release this change impacts several other sections in the draft).\r\n\r\n> Implementation wise, I think application suites can choose to continue to encode the signature as it is currently, by encoding the total, indexes and proof into a single field, as long as their spec is clear this is the case.\r\n\r\nYes I think the point to clarify is that from this drafts perspective any data structure like a reveal indices array would be left to a higher level draft to define.\r\n\r\n> That said, we may end up with signatureValue in LD proof having different format than signature in JWT, because one chose to encode additional data into the signature. Is this a problem overall?\r\n\r\nGiven they are different digital signature representation formats I expect divergence at some level. So long as the core structure of any signature / proof and public key value remains structually the same upstream then I dont think we can prevent additional data structures being wrapped around them? \r\n",
          "createdAt": "2022-01-23T19:43:57Z",
          "updatedAt": "2022-01-23T19:43:57Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "> That been said, IMO the bbs+ spec should remain agnostic to the way the indexes of the revealed messages are encoded. This could lead to the proofValue having different formats between implementations; however, IMO this is not a problem. Higher level specs like JWP and LD-proofs will most likely want to use different formats for the revealed message indexes either way, because of the way they work\r\n\r\n+1 I think much of the different at these representation layers is really due to different approaches to problems like data canonicalization which should remain entirely opaque to the crypto layer (the concern of this draft)",
          "createdAt": "2022-01-23T19:45:57Z",
          "updatedAt": "2022-01-23T19:45:57Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "I think the opinion of the group has evolved sufficiently on this issue to conclude that any higher level serialization rules that accounts for the ordering of the messages required for operations like spkVerify and verify should be left to the application layer, therefore im marking this issue pending close, if others in the WG dis-agree please feel free to comment otherwise it will be closed during the next WG call.",
          "createdAt": "2022-04-21T23:35:25Z",
          "updatedAt": "2022-04-21T23:35:25Z"
        }
      ]
    },
    {
      "number": 11,
      "id": "I_kwDOF8lax8488ZzG",
      "title": "Improve documentation around BBS Signature message generator procedure",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/11",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "The specification currently has limited detail on how an important aspect of existing implementations of BBS associated to this draft works, that is the deterministic generation of what are known as message generators (a name that perhaps should be revisited). \r\n\r\nFor context a message generator is effectively a \"public parameter\" that is used to commit a digested message that will be protected by the resulting BBS signature. All of the message generators for all of the messages are required during sign, verify, deriveProof and verifyProof (even for those messages that remain un-revealed). For implementations of BBS signatures outside / not aligned to this draft, these generators are often communicated out of band or in conjunction with the signature or proof. \r\n\r\nImplementations following this draft however derive these generators via a deterministic process from the public key during the sign, verify, deriveProof and verifyProof operations thus removing the need to manage these generators as additional public parameter information associated to the signature.\r\n\r\nThis technique/procedure should be better documented and discussed by the working group.\r\n\r\nThis issue is also partially related to #10 in the sense that it explains why the revealed messages have to be ordered in reference to how they were signed as this provides the means to associate the correct message to its generator.\r\n\r\n\r\n\r\n\r\n\r\n",
      "createdAt": "2021-10-11T09:21:48Z",
      "updatedAt": "2022-02-16T00:59:31Z",
      "closedAt": "2022-02-16T00:59:31Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "This issue is a double up of #19 closing in favour of that.",
          "createdAt": "2022-02-16T00:59:31Z",
          "updatedAt": "2022-02-16T00:59:31Z"
        }
      ]
    },
    {
      "number": 15,
      "id": "I_kwDOF8lax84_SQWk",
      "title": "Generalize the presentation proof nonce",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/15",
      "state": "CLOSED",
      "author": "christianpaquin",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "ready-for-pr"
      ],
      "body": "The spec currently specifies a presentation nonce to prevent replay attack, and recommends it to be a random value. I suggest we had a few details and requirements around nonce generation, to accommodate various scenarios: \r\n - For replay protections, the nonce only need to be unique, so a verifier identifier + timestamp would work (to create proofs non-interactively).\r\n - If the holder keys are held in hardware that the user only has access for a limited period of time, then making the nonce random prevents the user pre-generating proofs to be used later after the authorized period.\r\n - A BBS+ attribute credential can be used to create a digital signature on some data, disclosing a subset of the attributes. In this case, the nonce can be the digest of the signed data.\r\n\r\nI can create a PR with suggested updates.\r\n\r\n",
      "createdAt": "2021-11-23T22:03:26Z",
      "updatedAt": "2022-03-21T02:35:17Z",
      "closedAt": "2022-03-21T02:35:17Z",
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree with defining requirements around nonce generation. I don\u2019t understand though how the third option prevents replay attacks or pre-generated proofs (could not the adversary replay the presentation of the same disclosed attributes or pre-generate proofs for the whole credential??). I would appreciate if you could explain that part. ",
          "createdAt": "2021-11-24T20:55:48Z",
          "updatedAt": "2021-11-24T20:55:48Z"
        },
        {
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The last point is a different potential use case: digital signature on say, a document, vs. using a BBS+ credential for authn/authz. E.g., Jane is a professional engineer of company A is asked to review and sign off on the design of a project from company B. She does, and uses her work credential with attributes (name, affiliation, level, role, etc.) to sign off the document, and discloses affiliation, level, and role (e.g., \"This was signed by a level 60 engineer from the Cloud group of Company A\"); she does not disclose her name because her company doesn't want the customer to poach their employees. In this case, the challenge `c` is the hash of the document, just like in conventional electronic signatures. There isn't a replay attack in this case; since the attacker would simply present the same signed document with same signature and disclosed attributes.",
          "createdAt": "2021-11-24T21:24:04Z",
          "updatedAt": "2021-11-24T21:24:04Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As a follow up to that issue, after talking with @christianpaquin I realized I had misunderstood the proposed use case. Although there could be a higher layer spec defining credentials for signing documents, I think it would be nice to also have that use case documented in the current spec and recommend a nonce accordingly (Maybe add a nonce generation section in the security considerations??).",
          "createdAt": "2021-11-30T17:41:43Z",
          "updatedAt": "2021-11-30T17:41:43Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed on work item call on the 15th of Dec, @christianpaquin is going to make a PR to address this issue",
          "createdAt": "2021-12-13T19:42:52Z",
          "updatedAt": "2021-12-13T19:42:52Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Addressed in PR #55, closing on that basis",
          "createdAt": "2022-03-21T02:35:17Z",
          "updatedAt": "2022-03-21T02:35:17Z"
        }
      ]
    },
    {
      "number": 16,
      "id": "I_kwDOF8lax84_viyB",
      "title": "Blinded signatures revision",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/16",
      "state": "CLOSED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "As it is right now, the commitment mechanic (blinded signatures) could lead to some inconsistencies and possible forged signatures. For example, if the Issuer signs the messages `m1`, `m2`, a \"standard\" (non-blinded) signature would be, `(A, e, s)` with\r\n\r\n    A = (g0 + h0 * s + h1 * m1 + h2 * m2)*(1/(SK+e))\r\n\r\nIf the Holder commits a message `m3` using `h1`, i.e., \r\n\r\n    commit = h0 * s\u2019 + h1 * m3\r\n\r\nThe blinded signature, created by the Issuer, would be \r\n\r\n    A_blind = (commit + g0 + h0 * s + h1 * m1 + h2 * m2)*(1/(SK+e)) = \r\n      = (g0 + h0 * (s+s\u2019) + h1 * (m1+m3) + h2 * m2) * (1/(SK+e)). \r\n\r\nNotice that `(A_blind, s+s\u2019, e)` is a valid BBS+ signature in the messages `(m1+m3)` and `m2`, which is not the desired outcome and a potential forgery (`A_blind`, `s`, `s\u2019` and `e` are known to the Holder). \r\n\r\nThe main problem is that currently there is no mechanism for the Issuer to validate that the Holder does not create commitments using the same G2 elements as themself (`h1` in the example above). My proposal is (at least for now) to define a blinded signature that would only contain committed from the Holder messages.\r\n",
      "createdAt": "2021-12-02T11:17:26Z",
      "updatedAt": "2021-12-08T10:09:30Z",
      "closedAt": "2021-12-08T10:09:29Z",
      "comments": [
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This is exactly why the commitment proof of knowledge needs to be verified by the issuer prior to creating a signature using the commitment.",
          "createdAt": "2021-12-04T17:13:26Z",
          "updatedAt": "2021-12-04T17:13:26Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thank you for your answer. I had misunderstood BlindMessagesProofGen. I think we should also mention that the Issuer should check that the used generators for the commitment are not also used for the signature, (i don't think it would be obvious to an implementer). I can make a pr for that and i think we can close this issue.",
          "createdAt": "2021-12-08T10:09:29Z",
          "updatedAt": "2021-12-08T10:09:29Z"
        }
      ]
    },
    {
      "number": 19,
      "id": "I_kwDOF8lax85ATa0V",
      "title": "More flexible default generators",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/19",
      "state": "CLOSED",
      "author": "andrewwhitehead",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "At the moment, the default generators are defined using roughly the formula `hash-to-curve(PK || index || count)`, meaning that the generators are dependent on both the public key of the issuer and the number of signed messages.\r\n\r\nThere is also discussion of wanting to use a set of predetermined random generators instead of the default generators, in which case the generators would be independent of both the public key and the number of messages in the signature.\r\n\r\nIn the interest of aligning these approaches somewhat, I think it's worth considering removing the message count from the hash input, so that the default generators depend only on the public key of the issuer. This could have positive effects on performance given that all the generators could be cached up to a maximum number of signed messages.\r\n\r\nThis change might also be relevant in the case of JSON-LD credentials. In order to commit to one or more hidden messages (to implement holder binding for instance) a holder would need to have the relevant message generators. But the total number of messages is often not known at this point in the credential exchange protocol, because the JSON-LD credential itself (including the proof block?) would need to be generated and normalized first. If the generators were independent of the number of messages and the hidden messages were among the first messages (not added to the end) then this would be made possible.",
      "createdAt": "2021-12-13T18:10:00Z",
      "updatedAt": "2022-05-20T19:41:10Z",
      "closedAt": "2022-05-20T19:41:10Z",
      "comments": [
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm fine if we want a different formula. As long as the inputs have sufficient entropy.",
          "createdAt": "2021-12-13T19:20:39Z",
          "updatedAt": "2021-12-13T19:20:39Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Related to #3 ",
          "createdAt": "2022-01-10T19:15:22Z",
          "updatedAt": "2022-01-10T19:15:22Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Another option is for the message generators to be pre generated and shared globally rather than being issuer specific like the proposal above. \r\n\r\nDiscussed on 10th Jan WG call, resolved to add a section to the spec that speaks about message generator creation which will take a seed and output a list of message generators",
          "createdAt": "2022-01-10T19:32:03Z",
          "updatedAt": "2022-01-10T19:32:03Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@andrewwhitehead will provide a PR that defines ^ process",
          "createdAt": "2022-01-10T19:32:27Z",
          "updatedAt": "2022-01-10T19:32:27Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "There was some discussion on the call around a DST for the generators. This is an extra parameter to hash-to-curve (besides the seed and message index used as input) which would separate generators used for different signing algorithms. Currently the draft specifies `BLS12381G1_XMD:BLAKE2B_SSWU_RO_BBS+_SIGNATURES:1_0_0`. I think for the next draft it might be something like `BLS12381G1_XOF:SHAKE256_SSWU_RO_BBS+_SIGNATURES:2022`. This implies that the chosen seed value should not include such information, and might be something trivial like the encoding of the words `message generators` in the common case.",
          "createdAt": "2022-01-10T22:26:07Z",
          "updatedAt": "2022-01-10T22:26:07Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Message generators must NOT be shared globally. They must be unique per public key for the protocol to be secure",
          "createdAt": "2022-01-11T05:21:05Z",
          "updatedAt": "2022-01-11T05:21:05Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "My proposal is to use Shake256(\u201cBBS_Domain_Generators\u201d || pk || count) to seed  the Xof then draw 64 bytes for each generator  and call hash2curve on the 64 bytes. That runs must faster than the current method in Ursa and is more secure",
          "createdAt": "2022-01-11T05:26:00Z",
          "updatedAt": "2022-01-11T05:26:00Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@mikelodder7 can you elaborate on the specific security concern here when using global message generators? This model would be similar to some usages of U-Prove, perhaps you could elaborate @christianpaquin.\r\n",
          "createdAt": "2022-01-11T05:54:36Z",
          "updatedAt": "2022-01-11T05:54:50Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "U Prove is a bad comparison. See  https://eprint.iacr.org/2012/298.pdf from Anna Lysyanskaya which says `UProve is not provably secure! No proof of security has been given under any reasonable assumption; and in fact, recently, Baldimtsi and Lysyanskaya [3] showed that all known approaches for proving security in the random oracle model will fail for the Brands blind signature scheme on which UProve is based, under essentially any assumption.`\r\n\r\nAs for a universal setup for BBS+, I have not seen any formal security proofs for one way or the other. Let me review the literature to see what I can find.",
          "createdAt": "2022-01-11T14:27:03Z",
          "updatedAt": "2022-01-11T14:27:03Z"
        },
        {
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As long as `h0` is different, the other `h_i` could be shared, no? This is not a U-Prove specific construct, this should work for messages built using a Pedersen commitment constructions. BBS+ and, e.g., U-Prove are not equivalent, sure, but these types of protocols have been long studied in the literature, even if there is no formal security proof (ECDSA doesn't have a security proof either...)\r\n\r\n",
          "createdAt": "2022-01-11T14:32:32Z",
          "updatedAt": "2022-01-11T14:32:32Z"
        },
        {
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "To clarify: we indeed need to make sure that the spec remains secure. BBS+ has a security proof, which _is_ a great benefit, so we should be careful to keep that. Camenisch-Drijvers-Lehmann's paper use random generators. Maybe they absolutely need this to prove the security. Maybe the shared generator approach is also secure (in practice), but can't be proven. We'd be stuck with a design choice of provable security vs. efficiency.",
          "createdAt": "2022-01-11T15:09:22Z",
          "updatedAt": "2022-01-11T15:09:22Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We\u2019ll ECDSA does have security proofs by they\u2019re wierd.\r\n\r\nSuppose we have universal generators h_i, if I commit to a value using that it will be the same for all signatures. Think same encryption same key same message problem. This is why AES and CHACHA use nonces to remove this problem. Same key, same message, different nonce means the attacker can\u2019t tell if the same message was encrypted with the same key. Nonce reuse attacks do happen.\r\n\r\nYou raise an interesting point to just have a random h_0. I\u2019ll think about that some more. In general though I still think the generators need to be context specific or domain separated ",
          "createdAt": "2022-01-11T18:30:14Z",
          "updatedAt": "2022-01-11T18:30:14Z"
        },
        {
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It'd be worthwhile to have various academic experts review the v1 spec (when ready), wherever we land. ",
          "createdAt": "2022-01-11T21:43:41Z",
          "updatedAt": "2022-01-11T21:43:41Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "> It'd be worthwhile to have various academic experts review the v1 spec (when ready), wherever we land.\r\n\r\n+1 we will definitely seek broader review when appropriate.\r\n\r\n > To clarify: we indeed need to make sure that the spec remains secure. BBS+ has a security proof, which is a great benefit, so we should be careful to keep that. Camenisch-Drijvers-Lehmann's paper use random generators. Maybe they absolutely need this to prove the security. Maybe the shared generator approach is also secure (in practice), but can't be proven. We'd be stuck with a design choice of provable security vs. efficiency.\r\n \r\n This is IMO is core to conversation here, is the random nature in which the generators are create0d in this paper, core to the security proof, if not is there a provable security benefit in these generators instead being issuer specific (e.g derived from the issuers public key) otherwise the simplest possible implementation would be for them to be global public parameters.",
          "createdAt": "2022-01-11T21:54:20Z",
          "updatedAt": "2022-01-11T21:54:20Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "> In general though I still think the generators need to be context specific or domain separated\r\n\r\n@mikelodder7 is there a security basis you can point to for needing this? Anyway we could clarify with the authors of the Camenisch-Drijvers-Lehmann's paper whether the generators being generated randomly contributes to the security?",
          "createdAt": "2022-01-11T21:57:23Z",
          "updatedAt": "2022-01-11T21:57:23Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Suppose we have universal generators h_i, if I commit to a value using that it will be the same for all signatures. Think same encryption same key same message problem. \r\n\r\nThe bbs+ proof is also randomized even without a nonce (through r1, r2 etc.). Furthermore, the proof that it is zero knowledge does not make assumptions about the generators. The fact that it is zero-knowledge I think can ease those concerns. (not to say that it is not important for the generators to be sufficiently randomized)\r\n\r\nIn literature, it is true that Camenisch, Drijvers and Lehmann have hi as random elements and part of the Issuer\u2019s key but Man Ho Au, Susilo and Yi Mu refer to them as \u201cpublic common parameters\u201d and calculate them in a issuer independent way. In the end, if the generators are sufficiently randomized through a secure hash-function I don't see why any of the proofs will not be holding. But I also agree that care must be taken and contacting the authors seems a greet idea.",
          "createdAt": "2022-01-11T22:12:27Z",
          "updatedAt": "2022-01-11T22:12:27Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "> In the end, if the generators are sufficiently randomized through a secure hash-function I don't see why any of the proofs will not be holding\r\n\r\n@BasileiosKal can you clarify, do you mean so long as the message generators were generated in a sufficiently random manner then they are safe to be re-used across multiple signatures even from different issuers? Or that they must be universally random?",
          "createdAt": "2022-01-11T22:15:37Z",
          "updatedAt": "2022-01-11T22:15:37Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> @BasileiosKal can you clarify, do you mean so long as the message generators were generated in a sufficiently random manner then they are safe to be re-used across multiple signatures even from different issuers? Or that they must be universally random?\r\n\r\nYes my argument is that I think it is safe to reuse generators, as long as they where originally created to be sufficiently random.",
          "createdAt": "2022-01-11T22:36:57Z",
          "updatedAt": "2022-01-11T22:36:57Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I\u2019m not as worried about the proofs as I am the signing. The other proposal from this group is to make signing deterministic which might also impact this.",
          "createdAt": "2022-01-11T22:42:16Z",
          "updatedAt": "2022-01-11T22:42:16Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "> I\u2019m not as worried about the proofs as I am the signing\r\n\r\nIs there a more specific security concern you could elaborate on here?\r\n\r\n> The other proposal from this group is to make signing deterministic which might also impact this.\r\n\r\nAnyway we can improve the understanding of the implications of this? For example does the current proposal for deterministic signatures for BBS mean that using global message generators across signatures is not possible?",
          "createdAt": "2022-01-11T22:53:46Z",
          "updatedAt": "2022-01-11T22:53:46Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@mikelodder7 any follow up here about a specific security concern?",
          "createdAt": "2022-01-18T01:56:16Z",
          "updatedAt": "2022-01-18T01:56:16Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> > I\u2019m not as worried about the proofs as I am the signing\r\n> \r\n> Is there a more specific security concern you could elaborate on here?\r\n\r\n\r\nusing the same generators with signatures could potentially leak the messages signed since the commitments will always be the same. Researching to see if this is as bad as I think it might be or not\r\n\r\n> \r\n> > The other proposal from this group is to make signing deterministic which might also impact this.\r\n> \r\n> Anyway we can improve the understanding of the implications of this? For example does the current proposal for deterministic signatures for BBS mean that using global message generators across signatures is not possible?\r\n\r\nNo we should be able to but it does mean signatures are distinct and unique which cryptographically isn\u2019t a problem but could be correlation risk.",
          "createdAt": "2022-01-18T18:09:28Z",
          "updatedAt": "2022-01-18T18:09:28Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> using the same generators with signatures could potentially leak the messages signed since the commitments will always be the same.\r\n\r\nI'm a bit confused, was it suggested to make the commitments deterministic as well?",
          "createdAt": "2022-01-18T18:33:30Z",
          "updatedAt": "2022-01-18T18:33:30Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It\u2019s true that random and fixed generators are not always equivalent (as shown by this https://eprint.iacr.org/2019/202.pdf paper). However, a takeaway from the paper is that that CDH is just as strong (or even stronger) in cases where a fixed, instead of a random generator, is used. The same result is proven for DL. Wouldn\u2019t that mean that if the sk is sufficiently randomized, the signature will be Indistinguishable from any other element in the group??\r\n\r\nAnother detail is that if we decide to use fixed generators, we should specify that the secret key should not have any dependency to that generator, to avoid problems like in the case of the strong power DDH mentioned in the same paper.\r\n\r\n> No we should be able to but it does mean signatures are distinct and unique which cryptographically isn\u2019t a problem but could be correlation risk.\r\n\r\nWouldn't that be the case even if the generators are not fixed?? If e and s are random, the signatures will be unique. IMO we should add a section to the Security Considerations, saying that the signature should be kept secret to avoid correlation.",
          "createdAt": "2022-01-20T13:53:30Z",
          "updatedAt": "2022-01-20T13:53:30Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "After thinking more about this there may be a potential problem. Pairings make DDH in G1 easy, both in the fixed and in the random generator setting. Furthermore, I think there is a way, using exactly this fact, for an adversary to decide if 2 signatures are on the same messages `mod q`, if a fixed generator is used. \r\n\r\nIf `((P1 + h0*s1 + h[1]*msg1)*(1/(e1+SK)), e1, s1)` and `((P1 + h0*s2 + h[1]*msg2)*(1/(e2+SK)), e2, s2)` are two different signatures on `msg1` and `msg2` respectively (same generators and key, different `e` and `s` values) then the adversary could compute\r\n\r\n```\r\nI1 = e((P1 + h0*s1 + h[1]*msg1)*(1/(e1+SK)), w+P2*e1) * e(-P1 - h0*s1, P2) = \r\n    = e(P1 + h0*s1 + h[1]*msg1, P2) * e(-P1 - h0*s1, P2) => I1 = e(h[1]*msg1. P2)\r\n\r\nI2 = e((P1 + h0*s2 + h[1]*msg2)*(1/(e2+SK)), w+P2*e2) * e(-P1 - h0*s2, P2) = \r\n    = e(P1 + h0*s2 + h[1]*msg2, P2) * e(-g0 - h0*s2, P2) => I2 = e(h[1]*msg2. P2)\r\n```\r\n\r\nAs a result, if I'm not mistaken, the adversary could check if `I1 = I2` to decide if `msg1 = msg2 mod q`, which can correlate the two signatures. Note that the above method only works if there is only 1 message been signed by each signature.\r\n\r\nHowever, we can also prove that an adversary can not extract the message from the signature since such an adversary could be used to solve DL in G1; If the adversary `A` on input a bbs+ signature on the message `m` returns that message, we could just query `A` with `((g0 + h0*s + a)*(1/(e+x)), e, s)` where `a = h[1]*c` is the DL problem we trying to solve. Notice that the query is a valid bbs+ signature on `c` meaning that we will get from `A` the DL of `a` on the basis of `h[1]`, i.e., `c`.\r\n\r\nFor that reason, and the fact that even if we used random generators, there is no proof (currently) that two signatures on the same message couldn't be correlated (for example, if the same method as in the security proof of Lemma 1, in [this](https://eprint.iacr.org/2016/663.pdf) paper, is used to create random generators, the same method as above could be used to decide if `msg1 = msg2 mod q`), IMO the added complexity of using different random generators for each signature is not worth it. In most applications, the signatures will be kept private to avoid correlation either way, while if someone wants to actually use the signature, they will also disclose the signed messages.",
          "createdAt": "2022-01-23T20:28:22Z",
          "updatedAt": "2022-01-24T08:35:00Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@mikelodder7 ^",
          "createdAt": "2022-01-23T21:46:12Z",
          "updatedAt": "2022-01-23T21:46:12Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@BasileiosKal if I understand your analysis correctly, if we do migrate to a construction of a BBS+ signature that is deterministic in nature on purpose due to the benefits it brings, then the ability for a possessor of two BBS signatures issued by the same issuer to know that the same set of messages were signed would become apparent anyway?\r\n\r\nIn general I agree with the thinking that correlation via the signature value is not a concern, this is present with most digital signature schemes anyway (esp those that are deterministic in nature like EdDSA or the deterministic construction for ECDSA). The added anti-correlation mechanisms of BBS+ come via the derived proofs, we should add a section in the privacy considerations that describes this nuance",
          "createdAt": "2022-01-23T22:04:42Z",
          "updatedAt": "2022-01-23T22:04:42Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> if we do migrate to a construction of a BBS+ signature that is deterministic in nature on purpose due to the benefits it brings, then the ability for a possessor of two BBS signatures issued by the same issuer to know that the same set of messages were signed would become apparent anyway?\r\n\r\nYes exactly. IMO this will not have any practical significance, especially since the message itself and the SK will be secure against an attacker. An addition to the security considerations section should suffice.",
          "createdAt": "2022-01-23T23:07:01Z",
          "updatedAt": "2022-01-23T23:07:01Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Overall, I believe this is a good direction. But, I'd like to do formal security proof that default generators in a universal setup are secure. Also, the generator procedure should be able to be done via computation like domain -> shake256 -> hash2curve(index, okm, dst) -> G",
          "createdAt": "2022-01-24T17:16:55Z",
          "updatedAt": "2022-01-24T17:16:55Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> If `((P1 + h0*s1 + h[1]*msg1)*(1/(e1+SK)), e1, s1)` and `((P1 + h0*s2 + h[1]*msg2)*(1/(e2+SK)), e2, s2)` are two different signatures on `msg1` and `msg2` respectively (same generators and key, different `e` and `s` values) then the adversary could compute\r\n> \r\n> ```\r\n> I1 = e((P1 + h0*s1 + h[1]*msg1)*(1/(e1+SK)), w+P2*e1) * e(-P1 - h0*s1, P2) = \r\n>     = e(P1 + h0*s1 + h[1]*msg1, P2) * e(-P1 - h0*s1, P2) => I1 = e(h[1]*msg1. P2)\r\n> \r\n> I2 = e((P1 + h0*s2 + h[1]*msg2)*(1/(e2+SK)), w+P2*e2) * e(-P1 - h0*s2, P2) = \r\n>     = e(P1 + h0*s2 + h[1]*msg2, P2) * e(-g0 - h0*s2, P2) => I2 = e(h[1]*msg2. P2)\r\n> ```\r\n> \r\n> As a result, if I'm not mistaken, the adversary could check if `I1 = I2` to decide if `msg1 = msg2 mod q`, which can correlate the two signatures. Note that the above method only works if there is only 1 message been signed by each signature.\r\n\r\nAs noted, this wouldn't really matter for signatures from a single issuer if deterministic signatures are adopted, however... when the same generators are shared, then it also works for signatures across multiple issuers, regardless of having deterministic signatures.\r\n\r\nThat said, I've been generally assuming that when the signature value itself is revealed (instead of using a ZKP), then all the messages are also expected to be revealed. That would be worth documenting if it is the case.",
          "createdAt": "2022-01-24T17:51:43Z",
          "updatedAt": "2022-01-24T17:52:33Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> But, I'd like to do formal security proof that default generators in a universal setup are secure\r\n\r\n+1. What security properties do we need to prove in the universal default generators setup?? Both the SK and -if my computations where not wrong- the message, are provably secure. On the other hand, the signatures could be correlated. What other security properties should we turn our attention to?",
          "createdAt": "2022-01-24T18:16:02Z",
          "updatedAt": "2022-01-24T18:16:02Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> As noted, this wouldn't really matter for signatures from a single issuer if deterministic signatures are adopted, however... when the same generators are shared, then it also works for signatures across multiple issuers, regardless of having deterministic signatures.\r\n\r\nThat\u2019s a very interesting point. Maybe we should define P2 as issuer specific to avoid this problem (cross-issuer correlation of signatures on the same message)?? Although I do agree that it still does not seem to have enough practical significance to validate the added complexity. Adding to the documentation seems necessary though.",
          "createdAt": "2022-01-24T18:30:18Z",
          "updatedAt": "2022-01-24T18:30:18Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> +1. What security properties do we need to prove in the universal default generators setup?? Both the SK and -if my computations where not wrong- the message, are provably secure. On the other hand, the signatures could be correlated. What other security properties should we turn our attention to?\r\n\r\nFirst, it should be secure in the scenario where multiple issuers are reusing the generators and it shouldn't be possible to know if the same message is signed at the same position. Second, an attacker should not be able to trick a signer by copying the commitments to another signer. I'll try to think of more properties as we go along. The second solution is already partially accounted for by using a blind signature proof of knowledge of committed values. I'm worried about the first scenario for both signing and proving.\r\n",
          "createdAt": "2022-01-24T18:57:11Z",
          "updatedAt": "2022-01-24T18:57:11Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": " > First, it should be secure in the scenario where multiple issuers are reusing the generators and it shouldn't be possible to know if the same message is signed at the same position.\r\n\r\n@mikelodder7 can you elaborate on this more, do you mean by a party that has two signatures from two issuers or two proofs from two issuers? Because I agree if it is the latter but if it is the former, what is the attack vector?\r\n\r\n> Second, an attacker should not be able to trick a signer by copying the commitments to another signer\r\n\r\nIm unsure how universal/global generators would facilitate this deceit?",
          "createdAt": "2022-01-27T02:06:37Z",
          "updatedAt": "2022-01-27T02:07:05Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "At this point generator creation has been mostly reduced to the choice of a seed value. Closing as there are no currently proposed changes.",
          "createdAt": "2022-05-20T19:41:10Z",
          "updatedAt": "2022-05-20T19:41:10Z"
        }
      ]
    },
    {
      "number": 20,
      "id": "I_kwDOF8lax85ATp39",
      "title": "NIZK's must use fiat-shamir hash comparison",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/20",
      "state": "CLOSED",
      "author": "mikelodder7",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "When verifying any NIZK, it is necessary to check if the fiat-shamir heuristics are the same i.e. the challenges.\r\nComparing whether the commitments are the same is not enough. ",
      "createdAt": "2021-12-13T19:22:25Z",
      "updatedAt": "2022-02-16T00:49:50Z",
      "closedAt": "2022-02-16T00:49:50Z",
      "comments": []
    },
    {
      "number": 24,
      "id": "I_kwDOF8lax85BdmyZ",
      "title": "Terminology clarification",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/24",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "core"
      ],
      "body": "Clarify terminology for \r\n\r\nDomain Parameters\r\nGenerators (and their relationship to domain parameters)\r\nGenerators with specific purposes (e.g message generators and blinding factor generators)",
      "createdAt": "2022-01-10T19:20:10Z",
      "updatedAt": "2022-05-23T19:57:43Z",
      "closedAt": "2022-05-23T19:57:42Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "There has been significant work on the terminology throughout this draft therefore closing this issue as it is no-longer relevant.",
          "createdAt": "2022-05-23T19:57:42Z",
          "updatedAt": "2022-05-23T19:57:42Z"
        }
      ]
    },
    {
      "number": 25,
      "id": "I_kwDOF8lax85BeKXa",
      "title": "Variable and function naming",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/25",
      "state": "CLOSED",
      "author": "andrewwhitehead",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "andrewwhitehead"
      ],
      "labels": [
        "core"
      ],
      "body": "The current draft uses the caret and tilde characters in variable naming, as they are in some of the source research. This causes issues with the markdown format of the specification in that it is burdensome and/or impossible to properly escape these characters.\r\n\r\nI don't see any clear standards on variable or function naming in other IETF drafts. Variables may be upper-, lower-, camel-, or snake-cased. Functions can be camel-cased, snake-cased, or kebab-case (ie. `HKDF-Extract`).\r\n\r\nSome suggestions for discussion:\r\n\r\n- name spec-internal variables and functions in snake case unless they represent an initialism (like `DST`) or are commonly capitalized (such as a field `F` or the set of integers `Z`). I think there is a tendency to use capitalized variables for elliptic curve points like `A` in the signature\r\n- name external functions according to their respective standards when possible, for example `hash_to_curve`\r\n- a trailing apostrophe is allowed in variable names, such as `s'` - precedent in hash-to-curve draft for example\r\n- for variables currently using `~` as a suffix use `_b` short for blinding factor\r\n- for variables currently using `^` as a suffix use `_c` short for commitment",
      "createdAt": "2022-01-10T21:53:34Z",
      "updatedAt": "2022-05-20T19:38:56Z",
      "closedAt": "2022-05-20T19:38:55Z",
      "comments": [
        {
          "author": "bumblefudge",
          "authorAssociation": "CONTRIBUTOR",
          "body": "See #17 ",
          "createdAt": "2022-01-24T19:11:41Z",
          "updatedAt": "2022-01-24T19:11:41Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I believe this has been resolved by other issues and PRs.",
          "createdAt": "2022-05-20T19:38:55Z",
          "updatedAt": "2022-05-20T19:38:55Z"
        }
      ]
    },
    {
      "number": 26,
      "id": "I_kwDOF8lax85CRz0I",
      "title": "Conceptually seperate message generators from public key definition",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/26",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "At the moment in the draft a BBS signature public key is defined as an ordinary public key (using the based generator for the curve group) + a set of message generators used for committing messages to a BBS signature. Given the conversation occurring in #19 even if the outcome is to stick with a set of message generators that are derived through a deterministic process from the ordinary public key, I think we should remove the concept of a BBS signature public key and regard message generators as \"public parameters\" instead.",
      "createdAt": "2022-01-23T19:34:47Z",
      "updatedAt": "2022-01-27T18:40:46Z",
      "closedAt": "2022-01-27T18:40:46Z",
      "comments": []
    },
    {
      "number": 27,
      "id": "I_kwDOF8lax85CR1vI",
      "title": "Setup automated tooling for publishing the latest version of the draft",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/27",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "The authors of the [jwp draft](https://github.com/json-web-proofs/json-web-proofs) have done some great work in setting up automation around draft publishing / archiving and diff rendering, we should considering adopting similar technology to facilitate development of the draft.",
      "createdAt": "2022-01-23T20:10:05Z",
      "updatedAt": "2022-01-26T01:00:44Z",
      "closedAt": "2022-01-26T01:00:44Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Addressed with #32 ",
          "createdAt": "2022-01-26T01:00:44Z",
          "updatedAt": "2022-01-26T01:00:44Z"
        }
      ]
    },
    {
      "number": 28,
      "id": "I_kwDOF8lax85CSaB6",
      "title": "Supporting bound BBS signature usecases",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/28",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "As has been discussed before in [related communities](https://github.com/w3c-ccg/ldp-bbs2020/issues/37), the loose intended definition of bound BBS signatures refers to a signature that features a binding to a secret key (private key) possessed by the holder, which is required to be known by the holder in order to derive a proof using the signature. Effectively it is the introduction of a proof of key possession factor to a BBS signature which increases the assurances a relying party or verifier has when presented with a derived proof.\r\n\r\nMechanically this \"feature\" could be realised in multiple ways which affect the scope of this draft:\r\n1. Would be to leverage the blind sign functionality and treat the bound secret key as a blinded message.\r\n2. Would be to doing something more opinionated at the level of this draft introducing the concept of bound signatures and potentially removing the more flexible blind sign functionality.",
      "createdAt": "2022-01-24T03:23:22Z",
      "updatedAt": "2023-05-08T18:19:54Z",
      "closedAt": "2023-05-08T18:19:54Z",
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "IMO if the main use case for blind signatures is for holder binding it may be better to move the blind signature functionality on a extension of the spec to keep the core spec as simple as possible (which IMO will be appreciated by the IETF). Holder binding could be achieved with similar but much simpler mechanisms.",
          "createdAt": "2022-01-24T18:47:21Z",
          "updatedAt": "2022-01-24T18:47:21Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I would definitely be open to making the blind signature support an optional extension. For me it also raises questions about supporting deterministic signatures.",
          "createdAt": "2022-01-24T21:28:11Z",
          "updatedAt": "2022-01-24T21:28:11Z"
        },
        {
          "author": "brentzundel",
          "authorAssociation": "MEMBER",
          "body": "Since the underlying algorithm already natively supports the signing of blinded attributes which may be used for binding the signed data to a holder, it doesn't make sense to me to pursue alternative mechanisms for doing so.",
          "createdAt": "2022-01-25T16:52:58Z",
          "updatedAt": "2022-01-25T16:52:58Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Without a proposal for holder binding done in a more opinionated way, I can see this perspective, however I do think there are simpler options so will put together something more concrete to help inform this discussion.",
          "createdAt": "2022-01-25T20:05:44Z",
          "updatedAt": "2022-01-25T20:05:44Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "NONE",
          "body": "> potentially removing the more flexible blind sign functionality.\r\n\r\nThis would invalidate private linking use-cases, where the holder wants to link different credentials together from multiple issuers without revealing the linkage to them, and can selectively disclose any linkages during presentation as needed.  This looks like binding but is subtly different as both may need to exist separately in such use-cases.\r\n\r\nAlso, blind signing is useful as a private witness where the issuer can sign something the holder wants witnessed without having to reveal the contents.\r\n\r\n",
          "createdAt": "2022-01-25T20:41:16Z",
          "updatedAt": "2022-01-25T20:41:16Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "> This would invalidate private linking use-cases, where the holder wants to link different credentials together from multiple issuers without revealing the linkage to them, and can selectively disclose any linkages during presentation as needed. This looks like binding but is subtly different as both may need to exist separately in such use-cases.\r\n\r\n@quartzjer do you mean general private linking use-cases? like any attribute in common across credential / signatures? As i dont think this invalidates those usecases?\r\n\r\n> Also, blind signing is useful as a private witness where the issuer can sign something the holder wants witnessed without having to reveal the contents.\r\n\r\nAgree with this, but IMO this is really just stating the most general class of usecases that blind sign solves for, is there anything more concrete we could discuss?\r\n\r\nTo be clear im not saying arbitrary blind sign functionality is not useful, just questioning whether we need to standardize that now, vs via an extension later. Because it significantly complicates the current draft. Essentially all the blind sign functionality defines is a pre-protocol for how a holder constructs a commitment representing a set of blinded messages and an issuer verifies this before including it in their issued signature.",
          "createdAt": "2022-01-25T21:20:33Z",
          "updatedAt": "2022-01-25T21:20:33Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think it's also fair to say that even if blind signing is removed from the core spec, we would ensure that it was not made impossible, and the functionality would likely remain in existing implementations.",
          "createdAt": "2022-01-25T21:23:00Z",
          "updatedAt": "2022-01-25T21:23:00Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "+1 @andrewwhitehead exactly",
          "createdAt": "2022-01-25T21:29:31Z",
          "updatedAt": "2022-01-25T21:29:31Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "NONE",
          "body": "> do you mean general private linking use-cases?\r\n\r\nI was speaking to linking of multiple different credentials (by using the same link secret, blinded to multiple issuers).\r\n\r\n> I think it's also fair to say that even if blind signing is removed from the core spec, we would ensure that it was not made impossible, and the functionality would likely remain in existing implementations.\r\n\r\nAhh yes, this I completely understand and agree with, it can definitely be an extension since it is pretty self-isolated. ",
          "createdAt": "2022-01-25T22:00:59Z",
          "updatedAt": "2022-01-25T22:00:59Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "> I was speaking to linking of multiple different credentials (by using the same link secret, blinded to multiple issuers).\r\n\r\nOk great the proposal made in this issue would not eliminate that capability. As said above we are really just talking about the pre-protocol around blinding messages for an issuer to sign.",
          "createdAt": "2022-01-25T22:06:32Z",
          "updatedAt": "2022-01-25T22:06:32Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Related to #37 ",
          "createdAt": "2022-02-23T09:35:50Z",
          "updatedAt": "2022-02-23T09:35:50Z"
        },
        {
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Rehydrating this discussion for a fresh new year :) As discussed on today's meeting, this group should make a recommendation on how to achieve user/holder binding in a uniform way to support credential profiles in various groups of interest (e.g., JWP, VC, anoncred). Sounds like next step involves creating a skeleton plan of what's needed to achieve this: update blind sig spec, and explain how to use it to bind a user-controlled secret to a BBS sig.\r\n\r\n(tagging meeting attendees, FYI; @brentzundel , @BasileiosKal, @andrewwhitehead, @tmarkovski)",
          "createdAt": "2023-01-09T20:12:11Z",
          "updatedAt": "2023-01-09T20:12:11Z"
        },
        {
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I am here to confirm that the current IETF drafts have no support for holder binding, and not timeline for adding it.\r\n\r\nIs this correct?\r\n\r\nThe reason ask is the VCWG will not be commenting on anything that is not supported by the CFRG drafts, and as an editor of https://github.com/w3c/vc-di-bbs\r\n\r\nI will be pushing to remove any mention of \"linked secrets / holder binding\" starting right now, based on my current understanding of the supported features in the draft.\r\n\r\n",
          "createdAt": "2023-04-21T15:16:52Z",
          "updatedAt": "2023-04-21T15:16:52Z"
        },
        {
          "author": "tmarkovski",
          "authorAssociation": "MEMBER",
          "body": "This is my understanding, yes. The [Blind Signatures extension](https://identity.foundation/bbs-signature/draft-blind-bbs-signatures.html) is not a CFRG draft and I don't believe a timeline has been set.",
          "createdAt": "2023-04-22T12:48:40Z",
          "updatedAt": "2023-04-22T12:48:40Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeap! That's my understanding as well! Holder binding will be out of scope for the current core CFRG draft.\r\n\r\nThat said, there is definitely interest in the WG to create separate documents describing that functionality (either updating the Blind Signatures document or creating a separate one just for Holder Binding).\r\n\r\nAs far as timelines go, there is non. However, i think the hope is that after the next IETF, the core draft will be stable enough so we can start working on those extensions (that will hopefully also be submitted to the CFRG).",
          "createdAt": "2023-04-22T14:33:00Z",
          "updatedAt": "2023-04-22T14:33:00Z"
        },
        {
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'd be interested in seeing progress before the next IETF meeting. Even in draft form, a proposal we feel comfortable with could help shape things for potential integrators. I'm not a BLS/pairing expert, so it's not something I can lead, but I'd be interested in prototyping a proposal.",
          "createdAt": "2023-04-23T00:10:36Z",
          "updatedAt": "2023-04-23T00:10:36Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "FYI: posted a draft document on Holder binding in #262",
          "createdAt": "2023-04-30T20:18:48Z",
          "updatedAt": "2023-04-30T20:18:48Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Closing as duplicate of #262, where we can continue the conversation.",
          "createdAt": "2023-05-08T18:19:54Z",
          "updatedAt": "2023-05-08T18:19:54Z"
        }
      ]
    },
    {
      "number": 29,
      "id": "I_kwDOF8lax85CSaUd",
      "title": "Supporting use cases for blind signing",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/29",
      "state": "OPEN",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "blind-sign-extension"
      ],
      "body": "Currently the spec documents a procedure for constructing BBS signatures where by some / all of the messages signed by the signer are unknown to them. This issue is to discuss the usecases for this feature and whether it should remain in scope for the core spec of whether it could be added in the form of a seperate extension specification. The tradeoff being that electing to keep blind signing in scope significantly increases deliverables for the spec in the form of multiple cryptographic operations and data structures.\r\n\r\nNote - related to this is a discussion on how we should handle \"bound\" bbs signatures captured in issue #28",
      "createdAt": "2022-01-24T03:25:08Z",
      "updatedAt": "2022-04-21T23:31:56Z",
      "closedAt": null,
      "comments": [
        {
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "When BBS+ is used to create an anonymous credentials (messages are user attributes), then there are some interesting use cases. For example, the duty of the issuer (BBS+ signer) could be performed by two entities in a federation: an attribute provider (knows the user attribute) and an issuer (secure machine holding the crypto keys), and perhaps you don't want to leak the attribute values to the issuer, but it trusts the attribute provider to set the values. Another example is to carry-over attributes from one credential to another: say the credential contains a user-ID, never disclosed but used for non-revocation proofs. A new credential could be issued or linked to another one by copying the attribute value over; a revocation would then invalidate both credentials.\r\n\r\nSimplifying the spec is an important goal; the various signing algs are confusing to a new reader. It would be great to achieve this functionality through an extension. FWIW, that's what with did for U-Prove using the [collaborative issuance extension](https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/U-Prove20Collaborative20Issuance20Extension.pdf). See also this [white paper](https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/U-Prove20extensions20paper.pdf) for more background on the feature, including more details of the scenarios described above.",
          "createdAt": "2022-01-28T03:24:32Z",
          "updatedAt": "2022-01-28T03:24:32Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Thanks @christianpaquin this is awesome context both the usecase and the example of the model you took to accomodate it  in U-Prove.\r\n\r\nIf we simply removed sections 3.7-3.11 I believe they could form part or most of the extension to do this. Provided we have an alternative proposal for holder binding such as proposed by #37 ",
          "createdAt": "2022-01-28T04:00:15Z",
          "updatedAt": "2022-01-28T04:02:40Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Another example is to carry-over attributes from one credential to another: say the credential contains a user-ID, never disclosed but used for non-revocation proofs. A new credential could be issued or linked to another one by copying the attribute value over; a revocation would then invalidate both credentials.\r\n\r\nVery interesting use cases. Is the idea here for the holder to send a commitment with the user-ID to a new issuer? If so, how the second issuer can be sure that the holder committed to the correct user-ID (also contained in the first credential)?\r\n\r\n> an attribute provider (knows the user attribute) and an issuer (secure machine holding the crypto keys), and perhaps you don't want to leak the attribute values to the issuer, but it trusts the attribute provider to set the values. \r\n\r\nAlso would in this case be necessary for the whole procedure of blind signatures to be followed (which also involves creating Schnorr proofs about the knowledge of the attributes and the correctness of the commitment)? If the requirement is only for information to not be leaked, wouldn't just the Pedersen commitment suffice? If that is the case, maybe we should define the blind messages nizk creation and verification as optional, to support that use-case.",
          "createdAt": "2022-01-28T10:55:19Z",
          "updatedAt": "2022-01-28T11:58:44Z"
        },
        {
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "body": " \r\n> Is the idea here for the holder to send a commitment with the user-ID to a new issuer? If so, how the second issuer can be sure that the holder committed to the correct user-ID (also contained in the first credential)?\r\n\r\nYes. Conceptually, the holder creates a presentation proof with a commitment, showing that the undisclosed attribute is the same as in its credential; after validation by the issuer, the commitment can be integrated in the new credential. The U-Prove extension above shows how to do that for Brands' credentials; the details would be slightly different for a BBS+ based credential. An analysis is required to answer the questions you raised. Bottom line, it's not a trivial thing and perhaps this justifies specifying this functionality outside of the core spec (making sure however it has the right hooks for extensions).",
          "createdAt": "2022-01-28T14:37:15Z",
          "updatedAt": "2022-01-28T14:37:58Z"
        }
      ]
    },
    {
      "number": 30,
      "id": "I_kwDOF8lax85CbKCy",
      "title": "Naming of the draft BBS vs BBS+",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/30",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "I propose we rename the draft to \"The BBS Signature Scheme\" and elect to drop the + from all mentions of BBS. Through appropriate citations of the academic work I think we can still achieve the right level of association to the schemes origins. The rationale for dropping the + is that in many visible places that character is not allowed (e.g naming repositories, naming packages and programming language syntax)",
      "createdAt": "2022-01-25T22:14:16Z",
      "updatedAt": "2022-01-26T00:52:59Z",
      "closedAt": "2022-01-26T00:52:58Z",
      "comments": [
        {
          "author": "quartzjer",
          "authorAssociation": "NONE",
          "body": "I definitely support this :+1:.",
          "createdAt": "2022-01-25T22:23:33Z",
          "updatedAt": "2022-01-25T22:23:33Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Addressed in #32 there was only two minor inconsistencies in the draft already that have been addressed",
          "createdAt": "2022-01-26T00:52:58Z",
          "updatedAt": "2022-01-26T00:52:58Z"
        }
      ]
    },
    {
      "number": 31,
      "id": "I_kwDOF8lax85CbLrn",
      "title": "Remove KeyGen definition",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/31",
      "state": "CLOSED",
      "author": "andrewwhitehead",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "core"
      ],
      "body": "This may be defined as a property of the profile along with details of the pairing-friendly curve in use. For BLS curves it probably makes sense to reference the BLS Signatures IETF draft (hopefully that is getting an update?).",
      "createdAt": "2022-01-25T22:23:33Z",
      "updatedAt": "2022-05-13T21:55:19Z",
      "closedAt": "2022-05-13T21:55:19Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "For reference the draft is located here https://github.com/cfrg/draft-irtf-cfrg-bls-signature",
          "createdAt": "2022-01-26T09:12:35Z",
          "updatedAt": "2022-01-26T09:15:14Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "In particular this section https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-bls-signature-04#section-2.3",
          "createdAt": "2022-01-26T09:16:06Z",
          "updatedAt": "2022-01-26T09:16:06Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Depending on the outcome of #87 if this is merged then we can close this as the definition for key gen in the spec has diverged from BLS signatures",
          "createdAt": "2022-03-21T02:29:15Z",
          "updatedAt": "2022-03-21T02:29:15Z"
        },
        {
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Following the discussion in the 4/4/2022 call, I agree the spec should allow implementers to use random keys; the currently proposed implementation could be move to an appendix or a profile.",
          "createdAt": "2022-04-04T19:03:02Z",
          "updatedAt": "2022-04-04T19:03:02Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Agree with @christianpaquin, to provide further context the spec is currently not clear that the exact KeyGen operation defined is not required by implementations and instead they are free to generate keys in other ways if they wish.",
          "createdAt": "2022-04-04T21:28:03Z",
          "updatedAt": "2022-04-04T21:28:03Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Either a note at the top of this operations definition or shifting it to an appendix is likely the way we will resolve this",
          "createdAt": "2022-04-04T21:28:48Z",
          "updatedAt": "2022-04-04T21:28:48Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "I think given there are a couple of deviations from the BLS signature spec such as the salt keeping this definition in this spec feels like the most accomodating solution? If we agree can this issue be closed?",
          "createdAt": "2022-04-21T19:58:47Z",
          "updatedAt": "2022-04-21T19:58:47Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@andrewwhitehead",
          "createdAt": "2022-04-21T19:59:03Z",
          "updatedAt": "2022-04-21T19:59:03Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, I think that's fine. We probably ought to reference the BLS signature draft since it's a straight copy.",
          "createdAt": "2022-04-22T16:52:28Z",
          "updatedAt": "2022-04-22T16:52:28Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Closing this issue based on the consensus above, we can round back to appropriate referencing of prior art one these operation definitions have settled a little more",
          "createdAt": "2022-05-13T21:55:19Z",
          "updatedAt": "2022-05-13T21:55:19Z"
        }
      ]
    },
    {
      "number": 33,
      "id": "I_kwDOF8lax85CbhY5",
      "title": "Consider renaming nonce in the proof to presentation message",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/33",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "As discussed in the WG call on the 24th of Jan, the usage of the term nonce was found to confuse reviewers of #21, upon discussing this the suggestion was to potentially rename this to presentation message as was the case with uProve. This is to convey the structure we are talking about may not be limited to being used as just a cryptographic nonce, instead it may be used to convey other information accompanying the proof generated",
      "createdAt": "2022-01-26T00:54:36Z",
      "updatedAt": "2022-01-28T00:38:06Z",
      "closedAt": "2022-01-28T00:38:06Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Fixed in #36",
          "createdAt": "2022-01-28T00:38:06Z",
          "updatedAt": "2022-01-28T00:38:06Z"
        }
      ]
    },
    {
      "number": 34,
      "id": "I_kwDOF8lax85CbiGG",
      "title": "Add documentation on how contributors can build the HTML / TXT version of spec locally",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/34",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "help wanted"
      ],
      "body": "Requires users to have make installed, list commands and add to a contributors document in the repository",
      "createdAt": "2022-01-26T01:00:19Z",
      "updatedAt": "2022-05-05T00:57:55Z",
      "closedAt": "2022-05-05T00:57:55Z",
      "comments": [
        {
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'll suggest some text to the main page README.",
          "createdAt": "2022-05-04T14:43:51Z",
          "updatedAt": "2022-05-04T14:43:51Z"
        }
      ]
    },
    {
      "number": 37,
      "id": "I_kwDOF8lax85CkCkW",
      "title": "Holder Binding",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/37",
      "state": "CLOSED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Currently the spec is missing a way to bind a signature to a user. The proposal from [here](https://github.com/w3c-ccg/ldp-bbs2020/issues/37) is to use BLS keys. Essentially the process will be the following,\r\n\r\n1. User creates BLS keys i.e., BLS_SK and BLS_PK in G1 (`BLS_PK = P * BLS_SK `) where `P` a point in G1\r\n2. The Issuer will use the BLS_PK of the user as a commitment i.e.,\r\n```\r\nA = (P1 + BLS_PK + h0 * s + h[1] * msg[1] + h[2] * msg[2] + \u2026 + h[L] * msg[L]) * (1/(e + x))\r\n```\r\n3. The user will have to know BLS_SK to derive a BBS+ proof creating the binding. \r\n\r\nAn issue is what base points to use i.e., `P` (base point for use with BLS) and `P1` (base point for use with BBS+). Those points need to be different. A choice is to use `P` as defined by the [BLS signatures spec](https://datatracker.ietf.org/doc/draft-irtf-cfrg-bls-signature/), which is the base point of G1 as defined from the [pairing-friendly-curves-draft](https://datatracker.ietf.org/doc/draft-irtf-cfrg-pairing-friendly-curves/) spec.\r\n\r\nThe advantage is that BLS will most likely use the base point as defined by the pairing-friendly-curves spec, so we will be in spec when it comes to BLS keys. The negative is that we will need to define a different base point for BBS+ (i.e, `P1`). My proposal is to just use `P1 = P*2`. Another option is to use a random point in G1 as the base point for BBS+ if there is some security reason to do so.",
      "createdAt": "2022-01-27T21:14:25Z",
      "updatedAt": "2023-05-08T18:24:57Z",
      "closedAt": "2023-05-08T18:24:56Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "To be clear this proposal would yield a couple of use-ability benefits\r\n\r\n1. The commitment required by the issuer of the BBS signature to construct a bound variant is just an ordinary public key in G1, so no need to standardise the representation of new cryptographic information\r\n2. The pop mechanism used by a holder to proove to an issuer they possess the private key associated to the supplied public key for binding becomes just an ordinary BLS signature, so no need to standardise the representation of new cryptographic information here and a protocol to support it (e.g creating some form of POP and verifying it) ",
          "createdAt": "2022-01-28T00:45:31Z",
          "updatedAt": "2022-01-28T09:30:19Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Together with this in place if agreed I think would allow us to remove the more general blind sign API from the core draft if we fail to find substantive use cases justifying its presence, discussed more in #29 ",
          "createdAt": "2022-01-28T00:46:42Z",
          "updatedAt": "2022-01-28T09:32:16Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> To be clear this proposal would yield a couple of use-ability benefits\r\n> \r\n> 1. The commitment required by the issuer of the BBS signature to construct a bound variant is just an ordinary public key in G1, so no need to standardise the representation of new cryptographic information\r\n> 2. The pop mechanism used by a holder to proove to an issuer they possess the private key associated to the supplied public key for binding becomes just an ordinary BLS signature, so no need to standardise the representation of new cryptographic information here and a protocol to support it (e.g creating some form of POP and verifying it)\r\n> \r\n\r\nExactly. The main goal is to make the spec simpler and more readable. In compliance with the discussion at #29 the idea is that if people just want to use the core operations of bbs+ (for example for use-cases like #39) they can do so without having to concern themselves with the details of blind signatures (which do take a significant amount of the spec currently). On the other hand, for use-cases like the ones proposed [here](https://github.com/decentralized-identity/bbs-signature/issues/29#issuecomment-1023851074), people can just as easily use the spec extension.",
          "createdAt": "2022-01-28T12:21:27Z",
          "updatedAt": "2022-01-28T12:21:27Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "After thinking about this more I propose that any formal support for a BBS signature that features a cryptographic binding to the holder / prover be left to an extension spec, this keeps the core BBS signature scheme draft simple and focused",
          "createdAt": "2022-02-23T09:31:13Z",
          "updatedAt": "2022-02-23T09:31:13Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on WG call on 20th of Mar. Will revisit after re-viewing the latest academic works.",
          "createdAt": "2023-03-20T19:59:41Z",
          "updatedAt": "2023-03-20T19:59:41Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Closing in favour of #262 where the new discussion is being had.",
          "createdAt": "2023-05-08T18:24:56Z",
          "updatedAt": "2023-05-08T18:24:56Z"
        }
      ]
    },
    {
      "number": 38,
      "id": "I_kwDOF8lax85CkHdK",
      "title": "Message Generators Creation Method",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/38",
      "state": "CLOSED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "mikelodder7"
      ],
      "labels": [
        "ready-for-pr"
      ],
      "body": "Since the consensus seems to be to move to global fixed message generators shared between issuers (see #19 ) the next step would be to decide how to create those generators.  Opening this issue to create some discussion around possible proposals. My understanding is that they will be deterministically generated by a common seed (created from some nothing-up-my-sleeve value).\r\n\r\nI would also propose for the process to be such that it will create a strong binding between index and generator (i.e., something like `hash-to-curve(seed, dst, index)`) to help with indexing in applications and avoiding ambiguities.",
      "createdAt": "2022-01-27T21:38:22Z",
      "updatedAt": "2022-03-11T03:32:53Z",
      "closedAt": "2022-03-11T03:32:53Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@mikelodder7 I think last time we chatted you potentially had a good proposal for how this could be done?",
          "createdAt": "2022-01-28T03:55:57Z",
          "updatedAt": "2022-01-28T03:55:57Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Here's my proposal\r\n\r\n1. Set the global domain separator to be `GLOBAL_DST='BBS_SETUP_GENERATOR_IKM_1_0_0\\0\\0\\0'` read as 32 bytes.\r\n2. Decide on a nothing up my sleeve value for the GLOBAL_SEED like some Shakespeare poem or quote.\r\n3. Hasher = SHAKE256(GLOBAL_DST, GLOBAL_SEED)\r\n\r\nCalculate the generators as follows\r\n\r\n4. Set the generator `DST=BBS_BLS12381G1_XOF:SHAKE-256_SSWU_RO_`\r\n5. Set generators to empty collection\r\n6. for i < num_generators \r\n7. tv = Hasher.Read(64) // Read out 64 bytes from XOF\r\n8. generators[i] = Hash2Curve(tv, DST)\r\n9. output generators\r\n\r\nThe advantage of this approach is if we determine the global approach to be insecure we change the GLOBAL_SEED to be the signer's public key leaving all else the same. If we change curves then DST is updated to reflect that in the name. \r\n",
          "createdAt": "2022-01-28T19:54:18Z",
          "updatedAt": "2022-01-28T19:54:18Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "A couple of things we will need to generalise in spec text is the underlying curve and subgroup, note the [current tool](https://github.com/decentralized-identity/bbs-signature/tree/main/tooling/message-generators) is coupled to BLS12-381 ",
          "createdAt": "2022-01-29T22:01:30Z",
          "updatedAt": "2022-01-29T22:01:30Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sure but the curve can easily be swapped ",
          "createdAt": "2022-01-30T03:51:08Z",
          "updatedAt": "2022-01-30T03:51:08Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Yeap agreed, just taking a note so we don't loose track of it",
          "createdAt": "2022-01-30T20:51:11Z",
          "updatedAt": "2022-01-30T20:51:11Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1 for that method.",
          "createdAt": "2022-01-31T17:34:30Z",
          "updatedAt": "2022-01-31T17:34:30Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Add a check for point at infinity and the base generator.",
          "createdAt": "2022-02-07T19:32:27Z",
          "updatedAt": "2022-02-07T19:32:27Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Can hash-to-curve return infinity? \ud83e\udd14",
          "createdAt": "2022-02-07T19:33:09Z",
          "updatedAt": "2022-02-07T19:33:09Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "With very small odds 1/2^256. It\u2019s nice to check for it in case an attacker inserts one",
          "createdAt": "2022-02-07T19:34:34Z",
          "updatedAt": "2022-02-07T19:34:34Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Could we generalize this to check other generators other than just these? e.g what about the generator used for the blinding factor?",
          "createdAt": "2022-02-07T22:59:52Z",
          "updatedAt": "2022-02-07T22:59:52Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@mikelodder7 is this ready for a PR?",
          "createdAt": "2022-02-07T23:00:03Z",
          "updatedAt": "2022-02-07T23:00:03Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "If so would you be willing to contribute one?",
          "createdAt": "2022-02-07T23:00:27Z",
          "updatedAt": "2022-02-07T23:00:27Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yea it is. I can contribute one",
          "createdAt": "2022-02-07T23:06:53Z",
          "updatedAt": "2022-02-07T23:06:53Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@mikelodder7 bump on this one, I think it should be defined under operations, generically (e.g agnostic of the underlying curve). Then the specific cipher suite can profile it",
          "createdAt": "2022-02-23T21:52:14Z",
          "updatedAt": "2022-02-23T21:52:14Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "I've opened #71 in an attempt to move this issue forward.",
          "createdAt": "2022-02-24T01:01:31Z",
          "updatedAt": "2022-02-24T01:01:31Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think there's one improvement we could make here to improve efficiency. At the moment the assumption seems to be that we reject infinity and the default generator by proceeding to the next XOF hash output, but that implies that we have to perform hash-to-curve for every previous generator in order to rule out those values. Instead, I think we should handle the infinity and default generator cases by initializing a new XOF based on the previous output (I'm not sure if cloning the current hash state and adding more input is widely supported). This has the advantage that in order to access generator 20, for example, you only need to advance the XOF output 20 times and can skip 20 hash-to-curve operations, which are much more expensive.",
          "createdAt": "2022-02-25T01:10:33Z",
          "updatedAt": "2022-02-25T01:10:33Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don\u2019t see how that\u2019s more efficient since you already read those out anyway with the current construction.  The checking for infinity and base point is for the security proof. The odds of this happening in practice is 2^-256",
          "createdAt": "2022-02-25T01:47:28Z",
          "updatedAt": "2022-02-25T01:47:28Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Okay so we're not going to reject those points when creating the generators? It is very unlikely to happen.",
          "createdAt": "2022-02-25T01:56:28Z",
          "updatedAt": "2022-02-25T01:56:28Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "No you would still reject them but the odds of it actually happening is Incredibly low",
          "createdAt": "2022-02-25T01:58:10Z",
          "updatedAt": "2022-02-25T01:58:10Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Also the current algorithm already allows you just read out to generator 20 without having to do 20 hash to curves",
          "createdAt": "2022-02-25T01:59:42Z",
          "updatedAt": "2022-02-25T01:59:42Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It seems like it only lets you do that if you assume that all the previous points were accepted. Although I'm not sure now what it means to reject a point. Maybe we can add that to the algorithm.",
          "createdAt": "2022-02-25T02:14:36Z",
          "updatedAt": "2022-02-25T02:14:36Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "> Also the current algorithm already allows you just read out to generator 20 without having to do 20 hash to curves\r\n\r\nYeah I think the point here that @andrewwhitehead is raising is what if one of the generators between 1 and 19 evaluated to infinity so the algorithm had to recompute a generators, in this case strictly the 20th generator is actually the 19th but to be sure you have to compute all in order.",
          "createdAt": "2022-02-25T02:39:45Z",
          "updatedAt": "2022-02-25T02:39:45Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Wouldn't modifying this algorithm in the way you describe @andrewwhitehead also make the generator computation fully parallelizable?",
          "createdAt": "2022-02-25T02:43:09Z",
          "updatedAt": "2022-02-25T02:44:11Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I\u2019m not seeing how since it still depends on the previous value",
          "createdAt": "2022-02-25T02:44:40Z",
          "updatedAt": "2022-02-25T02:44:40Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "In the proposal made by andrew it would mean the current generator computation would always know which bytes to start with for its hash to curve operation there would never be the potential for \"bad\" generators that came before it (e.g bytes drawn from the XOF that when hashed to curve, evaluated to infinity).\r\n\r\nI think the tradeoff we are playing with here is the efficiency of re-initializing the XOF function per-generator and skipping to read a certain set of bytes vs the algorithm as it is described above.",
          "createdAt": "2022-02-25T02:51:16Z",
          "updatedAt": "2022-02-25T02:51:16Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@tplooker Good point on the parallelization, you would still need to go through the hash output of course but it would give more options if points did not depend on previous hash-to-curve outputs.",
          "createdAt": "2022-02-25T03:08:54Z",
          "updatedAt": "2022-02-25T03:08:54Z"
        }
      ]
    },
    {
      "number": 39,
      "id": "I_kwDOF8lax85Cl0UN",
      "title": "[USECASE] Privacy Preserving Authorization/Access Tokens",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/39",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Currently the most prolific model for expressing authorization/access tokens on the web are those like JWT based ones as used by the OAuth2.0 protocol. In order to provide these tokens with the necessary authenticity and integrity guarantees the tokens are secured using conventional cryptographic primitives like traditional digital signatures and or structures like HMACs.  To make use of one of these access tokens issued by a protocol like OAuth2.0, a relying party most commonly includes the access token as issued, in the Authorization header of an HTTP request they make to a resource server to prove authority. Some limitations of this model are:\r\n- That repeated requests to the same resource server correlates the relying party. \r\n- These access tokens are most often bearer in nature, which means if the token is intercepted by a malicious third party, they then obtain the same level of access as the relying party at the resource server. \r\n- Finally when authorization has been granted to a relying party from an authorization server that gives it access across multiple resource servers, having a single access token can leak certain information un-intentionally to the various resource servers as the access token is used.\r\n\r\nAn access token secured with a BBS signature could help to solve some of these challenges in the following ways:\r\n\r\n1. An access token secured with a BBS signature would never be directly revealed via a request to a resource server, thus mitigating the correlation risk. Instead each time a relying party were to make a request to a resource server they instead would compute a derived proof of the access token and include that result in the request to the resource server. The resource server still obtains the same level of confidence (if not better) around proof of authority associated to the request, without strongly correlating the client via the signature on the access token.\r\n2. Because an access token secured with a BBS signature is never directly revealed via a request to a resource server, instead only a derived proof which cannot be replayed, the likely hood of the access token being intercepted by a malicious third party is strongly mitigated.\r\n3. Finally because BBS Signatures enable multi-message signing and selective disclosure during the deriving of a proof, a relying party could leverage this to derive proofs from a single access token that proves authority to perform actions at independent resource servers without the risk of un-intentionally information leakage.",
      "createdAt": "2022-01-28T09:58:58Z",
      "updatedAt": "2022-02-15T08:48:27Z",
      "closedAt": "2022-02-15T08:48:26Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Added into the draft in https://github.com/decentralized-identity/bbs-signature/commit/bf70e40f8aab8472e34e907953e8c7788efd6a78 ",
          "createdAt": "2022-02-15T08:48:26Z",
          "updatedAt": "2022-02-15T08:48:26Z"
        }
      ]
    },
    {
      "number": 40,
      "id": "I_kwDOF8lax85CoEOy",
      "title": "Message Encoding",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/40",
      "state": "CLOSED",
      "author": "mikelodder7",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "ready-for-pr",
        "core"
      ],
      "body": "Data can be encoded multiple ways depending on how it will be used with other ZKPs. For example, it will not be useful to hash an integer to a 32 byte value using SHA256 and expect it to work properly with Range Proofs. The following is a list of encodings and the use cases they can be used:\r\n\r\n1. **Hashed**: for aribitrary length data fields that will not fit in the base field e.g. images, strings, biometrics, blockchain transaction info. Use hash2field or some other method to hash the data into a 32 byte base field value.\r\n2. **Bytes**: a value that is already in the base field\r\n3. **Numbers**: for range proofs. The value is zero-centered by take computing the base field modulus `z`=`q` / 3 integer division as the zero center and adding the positive number or substracting the negative number. To support complex numbers like decimal, the number is converted to fixed point arithmetic. The [Q format](https://en.wikipedia.org/wiki/Q_(number_format)) is used for these numbers as Q64.160. This leaves two bytes to avoid numbers greater than `q`. While it does not represent the full breadth of IEEE754 numbers, it does give a considerable resolution -2<sup>63</sup> to 2<sup>63</sup>-2<sup>-160</sup> signed and 0 to 2<sup>64</sup>-2<sup>-160</sup> unsigned or about 48 decimal places of precision. If decimals are rounded to the nearest integer, then Q format is not necessary.\r\n4. **Null**: Hard coded as 5. Means the value is not included or not used.\r\n5. **Empty**: Hard coded as 11. Means the value is included but is an empty string or zero bytes. For example, a person does not have a middle name but a value is required to be entered.\r\n6. **Ignored**: Hard coded as 23. For data fields that were ignored or not answered by the person. This is different than empty where the person's answer is literally nothing vs they chose not to answer it at all.\r\n\r\nSmall safe primes were used for the last three but can really be any value that is not `0` or `1`.\r\n\r\n### Comparing numbers to Null, Empty, Ignored\r\n\r\nNo DLEQ proof is needed to check for this since the verifier gets to pick the bounds and in theory this could be done but isn't meaningful",
      "createdAt": "2022-01-28T19:57:31Z",
      "updatedAt": "2022-05-23T19:54:46Z",
      "closedAt": "2022-05-23T19:54:46Z",
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I\u2019m fine with the encodings. I was thinking about the scope though, i.e., is the bbs+ spec the best place to define them. To my knowledge crypto specs don\u2019t usually define data representations.\r\n\r\nFrom the bbs+ perspective will it make a difference If 5 means Null or something else?",
          "createdAt": "2022-01-31T17:34:54Z",
          "updatedAt": "2022-01-31T17:34:54Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don\u2019t think so as long as we agree what means what",
          "createdAt": "2022-01-31T18:02:09Z",
          "updatedAt": "2022-01-31T18:02:09Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Being addressed in #61 ",
          "createdAt": "2022-03-06T23:17:21Z",
          "updatedAt": "2022-03-06T23:17:21Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Addressed in #61, closing",
          "createdAt": "2022-05-23T19:54:46Z",
          "updatedAt": "2022-05-23T19:54:46Z"
        }
      ]
    },
    {
      "number": 43,
      "id": "I_kwDOF8lax85Csil6",
      "title": "Supporting deterministic signatures",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/43",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [
        "mikelodder7"
      ],
      "labels": [
        "ready-for-pr"
      ],
      "body": "BBS Signatures as defined in academic literature are non-deterministic in nature. In general non-deterministic digital signatures can be difficult from an implementation perspective due to their dependency on a sound RNG. It causes complexities around confirming implementation correctness because the RNG often has to be mocked or seeded in a particular way. There is the potential to modify the signature construction in this draft to make signatures deterministic, @mikelodder7 could you share your proposal for this?\r\n\r\nThe main questions I think we as a WG should be asking are:\r\n- Do we want deterministic signatures?\r\n- Do we want to take on the scope of deterministic signatures in the current draft?\r\n- Given we are deviating from academic literature, what security proofs do we need?",
      "createdAt": "2022-01-31T04:56:03Z",
      "updatedAt": "2022-03-06T23:19:03Z",
      "closedAt": "2022-03-06T23:19:03Z",
      "comments": [
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "My suggestion is this:\r\n\r\nu512() is a function that converts 64 bytes as a 512-bit number.\r\n\r\nFor regular signing:\r\n\r\ninputs: \r\n- base order `q`\r\n- secret key `x`\r\n- messages `mi,...,mn`\r\n\r\n1. hasher = SHAKE256(x, mi, ..., mn)\r\n2. e = uint512(hasher.read(64)) % q\r\n3. s = uint512(hasher.read(64)) % q\r\n4. finish as normal\r\n\r\nFor blind signing:\r\ninputs:\r\n- base order `q`\r\n- secret key `x`\r\n- known_messages `mi,...,mn`\r\n- commitment `U`\r\n\r\n1. hasher = SHAKE256(x, U, mi,...,mn)\r\n2. e = uint512(hasher.read(64)) % q\r\n3. s = uint512(hasher.read(64)) % q\r\n4. finish as normal",
          "createdAt": "2022-02-03T20:25:46Z",
          "updatedAt": "2022-02-03T20:25:46Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I like this method, but a comment from [here](https://datatracker.ietf.org/doc/html/rfc6979#section-3.2) worries me, i.e., \"Performing a simple modular reduction would induce biases that would be detrimental to signature security\"\r\n\r\nIs this something that we will have to also worry about?\r\n",
          "createdAt": "2022-02-03T20:54:44Z",
          "updatedAt": "2022-02-03T20:54:44Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This method already addresses the bias by pulling double the bytes. See https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-13#section-5.1.",
          "createdAt": "2022-02-03T20:58:22Z",
          "updatedAt": "2022-02-03T20:58:22Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The bias is something to be aware of, but this method handles it properly.",
          "createdAt": "2022-02-03T20:58:42Z",
          "updatedAt": "2022-02-03T20:58:42Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "FYI, this is how it should be done with a single signer context. Threshold signing should not be restricted to this since all sorts of attacks can happen with deterministic signing.",
          "createdAt": "2022-02-07T19:24:11Z",
          "updatedAt": "2022-02-07T19:24:11Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Currently covered in #62 ",
          "createdAt": "2022-02-15T08:47:18Z",
          "updatedAt": "2022-02-15T08:47:18Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Closing with the merging of #62, resolution was to include this, initial test vectors conforming to this approach have been added in #67 ",
          "createdAt": "2022-03-06T23:19:03Z",
          "updatedAt": "2022-03-06T23:19:03Z"
        }
      ]
    },
    {
      "number": 46,
      "id": "I_kwDOF8lax85Cwar2",
      "title": "[Proposal] An interop profile document",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/46",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Given the discussion in #8 around how the core bbs signature draft should relate to underlying cryptographic primitive selection, I wanted to propose an approach that may be inline with this emerging consensus.\r\n\r\nInstead of mentioning in the core bbs signature draft anything around concrete curves or digest algorithms we could define a seperate document which is an opinionated \"bbs signature profile\" aimed at promoting interoperable implementations. The profile would also host test vectors to facilitate this process.\r\n\r\nIf this approach is accepted by the community then I would suggest we immediately start work on one profile that uses the following.\r\n- BLS12-381 as the pairing friendly curve\r\n- SHAKE256 as the digest algorithm\r\n\r\nAlternatively if having multiple document is too complex we could elect to merge these, however we would need to be careful in how we structure the document.",
      "createdAt": "2022-01-31T22:11:44Z",
      "updatedAt": "2022-02-16T04:40:52Z",
      "closedAt": "2022-02-16T04:40:52Z",
      "comments": [
        {
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think ideally, you just name the algorithm and define it concretely for those parameters... a profile for their configuration seems a bit excessive to me.\r\n\r\nI do think you should make it obvious how someone might replace either in your spec, but I don't think you need to take ownership of defining that generality for all of IETF.\r\n",
          "createdAt": "2022-01-31T22:17:16Z",
          "updatedAt": "2022-01-31T22:17:16Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Ok so a counter proposal would be to generalize section 5 https://identity.foundation/bbs-signature/draft-bbs-signatures.html#name-overview which is currently empty to be more \"profiles\" with the definition of BLS12-381 under that alongside concrete test vectors?",
          "createdAt": "2022-01-31T23:51:51Z",
          "updatedAt": "2022-01-31T23:51:51Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes I think the draft should define profiles generically, plus a BLS12-381 profile concretely. That's the only curve we currently have implementations for, and we need some test vectors to make it normative.\r\n\r\nEach profile needs to define a few things either directly or by reference, and I suggest we name the profiles using a method similar to the [Noise protocol names](https://noiseprotocol.org/noise.html#protocol-names-and-modifiers). The name would presumably be used as a DST in generator creation.\r\n\r\nBesides the basic curve operations (KeyGen, hash-to-curve), and which group is used for the signature, I believe the profile should also specify the message encoding method. For a simple message encoding to include in the first draft I'd suggest just calling it something like `H2C-SHAKE256`, and requiring that all messages which aren't already scalar values must be strings hashed using `hash-to-curve` with `SHAKE256` as the digest algorithm (NB the hash used in generator creation does not have to be the same as the one used in message encoding).\r\n\r\nIn this case the profile name might be something like `BBS-2022:BLS12381-G2:H2C-SHAKE256` (it seems to read better with colons instead of underscores). I suppose another component could be added to the name if custom generators are used?",
          "createdAt": "2022-02-01T18:14:27Z",
          "updatedAt": "2022-02-01T18:21:57Z"
        },
        {
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Have a look at:\r\n\r\n- https://www.rfc-editor.org/rfc/rfc9162.html\r\n\r\n- https://datatracker.ietf.org/doc/html/rfc8812\r\n\r\nfor examples of registering things.",
          "createdAt": "2022-02-02T15:30:44Z",
          "updatedAt": "2022-02-02T15:30:54Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "This issue has been addressed in #47 and #60, with the general consensus being around defining the BLS12-381 ciphersuite/profile within the draft",
          "createdAt": "2022-02-16T04:40:51Z",
          "updatedAt": "2022-02-16T04:40:51Z"
        }
      ]
    },
    {
      "number": 48,
      "id": "I_kwDOF8lax85C0yau",
      "title": "Register algorithms for BBS signatures in JOSE and COSE IANA registry",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/48",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "pending-close"
      ],
      "body": "As raised by @OR13 on a recent PR review we should consider the scope to register the relevant JOSE and COSE algs with the IANA registry as a part of the core draft.",
      "createdAt": "2022-02-01T19:55:28Z",
      "updatedAt": "2022-03-21T21:23:04Z",
      "closedAt": "2022-03-21T21:23:04Z",
      "comments": [
        {
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Here is a good example to copy from: \r\n\r\nhttps://datatracker.ietf.org/doc/html/rfc8812\r\n\r\nI would just do this in the current spec.\r\n\r\nThe sooner these are registered with IANA, the sooner we can all be using this suite with confidence.\r\n\r\nI think its a huge mistake to build on this suite without doing this work...because you may find that your signature or key representations change out under you, and your interoperability is destroyed because you have no name for their former and newer serializations.",
          "createdAt": "2022-02-02T15:16:27Z",
          "updatedAt": "2022-02-02T15:17:12Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As long as it doesn't lock implementors into only using JOSE/COSE",
          "createdAt": "2022-02-07T19:56:56Z",
          "updatedAt": "2022-02-07T19:56:56Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Of course not, just defines how the scheme can be used in those data representations",
          "createdAt": "2022-02-07T22:58:41Z",
          "updatedAt": "2022-02-07T22:58:41Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Its worth noting that the current standard JOSE and COSE forms do not support the style of cryptographic representation required by a protocol like BBS Signatures. However [JWP](https://github.com/json-web-proofs/json-web-proofs) is likely to define one that will, so the ability to register suitable algorithms in the IANA registry, in this draft, will likely be dependent on that drafts completion, alternatively another internet draft could be written after this to define the registration.",
          "createdAt": "2022-02-16T07:54:21Z",
          "updatedAt": "2022-02-16T07:54:21Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Based on the perspective shared above I'm proposing we close this issue on the grounds that it is out of scope for the current drafts to make IANA registrations for specific data representation forms like JOSE and COSE, marking as pending-close on that basis.",
          "createdAt": "2022-03-21T02:33:59Z",
          "updatedAt": "2022-03-21T02:33:59Z"
        },
        {
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@tplooker I mostly care about the `OKP`, `crv`, `alg` side of these registrations.... Are they going to be handled in a different IETF spec? if so, can we link to something before closing this, so future searchers know where to join in / help ?",
          "createdAt": "2022-03-21T12:50:09Z",
          "updatedAt": "2022-03-21T12:50:09Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "w.r.t BLS12-381 key representation [this draft](https://tplooker.github.io/draft-looker-cose-bls-key-representations/draft-looker-cose-bls-key-representations.html) is where the definitions for JOSE and COSE iana registrations are mastered.\r\n\r\nw.r.t to the algorithmic registration for BBS in JWP (an extension of JOSE) refer to [here](https://json-web-proofs.github.io/json-web-proofs/draft-jmiller-json-proof-algorithms.txt). No current extension draft for usage of BBS in COSE exists yet.",
          "createdAt": "2022-03-21T21:20:11Z",
          "updatedAt": "2022-03-21T21:20:11Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@OR13 does that help?",
          "createdAt": "2022-03-21T21:21:36Z",
          "updatedAt": "2022-03-21T21:21:36Z"
        },
        {
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "body": "- (jwk) https://tplooker.github.io/draft-looker-cose-bls-key-representations/draft-looker-cose-bls-key-representations.html\r\n- (alg) https://json-web-proofs.github.io/json-web-proofs/draft-jmiller-json-proof-algorithms.txt\r\n\r\ngood to close",
          "createdAt": "2022-03-21T21:22:46Z",
          "updatedAt": "2022-03-21T21:22:46Z"
        }
      ]
    },
    {
      "number": 52,
      "id": "I_kwDOF8lax85C990s",
      "title": "Cite relevant prior academic works",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/52",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "core"
      ],
      "body": "The BBS Signature scheme is based on a wealth of prior academic work that should be appropriately referenced. Any deviations from these works should also be documented in an informative appendix while the scheme continues to develop. Lets use this issue to collate these sources",
      "createdAt": "2022-02-03T20:50:48Z",
      "updatedAt": "2022-06-27T20:41:56Z",
      "closedAt": "2022-06-27T20:41:56Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "[Anonymous Attestation Using the Strong Diffie Hellman Assumption Revisited](https://www.researchgate.net/publication/306347781_Anonymous_Attestation_Using_the_Strong_Diffie_Hellman_Assumption_Revisited)",
          "createdAt": "2022-02-03T20:52:48Z",
          "updatedAt": "2022-02-03T20:52:48Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "First revision from bbs to bbs+: [Constant-Size Dynamic k-TAA (2006)](https://link.springer.com/chapter/10.1007/11832072_8)\r\n\r\nMost recent work (to my knowledge) on bbs+ (paywalled): [A Novel Dynamic Group Signature with Membership Privacy(2021)](https://ieeexplore.ieee.org/abstract/document/9346238)\r\n\r\nOther relevant work but not strictly about bbs+:\r\n\r\n- [Short Group Signatures (2004)](https://link.springer.com/chapter/10.1007/978-3-540-28628-8_3)\r\n\r\n- [Short Signatures Without Random Oracles (2004)](https://link.springer.com/chapter/10.1007/978-3-540-24676-3_4)\r\n\r\n- [Signature Schemes and Anonymous Credentials from Bilinear Maps (2004)](https://link.springer.com/chapter/10.1007/978-3-540-28628-8_4)\r\n",
          "createdAt": "2022-02-03T21:10:43Z",
          "updatedAt": "2022-02-03T21:10:43Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Related to the discussion in #69 and #70",
          "createdAt": "2022-03-06T23:16:27Z",
          "updatedAt": "2022-03-06T23:16:27Z"
        }
      ]
    },
    {
      "number": 54,
      "id": "I_kwDOF8lax85DDhyM",
      "title": "Indexes and messages notation",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/54",
      "state": "CLOSED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "BasileiosKal"
      ],
      "labels": [
        "ready-for-pr"
      ],
      "body": "The spec makes heavy use of lists of messages and indexes. We need a consistent way to represent those.\r\n\r\n**- Option 1**:\r\nRepresent indexes with a consisted format like `I_t`, `I_d` corresponding to the total and disclosed messages. Represent the messages with something like,\r\n\r\n    (msg[i] for i in I_d)   // or I_t\r\n\r\nAs such `spkGen` for example will be,\r\n\r\n    spkGen(spk, PK, I_t, I_d, (msg[i] for i in I_d), pm)\r\n\r\n**- Option 2**:\r\nDefine that all signatures on `L` messages will use the `L` first generators. With that, instead of the indexes of all the signed messages we can pass just the `totalSignedMessages`. That will also allow for a solution like [here](https://github.com/decentralized-identity/bbs-signature/issues/10#issuecomment-1018041832) with\r\n\r\n    spkGen(spk, PK, revealedMessages, totalSignedMessages, pm)\r\n\r\nwhere `revealedMessages` is a map between index and message. The drawback here is that when creating commitments for blind signatures, the user will need to choose the `n` first generators, with `n = Total_Committed_Messages` (i.e., always follow the example flow from the [blind signatures spec](https://github.com/decentralized-identity/bbs-signature/blob/main/draft-blind-bbs-signatures.md)), which could be restrictive for some applications.\r\n\r\n**- Option 3**:\r\nA compination of both, i.e.,\r\n\r\n    spkGen(spk, PK, Indexes, revealedMessages, pm)\r\n\r\nwhere again `revealedMessages` is a map between index and message and `Indexes` the indexes of all the messages",
      "createdAt": "2022-02-05T18:20:43Z",
      "updatedAt": "2022-03-02T17:56:29Z",
      "closedAt": "2022-03-02T17:56:29Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "With the merge of #64 is there anything outstanding with this issue @BasileiosKal? or can we close this?",
          "createdAt": "2022-03-02T04:58:39Z",
          "updatedAt": "2022-03-02T04:58:39Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeap. Further discussions on generators and indexes is better to be held elsewhere (like #68). Closing.",
          "createdAt": "2022-03-02T17:56:29Z",
          "updatedAt": "2022-03-02T17:56:29Z"
        }
      ]
    },
    {
      "number": 59,
      "id": "I_kwDOF8lax85DvVOX",
      "title": "Document rationale for why BBS Signatures are only efficient when the signatures generated are in G1 and public keys are in G2",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/59",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Unlikes BLS signatures which as per [the spec](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-bls-signature-02#section-2.1) define two possible variations in the scheme based on which sub-group is used for the signatures and public keys. Because of the unique mathamatical computations involved for proof generation (SPK gen) being only efficient when performed in G1, the effective variant of BBS signatures that would instead use G2 is impractical. We should document this in the spec.",
      "createdAt": "2022-02-13T21:32:49Z",
      "updatedAt": "2022-02-16T08:59:22Z",
      "closedAt": "2022-02-16T08:59:21Z",
      "comments": []
    },
    {
      "number": 68,
      "id": "I_kwDOF8lax85ETuUH",
      "title": "Named message generators",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/68",
      "state": "CLOSED",
      "author": "andrewwhitehead",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "core"
      ],
      "body": "I'm finding that it would be beneficial to define generators more generally, instead of just having `H_0` for blind signatures and `H_1 ... H_n` for indexed messages. Extensions to the BBS signature scheme may want to reserve one or more message indexes for particular purposes (wallet binding, revocation, etc), but this leads to conflict when multiple extensions are used at once. You would likely need to define a new signature scheme for every supported combination in order to specify what message indexes are used for what purpose.\r\n\r\nInstead, I believe we can define special-purpose message generators which have unique identifiers rather than indexes. You can also think of these as 'unordered' generators, with standard usage that is consistently defined across various credential schemas. A few potential uses that I've identified:\r\n\r\n- a 'linked secret'/'wallet binding' generator for preventing use of credentials without the secret (Indy's use case)\r\n- a 'device binding' generator (for a secret value that can be authenticated as generated by a trusted module)\r\n- revocation entry and revocation group generators for linking to an accumulator or other revocation mechanism\r\n- a schema identifier generator\r\n- a credential ID generator\r\n- a credential set ID generator (for a collection of credentials that can be presented in combination)\r\n- a credential creation time generator\r\n- a credential expiration time generator\r\n\r\nWe could also reformulate a couple things in these terms:\r\n\r\n- `H_0` becomes the 'blinded signature' or 'commitment' generator\r\n- `P1` could be replaced by a 'base point' generator - freeing it up to be used as a holder binding generator as in #37 (NB. in this case the associated message would always be `1`)\r\n\r\nThese generators might be defined either specific to an issuer key or globally by adding a unique identifier to the hash-to-curve input. Some thought would be needed here to define the process exactly. For debugging purposes, messages tied to these generators might also be represented as a dictionary while numbered messages are represented as a list, for example:\r\n\r\n```json\r\n{\r\n  \"revocation index\": 1,\r\n  \"revocation group\": \"mydomain.com/users\",\r\n  \"schema\": \"http://schema.org/Person\"\r\n}\r\n```",
      "createdAt": "2022-02-21T16:40:49Z",
      "updatedAt": "2022-05-20T19:35:40Z",
      "closedAt": "2022-05-20T19:35:39Z",
      "comments": [
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> `P1` could be replaced by a 'base point' generator - freeing it up to be used as a holder binding generator as in https://github.com/decentralized-identity/bbs-signature/issues/37\r\n\r\nIn particular - this could be made into an issuer-specific (public key-specific) generator, potentially alleviating security concerns with the other generators being universal.",
          "createdAt": "2022-02-21T17:10:01Z",
          "updatedAt": "2022-02-21T17:10:01Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@andrewwhitehead I really like the thinking here I agree there are many applications of generators within BBS signatures for special purposes. IMO in order to keep the core draft simple I think we leave operations that involve using generators with a contract like proposed in #64, put simply the core draft should not be aware of any specific application of a particular generator. Instead we can profile on top of the core draft a \"bound\" variant of the BBS signature scheme that defines the generator used for cryptographic holder binding and the likes",
          "createdAt": "2022-02-21T20:58:25Z",
          "updatedAt": "2022-02-21T20:58:25Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1. This is definitely very usefully. An issue IMO is how we define those special purpose generators. Would the generators used for blind signatures be considered \"special purpose\" in that case?? If yes this would be more complicated than just defining specific use and identifiers for 5-10 generators. Finally, shouldn't we also try to define the \"special\" messages corresponding to those \"special\" generators??\r\n\r\nOne way could be:\r\n1. define the core operations to act on any generator (as in PR #64 which as @tplooker mentioned leaves the core operations agnostic and hence simple). Since the operations will take as input a list of generators and not indexes or identifiers they will not know if the generator is special or not.\r\n2.  define the concept of messages \"committed\" using a generator (i.e., the concept of the mapping between the message and the generator, briefly touched again on PR #64).\r\n3.  define some special generators and the meaning of the messages \"committed\" with them (i.e., a message \"committed\" with special generator \"special_generator_1\" will represent the signatures expiration time etc.). This can be an extra section. No change will be needed in the core operations.\r\n\r\nThe generators used for blinding will not be considered \"special\", which avoids many complexities. @andrewwhitehead is this what you had in mind?? ",
          "createdAt": "2022-02-21T22:44:23Z",
          "updatedAt": "2022-02-21T22:44:23Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "The difficult complexity arises when we want to start tracking the allocation of ordinary message generators in certain contexts for special purposes, my inclination is to instead keep these seperate. \r\n\r\nFor instance we dont want a situation to arise where a prover tries to fool a verifier into saying here is a proof from a \"bound\" BBS signature where the first message is un-revealed but because that generator is used in the same way as \"non bound\" BBS signatures some other mechanism would have to be used by the verifier to disambiguate that they are truely looking at a proof generated from a \"bound\" BBS signature.",
          "createdAt": "2022-02-22T02:26:12Z",
          "updatedAt": "2022-02-22T02:26:12Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "The counter problem this creates is because the number of message generators is effectively un-bounded how do we ensure when we select \"special generators\" that they do not collide with message generators?",
          "createdAt": "2022-02-22T02:27:41Z",
          "updatedAt": "2022-02-22T02:27:41Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "This complexity gets even hard to solve for if we want to support arbitrary blind message signing but also maintain conceptually different generators (e.g a set of message generators and a set of blind message generators)",
          "createdAt": "2022-02-22T02:29:01Z",
          "updatedAt": "2022-02-22T02:29:01Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> +1. This is definitely very usefully. An issue IMO is how we define those special purpose generators. Would the generators used for blind signatures be considered \"special purpose\" in that case?? If yes this would be more complicated than just defining specific use and identifiers for 5-10 generators. Finally, shouldn't we also try to define the \"special\" messages corresponding to those \"special\" generators??\r\n\r\nI probably shouldn't include the `H_0` generator in this because it adds confusion, and that generator is used in the SPK (although I'm not sure at the moment why it isn't treated as a normal hidden message). It's fine to continue defining it as the zeroth indexed generator. And yes, the format of the messages committed with a particular \"special\" generator will need to be defined, but that can be specified in the same extension draft where the generator is named.\r\n\r\n> 1. define the core operations to act on any generator (as in PR [Messages and generators notation update for readability\u00a0#64](https://github.com/decentralized-identity/bbs-signature/pull/64) which as @tplooker mentioned leaves the core operations agnostic and hence simple). Since the operations will take as input a list of generators and not indexes or identifiers they will not know if the generator is special or not.\r\n\r\nI think I agree with this.\r\n\r\n> 2. define the concept of messages \"committed\" using a generator (i.e., the concept of the mapping between the message and the generator, briefly touched again on PR [Messages and generators notation update for readability\u00a0#64](https://github.com/decentralized-identity/bbs-signature/pull/64)).\r\n\r\nAlso makes sense.\r\n\r\n> 3. define some special generators and the meaning of the messages \"committed\" with them (i.e., a message \"committed\" with special generator \"special_generator_1\" will represent the signatures expiration time etc.). This can be an extra section. No change will be needed in the core operations.\r\n\r\nAt the moment I think it would be best to define the general concept of 'extension generators' and how to create them independent of the curve being used (ie. hash a URI to a group element, perhaps), in the core draft. Then extensions to the BBS draft can simply say something like \"define the credential index generator as an extension generator with URI <http://...>\". Depending on uptake the implementations might cache certain generators that are frequently used. I don't think we need to add any specific instances of these generators to the core draft currently.\r\n\r\nNaming-wise we could also distinguish between 'ordered' and 'unordered' generators.",
          "createdAt": "2022-02-22T03:30:11Z",
          "updatedAt": "2022-02-22T03:48:36Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> The counter problem this creates is because the number of message generators is effectively un-bounded how do we ensure when we select \"special generators\" that they do not collide with message generators?\r\n\r\nWe just need to select them randomly or based on a hash. The chance of collision is on the same order as with selecting a secret key, I believe.\r\n\r\n> This complexity gets even hard to solve for if we want to support arbitrary blind message signing but also maintain conceptually different generators (e.g a set of message generators and a set of blind message generators)\r\n\r\nI'm not really sure what you're getting at here, the generators are the same in any case. It seems reasonable that the issuer will only accept commitments for certain known message generators depending on the protocol being executed.\r\n\r\nIncidentally parties should never be sending message generators themselves, they should only be referred to or known implicitly.",
          "createdAt": "2022-02-22T03:38:21Z",
          "updatedAt": "2022-02-22T03:38:21Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> At the moment I think it would be best to define the general concept of 'extension generators' and how to create them independent of the curve being used (ie. hash a URI to a group element, perhaps), in the core draft. Then extensions to the BBS draft can simply say something like \"define the credential index generator as an extension generator with URI http://.../\". Depending on uptake the implementations might cache certain generators that are frequently used. I don't think we need to add any specific instances of these generators to the core draft currently.\r\n\r\nAh ok, I think I understand better now. Thanks you! So the concept is to define an alternative way of creating generators, something like `Hash2Curve(Hasher(GID), DST)`, where `GID` a special generator identifier??\r\n\r\nTwo things worry me though. \r\n1. To @tplooker point, domain separation becomes very important for some of those use cases. We will not be able to define the necessary DSTs here though.\r\n2. Applications should not be able to define their own generator identifiers (`GID` above). A URI could contain random or \u201crandom looking\u201d elements. The prover could then try to convince the verifier that they supplied correct \"special generator URIs\". If those are not specified by some spec or profile, there is no way for the verifier to know that the random looking elements they contain are not maliciously formed (which will result to maliciously formed generators). the prover could perform \"pre-image\" attacks to create generators that would allow them to present proofs for messages they don\u2019t have etc. \r\n\r\nIMO if the definition of special generators does not raise complexity too much, it can be useful including it to the spec but only as a point that other profiles and specs can expand upon and we should make it clear that this is the case, i.e., that applications must not define their own special generators.",
          "createdAt": "2022-02-22T18:03:04Z",
          "updatedAt": "2022-02-22T18:03:04Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> It seems reasonable that the issuer will only accept commitments for certain known message generators depending on the protocol being executed.\r\n\r\nFor blind signatures, I think there is benefit in allowing the use of any arbitrary generator, to support use cases like in issue #29 (and more specifically [here](https://github.com/decentralized-identity/bbs-signature/issues/29#issuecomment-1023851074)) where a \u201cmessage\u201d generator for one signature could become a \u201ccommitment\u201d generator for another.\r\n\r\n> Incidentally parties should never be sending message generators themselves, they should only be referred to or known implicitly.\r\n\r\nDefinitely. We must document that in the spec.",
          "createdAt": "2022-02-22T18:14:16Z",
          "updatedAt": "2022-02-22T18:21:48Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> For blind signatures, I think there is benefit in allowing the use of any arbitrary generator, to support use cases like in issue https://github.com/decentralized-identity/bbs-signature/issues/29 (and more specifically https://github.com/decentralized-identity/bbs-signature/issues/29#issuecomment-1023851074) where a \u201cmessage\u201d generator for one signature could become a \u201ccommitment\u201d generator for another.\r\n\r\nTechnically any message generator can be used in a commitment. I'm just saying that from a business logic and security perspective the issuer should only be issuing blinded signatures in specific use cases, and the holder will basically be told what form the commitment should take. In fact all the cases I can think of work better with named generators than with positional ones, because they can better restrict the interpretation of the message \u2013\u00a0for example, as a linked secret, instead of just 'message 1'.",
          "createdAt": "2022-02-22T18:28:45Z",
          "updatedAt": "2022-02-22T18:28:45Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Right. So i guess the question i have (although this may be better discussed separately) is will the blind signatures extension define specific generator URIs to be used, i.e., only named generators, which may not allow the above [use case](https://github.com/decentralized-identity/bbs-signature/issues/29#issuecomment-1023851074) but increase simplicity and security or will blind signatures be able to use any generator increasing flexibility, and leave the exact definition of the named generator URIs to another spec (like a profile or a registry)?? \r\n\r\nRegardless I think the concept of the \"special\" named generators is worth documenting in the spec. I do agree that many use cases will benefit from it. As i said applications should not define their own named generators but technically an Issuer could, as long as the verifier can validate that those named generators are as defined from the issuer. I would prefer to just say that only other specs can define URIs for named generators though (maybe even an IANA registry??). This also has the advantage that those specs can define the necessary DSTs.",
          "createdAt": "2022-02-22T21:42:29Z",
          "updatedAt": "2022-02-22T21:42:29Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't think the blind signatures extension needs to refer to any specific generators except `P1` and `H0` or whatever fills that role. It could have a non-normative section about generator selection maybe. Another nice thing about the named generators is that you can compose multiple commitments more easily since they aren't sensitive to ordering, which might help in that particular use case. (I notice that the example of a separate attribute provider only hides the attribute value if it has a large range, otherwise the issuer could discover the value by testing.)\r\n\r\nAgree that applications should not be defining their own named generators (or whatever we call them), I think it's more of an ecosystem-level concept, and it makes sense to me to have a registry for them. I'm not sure what kind of DST is required, maybe it should just be the BBS signature scheme identifier as with the current generators?",
          "createdAt": "2022-02-22T22:13:21Z",
          "updatedAt": "2022-02-22T22:13:21Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Currently, I don't think any special mechanism for 'named' generator creation needs to be defined, as we can define everything in terms of `CreateGenerators` (see #71).\r\n\r\n- The current generators `(P1, H1, ... Hn)` can be defined by `CreateGenerators(PROTOCOL_DST, CORE_SEED, n+1)[0..n]`. CORE_SEED would normally be a spec-defined global seed value, but could be the issuer public key for issuer-specific generators, or an application-specific value if desired.\r\n- Extensions may define one or more seeds for their own generators, as well as usage details. For example a 'credential metadata' spec could define a seed which was a URI pointing at the specification. It would then outline that generator `0` for the given seed is used for the credential schema, generator `1` for the credential ID, and generator `2` for the issuance date in YYYYMMDD format.\r\n- Using the same mechanism, the blind signature spec would define the `s` generator (currently `H0`) as `CreateGenerators(PROTOCOL_DST, BLIND_SIGN_SEED, n)[0]`.",
          "createdAt": "2022-03-02T20:18:48Z",
          "updatedAt": "2022-03-02T20:19:33Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As a further update following #70, it looks like there is no avoiding `H0` so it would have to be defined in the core. In that case I think it should just be the 0th element of the `CreateGenerators(PROTOCOL_DST, CORE_SEED, n+1)` sequence (basically the same as now).\r\n\r\nIf we do decide to replace `P1` (need to create a separate issue for this) then element `0` could be that base point, element `1` would be `H0`, and the message generators would be elements `2..n+1`.",
          "createdAt": "2022-03-03T21:00:52Z",
          "updatedAt": "2022-03-03T21:00:52Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Even if we decide to change `P1`, It may be useful to define it in the core spec separately from the generators created from `CreateGenerators` (i.e., as its own \"named\" generator). That way, even if we move to issuer specific generators, `P1` will not change (in all literature `P1` is fixed).",
          "createdAt": "2022-03-04T10:47:08Z",
          "updatedAt": "2022-03-04T10:47:08Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closing as I believe this is allowed by the current spec, and the implementation becomes an application concern.",
          "createdAt": "2022-05-20T19:35:39Z",
          "updatedAt": "2022-05-20T19:35:39Z"
        }
      ]
    },
    {
      "number": 69,
      "id": "I_kwDOF8lax85EdnEX",
      "title": "Ensure SpkGen algorithm is still consistent with academic literature",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/69",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "core"
      ],
      "body": "Opening this to track the ongoing work happening in the background after the merging of #62, @BasileiosKal and @mikelodder7 will co-ordinate on this and once complete we can close this issue",
      "createdAt": "2022-02-23T21:44:59Z",
      "updatedAt": "2022-12-05T19:48:23Z",
      "closedAt": "2022-12-05T19:48:22Z",
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Just to track some issues. All of those may become mute from issue #70.\r\n\r\n1. After talking with Mike i understood that the problem was not that the equations between the spkGen and spkVerify are not consistent but that they are not consistent with the paper, especially the ones going into the SPK. Specifically, the first equation proven by the SPK in the spec now is `Abar - D = - A' * e - H0 *r2` while the same equation in the paper is `Abar - D = - A' * e + H0 *r2`. The second equation is the same in both cases. From my calculations, there is an extractor for those equations, however its quite different from the one used in the paper, which means we must describe it in the spec. IMO it would be better to change `r2^ = r2~ + c * r2` to  `r2^ = r2~ - c * r2` so at least the equations going into the SPK will be the same as in the paper, meaning that we don't have to describe a new extractor in the spec. Changing the formulas is fine but i would prefer equivalent equations to go into the SPK so we don't have to describe a new extractor, especially since it doesn't seem to give to much of an efficiency advantage (it's only calculating one more negative).\r\n\r\n2. Just to track another issue here, Mike mentioned that the `m^_i` in `C2` in spkVerify may need to go with a \"-\", although looking at it now it seems consistent?? because of the `-r3~` and `-r3^` multiplied with `D`? I may be missing something.",
          "createdAt": "2022-02-24T14:52:54Z",
          "updatedAt": "2022-02-24T14:52:54Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Closing in favour of #79 which documents a broader set of considerations.",
          "createdAt": "2022-12-05T19:48:22Z",
          "updatedAt": "2022-12-05T19:48:22Z"
        }
      ]
    },
    {
      "number": 70,
      "id": "I_kwDOF8lax85Eduuo",
      "title": "Simpler SpkGen option",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/70",
      "state": "CLOSED",
      "author": "andrewwhitehead",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "core"
      ],
      "body": "I'm curious what's wrong with this simpler SPK alternative which doesn't specifically use `h_0` and `s`, treating them as a hidden message: https://hackmd.io/8t8o56mvTL6p-VZyayLnTA?view\r\n\r\nOne benefit here is that blind signatures become a true extension of the core spec, probably using a [named generator](#68), and signatures which don't involve this generator at all can be supported.",
      "createdAt": "2022-02-23T22:26:05Z",
      "updatedAt": "2023-03-20T19:53:54Z",
      "closedAt": "2023-03-20T19:53:54Z",
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That is truly very interesting. How will you prove zero knowledge though?? Following the same logic from the [paper](https://eprint.iacr.org/2016/663.pdf) doesn't seem possible, especially for `Abar` (the issuer will have to publish `Gbar ^ (-e)` for every signature, but the simulator will not know which one to use since they don't know the signature. Note that in the papers version the issuer publishes `Gbar ^ x` which is the same for all signatures)",
          "createdAt": "2022-02-24T00:09:33Z",
          "updatedAt": "2022-02-24T00:09:33Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "At first glance, I think you just take a random `p` and `D`, set `A' = Gbar_1*p` and `Abar = Gbar_2*p - D`? I need to go through it a bit more though.",
          "createdAt": "2022-02-24T00:20:55Z",
          "updatedAt": "2022-02-24T00:29:04Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Wright, that makes sense. In general, although I do agree that we may need to look more into it, this is a strong +1 from me. It simplifies spkGen so much that I think it is worth moving away from the papers. We will need to describe the simulator/ extractor in the spec though. IMO it's worth it.\r\n\r\nAlso, I think `C2` in the prover should be\r\n```\r\nC2 = D*r3~ - sum_over_R(H_i * m~_i)\r\n```\r\nAnd then in the verifier it should be\r\n```\r\nC2 = (-P1 - sum_over_D(H_i * m_i)) * c + D * r3^ - sum_over_R(H_i * m^_i)\r\n```\r\n(we may want to invert all the + and - for efficiency. i,e., leave the equations the same and only change `D*r3~` to `D*(-r3~)` in the prover and `D*r3^` to `D*(-r3^)` to the verifier. I think that can also work)",
          "createdAt": "2022-02-24T12:57:26Z",
          "updatedAt": "2022-02-24T14:45:28Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks, yes I just negated `r3` in `C2` consistent with the current proof.",
          "createdAt": "2022-02-24T16:19:37Z",
          "updatedAt": "2022-02-24T16:19:37Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@andrewwhitehead prove that this is secure. If you're going to deviate from the original paper spec then please provide a proof of security.",
          "createdAt": "2022-02-28T21:22:42Z",
          "updatedAt": "2022-02-28T21:22:42Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It's actually trivial to convert from this proof output to the current proof output and still have it verify, which tells me it must be secure from the verifier's perspective. Is there more to the original proof than the Lemma 2 paragraph?\r\n\r\nIn any case, for a proof from this method `(A', Abar, D, e^, r2^, m^_0, {m^_i}, c)` one can just set `Abar2 = Abar + D`, `r3^ = - r2^`, `s^ = m^_0` and output `(A', Abar2, D, e^, r2^=0, r3^, s^, {m^_i}, c)`. A prover could do this now and save a few cycles (the `r3^` negation is only because it's negated earlier here).",
          "createdAt": "2022-03-01T00:34:07Z",
          "updatedAt": "2022-03-01T00:50:50Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I do also agree with @mikelodder7 that we should supply a proof of security on the spec, i.e., describe an extractor and a simulator, rather than mapping to the original proof value (although that is good for having confidence in the security of the new method). Those do seem to be more or less constructed by @andrewwhitehead though and from my testings everything seems to work. Still more reviews are needed (and will likely come from the cfrg).",
          "createdAt": "2022-03-01T16:37:45Z",
          "updatedAt": "2022-03-01T16:37:45Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes I agree it needs a formal proof, but I'm still curious why the original proof goes to the trouble it does with H_0, as it seems like an intentional choice.",
          "createdAt": "2022-03-01T17:02:13Z",
          "updatedAt": "2022-03-01T17:02:13Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It is curious. \u03a4he only thing that comes to mind is that they wanted to just use the proof of knowledge they had on [Camenisch, Drijvers and Hajny, 2016](https://www.researchgate.net/profile/Jan-Camenisch/publication/310823143_Scalable_Revocation_Scheme_for_Anonymous_Credentials_Based_on_n-times_Unlinkable_Proofs/links/599bdfd745851574f4ac7bcd/Scalable-Revocation-Scheme-for-Anonymous-Credentials-Based-on-n-times-Unlinkable-Proofs.pdf) for weak Boneh-Boyen signatures, which they do reference as \"inspiration\" for the bbs+ proof. In that proof (for weak Boneh-Boyen signatures), if we map `sigma` to `A`, `m` to `e` and `g1` to `B` we will get essentially the \"standard\" bbs+ proof I think.",
          "createdAt": "2022-03-01T17:39:28Z",
          "updatedAt": "2022-03-01T17:42:05Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I've updated the document now to add an attempt at the proof.",
          "createdAt": "2022-03-01T20:06:59Z",
          "updatedAt": "2022-03-01T20:06:59Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think there's two ways this could be integrated in the current spec(s).\r\n\r\n- Simply update `SpkGen` and `SpkVerify` to follow this method, but explicitly handling `s` as an unrevealed message. This would mean that the `s` generator would need to be defined in the core spec, whether it is chosen to be global or issuer-specific. Commitments, commitment proofs, blinded signature creation, and unblinding would still be defined in the separate specification.\r\n\r\n- `Sign`, `Verify`, `SpkGen`, and `SpkVerify` can be updated to remove any mention of `s`. This would change the representation of the basic signature to have just `A` and `e` components. Since the blind signing extension spec already needs to define its own `BlindSign` method in order to include the commitment value, this does seem like a reasonable option to me. Note that blind signatures would still be compatible with the core methods, but `s` would be handled as an unrevealed message against a standard generator (defined in the extension spec).",
          "createdAt": "2022-03-02T19:27:06Z",
          "updatedAt": "2022-03-02T19:33:25Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I would go with option 1. IMO changing the signature would raise more questions and require more proofs (and unforgability proofs would be much harder constructed and described). This also facilitates the fact that `s` should be treated differently at least in `spkGen` i.e., as a secret message that is never revealed. That also requires `s` to be uniform random (not much use if the verifier is able to guess it) so it is easier to define it that way in `sign`.\r\n\r\nThe reason i think we should keep using `s` in `spkGen` is that if we don't then if `A` becomes known it can be used to reveal all the messages from the proof since it holds that `e(A, D) = e(B, A')`. The adversary could just keep trying hidden messages -which most likely will not be that many- and check the equality until they find `B`. Granted this \"attack\" is highly unlikely (maybe if the issuer's records get compromised, and only `A` is revealed?), but that will not even be possible if `B` contains a uniformly random element.",
          "createdAt": "2022-03-02T21:12:13Z",
          "updatedAt": "2022-03-02T21:42:11Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It seems likely that if `A` becomes known then `s` would also be known, no?\r\n\r\nIn any case I did find this in section 5.2 of CL16:\r\n\r\n>Our protocol is quite similar to the most recent qSDH-based DAA schemes [Che09,BL10,CU15]. However, a few key changes were needed to achieve provable security and address the problems mentioned in Sect. 2. First, we use a BBS+ signature for the membership credential, instead of the simplified credential where the s-value is ommited as used in the recent schemes [Che09,BL10,CU15]. This credential is proven to be unforgeable, where the simplified version is not.",
          "createdAt": "2022-03-02T21:59:35Z",
          "updatedAt": "2022-03-02T21:59:35Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> It seems likely that if A becomes known then s would also be known, no?\r\n\r\nYea which kinda raises an issue now that i think about it. If the signature is revealed at any point any subsequent proof presentations will be insecure (not zero knowledge). \r\n\r\nMaybe a some slight modification of the original proposal is needed?? Just throwing an idea, maybe defining first `D = B * r2` and then `A' = A * (r1*r2)` and `Abar = A'*(-e) + D * (r1) = A'*x`?? I have not test the modification at all formally for security, but from a very quick look it seems it may hold and i think it may also solve the above issue.",
          "createdAt": "2022-03-02T22:39:26Z",
          "updatedAt": "2022-03-02T22:39:26Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So here's the proposed modification and the security analysis; https://hackmd.io/@Vasileios/H190hWAg5\r\n\r\nEssentially it's the same method as the [original proposal](https://hackmd.io/8t8o56mvTL6p-VZyayLnTA?view) from @andrewwhitehead but using an additional random number when blinding `A` in a way that doesn't raise complexity too much. This changes a little the specifics of the proof and makes spkGen to have 2 additional steps but it avoids the above problem, i.e., it no longer holds that `e(A, D) = e(B, A')`. Notice also that the simulator is essentially the same as the one in [CDL16](https://eprint.iacr.org/2016/663.pdf).",
          "createdAt": "2022-03-03T13:38:35Z",
          "updatedAt": "2022-03-03T13:38:35Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looks good to me, and the intent of the original seems clearer now. I slightly prefer setting `r3 = -1/r2` so that the verifier doesn't need to negate anything, but if message responses need to be in the form `m^i = m~i - c*m_i` then that might change anyway.",
          "createdAt": "2022-03-03T17:56:08Z",
          "updatedAt": "2022-03-03T17:56:08Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Looks good to me, and the intent of the original seems clearer now. I slightly prefer setting r3 = -1/r2 so that the verifier doesn't need to negate anything, but if message responses need to be in the form m^i = m~i - c*m_i then that might change anyway.\r\n\r\nThanks! That's a good point. I negated the `1/r2` and left the messages as `m^i = m~i + c*m_i`. This seems to be the most efficient way.\r\n\r\nI guess the next step is that we should decide if it is worth to update the spec and move away from the papers. As it is now, it seems that the `spkGen` will be more efficient and with 3-4 less steps + less point multiplications with scalars. So I don't see why to not update it since there is a more efficient version with a proof of security. Granted the security proof needs more reviews but those will likely come from the cfrg.",
          "createdAt": "2022-03-04T10:55:21Z",
          "updatedAt": "2022-03-04T11:03:39Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I disagree that the reviews will come from the cfrg. If we\u2019re that confident in the changes let\u2019s write up a paper and submit it to be peer reviewed.",
          "createdAt": "2022-03-04T12:37:45Z",
          "updatedAt": "2022-03-04T12:37:45Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We can If @andrewwhitehead is interested. I was thinking maybe working on a paper that will give an overview of bbs+ as it forms in the spec with a little more detailed security analyses compared to the original paper (+binding +blinding maybe??). Maybe we can merge the 2. First though, I don't think that having something like that been reviewed by the academic community is necessary to move with the update. Secondly, simplifying the spkGen algorithm it may not be enough novelty to have a paper submitted to a good conference (not to mention a journal).  \r\n\r\nIn the end the question kinda remains, publishing a paper will take at the very least a couple of months. In the mean time should we update the spec?? (IMO yes but i do also understand the counter point).",
          "createdAt": "2022-03-04T18:51:48Z",
          "updatedAt": "2022-03-04T18:51:48Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm happy to help out where I can, but probably can't commit to following through with a paper or conference presentation right now.\r\n\r\nJust to summarize the suggested update, ignoring sign changes (`s`, `s~`, `s^` should be named explicitly as well)...\r\n\r\n- `A'` is set to `Ar1*r2` instead of `Ar1`\r\n- `D` is set to `Br2` instead of `Br1 - H0r2`\r\n- `Abar` is set to `A'(-e) + Br1*r2` instead of `A'(-e) + Br1`, still equal to `A'x`\r\n- `C1` shows that `Abar = A'(-e) + Dr1` instead of `Abar = A'(-e) + D + H0r2`\r\n- `C2` remains essentially the same\r\n- `s^` uses the same formula as unrevealed messages, `s~ + cs` instead of `s~ + c(s - r2 * r3)` used to cancel out the extra `H0r2` factor in `D`\r\n\r\nBecause we are not looking to support the revocation mechanism in the paper, including the SPK generation performed in cooperation by the host and the TPM (`Sign Proceed`), it makes sense that the SPK can be simplified a little.",
          "createdAt": "2022-03-04T19:47:55Z",
          "updatedAt": "2022-03-04T21:46:00Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes. We may also be able to adjust the `Sign Proceed` operation to work with the simplified version. I may have to look more into it but In the protocol I think `s` isn't communicated between the host and the TPM meaning that there is no reason to \"randomize\" it beforehand using `s'`. Treating it as any other hidden message may work.",
          "createdAt": "2022-03-07T17:34:37Z",
          "updatedAt": "2022-03-07T17:34:37Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Interestingly a similar optimization has been documented in a new academic publication (cannot link yet as it isn't public) that formally proves the security of this construction, we will pause progressing this issue until that paper has been further reviewed.",
          "createdAt": "2022-12-05T19:46:18Z",
          "updatedAt": "2022-12-05T19:46:18Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on WG call on 20th of Mar. Closing for now and will revisit when reviewing the latest academic works!",
          "createdAt": "2023-03-20T19:53:54Z",
          "updatedAt": "2023-03-20T19:53:54Z"
        }
      ]
    },
    {
      "number": 73,
      "id": "I_kwDOF8lax85EyFjQ",
      "title": "Deterministic SPK",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/73",
      "state": "CLOSED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "ready-for-pr",
        "core"
      ],
      "body": "Although deterministic proof generation should not be used in practice it may be useful to support it, so we can more easily create and update test vectors. This MUST NEVER be used in practice. The main idea is to incorporate a secret key managed by the holder of the bbs signature into spkGen that is going to be used for the generation of the random elements. This secret MUST be unique for every proof generation procedure. One possible method then, is to use the same algorithm as in deterministic signing, i.e.,\r\n```\r\nH = XOF(Holders_SK || msg_i1 ||\u2026||msg_iR || pm)\r\nr1~ = OS2IP(H.read(64)) mod q\r\nr2~ = OS2IP(H.read(64)) mod q\r\n              .\r\n              .\r\n              .\r\n```\r\nIn spkGen, maybe we can also use [RFC 8937](https://www.rfc-editor.org/rfc/rfc8937.html), which gives good security properties and is easy to use, since you don't need direct access to the secret key itself. Each random element (in the non-deterministic case) could be\r\n```\r\nrandom_element_i = OS2IP(HKDF-Expand(HKDF-Extract(HASH(Sig(Holders_SK, DST)), PRF(L)), i, 64)) mod q\r\n```\r\nTo get a deterministic spk, we could just replace the PRF with an XOF or hash. That said, this does \"bound\" the holder to use a secret, even in the non-deterministic case.\r\n",
      "createdAt": "2022-02-28T11:30:24Z",
      "updatedAt": "2023-02-24T04:26:16Z",
      "closedAt": "2023-02-24T04:26:16Z",
      "comments": [
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In Rust this is often done by making the method generic over a `rand::Rng + CryptoRng` and then substituting a deterministic generator, like a seeded ChaCha permutation.",
          "createdAt": "2022-03-02T00:10:10Z",
          "updatedAt": "2022-03-02T00:10:10Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Related to #7 and somewhat #212 ",
          "createdAt": "2022-12-05T19:47:26Z",
          "updatedAt": "2022-12-05T19:47:26Z"
        }
      ]
    },
    {
      "number": 74,
      "id": "I_kwDOF8lax85EyHKt",
      "title": "Adding the revealed messages to the chalenge to avoid forgery",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/74",
      "state": "CLOSED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "BasileiosKal"
      ],
      "labels": [
        "ready-for-pr",
        "core"
      ],
      "body": "The following is a method that could possibly allow the prover to reveal messages for which they don't have a signature, taking advantage of the Fiat\u2013Shamir challenge not containing the revealed messages. Let the prover with a signature `(A, e, s)` on messages `msg_1`, `msg_2` and `msg_3`, creating an spk revealing only `msg_1`. Going through the spkGen process the prover will calculate\r\n```\r\nC2_prover = D*(-r3~) +H0 * (s~) + H_2 * m~_2 + H_3 * m~_3\r\n```\r\nThe proof value will be,\r\n```\r\nspk = (Abar, A\u2019, D, c, e^, r2^, r3^, s^, m^_2, m^_3)\r\n```\r\nFrom the verification process we know that if `T = P1 + H_1 * msg_1` then \r\n\r\n```\r\n#EQ1: T*c + D * (-r3^) + H0*s^ + H_2 * m^_2 + H_3 * m^_3 = C2_prover\r\n```\r\n\r\nLet the prover now calculate the following,\r\n1.\t`c\u2019  = c ^ -1 mod q`\r\n2.\t`msg_adv  = m^_2 * c'`\r\n\r\nand instead of revealing spk, they send `spk2`,\r\n```\r\nspk2 = (Abar, A\u2019, D, c, e^, r2^, r3^, s^, m^_3)\r\n```\r\nwith revealed messages `msg_1` and `msg_adv`. \r\n\r\nThe verifier receiving `spk2` and `msg_1`, `msg_adv` will calculate `C1_verifier`, `C2_verifier` and check the pairing equality. Note that since `Abar, A\u2019, D, c, e^, r2^` remain the same between `spk` and `spk2`, `C1_prover = C1_verifier` and `e(A', PK) = e(Abar, P2)`. To calculate `C2_verifier` the verifier will first calculate `T2` as,\r\n\r\n```\r\nT2 = P1 + H_1 * msg_1 + H_2 * msg_adv = P1 + H_1 * msg_1 + H_2 * (m^_2 * c')\r\n```\r\nFrom that the verifier will calculate,\r\n```\r\nC2_verifier = T2*c + D * (-r3^) + H0*s^ + H_3 * m^_3 =\r\n   = D * (-r3^) + H0*s^ + (P1 + H_1 * msg_1) * c +  H_2 * (m^_2 * c' * c)  H_3 * m^_3 =  \r\n   = D * (-r3^) + H0*s^ + T * c +  H_2 * m^_2 +  H_3 * m^_3  = C2_prover\r\n```\r\nThe last equality follows from #EQ1. As a result, the verification will succeed for `msg_1` and `msg_adv`.\r\n\r\nObviously, this should not be possible, since this proves knowledge of a signature that the prover doesn't have (which contains `msg_adv`). If I'm correct on the above, most likely the only issue is with the Fiat\u2013Shamir heuristic. Note that if the protocol was interactive, that method will not work, since the prover would have to \"commit\" to the messages prior of getting the challenge `c`. Hence we should also pass the revealed messages to the hash of the challenge during spkGen and spkVerify, to \"commit\" them before the challenge is created. ",
      "createdAt": "2022-02-28T11:37:48Z",
      "updatedAt": "2022-06-27T19:45:11Z",
      "closedAt": "2022-06-27T19:45:11Z",
      "comments": [
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "No this is not correct. BBS+ is unforgeable like ECDSA. This includes in proofs. You have a bug in your math. If you compute it correctly you can\u2019t forge proofs or signatures ",
          "createdAt": "2022-02-28T20:40:31Z",
          "updatedAt": "2022-02-28T20:40:31Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@mikelodder7 can you highlight the bug in the maths here?",
          "createdAt": "2022-02-28T20:57:10Z",
          "updatedAt": "2022-02-28T20:57:10Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The problem is sending msg_adv and not m^_2. m^_2 = m~_2 +cm_2. msg_adv = m_2c' + m_2. If you calculate with that difference the equation does not balance. @BasileiosKal. ^^",
          "createdAt": "2022-02-28T21:02:45Z",
          "updatedAt": "2022-02-28T21:02:45Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It appears to work in my quick test. I think just adding the number of revealed messages to the challenge hash might be sufficient, unless there's a way to do the same thing in reverse to make that balance.",
          "createdAt": "2022-02-28T21:08:28Z",
          "updatedAt": "2022-02-28T21:08:28Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So your saying I should have over 1/c* my first name as the revealed message? In practice will someone believe that? No. The procedure for revealed messages should include the mapping of how they got to the cryptographic value.",
          "createdAt": "2022-02-28T21:15:35Z",
          "updatedAt": "2022-02-28T21:15:35Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "For example, let's assume m_2 is my first name. The mapping is hash to Z_q*. If I received msg_adv, I would hash to Z_q* and check it. The hashing effectively destroys the 1/c computation and the proof fails.",
          "createdAt": "2022-02-28T21:18:00Z",
          "updatedAt": "2022-02-28T21:18:00Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm not seeing how this is even working.  Just tried in my rust code and it fails.",
          "createdAt": "2022-02-28T21:18:31Z",
          "updatedAt": "2022-02-28T21:18:31Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It would probably not be useful for any hashed values, but it could work for numeric values since the prover can run the protocol many times until they get a `msg_adv` value within a useful range.",
          "createdAt": "2022-02-28T21:32:17Z",
          "updatedAt": "2022-02-28T21:32:17Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I do also agree this is hard to take advantage in practice but we should be protected against it either way. \r\n\r\nA forgery is still dangerous IMO.  If it's a name we talking about this may not be of use but what if it's a revocation ID and I'm able to present a different one??\r\n\r\nThe message mappings are not mandatory and IMO the proof should be safe without them. We could make hashing of the messages mandatory but I think there are simpler solutions.\r\n\r\n> I think just adding the number of revealed messages to the challenge hash might be sufficien\r\n\r\nYeap that may be anotherore efficient solution\r\n",
          "createdAt": "2022-02-28T21:35:03Z",
          "updatedAt": "2022-02-28T21:35:03Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Still not seeing how this attack even works. I just tried it and my proof fails.",
          "createdAt": "2022-02-28T21:38:26Z",
          "updatedAt": "2022-02-28T21:38:26Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I added a reproduction [here](https://github.com/andrewwhitehead/bbs-issue-74). (Edit: updated to add the unforged proof check.)",
          "createdAt": "2022-02-28T21:57:17Z",
          "updatedAt": "2022-02-28T22:34:12Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@andrewwhitehead That example is not using an unsigned message.  The point of this is that mh isn't even signed. Try it with another random message that's not in the signature.",
          "createdAt": "2022-03-01T00:42:05Z",
          "updatedAt": "2022-03-01T00:42:05Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mikelodder7 The point is that the proof verifies with the revealed message `m_adv` which is not the same as what was signed (`mh`).",
          "createdAt": "2022-03-01T00:54:43Z",
          "updatedAt": "2022-03-01T00:54:43Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Actually, it's not sufficient to add the number of revealed messages, I believe the actual revealed messages have to be added to the hash to prevent substitution.",
          "createdAt": "2022-03-01T01:49:27Z",
          "updatedAt": "2022-03-01T01:49:27Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "I remember @christianpaquin mentioning on a WG call that UProve included a similar mechanism?",
          "createdAt": "2022-03-01T01:55:40Z",
          "updatedAt": "2022-03-01T01:55:40Z"
        },
        {
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I remember @christianpaquin mentioning on a WG call that UProve included a similar mechanism?\r\n\r\nYes, in the [U-Prove spec](https://github.com/microsoft/uprove-csharp-sdk/blob/master/docs/U-Prove%20Cryptographic%20Specification%20V1.1%20Revision%203.pdf), the prover hashes (among other things) the disclosed attribute indices and their values (see `c_p` calculation on page 18).",
          "createdAt": "2022-03-01T15:56:32Z",
          "updatedAt": "2022-03-01T15:56:32Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> The problem is sending msg_adv and not m^_2. m^_2 = m~_2 +cm_2. msg_adv = m_2c' + m_2. If you calculate with that difference the equation does not balance. @BasileiosKal. ^^\r\n\r\nIf we take  `msg_adv = m~_2 * c' + msg_2` then when the verifier calculates `C2` they will get\r\n```\r\nC2_verifier = (P1 + H_1 * msg_1 + H_2 * (m~_2*c' + msg_2))*c + D * (-r3^) + H0*s^ + H_3 * m^_3 =\r\n   = D * (-r3^) + H0*s^ + (P1 + H_1 * msg_1 + H_2 * msg_2) * c  + H_2 * m~_2 + H_3 * m^_3 =  \r\n   = D * (-r3~) + H0*s~ - (P1 + H0*s + H_1 * msg_1 + H_2 * msg_2  + H_3 * msg_3) * c  + ...\r\n         ... + (P1 + H_1 * msg_1 + H_2 * msg_2) * c  + H0*(s*c) + H_2 * m~_2 + H_3 * m~_3  + H_3 * msg_3 *  c =\r\n   = D * (-r3~) + H0*s~ + H_2 * m~_2 + H_3 * m~_3 = C2_prover\r\n```\r\nSo i don't see where I'm wrong to be honest, but i could be missing something.",
          "createdAt": "2022-03-01T16:14:09Z",
          "updatedAt": "2022-03-01T16:14:09Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Actually, it's not sufficient to add the number of revealed messages, I believe the actual revealed messages have to be added to the hash to prevent substitution.\r\n\r\nRight, I guess nothing stops the prover from passing the \"wrong\" number of messages from the start (i.e., 2 in the example above). Maybe, aside from the revealed messages, we should also pass the `H_i` (or their indexes) similar to what U-prove does?? @christianpaquin where there any attacks that passing things like `<D>` and `<C>` in the challenge avoided, or it was for general good security practices??",
          "createdAt": "2022-03-01T16:22:31Z",
          "updatedAt": "2022-03-01T16:26:44Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@BasileiosKal is this addressed via #95 or are there still updates we need to make to the proof challenge?",
          "createdAt": "2022-05-03T21:44:05Z",
          "updatedAt": "2022-05-03T21:44:05Z"
        }
      ]
    },
    {
      "number": 75,
      "id": "I_kwDOF8lax85FEO4w",
      "title": "BBS spk security against an untrusted/compromised issuer",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/75",
      "state": "CLOSED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "BasileiosKal"
      ],
      "labels": [
        "ready-for-pr"
      ],
      "body": "Let\u2019s say that the issuer gets compromised, i.e., both their secret key `x` and the records with the signatures they signed will become known. Let\u2019s assume a holder has a bbs+ signature `(A, e, s)` from that issuer with `A = B * (1/(e+x))` where `B = P1 + H0*s + H_1*msg_1 + \u2026 + H_L*msg_L`. Any spk will be of the form, `spk = (A', Abar, D, ...)` where \r\n```\r\nA' = A * r1 =  B * r1 * (1/(e+x))\r\n```\r\n and \r\n```\r\nAbar = A' * x =  B * r1 * (x/(e+x))\r\n```\r\nThe values `(B, B*x, A', Abar)` essentially form a DDH tuple, which is easy to solve using pairings. Specifically, it will hold, \r\n```\r\ne(B*x, A\u2019) = e(B*x, B*r1*(1/(e+x))) = e(B, B) ^(r1*(x/(e+x))) = e(B, B*r1*(x/(e+x)))\r\n```\r\nmeaning that,\r\n```\r\ne(B*x, A') = e(B, Abar)\r\n```\r\nSo, if an adversary who knows `x` and `s`, sees (or has already seen) a proof with `A\u2019` and `Abar`, they can just try different messages, construct `B` and check the above equality between the pairings. Since the messages will not be many this is not hard to do and will result in the secret messages of the holder been revealed. \r\n\r\nIf the Issuer is untrusted, they can use the above equation to track the holder by correlating the spk's with specific signatures.\r\n\r\nThis is mitigated a little by using blind or bound signatures. If the commitment is not revealed an adversary will not be able to construct `B` by trying possible hidden messages. However, it is reasonable to assume here that if the issuers secret key and the signatures they signed are revealed so will the commitments (they will be known -and possibly recorded- by the issuer). Furthermore, if the issuer is untrusted. they can still correlate the holder.\r\n\r\nAs a result, the bbs+ proofs are not secure against an untrusted or compromised issuer. This is not that much of an issue and is like what happens in most PKIs but it might be worth documenting it in the security considerations in the spec so we will have an accurate security model.",
      "createdAt": "2022-03-03T18:07:34Z",
      "updatedAt": "2022-04-01T08:46:37Z",
      "closedAt": "2022-04-01T08:46:37Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Really interesting issue, IMO this definitely needs to be in the security considerations section. ",
          "createdAt": "2022-03-03T21:36:35Z",
          "updatedAt": "2022-03-03T21:36:35Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "> So, if an adversary who knows x and s, sees (or has already seen) a proof with A\u2019 and Abar, they can just try different messages, construct B and check the above equality between the pairings. Since the messages will not be many this is not hard to do and will result in the secret messages of the holder been revealed.\r\n\r\nOne potential mitigation we should look to include here is for issuers to not keep a copy of signatures they issue? So if the issuer is compromised chances are the attacker doesnt get a copy of the s value for a signature?",
          "createdAt": "2022-03-03T21:37:21Z",
          "updatedAt": "2022-03-03T21:37:21Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> One potential mitigation we should look to include here is for issuers to not keep a copy of signatures they issue? So if the issuer is compromised chances are the attacker doesnt get a copy of the s value for a signature?\r\n\r\nYes, that's a good point. An honest issuer should discard at the very least `s` and not keep a record of it. If an adversary doesn't have `s`, even if they have the issuer's secret key, the above doesn't work. We should also instruct the holders of the signature that revealing `s` could compromise the security of the proof if the issuer's secret key is leaked.",
          "createdAt": "2022-03-04T00:12:23Z",
          "updatedAt": "2022-03-04T10:48:19Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Yes agreed, because `s` is apart of the original signature over all messages and the primary attack vector here is being able to reveal, un-revealed messages in a proof of a signature involving `s` chances are that if the issuers private key is compromised and so is `s` the attacker probably also got a copy of the original messages signed by the signature. None the less we should document this consideration carefully in the spec so implementers are aware.",
          "createdAt": "2022-03-04T20:50:41Z",
          "updatedAt": "2022-03-04T20:50:41Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "I've tagged this issue as ready for PR as it appears we are clear around the resolution which is to add a note to the security considerations section",
          "createdAt": "2022-03-06T23:14:26Z",
          "updatedAt": "2022-03-06T23:14:26Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm having trouble seeing what correlation is enabled here.\r\n\r\n    e(B*x, A') = e(B, Abar)\r\n\r\nThis seems self-evident given that `Abar = A'x`, plus you could substitute any point for `B` in the equation and the result would be the same. That said, it did seem to me like there was a problem when this issue was initially filed.",
          "createdAt": "2022-03-21T20:58:45Z",
          "updatedAt": "2022-03-21T21:01:25Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That is absolutely correct. Tbo kinda annoyed with my self that i missed it. I'm really sorry about that. Although It does seem to me that the issuer may still find a relationship that would correlate the prover. For example, they could calculate `K = e(p1*c, B*r1)` (since they know e, x, d) and check `e(p1*c, A') = K*(1/x+e)`. Another thing i missed though is that any method like that works on type 2 or 3 pairings. However we are exclusively using type 3 since we are using the construction of CDL16. Maybe just a note documenting that will suffice instead of the addition in #86.",
          "createdAt": "2022-03-22T13:33:00Z",
          "updatedAt": "2022-03-22T13:33:00Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Just re-opening this issue so we can be sure to capture any updated text required in the security considerations merged in #86 ",
          "createdAt": "2022-03-23T21:29:34Z",
          "updatedAt": "2022-03-23T21:29:34Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Addressed in #91. Closing",
          "createdAt": "2022-04-01T08:46:37Z",
          "updatedAt": "2022-04-01T08:46:37Z"
        }
      ]
    },
    {
      "number": 76,
      "id": "I_kwDOF8lax85FL7G0",
      "title": "Update core operations to clarify the form of input messages",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/76",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [
        "tplooker"
      ],
      "labels": [
        "ready-for-pr",
        "core",
        "editorial"
      ],
      "body": "Currently the core sign, verify, spkGen and spkVerify operations are silent on the form the messages take into the algorithm, based on conversations with @mikelodder7 these are most often inputed in the form of scalars as outputed by the MapToScalar function being proposed in #61. We should clarify this further in the spec.",
      "createdAt": "2022-03-06T23:53:49Z",
      "updatedAt": "2023-02-14T22:59:42Z",
      "closedAt": "2023-02-14T22:59:42Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed on WG call 15th of August, subsequent text has clarified this significantly however supporting text at the start of the relevant operations would help to resolve any outstanding ambiguity.",
          "createdAt": "2022-08-15T18:55:29Z",
          "updatedAt": "2022-08-15T18:55:29Z"
        }
      ]
    },
    {
      "number": 78,
      "id": "I_kwDOF8lax85FQQWd",
      "title": "Domain separation of generated signatures",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/78",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [
        "BasileiosKal"
      ],
      "labels": [
        "ready-for-pr",
        "core"
      ],
      "body": "At the moment within the scope of this specification there are several points of extension, such as\r\n\r\n- How messages are mapped to their appropriate scalar values\r\n- How the generators used to commit each message are created (e.g from a global, issuer specific or signature specific seed)\r\n\r\nMany of these above decisions will be limited or at least formally defined in a concrete [ciphersuite](https://identity.foundation/bbs-signature/draft-bbs-signatures.html#name-bls12-381-ciphersuite) to promote interoperability. However with multiple possible cipher suites overtime that make different choices, how do we ensure that a signature generated under one cipher suite is not confused with one generated under another cipher suite. \r\n\r\nOne proposal to limit the possibility of this occurring is to define that the first message in a BBS signature MUST always be revealed further more this message could contain a range of information OR something more limited like a cipher suite identifier. As raised by @BasileiosKal on the call, putting too much information in this revealed message is likely to create a correlation risk that would erode some of the benefit that BBS signatures provide, so perhaps a better middle ground would be to instead encode the cipher suite identifier (e.g for the current BLS12381 cipher suite in the spec this could be the hash scalar produced from the string `BBS_BLS12381G1_XOF:SHAKE-256`)",
      "createdAt": "2022-03-07T20:29:15Z",
      "updatedAt": "2022-05-03T21:42:22Z",
      "closedAt": "2022-05-03T21:42:21Z",
      "comments": [
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If you do this approach you can no longer link messages across signatures anymore. The better approach which the original paper says is to use unique generators per signer or as we've started calling it local create generators based on the signers public key.",
          "createdAt": "2022-03-07T21:18:13Z",
          "updatedAt": "2022-03-07T21:19:11Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@mikelodder7 can you please elaborate on how this is the case, the preferred proposal is merely to have the first message be a protocol identifier? I dont see how this would prevent cross signature?",
          "createdAt": "2022-03-07T21:36:56Z",
          "updatedAt": "2022-03-07T21:36:56Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Local generators would still not fully address the security concern described above, for example as a holder or verifier I would not know which message mapping methods are being used in the cipher suite so a malicious party could use this to attack in certain scenarios",
          "createdAt": "2022-03-07T21:40:12Z",
          "updatedAt": "2022-03-07T21:40:12Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If each message is mapped differently to a scalar per issuer then that means my name will not map to the same value in two different signatures and therefore I can't prove they are equal.",
          "createdAt": "2022-03-07T21:41:38Z",
          "updatedAt": "2022-03-07T21:41:38Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If you want a correlating identifier then why even use BBS+?!?",
          "createdAt": "2022-03-07T21:42:07Z",
          "updatedAt": "2022-03-07T21:42:07Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It solves the problem because local generators are unique per signer therefore the commitments are different and serve the same purpose as the cipher suite. ",
          "createdAt": "2022-03-07T21:43:25Z",
          "updatedAt": "2022-03-07T21:44:09Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Mike I think you are miss reading the actual proposal here e.g the first message is simply just the scalar mapped representation of the cipher suite id `BBS_BLS12381G1_XOF:SHAKE-256`, this is not correlating nor negates the ability to prevent cross signature linking.",
          "createdAt": "2022-03-07T21:47:21Z",
          "updatedAt": "2022-03-07T21:47:21Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Further more as I said above signer specific generators alone would not address the security concern about how different cipher suites may elect to support different message mapping procedures",
          "createdAt": "2022-03-07T21:47:59Z",
          "updatedAt": "2022-03-07T21:48:11Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I understand it better now. Thanks. That helps to clarify it.",
          "createdAt": "2022-03-07T21:51:19Z",
          "updatedAt": "2022-03-07T21:54:06Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@mikelodder7 great, would you support such a proposal?",
          "createdAt": "2022-03-07T22:40:44Z",
          "updatedAt": "2022-03-07T22:40:44Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1 from me. I do like the proposal. \r\n\r\nI may prefer the domain separation string to be an optional parameter of the `sign`, `verify` etc functions, so we would avoid saying that the first message MUST always be revealed, which may be confusing (for clarity, i would prefer the input list of messages to be just the attributes the issuer wants to sign). This way, if the prover and the holder have already agreed on what cyber suite to use, it will not be necessary for the prover to actually \"reveal\" that message since the verifier will already \"know it\".",
          "createdAt": "2022-03-07T23:01:28Z",
          "updatedAt": "2022-03-07T23:01:28Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Agree, in a practical sense I would expect the sign and verify APIs would take the cipher suite id as a seperate parameter rather than as the first message, that way it is clear it wouldn't actually have to be communicated to another party as the expectation is that this is communicated at a higher level similar to the DST.",
          "createdAt": "2022-03-08T00:27:14Z",
          "updatedAt": "2022-03-08T01:34:39Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "To me the proposal is clear, so I will submit a PR to further the conversation",
          "createdAt": "2022-03-08T02:49:48Z",
          "updatedAt": "2022-03-08T02:49:48Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think it would be better to calculate this domain separation message in the same way as the challenge, using all the parameters that need to be enforced to avoid malleability which aren't going to vary at the time of presentation. This value would likely be cached by the prover. It may or may not be provided by the issuer at the time of issuance, I think generally it would be unless trying to save a minuscule amount of bandwidth. The inputs should include at least:\r\n\r\n- the cipher suite (and by extension the hash function and curve details)\r\n- the issuer's public key (to avoid issues such as #85)\r\n- the number of signed messages\r\n- the generator points used, in a standard order\r\n\r\nNB that the last two are necessary if the generators are not always deterministically generated from the issuer's public key and the number of messages, as they were in the earlier text. This leaves only a few things to hash into the presentation challenge:\r\n\r\n- `A'`, `Abar`, `D`, `C1`, `C2`\r\n- the revealed message indices and values (see #74), including the value of the domain separation message \u2013 and by extension the values above\r\n- the presentation nonce\r\n\r\nThe domain separation message could optionally include a byte string containing application-specific scope information. This would probably be the place for things like a schema identifier or revocation registry identifier (required-revealed attributes), and could be used to discriminate signatures that are meant to be bound to a specific session (adding a signature nonce).",
          "createdAt": "2022-03-21T23:23:51Z",
          "updatedAt": "2022-03-22T16:26:08Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Regarding the generators, couldn't the Verifier \"validate\" them using the global seed?? Other than that its a +1 from me.\r\n\r\nAlso I think we must update the blindSignatures extension to accommodate these changes. I imagine that in the extension the number of signed messages etc., will also have to take into consideration the blinded messages and so on.",
          "createdAt": "2022-03-28T20:51:45Z",
          "updatedAt": "2022-03-28T20:51:45Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "> Regarding the generators, couldn't the Verifier \"validate\" them using the global seed?? Other than that its a +1 from me.\r\n\r\nThis is a good question to me, if the cipher suite always fully defines the generators then I can see how perhaps this inclusion could be redundant, however if someone were to define a BBS signature cipher suite that uses signature specific, random or issuer specific generators then maybe it becomes useful to have these protected through the integrity of the signature?\r\n\r\n> Also I think we must update the blindSignatures extension to accommodate these changes. I imagine that in the extension the number of signed messages etc., will also have to take into consideration the blinded messages and so on.\r\n\r\n+1 to this too I will open an issue to track more generally that we will need to revise the blind signature extension draft to be consistent with the core draft.",
          "createdAt": "2022-03-28T21:27:39Z",
          "updatedAt": "2022-03-28T21:27:52Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It's possible that the generator values could be left out, for now at least I'm erring on the side of caution and adding them.",
          "createdAt": "2022-03-28T23:47:47Z",
          "updatedAt": "2022-03-28T23:47:47Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "> It's possible that the generator values could be left out, for now at least I'm erring on the side of caution and adding them.\r\n\r\nCould you elaborate on the potential concern here?",
          "createdAt": "2022-03-29T00:29:33Z",
          "updatedAt": "2022-03-29T00:29:33Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "> This is a good question to me, if the cipher suite always fully defines the generators then I can see how perhaps this inclusion could be redundant, however if someone were to define a BBS signature cipher suite that uses signature specific, random or issuer specific generators then maybe it becomes useful to have these protected through the integrity of the signature?\r\n\r\nJust another thought here, maybe what is actually featured in this message is the cipher suite id + an additional data structure, where the structure and contents of which is dictated by the cipher suite itself? So for ciphersuites like the current one in the spec we dont have to include all the generators because they are fixed (e.g derived from a global seed) whereas another ciphersuite would be free to include them in the additional data structure if they saw benefit?",
          "createdAt": "2022-03-29T02:49:32Z",
          "updatedAt": "2022-03-29T02:49:32Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "So for example for the [current ciphersuite](https://identity.foundation/bbs-signature/draft-bbs-signatures.html#name-bls12-381-ciphersuite) we could define that the additional data structure just contains the public key and number of signed messages.",
          "createdAt": "2022-03-29T02:50:42Z",
          "updatedAt": "2022-03-29T02:50:42Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It may be a little confusing as to why we allow generators to be included in the additional data structure (if we document the possibility somehow) since we don't allow ciphersuits to define their own generators. This is also related with the discussion in #68, but even if we allow ciphersuits to define the generators seed, it will be no different from the situation with the current ciphersuits (i.e., the validity of the generators could be derived from that seed). \r\n\r\nAlso it may be hard to define in the ciphersuits which generators to add to the \"signature domain separation\" since their exact number will most likely not be known. In contrast, at signing time, the issuer will know exactly which generators they will use. As an alternative we could perhaps add the seed value.\r\n\r\n> It's possible that the generator values could be left out, for now at least I'm erring on the side of caution and adding them.\r\n\r\nI imagine It is more secure since the verifier will be \"forced\" to \"check\" the correctness of the generators every time, otherwise it will be left on the verifier to do the check if they want to. I'm not opposed to that, since i don't imaging it will raise complexity, though i don't see the requirement changing if the generators are derived from the issuers pk, or a specific requirement to do so now.",
          "createdAt": "2022-03-29T18:54:21Z",
          "updatedAt": "2022-03-29T18:54:21Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If the generators depend only on the seed value, then yes we can hash that instead and be more efficient. Maybe we should add security guidelines for ciphersuites to ensure agreement over the generators in the event that they do use a custom setup procedure.",
          "createdAt": "2022-03-30T18:44:41Z",
          "updatedAt": "2022-03-30T18:44:41Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agreed. IMO we should make the generators only depend on a seed (which could also be the signers pk). Ciphersuites could define their own seeds if they want to. I don't really see a requirement to allow ciphersuites to define their own generators all together, which is also less secure. That said we should also define the security requirements of the generators, even if we only allow ciphersuit specific seeds.",
          "createdAt": "2022-03-30T19:09:37Z",
          "updatedAt": "2022-03-30T19:09:37Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes it should be part of the common reference string (CRS). That way if they do define their own generators (like just picking them at random) we allow for it. The seed should be the safest and most compatible approach ",
          "createdAt": "2022-03-31T08:25:54Z",
          "updatedAt": "2022-03-31T08:25:54Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Addressed in #95, closing.",
          "createdAt": "2022-05-03T21:42:21Z",
          "updatedAt": "2022-05-03T21:42:21Z"
        }
      ]
    },
    {
      "number": 79,
      "id": "I_kwDOF8lax85FQeMK",
      "title": "Security Review of Differences",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/79",
      "state": "CLOSED",
      "author": "brentzundel",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "core"
      ],
      "body": "The work on the specification is progressing well, but there seem to be a number of changes being considered that will cause this specification to deviate from the published and peer-reviewed academic papers.\r\n\r\nWhile there may be more, I am concerned in particular about:\r\n#19 \r\n#37\r\n#70 \r\n#78\r\n\r\nIf these changes, or any others, are made which result in a deviation from the security proofs of the source material, then new security proofs need to be written before this spec is submitted as a draft to IETF.",
      "createdAt": "2022-03-07T21:30:34Z",
      "updatedAt": "2023-08-28T18:31:33Z",
      "closedAt": "2023-08-28T18:31:32Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Thanks Brent I think we need to be careful to seperate where there are true deviations from academic literature VS ones where the literature was just not aiming to define anything at that layer, for example #78 is not a deviation from academic literature its just merely a mechanism to ensure cipher suite domain separation",
          "createdAt": "2022-03-07T21:44:58Z",
          "updatedAt": "2022-03-07T21:44:58Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think that deterministic signatures also have to be evaluated in the context of the unforgeability proof.",
          "createdAt": "2022-03-07T21:59:34Z",
          "updatedAt": "2022-03-07T21:59:34Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "For example #62 from @mikelodder7 should be included.",
          "createdAt": "2022-03-07T22:08:32Z",
          "updatedAt": "2022-03-07T22:08:32Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "62 is computing the same thing as before it\u2019s just removing the same  check from being performed twice. It doesn\u2019t need a security proof",
          "createdAt": "2022-03-07T22:15:08Z",
          "updatedAt": "2022-03-07T22:19:08Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I do also agree. From the above IMO #19 has the biggest need for a security analyses. The reason I feel confident to keep using the proposed change is that it doesn't really change the security proofs of the original academic material (both the unforgeability and the zero knowledge proof of knowledge work the same). \r\n\r\nAlso note that the construction on section 5 of the original paper considers as the issuers public key only `w` and all other generators are created for all parties from a \"common reference string functionality\" and not from the issuer (similarly to what that issue proposes).\r\n\r\nFor some of the other issues, a security proof was written and is currently discussed for #70 although it does need reviews, #37 is essentially just a commitment the same with the ones considered in the original paper and as @tplooker noted, i don't see what security proof #78 will need.",
          "createdAt": "2022-03-07T22:16:01Z",
          "updatedAt": "2022-03-07T22:16:01Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> 62 is computing the same thing as before it\u2019s just removing the same check from being performed twice\r\n\r\nI think @tplooker meant the changes to the equations going in the SPK from the ones in the paper, not the duplicate checks part (which i do like).",
          "createdAt": "2022-03-07T22:24:49Z",
          "updatedAt": "2022-03-07T22:24:49Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "AFAIK there are no changes to the SPK that I made and should already match the original paper",
          "createdAt": "2022-03-07T22:33:00Z",
          "updatedAt": "2022-03-07T22:33:00Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> AFAIK there are no changes to the SPK that I made and should already match the original paper\r\n\r\nI think the first equation is different as i mentioned [here](https://github.com/decentralized-identity/bbs-signature/issues/69#issuecomment-1049939299). This is maybe better discussed elsewhere, (like #69 or maybe in a call?), but not saying that the math are not balanced, just that right now the first equation of the SPK is different (i think its `Abar - D = - A' * e - H0 *r2`, which is not simply the negation of what the paper uses). Whenever the change was introduced, it may need a security analyses (although it may be easier to update to use the same equations as in the paper).",
          "createdAt": "2022-03-07T22:45:44Z",
          "updatedAt": "2022-03-07T23:49:19Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "We are awaiting review of some new academic work that has be produced that re proves formal security for the scheme in a setting that is very close to what this draft documents. Furthermore we expect wider security review at the CFRG during the subsequent standardisation process. For now we will keep this issue open until progress is made on those two paths.",
          "createdAt": "2022-12-05T19:43:27Z",
          "updatedAt": "2022-12-05T19:43:27Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on WG call on 20th of Mar. Will revisit after we review and potentially use the updates from the latest academic works.",
          "createdAt": "2023-03-20T19:51:45Z",
          "updatedAt": "2023-03-20T19:51:45Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "With the publication of the new academic paper in EURO crypt and the pending updates to our draft to formally align it, once these have been applied, the intention is to close this issue.",
          "createdAt": "2023-05-08T18:21:51Z",
          "updatedAt": "2023-05-08T18:21:51Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on the WG call on the 17th of July. Will review and discuss closing this next week.",
          "createdAt": "2023-07-17T18:30:41Z",
          "updatedAt": "2023-07-17T18:30:41Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on the WG call on the 28th of Aug. Draft using latest academic work. Closing.",
          "createdAt": "2023-08-28T18:31:32Z",
          "updatedAt": "2023-08-28T18:31:32Z"
        }
      ]
    },
    {
      "number": 80,
      "id": "I_kwDOF8lax85FRXyd",
      "title": "Define the hash_to_curve operation using SHAKE-256 XOF for BLS12-381 ciphersuite",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/80",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Currently the [latest hash to curve draft](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-14) only defines [suites](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-14#section-8.8) for the BLS12-381. However due to the efficiencies involved in using SHAKE-256 we need to define the suite within this spec.",
      "createdAt": "2022-03-08T03:41:45Z",
      "updatedAt": "2022-03-09T00:42:39Z",
      "closedAt": "2022-03-09T00:42:39Z",
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Not really clear to me what the efficiencies are. SHAKE-256 doesn't seem to have a clear advantage over SHA256 from [here](http://bench.cr.yp.to/results-hash.html#amd64-skylake) and [here](https://keccak.team/sw_performance.html).  @mikelodder7 is the intent to use the faster KangarooTwelve(which is not standardized if I'm not mistaken) or the ParallelHashXOF256?? Also why not use ParallelHash256 if thats the case (do we need an XOF for hash2curve??).",
          "createdAt": "2022-03-08T20:10:25Z",
          "updatedAt": "2022-03-08T20:10:25Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We\u2019re using shake in other areas of the code and it is faster when used in hash to curve. Hash to curve requires multiple calls to sha256 vs one to shake",
          "createdAt": "2022-03-08T21:21:03Z",
          "updatedAt": "2022-03-08T21:21:03Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That clears it up! Thanks! That helped a lot to clarify it! I'm curious as to why since that is the case, the spec opts for use of expand_message_xmd with sha256 instead of expand_message_xof with shake256 when it comes to bls12-381.",
          "createdAt": "2022-03-08T21:43:00Z",
          "updatedAt": "2022-03-08T21:43:52Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "> That clears it up! Thanks! That helped a lot to clarify it! I'm curious as to why since that is the case, the spec opts for use of expand_message_xmd with sha256 instead of expand_message_xof with shake256 when it comes to bls12-381.\r\n\r\nLikewise, this was not immediately clear to me either especially considering other hash_to_curve suites elect to use SHAKE-256 defined in the draft.",
          "createdAt": "2022-03-09T00:41:26Z",
          "updatedAt": "2022-03-09T00:41:26Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Addressed in #81 ",
          "createdAt": "2022-03-09T00:42:39Z",
          "updatedAt": "2022-03-09T00:42:39Z"
        }
      ]
    },
    {
      "number": 85,
      "id": "I_kwDOF8lax85F0g0F",
      "title": "Correspondence between proof and public key",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/85",
      "state": "CLOSED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "BasileiosKal"
      ],
      "labels": [
        "ready-for-pr",
        "core"
      ],
      "body": "In general, I was under the impression that a signature can be used to derive proofs that would be validated with only 1 specific key (the issuers PK).\r\n\r\nThat does not seem to be the case. The holder can present proofs for credentials signed from an issuer with public key `PK`, that will be validated with `PK * y = P2 * (x*y)`, where `y` a scalar chosen by the holder. My question is: Is this dangerous?? It is not really a forgery. It may compromise the issuer's and/or holder's accountability though, i.e., an issuer may falsely claim that they never signed a specific credential or a holder that they never possessed (and used to create an spk) a credential signed from that issuer.\r\n\r\nYou can find the detailed mathematics here: https://hackmd.io/@Vasileios/HyuXt_kf9\r\n  and a reproduction here: https://github.com/BasileiosKal/dif-bbs-issue\r\n\r\nIn general the method is the following; Let the holder having the signature `(A, s, e)` on some messages. Let also the holder wanting to create a proof that would be validated with `PK * y` instead of `PK`, for some scalar `y`. During spkGen they will calculate `Abar_f = A\u2019 * y * e + B * r1 * y` and `D_f = B * r1 * y + H0 * r2`. Note that `e(Abar_f, P2) = e(A', PK * y)`. Changing some additional values in the proof, the holder can present the spk; `(A\u2019, Abar_f, D_f, \u2026)` that will be validated with `PK * y`. \r\n\r\nA similar method works with a signature. The holder can present `(A*(y^-1), s, e*y)` which is a valid signature for the key `PK * y` (which is why the above method doesn't go against the security proofs given in the literature, i.e., a bbs proof, proves knowledge of a signature not only from the secret key `x` but also for a signature from the \"secret key\" `y * x`).\r\n\r\nIf a mitigation is needed, maybe including the issuer's PK as one of the signed messages will be an efficient solution, that solves the issuer\u2019s and/or holder\u2019s accountability issue.",
      "createdAt": "2022-03-16T18:20:35Z",
      "updatedAt": "2022-05-03T21:41:39Z",
      "closedAt": "2022-05-03T21:41:38Z",
      "comments": [
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The PK is known by the verifier so if the holder does this then it won\u2019t validate properly ",
          "createdAt": "2022-03-16T18:39:51Z",
          "updatedAt": "2022-03-16T18:39:51Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@mikelodder7 that is probably a valid assumption to make in many circumstances, however if it is the position we take, we need to document it in the security considerations. e.g a verifier should be aware when trusting the verifier to supply the public key of the signer to verify that this condition exists.",
          "createdAt": "2022-03-16T18:45:43Z",
          "updatedAt": "2022-03-16T18:45:43Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agreed",
          "createdAt": "2022-03-16T18:47:40Z",
          "updatedAt": "2022-03-16T18:47:40Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "The fact this computation on the public key exists without a mitigation also degrades the non-repudiable nature of signatures also (e.g an issuer could use it as a way to say \"i didn't sign the signature used to generate this spk\")",
          "createdAt": "2022-03-16T18:47:47Z",
          "updatedAt": "2022-03-16T18:47:47Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Where a valid mitigation could be @mikelodder7's suggestion above.",
          "createdAt": "2022-03-16T18:48:16Z",
          "updatedAt": "2022-03-16T18:48:16Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> The PK is known by the verifier so if the holder does this then it won\u2019t validate properly\r\n\r\nAgreed. That is why there is not really a forgery here. However to @tplooker point, it does degrade the non-repudiable property of the protocol. Another example can be that a malicious issuer could claim that they originally signed a specific credential (and that the holder should pay them for that service for example).\r\n\r\nIn general i would be interested if there is also any other way to take advantage of that. Regardless IMO its kinda a weird property (with easy mitigation) that i would expect to not hold though. IMO, protocol designers need to be aware of it, and its possible mitigation, as to not introduce any vulnerabilities because they assumed otherwise.",
          "createdAt": "2022-03-16T19:20:27Z",
          "updatedAt": "2022-03-16T19:34:28Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Actually there\u2019s no need for any mitigation here. The technique could apply to ANY signature and public key. If the issuer alters their public key then no signature will verify or proof. The advantage of pairing based signatures is they can actually recover the signature to a working state but ECDSA schnorr and Ed25519 cannot.",
          "createdAt": "2022-03-16T21:53:04Z",
          "updatedAt": "2022-03-16T21:53:04Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "I think the threat model here is the holder creates a proof with a `PK = PK * y` and transmits the `PK` to the verifier alongside the spk and the verifier ends up concluding the underlying signature proven by the spk was not signed by the private key associated to `PK` instead of `PK *y`. How does this apply to ECDSA and Ed25519 when they dont feature an spk phase",
          "createdAt": "2022-03-16T21:59:54Z",
          "updatedAt": "2022-03-16T21:59:54Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "OR the signer uses the fact that the holder can do this while generating the proof to repudiate (deny) the underlying signature associated to the SPK.",
          "createdAt": "2022-03-16T22:02:46Z",
          "updatedAt": "2022-03-16T22:02:46Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The same problem exists with BLS signatures too. The verifier in ANY case should not get the public key from the holder. The point I\u2019m saying is if the public key changes in any way the other signatures fall apart. The holder isn\u2019t forging a proof here but randomizing it. That\u2019s why There sometimes called randomizable signatures",
          "createdAt": "2022-03-16T22:02:56Z",
          "updatedAt": "2022-03-16T22:02:56Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The signer could do this anyway",
          "createdAt": "2022-03-16T22:03:35Z",
          "updatedAt": "2022-03-16T22:03:35Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Ok so are you saying it would be sufficient to just add something along the lines of \"The verifier in ANY case should not get the public key from the holder\" to the security considerations section?",
          "createdAt": "2022-03-16T22:05:02Z",
          "updatedAt": "2022-03-16T22:05:02Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That\u2019s why holders should call verify whenever they receive a signature regardless of the scheme including Ed25519. That\u2019s just good practice in general ",
          "createdAt": "2022-03-16T22:05:02Z",
          "updatedAt": "2022-03-16T22:05:02Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We could, but to me it\u2019s good practice to never trust the holder. You trust the signer therefore you get the key information from them",
          "createdAt": "2022-03-16T22:06:43Z",
          "updatedAt": "2022-03-16T22:06:43Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I completely agree that we should never trust the holder however the issue is not about that (after all if the holder is allowed to present whatever pk they want they can just forge whatever credential they choose). The issue has to do with untrusted issuers. The above issue essentially says that there is no way currently to hold accountable an issuer for a credential they signed when it comes to the proofs. This to me seems like it could be a problem in some scenarios (which i don't think its true for other signatures schemes).",
          "createdAt": "2022-03-16T22:14:51Z",
          "updatedAt": "2022-03-16T22:14:51Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "But I can do that anyway as a issuer without having to do this method. ",
          "createdAt": "2022-03-16T22:16:24Z",
          "updatedAt": "2022-03-16T22:16:24Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't see how. The signature it self guarantees the non-repudiable property. How could i do the same thing when it comes to a proof (i.e., claim it was from a different pk??)",
          "createdAt": "2022-03-16T22:22:43Z",
          "updatedAt": "2022-03-16T22:22:43Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "To hold the issuer accountable requires them to register the key. Otherwise the issuer can just delete the signing key and claim they didn\u2019t create it.",
          "createdAt": "2022-03-16T22:24:02Z",
          "updatedAt": "2022-03-16T22:24:02Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "True, my point though is that they can do that even if they register their key. What if they register their key, use it to sign a credential and then claim they never did sign that credential themselves but it was signed by someone else?? Or what if they register my pk squared to a not so careful CA and claim that they are the ones signing my credentials??  You cant prove them wrong in those cases without a mitigation (It is not only about claiming they never signed something, they can also claim they did sign something they haven't).",
          "createdAt": "2022-03-16T22:46:11Z",
          "updatedAt": "2022-03-16T22:46:11Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "The PK is now apart of the signature domain introduced in #95 addressing this issue.",
          "createdAt": "2022-05-03T21:41:38Z",
          "updatedAt": "2022-05-03T21:41:38Z"
        }
      ]
    },
    {
      "number": 89,
      "id": "I_kwDOF8lax85GGntF",
      "title": "Convert challenge hash to scalar value",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/89",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "ready-for-pr",
        "core"
      ],
      "body": "Currently in the in spkgen and spkverify operations, the challenge is not appropriately being converted to its scalar representation, this needs to be rectified, issue originally raised during review of #84 [see here](https://github.com/decentralized-identity/bbs-signature/pull/84#pullrequestreview-911423521)",
      "createdAt": "2022-03-22T01:16:33Z",
      "updatedAt": "2022-05-23T18:11:21Z",
      "closedAt": "2022-05-23T18:11:20Z",
      "comments": []
    },
    {
      "number": 90,
      "id": "I_kwDOF8lax85GkqlR",
      "title": "Updates to blind signature extension draft",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/90",
      "state": "OPEN",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "ready-for-pr",
        "blind-sign-extension"
      ],
      "body": "We made significant progress on the core draft over the past couple of months, which is likely to have created some in-consistencies in how the blind sign draft maps onto it as an extension, this issue is just open to track this work and re-alignment.",
      "createdAt": "2022-03-28T21:32:13Z",
      "updatedAt": "2022-04-22T23:27:59Z",
      "closedAt": null,
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Partially addressed in #108 ",
          "createdAt": "2022-04-22T23:27:59Z",
          "updatedAt": "2022-04-22T23:27:59Z"
        }
      ]
    },
    {
      "number": 94,
      "id": "I_kwDOF8lax85HEYLC",
      "title": "Parameterise the bytes drawn from the XOF so they are defined by the cipher suite",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/94",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "ready-for-pr",
        "core"
      ],
      "body": "Throughout the operations defined by the spec there are numerous calls to the XOF where a certain number of bytes are read, via the .read() function. How many bytes are read is dependent on several decisions at the cipher suite level (e.g the curve used) hence the current \"magic numbers\" like 64 being used in these operations needs to be parameterised in the cipher suite definition.",
      "createdAt": "2022-04-04T21:23:27Z",
      "updatedAt": "2022-05-05T22:41:35Z",
      "closedAt": "2022-05-05T22:41:35Z",
      "comments": [
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This could be added as a simple ciphersuite parameter (a constant), or it could be defined generically.\r\n\r\nThe BLS signature draft uses `ceil((3 * ceil(log2(r))) / 16)` bytes (48 bytes for BLS12-381), while the draft currently uses 64 bytes. We could use the formula from the BLS signature draft or simply read `2n` bytes where `n` is the width of an encoded field element.",
          "createdAt": "2022-04-04T21:34:30Z",
          "updatedAt": "2022-04-04T21:34:30Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Another option could be `ceil((r+k)/8)` where `k` the security level of the ciphersuite. So for bls it would be the same (48 bytes) but for bn462 would be 74 bytes instead of 87 (that it would if we used the `ceil((3 * ceil(log2(r))) / 16)` formula). `2n` will definitely be secure, but it may be too inefficient. It would be 64 bytes for bls and 116 for bn462 if I'm not mistaken.",
          "createdAt": "2022-04-05T19:40:37Z",
          "updatedAt": "2022-04-05T19:40:56Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "How about we leave it to the cipher suite to pick the exact value but have the above as a recommended way of calculating it?",
          "createdAt": "2022-04-05T19:42:27Z",
          "updatedAt": "2022-04-05T19:42:27Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1. Just instead of a recommendation i think we should have `ceil((r+k)/8)` (or `2n` etc) as the minimum value that a ciphersuite must choose though.",
          "createdAt": "2022-04-05T20:05:08Z",
          "updatedAt": "2022-04-05T20:05:08Z"
        }
      ]
    },
    {
      "number": 96,
      "id": "I_kwDOF8lax85HhGDd",
      "title": "Element encoding when passed to HASH or XOF.",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/96",
      "state": "CLOSED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "ready-for-pr",
        "pending-close",
        "core"
      ],
      "body": "See discussion in PR #95\r\n\r\nIn the spec, we need a way to pass elements of different types (EC points, integers, scalars etc) to a hash function. In that case, the encoding of those elements becomes important. IMO there are two options:\r\n1. Explicitly making the transformation to octets for each hashed element. That would look something like\r\n```\r\nHASH(point_to_octets(PK), I2OSP(L), point_to_octets(H_1),..., point_to_octets(H_L),...)\r\n```\r\n2. Implicitly make the conversion (in the definition of the HASH for example or in a separate section etc.). This would look something like,\r\n```\r\nHASH(PK, L, H_1,..., H_L,... )\r\n``` \r\nPersonally I prefer 2. This would mean that we can also specify rules like the one Tobias pointed out [here ](https://github.com/decentralized-identity/bbs-signature/pull/95#discussion_r847082901)i.e., that each element should also be appended with its length, which i agree with. A consideration here is if we need to specify this rule for every element (even the point_to_octets outputs) or it is sufficient to specify it for general octet strings and non-negative integers (lengths of lists)??. IMO the latter will suffice, since there is not really any ubiquities that come to mind regarding the output of point_to_octets (which is also an octet string but with well defined length), but i could be mistaken.",
      "createdAt": "2022-04-11T11:49:30Z",
      "updatedAt": "2022-04-23T17:10:03Z",
      "closedAt": "2022-04-23T17:10:03Z",
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "2 additional notes:\r\n\r\n1. To @tplooker  [point](https://github.com/decentralized-identity/bbs-signature/pull/97#discussion_r847895296), making the points in G1 or G2 be prepended with their length optional swifts the weight to the cipher suite to describe when this will hold for interoperability. As a result IMO we should either make this a requirement or remove it entirely (i vote for the later, since the length of the `points_to_octets` output can be defined by its value).\r\n\r\n2. An additional consideration is whether we need to also prepend the lengths of lists to be hashed, to the list them serfs (for example the list of generators, or in the list of disclosed messages etc.)",
          "createdAt": "2022-04-12T17:39:44Z",
          "updatedAt": "2022-04-12T17:39:44Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@BasileiosKal can you confirm with the merging of #97 whether we can now close this issue?",
          "createdAt": "2022-04-22T03:43:07Z",
          "updatedAt": "2022-04-22T03:43:07Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeap! Closing",
          "createdAt": "2022-04-23T17:10:03Z",
          "updatedAt": "2022-04-23T17:10:03Z"
        }
      ]
    },
    {
      "number": 98,
      "id": "I_kwDOF8lax85Hk-u6",
      "title": "Clarify that the key generation operation is optional",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/98",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "ready-for-pr"
      ],
      "body": "Currently the specification offers a definition for [key generation](https://identity.foundation/bbs-signature/draft-bbs-signatures.html#name-keygen) however implementations do not have to follow this procedure to be interoperable and instead can design their own, the spec should clarify this.",
      "createdAt": "2022-04-12T02:52:22Z",
      "updatedAt": "2022-04-21T23:23:51Z",
      "closedAt": "2022-04-21T23:23:51Z",
      "comments": []
    },
    {
      "number": 99,
      "id": "I_kwDOF8lax85Hn7gS",
      "title": "How to contribute",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/99",
      "state": "CLOSED",
      "author": "alessandroguggino",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Good morning everyone,\r\n\r\nI'm a Computer Engineering master's student working on my thesis which makes use of BBS signatures.\r\nI would like to contribute to the repository since I think I have some suggestions and corrections, especially for the Blind Signature draft. (but maybe I could be wrong)\r\n\r\nHow am I supposed to do it? I have not found any guidelines, should I just do the work and then open a pull request?\r\n\r\nThank you for reading this and for your work, I really appreciate it!",
      "createdAt": "2022-04-12T10:44:57Z",
      "updatedAt": "2022-04-19T11:26:44Z",
      "closedAt": "2022-04-19T11:26:44Z",
      "comments": [
        {
          "author": "tmarkovski",
          "authorAssociation": "MEMBER",
          "body": "@alessandroguggino The best way would be to start a discussion as an issue here and describe your thoughts. If there are any changes to the computations, you can outline those and discuss it with the team. Once the problem and solution have been identified, you can submit an update in the form of a Pull Request.",
          "createdAt": "2022-04-12T15:39:56Z",
          "updatedAt": "2022-04-12T15:41:48Z"
        },
        {
          "author": "paulgrehan",
          "authorAssociation": "NONE",
          "body": "Hi @alessandroguggino - you can also sign up under a feedback agreement to be able to contribute given your student status, here's the link https://identity.foundation/join/#individual or reach out to us at membership@identity.foundation and we'll help get you started !",
          "createdAt": "2022-04-12T21:07:37Z",
          "updatedAt": "2022-04-12T21:07:37Z"
        },
        {
          "author": "alessandroguggino",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thank you!\r\n@paulgrehan Sorry, so should I join the foundation to contribute (= discuss and submit updates as pull requests) to this repository? Since there are legal implications, I would like to understand them a bit more before doing it.",
          "createdAt": "2022-04-13T14:07:41Z",
          "updatedAt": "2022-04-13T14:07:41Z"
        },
        {
          "author": "paul-yellowpink",
          "authorAssociation": "NONE",
          "body": "Hi @alessandroguggino - sorry for the delay in responding, for yourself and the group to get the most out of your participation it would be advantageous (chat in slack, join calls rather than an \"arms length\" iterative approach via PRs). It's not onerus for a student, if you are employed then it may require a contributor agreement however. If you could send an email to membership@identity.foundation I can cover in more detail :)",
          "createdAt": "2022-04-19T03:29:45Z",
          "updatedAt": "2022-04-19T03:29:45Z"
        },
        {
          "author": "paulgrehan",
          "authorAssociation": "NONE",
          "body": "Sorry - logged in with my other account - still me ;)",
          "createdAt": "2022-04-19T04:46:16Z",
          "updatedAt": "2022-04-19T04:46:16Z"
        },
        {
          "author": "alessandroguggino",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thank you again!\r\nI think we can close this issue then :)",
          "createdAt": "2022-04-19T11:26:44Z",
          "updatedAt": "2022-04-19T11:26:44Z"
        }
      ]
    },
    {
      "number": 100,
      "id": "I_kwDOF8lax85HqZQI",
      "title": "Add a security consideration for when the scalar representation of a message is zero",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/100",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "ready-for-pr",
        "core"
      ],
      "body": "If a mapped message value outputted by the MapMessageToScalarAsHash evaluates to zero then effectively this message wont be signed, therefore we should add a security consideration to the spec to handle this case.",
      "createdAt": "2022-04-12T19:26:51Z",
      "updatedAt": "2022-05-23T22:43:14Z",
      "closedAt": "2022-05-23T22:43:13Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Addressed in #101, closing",
          "createdAt": "2022-05-23T22:43:13Z",
          "updatedAt": "2022-05-23T22:43:13Z"
        }
      ]
    },
    {
      "number": 102,
      "id": "I_kwDOF8lax85H7B82",
      "title": "Handling information that must always be revealed in a signature proof",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/102",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "ready-for-pr",
        "core"
      ],
      "body": "One of the features of BBS signatures is the ability for the holder/prover to selectively disclose information they share with a verifier, which is a powerful feature. However, with this new feature comes new problems to solve. For example sometimes an issuer/signer of a token/credential using a BBS signature may want to ensure that a certain sub-set of the information protected by the signature is always revealed in a generated proof. An example might be the proof block in a LD-proof or the protected headers in a JWP. \r\n\r\nThere are two main solution approaches that affect this spec that I think should be discussed:\r\n\r\n1) Where the cryptographic layer is aware of this distinction in the two classes of information being signed (one class where that information must always be revealed in any generated proof, the other where that information is able to be selectively disclosed by the holder/prover) , note there is also some relevant commentary in #95 discussing this.\r\n2) Where the cryptographic layer is essentially unaware of this distinction and it is left to the implementation layer above to enforce this behaviour if it so desires (e.g JWP or LD-Proofs)\r\n\r\nThe main tradeoffs I see here is increasing the complication of cryptographic layer for a potential increase in security of the scheme operating across application domains vs keeping the cryptographic layer simpler. Note - I use \"potential\" here deliberately as I haven't personally concluded whether there is a substantial security issue with the scheme in using 2) to achieve this outcome.\r\n\r\nTo bring things up a further level in option 1) the sign/verify API likely to be exposed by implementations is \r\n\r\n`signature = sign(privateKey, requiredRevealPayload, selectivelyDisclosablePayloads)`\r\n`result = verify(publicKey, signature, requiredRevealPayload, selectivelyDisclosablePayloads)`\r\n\r\nVS options 2) where the sign/verify API is likely to be exposed more like \r\n\r\n`signature = sign(privateKey, payloads)`\r\n`result = verify(publicKey, signature, payloads)`\r\n\r\nTechnically with option 2) implementation layers using BBS in representation formats like JWP or LDP have to define within the bounds of their own specification if certain pieces of information MUST always be revealed. For example currently JWP using BBS defines that the first \"payload\" signed is the protected header. \r\n\r\nThe potential risk I see with this model is a case when a signer is using a single key pair to sign JWP structures secured with a BBS signature AND sign payloads in other representation formats, in this threat a verifier could be handed a BBS proof revealing no payloads and be convinced it was signed under a different representation format than JWP. One could definitely argue that a signer/issuer operating in this manner is violating certain commonly agreed cryptographic best practises in failing to limit cross application key usage and therefore option 2) is fine to proceed with in this spec with an appropriate security consideration.\r\n\r\nInterested to hear how other folks view this issue, in particular from spec editors involved in the development of representation layer technologies compatible with BBS signatures (e.g JWP or LD-Proofs) @quartzjer @selfissued @dwaite @OR13 \r\n",
      "createdAt": "2022-04-18T04:43:39Z",
      "updatedAt": "2022-05-03T21:40:03Z",
      "closedAt": "2022-05-03T21:40:02Z",
      "comments": [
        {
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This feels similar to crit in some ways. Given how frustrated some folks have been with alg none and crit in jose we should be cautious. \n\nMy gut says to make it harder for an ignorant developer or verifier to make mistakes, which leads me to believe that the signatures should be aware of required and optional disclosure.",
          "createdAt": "2022-04-18T13:15:46Z",
          "updatedAt": "2022-04-18T13:15:46Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "NONE",
          "body": "While it's traditionally higher level or application-space logic that enforces these kinds of requirements, similar to checking an issued-at or expiration... I think it's worth strongly considering having this capability in the crypto layer whenever feasible.\r\n\r\nThe tradeoff or caveat though is if the added complexity creates *any* higher possibility of a vulnerability, it's much better to deal with that when it happens in implementations (2) vs. in the algorithm itself (1).\r\n\r\nThe challenge in general with this space where BBS/JWP/LDP/etc live is that to build privacy preserving cryptographic primitives some of this logic _must_ be moved into the algorithms, and the complexity can't just be pushed up the stack.\r\n\r\nSo, sort of thinking out loud here...\r\n1. BBS is optimized for use-cases involving unlinkability\r\n2. The nothing-disclosed case is definitely a notable security consideration (but still could be a valid use-case)\r\n3. Most or nearly all issuers will want something required to be revealed\r\n4. If the location of the required payload is not uniform in every signature it becomes a linkability vector\r\n5. Adding requiredRevealPayload does not invalidate the nothing-disclosed use case (it can just be empty)\r\n6. The added algorithmic complexity to support it is minimal (in my limited understanding)\r\n\r\nI'm in favor of (1), having the algorithm natively support it.  The slightly larger calling syntax helps ensure that all implementations prioritize the distinction of what is required vs selectively disclosed, and it also provides a means for requiring disclosure that doesn't potentially introduce linkability when solved elsewhere.",
          "createdAt": "2022-04-18T17:08:03Z",
          "updatedAt": "2022-04-18T17:08:03Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "This issue was discussed on the WG call this morning where it was agreed that PR #95 would be updated to accomodate this change, I will tag this issue with \"ready-for-pr\" because of this pending close subject to that PR being merged",
          "createdAt": "2022-04-19T02:32:22Z",
          "updatedAt": "2022-04-19T02:32:22Z"
        },
        {
          "author": "tmarkovski",
          "authorAssociation": "MEMBER",
          "body": "What checks will the routine in `sign` and `verify` do to validate if the `requiredRevealPayload` is satisfied? If it does a simple array comparison of indexes, it doesn't make sense to add this protection on the signature suite spec level.\r\nThe sign/verify method shouldn't be opinionated, unless that's required for the cryptographic construction of the signature. I understand that most use cases will want this, we're still thinking within the frames of how we currently use them: LD and JWT, but the signature suite should work outside identity use cases as well.\r\nI think I must be missing something (other than the last WG meeting), since everyone is in favor of adding this protection, which seems like an obvious architectural anti-pattern to me.",
          "createdAt": "2022-04-20T14:44:52Z",
          "updatedAt": "2022-04-20T14:47:21Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@tmarkovski The requiredRevealPayload is incorporated into the hash for the DST message, along with other public parameters required for the security of the signature, like the issuer's public key. Unlike the other signature messages, this one cannot be selectively revealed, and so it would not be possible to verify a signature or a proof of knowledge without knowing the correct value for requiredRevealPayload.\r\n\r\nThe spec doesn't define a format for the requiredRevealPayload beyond it being represented as a byte string, but applications can use it to enforce agreement for any additional parameters. I'm curious what makes this look like an anti-pattern to you, but I would recommend listening to the meeting recording.",
          "createdAt": "2022-04-20T16:36:18Z",
          "updatedAt": "2022-04-20T16:36:18Z"
        },
        {
          "author": "tmarkovski",
          "authorAssociation": "MEMBER",
          "body": "Thanks for clarifying the use of it. My next question was why not allow any payload to participate in the DST message to allow extensions for it, but you answered that in the second paragraph. Which brings me to my next question: why is this parameter named `requiredRevealPayload` if it will allow arbitrary data by the application?\r\n\r\nMy thoughts on anti-pattern stem from the idea of using knowledge of downstream application into the spec, without making direct use of it.\r\nExample: needing a parameter for which messages are required for an application protocol is a downstream problem. However, parameter for integrity payload is a more generalized use. While both cases will be defined by applications, one is opinionated about what it is, the other one isn't.",
          "createdAt": "2022-04-20T18:28:15Z",
          "updatedAt": "2022-04-20T18:30:03Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We're still workshopping the naming, I think 'header' is in the lead at the moment although every term comes with its own baggage.",
          "createdAt": "2022-04-20T18:30:49Z",
          "updatedAt": "2022-04-20T18:30:49Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@tmarkovski essentially the conversation on the WG call yesterday and in the DIF slack channel appears to have shown support to have a cryptographically enforce-able way to support two types of information protected by a signature \r\n\r\n1) Header - Data protected by the original signature that must be revealed in any generated proof for the signature\r\n2) Payloads - An array of payloads protected by the original signature of which the holder/prover has the ability to selectively disclose\r\n\r\nThose are the current names anyway, if you have alternatives please feel free to suggest.",
          "createdAt": "2022-04-20T20:02:03Z",
          "updatedAt": "2022-04-20T20:02:03Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Or of course if you have a different take on the usefulness of this feature please feel free to share :)",
          "createdAt": "2022-04-20T20:04:15Z",
          "updatedAt": "2022-04-20T20:04:15Z"
        },
        {
          "author": "tmarkovski",
          "authorAssociation": "MEMBER",
          "body": "I've no objections (or suggestions) on the naming or the usefulness of this feature. By reading the OP description (and not having much more context), I made an assumption that the `requiredRevealPayload` refers to required message indices that applications need disclosed, which seemed like a very specific, opinionated application argument that shouldn't have place in these algorithms directly. As @andrewwhitehead explained, this parameter is a general header payload defined as public parameter by applications, which may contain information about what message indices may be required, in addition to other info. This makes a lot more sense and clears up my confusion.",
          "createdAt": "2022-04-20T20:25:23Z",
          "updatedAt": "2022-04-20T20:25:23Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Address via #95",
          "createdAt": "2022-05-03T21:40:02Z",
          "updatedAt": "2022-05-03T21:40:02Z"
        }
      ]
    },
    {
      "number": 103,
      "id": "I_kwDOF8lax85H-zMV",
      "title": "Add blurb describing replay attack protection feature of the scheme",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/103",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [
        "tplooker"
      ],
      "labels": [
        "ready-for-pr",
        "core"
      ],
      "body": "Currently the [introduction](https://identity.foundation/bbs-signature/draft-bbs-signatures.html#section-1) offers a description of two key properties the core scheme has which are selective disclosure and unlinkable presentations, however there is a third that should also be elaborated which is protection again replay attacks that the scheme naturally affords because of ability to feature a nonce in the presentation message generated as a part of the SPK.",
      "createdAt": "2022-04-19T02:40:29Z",
      "updatedAt": "2022-04-22T03:43:53Z",
      "closedAt": "2022-04-22T03:43:53Z",
      "comments": []
    },
    {
      "number": 107,
      "id": "I_kwDOF8lax85IHO3o",
      "title": "Add generator in G1 in BlindSign",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/107",
      "state": "CLOSED",
      "author": "alessandroguggino",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "blind-sign-extension"
      ],
      "body": "From the BlindSign function:\r\nhttps://github.com/decentralized-identity/bbs-signature/blob/506d70c0d266a3b04cb8e8a58796008d5284fd2e/draft-blind-bbs-signatures.md?plain=1#L175\r\n\r\nWe should add P1, the generator point in G1, in order to make a valid signature after the unblinding:\r\n`\r\nb = commitment + P1 + h0 * s'' + h[j1] * msg[1] + ... + h[jK] * msg[K]\r\n`\r\n\r\nIf you agree with me I will open a pull request where I will change `b` as proposed and add P1's definition into the Terminology section.",
      "createdAt": "2022-04-20T15:31:37Z",
      "updatedAt": "2022-04-22T22:35:45Z",
      "closedAt": "2022-04-22T22:35:45Z",
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeap! That makes sense to me.",
          "createdAt": "2022-04-20T16:15:35Z",
          "updatedAt": "2022-04-20T18:01:29Z"
        },
        {
          "author": "alessandroguggino",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I have seen that in the main draft P1 is defined in Notation instead of Terminology. But there is no Notation section. May I add it and modify the structure of the document following the one of the main draft?\r\nThis is related to issue #90. \r\nOtherwise, I just change the calculation of b for now.",
          "createdAt": "2022-04-20T18:19:20Z",
          "updatedAt": "2022-04-20T18:19:20Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Yes @alessandroguggino as documented in #90 feel free to update it for consistency. I would suggest instead of duplicating the terminology you could just reference the core draft?",
          "createdAt": "2022-04-20T20:09:03Z",
          "updatedAt": "2022-04-20T20:09:03Z"
        }
      ]
    },
    {
      "number": 109,
      "id": "I_kwDOF8lax85IOCRH",
      "title": "Update KeyValidate operation definition",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/109",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "ready-for-pr",
        "core"
      ],
      "body": "With the changes to how we handle the message generators the procedure as defined in this section doesn't make sense now as they are no longer apart of the public key, therefore this should be updated to reflect that.",
      "createdAt": "2022-04-21T23:13:43Z",
      "updatedAt": "2022-05-09T18:17:26Z",
      "closedAt": "2022-05-09T18:17:26Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "We also need to update the syntax of using this operation inside other operations like verify and spkGen which is currently inconsistent.",
          "createdAt": "2022-04-21T23:18:58Z",
          "updatedAt": "2022-04-21T23:18:58Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Also once we have merged #95 I think we need to update so that KeyValidate is called for both the sign and spkGen functions also as the public key will now form part of the DST signed into the signature? @BasileiosKal ",
          "createdAt": "2022-04-23T03:35:52Z",
          "updatedAt": "2022-04-23T03:35:52Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "[Current language](https://identity.foundation/bbs-signature/draft-bbs-signatures.html#name-validating-public-keys) in the specification hints at this check being performed across all operations, we should clear up this confusion.",
          "createdAt": "2022-04-23T03:36:45Z",
          "updatedAt": "2022-04-23T03:36:45Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It may be best to be careful, but I don't think there is a pressing reason to include keyValidate in sign and spkGen. It's use in verify and spkVerify is so we will not pass elements not in G2 in the pairings, which may resolve to unexpected behavior. The same danger doesn't seem to exist in sign and spkGen though, since we just hash the value. \r\n\r\nThat said, we must update the keyValidate procedure as described by @tplooker as well as clarify it's use.",
          "createdAt": "2022-04-25T07:02:53Z",
          "updatedAt": "2022-04-25T10:18:13Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "I could be convinced not to require this on sign or spkgen from an efficiency perspective, so long as it is required on verify and spkverify. I think not doing it on sign or spkgen just means there is the possibility that an invalid signature or proof may be generated? ",
          "createdAt": "2022-04-25T15:58:30Z",
          "updatedAt": "2022-04-25T15:58:30Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "For context an interesting vulnerability was found in a Java based implementation of ECDSA recently where public key validation was being skipped https://neilmadden.blog/2022/04/19/psychic-signatures-in-java/",
          "createdAt": "2022-04-25T15:59:51Z",
          "updatedAt": "2022-04-25T15:59:51Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for the context. In that vulnerability the issue seems to be that key-validation was skiped in verify. A mallicius prover can just skip key validation either way. If we consider a malicious issuer and an honest prover senario though, then a best strategy could be for the prover to veriy the entire signature (which would also call KeyValidate) instead.\r\n\r\nThat said, i don't see any practical application in this security model (dishonest issuer, honest prover), so i would sugest removing keyValidate from spkGen and adding a security consideration to cover all the caeses after.",
          "createdAt": "2022-05-02T11:04:49Z",
          "updatedAt": "2022-05-02T11:04:49Z"
        }
      ]
    },
    {
      "number": 110,
      "id": "I_kwDOF8lax85IOGBa",
      "title": "presentation header vs presentation message",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/110",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "ready-for-pr",
        "core"
      ],
      "body": "With the introduction of the header + message terminology in #95 the question for me remains whether we call the data structure currently known as presentation message that or presentation header. To me it makes more sense to call this a header and reserve the term message for the selectively disclosable payloads that are protected by the signature. We then have two types of headers 1) signature header set by the issuer/signer and required to be revealed in all proofs and 2) presentation header set by the holder/prover.",
      "createdAt": "2022-04-21T23:43:11Z",
      "updatedAt": "2022-05-03T19:53:13Z",
      "closedAt": "2022-05-03T19:53:13Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed on May 2nd WG call, in general there appeared to be no strong objection to tweaking the language in this direction so I will follow up with a PR",
          "createdAt": "2022-05-02T21:27:44Z",
          "updatedAt": "2022-05-02T21:27:44Z"
        }
      ]
    },
    {
      "number": 111,
      "id": "I_kwDOF8lax85IT7fR",
      "title": "Review security considerations",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/111",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "core"
      ],
      "body": "Some of the security considerations documented in the spec were originally copied from the [bls-signature-draft](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-bls-signature-04#section-5.2) and should now be re-reviewed for their applicability.",
      "createdAt": "2022-04-23T03:41:10Z",
      "updatedAt": "2022-09-19T18:50:42Z",
      "closedAt": "2022-09-19T18:50:42Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Much of the existing security considerations were reviewed in #112, leaving this issue open as a reminder to consider any new security considerations that we made need to add",
          "createdAt": "2022-05-03T05:41:34Z",
          "updatedAt": "2022-05-03T05:41:34Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed on WG call 15th of August, consistency has significantly improved since filing this issue, however leaving open for the time being for a deeper review to be conducted",
          "createdAt": "2022-08-15T18:53:01Z",
          "updatedAt": "2022-08-15T18:53:01Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed on WG call 19th of September, closing as a broader security review of the specification will be required in any case which may yield new security considerations.",
          "createdAt": "2022-09-19T18:50:42Z",
          "updatedAt": "2022-09-19T18:50:42Z"
        }
      ]
    },
    {
      "number": 113,
      "id": "I_kwDOF8lax85I24sb",
      "title": "Fix inconsistency in array style arguements supplied to operations API",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/113",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "core"
      ],
      "body": "Currently sign and verify function signatures look like the following\r\n\r\n```\r\nsignature = Sign(SK, PK, (msg_1,..., msg_L), (H_1,..., H_L))\r\n```\r\n\r\nand\r\n\r\n```\r\nresult = Verify(PK, (msg_1,..., msg_L), (H_1,..., H_L), signature)\r\n```\r\n\r\nWhereas the spkgen operations function signature looks like\r\n\r\n```\r\nspk = SpkGen(PK, (msg_1,..., msg_L), (H_1,..., H_L), RevealedIndexes, signature, pm)\r\n```\r\n\r\nwhere RevealedIndexes is a vector/array.\r\n\r\nWe need to either change the RevealedIndexes to be more like the the destructed syntax for messages and generators e.g `(msg_1,..., msg_L), (H_1,..., H_L)` or convert all array style arguments to inputs like the current definition for RevealedIndexes.",
      "createdAt": "2022-05-02T00:35:51Z",
      "updatedAt": "2022-06-28T20:04:38Z",
      "closedAt": "2022-06-28T20:04:38Z",
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "My vote is for the second option, i.e., convert `RevealedIndexes` to something like `(i1, i2, ..., iR)`. My reasoning is that otherwise, we will have to add many steps in each algorithm to convert each input to its destructed form (i.e., `1.  (msg_1, ..., msg_L) = messages`, `2.  (H_1, ..., H_L) = generators` etc.) that may hurt readability.\r\n\r\nOn the other hand, i feel like the term RevealedIndexes is very easy to understand, so although not internally consistent, leaving the inputs as they are (and sacrificing consistency) may be the best tradeoff for readability. ",
          "createdAt": "2022-05-02T10:19:13Z",
          "updatedAt": "2022-05-02T10:20:12Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Being addressed by #138 ",
          "createdAt": "2022-05-23T20:00:18Z",
          "updatedAt": "2022-05-23T20:00:18Z"
        }
      ]
    },
    {
      "number": 114,
      "id": "I_kwDOF8lax85I25iP",
      "title": "Improve Terminology and Syntax Consistency",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/114",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "pending-close",
        "core"
      ],
      "body": "Related to #25 currently the spec has a mix of casing for operation names, inputs, parameters and outputs this should be made consistent including whether short or more descriptive names are used.\r\n\r\nSuggested rules for inputs outputs and parameters \r\n\r\n- use snake case\r\n- use fully qualified names e.g msg -> message PK -> public_key\r\n\r\nSuggested rules for function naming\r\n\r\n- use snake case e.g SpkGen => spk_gen",
      "createdAt": "2022-05-02T00:44:16Z",
      "updatedAt": "2022-08-08T18:16:42Z",
      "closedAt": "2022-08-08T18:16:41Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "I'd also like to clarify that I think the section names should shift to using fully qualified names e.g KeyGen -> Key Generation where the actual function name would be `key_gen`",
          "createdAt": "2022-05-02T00:47:44Z",
          "updatedAt": "2022-05-02T00:47:44Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "alternatively if we think names will become to large even with just applying the rule to inputs outputs and parameters, then I'm happy to stick with brief names e.g msg",
          "createdAt": "2022-05-02T00:48:38Z",
          "updatedAt": "2022-05-02T00:48:38Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Raised by @BasileiosKal on the call the proposal to rename SpkGen to ProofGen or something similar because the proof is not just a signature proof of knowledge.",
          "createdAt": "2022-05-02T18:53:26Z",
          "updatedAt": "2022-05-02T18:53:26Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "My proposal for a terminology convention is:\r\n1. All EC points to be capital even in their octets representation (i.e., pub_key -> PK)\r\n3. All special points in G1 will be Pi, i = 1, 2, etc. For example, P1 will be the base point of G1, P2 will be the generator for the blind value (H_s in #95) and P3 the generator for the signature domain (H_d in #95). So B will be\r\n```\r\nB = P1 + P2 * s + P3 * domain + H_1 * msg_1 + .... + H_L * msg_L\r\n```\r\n4. All special points in G2 will be Qi, i = 1, 2, ..etc. This means that the base point in G2 will be Q1 and the pub key will be PK = Q1 * SK.\r\n5. All scalars will be lower case (i.e., SK -> sk)\r\n6. Core functions will be pascal case (i.e., proofVerify -> ProofVerify)\r\n7. Helper functions will be snake case. I'm going back and forward on this one since it will give us consistency with many functions we use from the h2c spec, however as @andrewwhitehead pointed it may be better to be internally consistent. So im also fine with making every function pascal case.",
          "createdAt": "2022-05-03T17:07:53Z",
          "updatedAt": "2022-05-03T17:07:53Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Labeling as pending close ahead of WG call on the 4th of july",
          "createdAt": "2022-07-04T00:59:54Z",
          "updatedAt": "2022-07-04T00:59:54Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Updates discussed to WG call:\r\n`Ciphersuite_ID` -> `ciphersuite_id`\r\n`H_s, H_d` -> `Q_1, Q_2`\r\n`MsgGenerators` -> `msgGenerators`",
          "createdAt": "2022-07-04T18:56:46Z",
          "updatedAt": "2022-07-04T18:56:46Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed on 8th august WG call, closing",
          "createdAt": "2022-08-08T18:16:41Z",
          "updatedAt": "2022-08-08T18:16:41Z"
        }
      ]
    },
    {
      "number": 117,
      "id": "I_kwDOF8lax85I3Uae",
      "title": "Consider making \"messages\" and therefore \"message generators\" optional to all operation APIs",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/117",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "pending-close",
        "core"
      ],
      "body": "Now we have introduced the concept of an optional header in #95 I want to consider whether we allow for constructions of BBS signatures which do not make use of the \"selective disclosure\" feature, instead just use BBS as an ordinary group signature. I believe there are several interesting usecases such as privacy preserving access tokens or hardware attestations that would likely use BBS in this form.\r\n\r\nIn short my proposal is for both the header and messages (along with message generators) to be optional. Meaning a signer could create a signature that has neither, either or both a header and array of messages.",
      "createdAt": "2022-05-02T04:18:15Z",
      "updatedAt": "2022-07-04T18:35:45Z",
      "closedAt": "2022-07-04T18:35:45Z",
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1. In this case, the issuer will just sign their public key and i dont really see any issues with that. We can specify that L >= 0 (where L the number of messages that can be selectively disclosed).",
          "createdAt": "2022-05-02T10:39:13Z",
          "updatedAt": "2022-05-02T10:39:13Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "One thing to check is in making this change whether there is anything different in the SpkGen or SpkVerify operations?",
          "createdAt": "2022-05-02T23:57:12Z",
          "updatedAt": "2022-05-02T23:57:12Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don\u2019t think there is. There is nothing special about a signature on just 1 message (the domain which will be just the hash of the signers PK)",
          "createdAt": "2022-05-03T17:33:55Z",
          "updatedAt": "2022-05-03T17:33:55Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "One other thing to note is that because the messages and message generators are seperate arguments past to the sign verify etc functions by making these arguments optional we create the case where only one could be supplied which would be invalid, for example just messages and no generators or vice versa.",
          "createdAt": "2022-05-03T19:56:37Z",
          "updatedAt": "2022-05-03T19:56:37Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That\u2019s a good point. I think a check must be added to ensure that the number of messages is the same with the number of generators (regardless of what we decide here). IMO this will also resolve this issue.",
          "createdAt": "2022-05-03T21:46:38Z",
          "updatedAt": "2022-05-03T21:46:38Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The method could also accept an optional list of (generator, message) pairs.",
          "createdAt": "2022-05-04T02:51:29Z",
          "updatedAt": "2022-05-04T02:51:29Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> The method could also accept an optional list of (generator, message) pairs.\r\n\r\nWe could but IMO it may be hard to get the values out of that list of tuples to be used in the operation, i.e., if the input is `[(H_1, msg_1), (H_2, msg_2), ...., (H_n, msg_n)]` wouldn't it be a little unclear how we will get the generators out to be passed in the `domain` etc.?? \r\n\r\nFurther i like passing a list of messages because it makes the API as similar as possible to standard \"known\" digital signatures, so people can draw clear lines between them (i.e., say stuff like \"it's just a digital signature but instead of 1 message you will pass a list of messages\" etc), just to help with adoption.\r\n\r\nThat said, i do recognize that the pairs approach makes sense and I'm definitely not opposed to it. I would like to see a PR to get a better idea of how it is going to look.",
          "createdAt": "2022-05-05T17:08:23Z",
          "updatedAt": "2022-05-05T17:08:23Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "The other option I would like us to consider is making the message generators parameters instead of inputs. How these generators are used most commonly in a cipher suite I suspect will be the determining factor in whether we make this change. IMO having not seen any security issues with sharing generators across signatures and issuers I think implementations are more likely to treat message generators as globally shared values, cached by implementations. If we believe this is going to be normal then documenting the message generators as parameters rather than inputs makes more sense to me.",
          "createdAt": "2022-05-05T20:30:36Z",
          "updatedAt": "2022-05-05T20:30:36Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So to recap it seems that there are three options,\r\n\r\n1. The current approach i.e., a messages list and a generator list as input.  This will look like the following\r\n     ```\r\n    signature = Sign(SK, PK, (msg_1, ..., msg_L), (H_1, ..., H_L), header)\r\n     ```\r\n2. @tplooker's proposal to pass the generators as parameters. This will look like,\r\n    ````\r\n    signature = Sign(SK, PK, (msg_1, ..., msg_L), header)\r\n   \r\n    Parameters: \r\n    - (H_1, ..., H_L): The generators used for the signature\r\n    ````\r\n3. @andrewwhitehead's proposal of passing one list with (generator, message) pairs. This will look like,\r\n    ```\r\n    signature = Sign(SK, PK, [(H_1, msg_1), ..., (H_L, msg_L)], header)\r\n    ```\r\n\r\nMy thoughts (see also the discussion above for more context): \r\n- Option 2 does give the clearer API. I'm only worried that we may break the separation between what constitutes as input and what as parameter.\r\n- Option 3 does remove the need to have to check if the messages and the generators lists have the same length. It may create the need to also pass an additional list of generators to ProofVerify though because that operation requires all the generators, not just the ones corresponding to the revealed messages. This may create some inconsistency between the ProofGen and ProofVerify api?? (not really sure about that)\r\n\r\nCurrently im leaning more towards option 2, if we can sufficiently justify the choice to the cfrg (see #125 also)",
          "createdAt": "2022-05-06T11:39:38Z",
          "updatedAt": "2022-05-06T12:28:48Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Just for completion, another alternative is to pass the lists of messages and generators, not in a de-structured form, but using \"named lists\", i.e., something like the following,\r\n\r\n```\r\nproof = ProofGen(PK, signature, header, messages, generators, revealedIndexes, ph)\r\n\r\nProcedure:\r\n            .\r\n            .\r\n            .\r\n7. (i1, i2, ..., iU) = revealedIndexes\r\n8. (j1, j2, ..., jR) = [L] \\ revealedIndexes\r\n9. msg_1, ..., msg_L = messages[1], ..., messages[L]\r\n10. msg_i1, ..., msg_iU = messages[i1], ..., messages[iU]\r\n11. H_1, ..., H_L = generators[1], ..., generators[L]\r\n12. H_j1, ..., H_jR = generators[j1], ..., generators[jR]\r\n            .\r\n            .\r\n            .\r\n```\r\nAs you can see, there will be a lot of steps needed to de-structure the input lists. There will be even more steps necessary to check the lengths of the input lists potentially. That said we will be totally explicit on how we get the necessary elements (the revealed messages, the corresponding generators etc.) from the inputs.",
          "createdAt": "2022-05-13T16:16:00Z",
          "updatedAt": "2022-05-13T16:16:00Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Labeling as pending close ahead of WG call on the 4th of july",
          "createdAt": "2022-07-04T00:59:15Z",
          "updatedAt": "2022-07-04T00:59:15Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed on 4th of july WG call, closing as resolved via #183",
          "createdAt": "2022-07-04T18:35:45Z",
          "updatedAt": "2022-07-04T18:35:45Z"
        }
      ]
    },
    {
      "number": 118,
      "id": "I_kwDOF8lax85I5N1W",
      "title": "Ciphersuites format",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/118",
      "state": "CLOSED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "core"
      ],
      "body": "The ciphersuites definition currently used in the spec needs to be updated.\r\n1. There are terms that must be defined by most likely referencing their definition to some other spec. Examples include the base points of G1 and G2, the prime order p of those groups the security level of the ciphersuite (`k` in PR #116). Are there any other definitions we should include??\r\n2. A specific format for the ID of each ciphersuite must also be defined. Something like,\r\n```\r\nCipher_ID = \"BBS_\" || H2C_SUITE_ID || GEN_SC || HASH_OUTPUT_LEN || _\"\r\n```\r\nwhere `GEN_SC` will be used to distinguish between the scopes of the generators seed (i.e., global or issuer specific) and `HASH_OUTPUT_LEN` between the number of bytes drawn for each XOF (since the consensus seems to be that we will parameterize that value)??",
      "createdAt": "2022-05-02T14:27:27Z",
      "updatedAt": "2022-08-15T18:50:12Z",
      "closedAt": "2022-08-15T18:50:12Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed on WG call 15th of August, issue has been resolved through #137",
          "createdAt": "2022-08-15T18:50:12Z",
          "updatedAt": "2022-08-15T18:50:12Z"
        }
      ]
    },
    {
      "number": 119,
      "id": "I_kwDOF8lax85I6dIS",
      "title": "Reference/Spec Implementation Language/Framework Selection",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/119",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "As resolved earlier this year multiple WG members expressed support for there to be a prototypical style implementation housed within this repo to test the implementability of the spec.\r\n\r\nThere are multiple possible languages/frameworks we could use, below is a bit of a list including key libraries we could use\r\n\r\n- Rust using https://docs.rs/bls12_381/latest/bls12_381/\r\n- Python using https://github.com/zebra-lucky/python-bls\r\n- Javascript using https://github.com/paulmillr/noble-bls12-381",
      "createdAt": "2022-05-02T19:51:23Z",
      "updatedAt": "2022-08-15T18:45:54Z",
      "closedAt": "2022-08-15T18:45:54Z",
      "comments": [
        {
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ok, time to stop procrastinating and start carving out time for this. I'll volunteer to implement a JavaScript one, since that's my most recently used language. I'll start something in my own repo; we can discuss next where that should go.",
          "createdAt": "2022-05-02T22:38:55Z",
          "updatedAt": "2022-05-02T22:39:46Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Thanks @christianpaquin really appreciate you taking the pen here!",
          "createdAt": "2022-05-02T23:09:07Z",
          "updatedAt": "2022-05-02T23:09:07Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed on WG call 15th of August, implementations by multiple WG members ongoing",
          "createdAt": "2022-08-15T18:45:53Z",
          "updatedAt": "2022-08-15T18:45:53Z"
        }
      ]
    },
    {
      "number": 121,
      "id": "I_kwDOF8lax85I7MCT",
      "title": "Rename Spk to Proof",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/121",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "ready-for-pr",
        "core"
      ],
      "body": "As raised by @BasileiosKal on the WG call this morning currently we refer to the proofs in the spec as the Spk when in reality the proofs generated are more complex then just a signature proof of knowledge (SPK), therefore renaming SpkGen and SpkVerify to me to ProofGen and ProofVerify would be more accurate.",
      "createdAt": "2022-05-02T23:55:47Z",
      "updatedAt": "2022-05-03T19:47:04Z",
      "closedAt": "2022-05-03T19:47:04Z",
      "comments": []
    },
    {
      "number": 125,
      "id": "I_kwDOF8lax85JJiFS",
      "title": "Refine the relationship/differences between inputs vs parameters for operations",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/125",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "pending-close",
        "core",
        "editorial"
      ],
      "body": "Currently for each operation documented in the spec we have the notion of both inputs and parameters, a convention adopted from the [bls-signature-draft](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-bls-signature-04). \r\n\r\nLoosely what I think we have been following as a largely unwritten rule is that inputs are usually more dynamic or application driven/supplied in nature, where as parameters are more constant across multiple invocations of an operation(s).\r\n\r\nTo make things more complex we also appear to have two types/scopes of parameters, parameters shared across all operations vs parameters semi-unique to an operation, although it doesn't look like we are following this strictly. \r\n\r\nI think we need to\r\n\r\n1) Rationalise the difference between what constitutes an input vs a parameter\r\n2) Decide on the scoping of various parameters and how we notate them in reference to specific operations for example do we inline them all? or reference them from a common section that applies to all operations, or both?\r\n\r\nFurthermore I think we need to revisit certain values that may instead be considered parameters instead of inputs, in particular message generators. This is discussed more in #117 ",
      "createdAt": "2022-05-05T22:28:35Z",
      "updatedAt": "2023-05-08T18:16:27Z",
      "closedAt": "2023-05-08T18:16:26Z",
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "One option would be to define that anything that is described by a ciphersuite (i.e., base points etc.,) is a parameter. This will also apply to the message generators.\r\n\r\nA stricter definition will be to consider anything that is defined by a ciphersuite AND it is independent from any inputs to be a parameter. This doesn't really apply to the message generators (their number depends to the number of messages).\r\n\r\nRegarding 2 my vote is to inline the parameters if we would to consider the message generators as a parameter. If the message generators are supplied as input we can have a separate section to avoid repeated text.",
          "createdAt": "2022-05-06T11:56:54Z",
          "updatedAt": "2022-05-06T11:56:54Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "DIscussed on WG call 15th August, I will look through the spec to see if we have resolved the ambiguity that was previously present",
          "createdAt": "2022-08-15T18:44:11Z",
          "updatedAt": "2022-08-15T18:44:11Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on the WG on the 6th of February. Will check for any inconsistency and try to close next weak.",
          "createdAt": "2023-02-06T20:00:30Z",
          "updatedAt": "2023-02-06T20:00:30Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on WG on the 6th of Mar. Will check for consistency and close before publishing draft 02.",
          "createdAt": "2023-03-06T19:59:01Z",
          "updatedAt": "2023-03-06T19:59:01Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Checks were done prior to draft-2 publication, no issue found, closing as a result.",
          "createdAt": "2023-05-08T18:16:26Z",
          "updatedAt": "2023-05-08T18:16:26Z"
        }
      ]
    },
    {
      "number": 126,
      "id": "I_kwDOF8lax85JJk6A",
      "title": "Add an `IsValidPoint` operation",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/126",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "ready-for-pr",
        "core"
      ],
      "body": "As raised by @mikelodder7 in #115 there are numerous cases within existing operations that require validating points, therefore having a single operation that documents these steps rather than repeating them will improve readability.",
      "createdAt": "2022-05-05T22:49:38Z",
      "updatedAt": "2022-07-04T18:55:33Z",
      "closedAt": "2022-07-04T18:55:33Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Additional context [here](https://github.com/decentralized-identity/bbs-signature/pull/115#discussion_r863084747)",
          "createdAt": "2022-05-05T22:55:11Z",
          "updatedAt": "2022-05-05T22:55:11Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "The signature related checks for this in the verify function are being captured in #133 ",
          "createdAt": "2022-05-11T23:15:13Z",
          "updatedAt": "2022-05-11T23:15:13Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Duplicate of #179, closing in favour of that issue",
          "createdAt": "2022-07-04T18:55:32Z",
          "updatedAt": "2022-07-04T18:55:32Z"
        }
      ]
    },
    {
      "number": 127,
      "id": "I_kwDOF8lax85JJlGw",
      "title": "Validate e and s signature components non-zero",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/127",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "ready-for-pr",
        "core"
      ],
      "body": "Raised by @mikelodder7 [here](https://github.com/decentralized-identity/bbs-signature/pull/115/files#r862931354)",
      "createdAt": "2022-05-05T22:51:31Z",
      "updatedAt": "2022-05-12T23:13:10Z",
      "closedAt": "2022-05-12T23:13:10Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Addressed in #133 ",
          "createdAt": "2022-05-11T09:03:43Z",
          "updatedAt": "2022-05-11T09:03:43Z"
        }
      ]
    },
    {
      "number": 131,
      "id": "I_kwDOF8lax85JPXkH",
      "title": "Consider splitting operations into Core and Higher level definitions",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/131",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "core"
      ],
      "body": "As raised by @BasileiosKal previously, to improved readability around the defined operations we could elect to group the operations into core and non-core, for instance `Sign`, `Verify`, `ProofGen` and `ProofVerify` could become `CoreSign`, `CoreVerify`, `CoreProofGen` and `CoreProofVerify`. We could then define more application specific higher-level operations like `SingleSign` and `MultiSign` where the function signatures could be something like the following\r\n\r\n```\r\nsignature = SingleSign(SK, header)\r\n```\r\n\r\n```\r\nsignature = MultiSign(SK, header, (msg_1,..., msg_L))\r\n```\r\n\r\n**Note** these ^ are just ideas about how we could encapsulate common usage patterns.",
      "createdAt": "2022-05-08T01:25:22Z",
      "updatedAt": "2022-07-04T18:57:30Z",
      "closedAt": "2022-07-04T18:57:30Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Some of this is being addressed by #154 ",
          "createdAt": "2022-05-27T21:59:19Z",
          "updatedAt": "2022-05-27T21:59:19Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Closing with the merge of #154 which settled the restructure of the sections",
          "createdAt": "2022-07-04T18:57:30Z",
          "updatedAt": "2022-07-04T18:57:30Z"
        }
      ]
    },
    {
      "number": 134,
      "id": "I_kwDOF8lax85JceAN",
      "title": "Fix Blind Messages Proof",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/134",
      "state": "OPEN",
      "author": "alessandroguggino",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "BasileiosKal"
      ],
      "labels": [
        "pending-close",
        "blind-sign-extension"
      ],
      "body": "I found something new from the Blind signature extension. I know that you are now focused on the core draft but I leave it here :)\r\n\r\nIn `BlindMessagesProofGen`:\r\nhttps://github.com/decentralized-identity/bbs-signature/blob/5fba426d415b85b6156a0c001e605482bdf3b770/draft-blind-bbs-signatures.md?plain=1#L249\r\nIn `BlindMessagesProofVerify`:\r\nhttps://github.com/decentralized-identity/bbs-signature/blob/5fba426d415b85b6156a0c001e605482bdf3b770/draft-blind-bbs-signatures.md?plain=1#L284\r\n\r\nThe values in `c` and `cv` are inconsistent: we should decide which one to follow.\r\n1) `c = hash(U || U~ || nonce)` and `cv = hash(U || U^ || nonce)` + add `U` (known messages) as input parameter in _BlindMessagesProofVerify_\r\n**or**\r\n2) `c = hash(commitment || U~ || nonce)` and `cv = hash(commitment || U^ || nonce)`\r\n\r\nP.S. I'm going to open a pull request to remove the unuseful escape chars and, if you want, update the draft to snake_case notation",
      "createdAt": "2022-05-11T08:25:05Z",
      "updatedAt": "2023-12-18T19:51:34Z",
      "closedAt": null,
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Hey @alessandroguggino good catch, yes there are some inconsistencies, however you are right that our focus as a WG is primarily on the core draft right now. Feel free to open a PR to address any syntax inconsistencies anything broader we will address once the core draft is complete/stable.",
          "createdAt": "2022-05-11T09:02:36Z",
          "updatedAt": "2022-05-11T09:02:36Z"
        }
      ]
    },
    {
      "number": 139,
      "id": "I_kwDOF8lax85Jp5_6",
      "title": "H_s and H_d not defined in BLS ciphersuite",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/139",
      "state": "CLOSED",
      "author": "christianpaquin",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "ready-for-pr",
        "core"
      ],
      "body": "The terminology section says that the `H_s` and `H_d` generators are defined by each ciphersuite, but they are not defined in the BLS12-381 Ciphersuite section.",
      "createdAt": "2022-05-13T21:16:47Z",
      "updatedAt": "2022-06-28T08:07:09Z",
      "closedAt": "2022-06-28T08:07:09Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Agree this is confusing, currently we have `blind_value_generator_seed` and `signature_dst_generator_seed` which are intended to be used with the [CreateGenerators](https://identity.foundation/bbs-signature/draft-bbs-signatures.html#name-creategenerators) operation to derive H_s and H_d, but this needs to be clarified further",
          "createdAt": "2022-05-13T21:47:44Z",
          "updatedAt": "2022-05-13T21:47:44Z"
        }
      ]
    },
    {
      "number": 141,
      "id": "I_kwDOF8lax85Jqyb9",
      "title": "Generators ordering",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/141",
      "state": "CLOSED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "core"
      ],
      "body": "It would be very useful to have a clear way to define the order of the generators in the draft. This would allow us to naturally also define the order of the signed messages that it is also needed.\r\n\r\nTwo options as far as I know are:\r\n1. Based on their index (i.e., the order of which they are created). So, H_1 will be the first generator created, H_2 the second etc.\r\n2. Based on their value (using some metric, maybe Euclidian distance??, or alphabetically using their octet representation??).\r\n\r\nIMO 2 seems to be a fair amount more complicated. \r\n\r\nOn the other hand, using 1, to validate that some generators have the correct \"order\" one will have to re-create them. \r\n\r\nFor that reason, I tent more in the second option, but I do recognize that both have trade-offs.",
      "createdAt": "2022-05-14T11:46:24Z",
      "updatedAt": "2022-06-26T15:48:19Z",
      "closedAt": "2022-06-26T15:48:19Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@BasileiosKal is this issue resolved now?",
          "createdAt": "2022-06-25T00:34:33Z",
          "updatedAt": "2022-06-25T00:34:33Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes! The spec moved with option 1 from above. Closing.\r\n\r\nIf there is other practical issues with the generators ordering in the cache, those will be better discussed in another issue.",
          "createdAt": "2022-06-26T15:48:19Z",
          "updatedAt": "2022-06-26T15:48:19Z"
        }
      ]
    },
    {
      "number": 143,
      "id": "I_kwDOF8lax85J0ceJ",
      "title": "H2C using SHA256",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/143",
      "state": "CLOSED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "ready-for-pr",
        "core"
      ],
      "body": "Currently the spec creates generators using hash-to-curve implemented with `shake256` (for which we describe a h2c ciphersuite).\r\n\r\nLooking at implementations of pairing-friendly-curves though, most of them seem to natively support h2c with `sha256` (like blst). This means that,\r\n1. We may have to implement h2c with `shake256` our self's.\r\n2. Applications that elect to use the natively supported h2c implementation (and will be many of those most likely) will create generators that are not interoperable with the ones we describe in the spec.\r\n\r\nAt the very least we may be creating an implementation barrier by making it hard to use `sha256` for h2c.\r\n\r\nSince efficiency is not an issue when creating generators, and taking into account the wider spread of `sha256`, should we update h2c to use `sha` instead of `shake`?? We can leave the ciphersuite definition for h2c using `shake256` as an alternative, while the bls12-381 ciphersuite will use h2c with `sha256`??",
      "createdAt": "2022-05-17T11:18:01Z",
      "updatedAt": "2022-08-30T07:26:21Z",
      "closedAt": "2022-08-30T07:26:20Z",
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@christianpaquin was this your experience as well with the javascript libraries?? \r\n\r\nc.c. @tplooker, @andrewwhitehead, @mikelodder7 ^^",
          "createdAt": "2022-05-17T11:18:22Z",
          "updatedAt": "2022-05-17T11:18:22Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "JavaScript libraries have shake/SHA3 available to them but will have to implement h2c. I think h2c is more of a barrier than SHAKE.",
          "createdAt": "2022-05-17T12:12:55Z",
          "updatedAt": "2022-05-17T12:12:55Z"
        },
        {
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> @christianpaquin was this your experience as well with the javascript libraries??\r\n\r\nI'm using the [noble-bls12-381](https://github.com/paulmillr/noble-bls12-381.git) library, which supports hash-to-the-BLS curve, but I haven't confirmed if it's the same as we specified. The hash-to-curve spec [BLS suites](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-14#section-8.8) use SHA-256, so I'd prefer using that. I know we had a discussion of using SHA vs SHAKE in the past, but I'd advocate to using the simple hash function whenever possible, because it should always be available in libraries (or environments) providing shake. ",
          "createdAt": "2022-05-17T15:37:47Z",
          "updatedAt": "2022-05-17T15:37:47Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I\u2019ve had to implement h2c in multiple languages and each language already had shake: Go, Rust, Java to name a few. My point is Shake was already available and h2c was not. H2c is the more limiting factor I have found not the other way around",
          "createdAt": "2022-05-17T15:40:55Z",
          "updatedAt": "2022-05-17T15:40:55Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The other problem I have with SHA2 Is its vulnerable to extension attacks. Implementers don\u2019t even think about that. This is why we have HMac & HKDF. By staying with SHA3 algorithms, implementors do not have to worry about that",
          "createdAt": "2022-05-17T15:47:40Z",
          "updatedAt": "2022-05-17T15:47:40Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "> I\u2019ve had to implement h2c in multiple languages and each language already had shake: Go, Rust, Java to name a few. My point is Shake was already available and h2c was not. H2c is the more limiting factor I have found not the other way around\r\n\r\nI think the point is, how many of these languages had H2C implementations but just not for XOFs? Because if H2C w SHA-256 exists in most languages then shifting to this variation would have a meaningful impact on implementation complexity",
          "createdAt": "2022-05-17T18:58:33Z",
          "updatedAt": "2022-05-17T18:58:33Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "I think its safe to assume that there are more H2C implementations w SHA-256 then there is XOF based purely on the fact that popular signature schemes like BLS signatures depends on it",
          "createdAt": "2022-05-17T19:00:10Z",
          "updatedAt": "2022-05-17T19:00:10Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "> I'm using the [noble-bls12-381](https://github.com/paulmillr/noble-bls12-381.git) library, which supports hash-to-the-BLS curve, but I haven't confirmed if it's the same as we specified. The hash-to-curve spec [BLS suites](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-14#section-8.8) use SHA-256, so I'd prefer using that. I know we had a discussion of using SHA vs SHAKE in the past, but I'd advocate to using the simple hash function whenever possible, because it should always be available in libraries (or environments) providing shake.\r\n\r\nAs an example [see here](https://github.com/paulmillr/noble-bls12-381/blob/main/math.ts#L1098) looks like this library only supports the ~~SWU~~ expand_msg variation of H2C rather than the XOF based one. [blst](https://github.com/supranational/blst) as a library is similar.",
          "createdAt": "2022-05-17T19:07:04Z",
          "updatedAt": "2022-05-17T19:25:20Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Swu has nothing to do with the hash function. To be clear it\u2019s the expand_msg vs expand_xof. That\u2019s the only difference ",
          "createdAt": "2022-05-17T19:14:53Z",
          "updatedAt": "2022-05-17T19:14:53Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "What you want is here https://github.com/paulmillr/noble-bls12-381/blob/main/index.ts#L236",
          "createdAt": "2022-05-17T19:21:12Z",
          "updatedAt": "2022-05-17T19:21:12Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The difference is quite small. You use expand_xof vs expand_msg, expand_xof is less code and faster to compute. I don\u2019t think this as big of a barrier as you are thinking it will be",
          "createdAt": "2022-05-17T19:22:50Z",
          "updatedAt": "2022-05-17T19:22:50Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": ">  Swu has nothing to do with the hash function. To be clear it\u2019s the expand_msg vs expand_xof. That\u2019s the only difference\r\n\r\nQuite right, my apologies.\r\n",
          "createdAt": "2022-05-17T19:23:21Z",
          "updatedAt": "2022-05-17T19:23:21Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In the end i think we are mostly in agreement here. I agree that a big barrier may be h2c but even in libs that have h2c implemented, a lot of times it will be with just a hash (like [noble-bls12-381](https://github.com/paulmillr/noble-bls12-381/blob/b55eca3ae0f2f1cb35d768cd432ca3f57d26a47a/index.ts#L278) and [blst](https://github.com/supranational/blst/blob/master/src/hash_to_field.c#L139)). This makes sense since most of them target bls-sigs. So IMO it's the combination of the two that makes things difficult and not just h2c.",
          "createdAt": "2022-05-18T19:02:36Z",
          "updatedAt": "2022-05-18T19:11:51Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If we have global message generators then libraries can just use cached values (up to a maximum message count) and might not have to implement H2C depending on the application.",
          "createdAt": "2022-05-18T19:14:12Z",
          "updatedAt": "2022-05-18T19:14:12Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That's true (although it may not always hold). I also agree with Mike in that it may not be a huge barrier, but IMO if we can make things a little bit easier for applications i don't see why not??",
          "createdAt": "2022-05-18T22:32:00Z",
          "updatedAt": "2022-05-18T22:32:00Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Merging #177 and #151 made it possible to define a bbs ciphersuite with only one hash function in the basis of a (single) H2C suite. This addresses this issue. Will close after the next call.",
          "createdAt": "2022-07-04T17:22:05Z",
          "updatedAt": "2022-07-04T17:22:05Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed in the 2022-07-04 WG call! Will leave open until we decide if we will define a second sha256 based ciphersuite in the spec.",
          "createdAt": "2022-07-04T21:50:54Z",
          "updatedAt": "2022-07-04T21:50:54Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed on 8th of August WG call there appears to be a meaningful improvement in the implementability of the scheme when using SHA256 based on pre-existing implementations. Therefore we see value in defining a cipher suite to work with SHA256. The question remains on whether this is an additional cipher suite OR a replacement for the current one that uses SHAKE 256.",
          "createdAt": "2022-08-08T18:52:43Z",
          "updatedAt": "2022-08-08T18:52:43Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "DIscussed on 15th of August WG call, based on implementation feedback we are going to define a SHA256 based ciphersuite to support further discussion around it.",
          "createdAt": "2022-08-15T18:16:15Z",
          "updatedAt": "2022-08-15T18:16:15Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Resolved in #213 ",
          "createdAt": "2022-08-30T07:26:20Z",
          "updatedAt": "2022-08-30T07:26:20Z"
        }
      ]
    },
    {
      "number": 146,
      "id": "I_kwDOF8lax85KDMFo",
      "title": "Clarify point serialization",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/146",
      "state": "CLOSED",
      "author": "christianpaquin",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "ready-for-pr",
        "core"
      ],
      "body": "The ciphersuite's `octets_to_point` is ambiguous, as it is unclear which point type should be returned (from G1 or G2). This can be inferred by cross-referencing other parts of the spec, but implementers would benefit from a clearer description; e.g., either adding a `_g1` of `_g2` suffix to the method or a type input. The BLS spec support two modes (where G1 and G2 are swapped), so the ambiguity is by design; BBS fixed the group, so we don't need to keep the BLS notation. `point_to_octects` is not as problematic, since presumably you can infer the input type, but we should harmonize both function names.\r\n\r\nAnother clarification question: both `point_to_octets` and `octets_to_point` refer to the CRFG pairing-friendly curves spec's Appendix C, but doesn't mention which mode to use (compressed or not).  As an example, the BLS spec uses compressed serialization (see its [Appendix A](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-bls-signature-04#appendix-A))",
      "createdAt": "2022-05-19T21:28:27Z",
      "updatedAt": "2022-05-20T02:55:57Z",
      "closedAt": "2022-05-20T02:55:57Z",
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I may be missing something but isn\u2019t it possible to determine if the point should be in G1 or G2 by the encoded to octets value of the point itself, based on the length of that value (called s_string in the [pairing-friendly-curves spec](https://www.ietf.org/archive/id/draft-irtf-cfrg-pairing-friendly-curves-10.html#name-zcash-serialization-format-)). The same holds for compression vs non-compression case that can be determined by the C_bit defined [here](https://www.ietf.org/archive/id/draft-irtf-cfrg-pairing-friendly-curves-10.html#name-point-serialization-procedu).\r\n\r\nIf I\u2019m not missing something and the proposal is to add the `_g1` and `_g2` suffixes to increase readability but have the operations essentially be the same in both cases I\u2019m all for it.",
          "createdAt": "2022-05-19T22:31:17Z",
          "updatedAt": "2022-05-19T22:31:17Z"
        },
        {
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, I think adding `_g1` and `_g2` would be the simplest solution. Maybe there are ways to figure out what needs to be done, but for devs calling a 3rd party BLS library (like me), it's not immediately clear which function to call (having to consciously recall which group if for pub keys and generators). Moreover, future ciphersuites might have different rules, so an explicit target group removes potential ambiguity.",
          "createdAt": "2022-05-19T23:23:29Z",
          "updatedAt": "2022-05-19T23:23:29Z"
        }
      ]
    },
    {
      "number": 148,
      "id": "I_kwDOF8lax85KDjM1",
      "title": "Clarify number of bytes drawn from xof for `hash` function",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/148",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "ready-for-pr",
        "core"
      ],
      "body": "Currently the BLS12-381 ciphersuite defines to use SHAKE-256 for the implementation of the `hash` function but doesn't clarify how many bytes to draw, this should be updated.",
      "createdAt": "2022-05-20T00:05:25Z",
      "updatedAt": "2022-09-19T18:49:06Z",
      "closedAt": "2022-09-19T18:49:06Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "We now only use the `hash` function on one place in the draft which is for the key generation procedure which we are currently considering revising, so this issue is blocked by #186",
          "createdAt": "2022-08-08T18:41:42Z",
          "updatedAt": "2022-08-08T18:41:42Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed on 8th August WG call",
          "createdAt": "2022-08-08T18:41:59Z",
          "updatedAt": "2022-08-08T18:41:59Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Also related to #143 because using a non XOF would not create such ambiguity",
          "createdAt": "2022-08-15T18:41:19Z",
          "updatedAt": "2022-08-15T18:41:19Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed on WG call 19th of september, resolved to close",
          "createdAt": "2022-09-19T18:49:06Z",
          "updatedAt": "2022-09-19T18:49:06Z"
        }
      ]
    },
    {
      "number": 150,
      "id": "I_kwDOF8lax85KH0Hv",
      "title": "Core vs message generators",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/150",
      "state": "CLOSED",
      "author": "andrewwhitehead",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "ready-for-pr",
        "core"
      ],
      "body": "At the moment we have separate generator seed values within each ciphersuite used to generate the 'H_s' and 'H_d' generators. This could be made a little more efficient by using a single seed value and defining these generators as the successive outputs.\r\n\r\nInstead of `blind_value_generator_seed` and `signature_dst_generator_seed` I would suggest a something like a `core_generator_seed`. Then `H_s` becomes the first output of `CreateGenerators(dst, core_generator_seed, 2)` and `H_d` the second.\r\n\r\nSyntax wise, we could use an alternative naming for these generators and refer to them by their number, consistent with the `H_i` generators. Perhaps `Q_i`?\r\n\r\nAdditionally, we could potentially solve the holder binding issue (#37) by replacing `P1` with `Q_1`, making `H_s` and `H_d` the subsequent generators (`Q_2` and `Q_3`) and freeing up `P1` for application usage.",
      "createdAt": "2022-05-20T19:56:16Z",
      "updatedAt": "2022-06-24T21:13:54Z",
      "closedAt": "2022-06-24T21:13:53Z",
      "comments": [
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "To my knowledge `P1` serves two purposes in the original formulation. For a signature over messages `m_i`, with `B = P1 + H_0*s + H_1*m_1 ...`\r\n\r\n1. The signature can't be multiplied by a scalar in order to present alternative message values. For example, setting `A1 = A*n, s1 = s*n`, the signature `(A1, e, s1)` might be valid over messages `m_i*n` except for the fact that `P1` becomes `P1*n`. In a sense we can think of `P1` as a message generator which always signs the message scalar `1`.\r\n\r\n2. As part of the zero knowledge proof for disclosed messages `D`, the equation `P1 + sum(i in D, H_i*m_i) = sum(i not in D, H_i*m_i)` is proven. In the case where no messages are disclosed, only `P1` is left on the left hand side.\r\n\r\nIn the current formulation we always have at least one revealed message (the domain), and so there is always something on the left hand side of the proof equation. Since the domain value is generated by a hash, it would also be extremely difficult to choose a header message such that a chosen scalar multiple of the domain value could be substituted. ~~I believe this means we could technically do away with `P1` entirely (but that would mean updating the proofs and so it's probably not worthwhile).~~",
          "createdAt": "2022-05-20T20:50:20Z",
          "updatedAt": "2022-05-20T22:27:57Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don\u2019t think it is possible to NOT use `P1` (or not \"sign\" 1 in general, under any generator). If the signature is `A = (Q1 * domain_1 + sum(i in L, H_i * m_i)) * (1/(e +SK))` then i can calculate any `domain_2` i want, set `k = domain_2 / domain_1` and calculate\r\n```\r\nA * k = (Q1 * domain_1 * k  + sum(i in L, H_i * (m_i * k))) * (1 / (e + SK)) \r\n        = (Q1 * domain_2  + sum(i in L, H_i * (m_i * k))) * (1 / (e + SK)) \r\n```\r\nWhich is a signature on `domain_2` and the messages `m_i * k`?? Unless im missing something.\r\n\r\nThat said I\u2019m not opposed with using 1 seed for all \"core\" generators and on freeing `P1`, by substituting it with another generator. I don't think from an implementation\u2019s perspective it makes much difference and we are at the very least enabling some interesting use cases \r\n",
          "createdAt": "2022-05-20T21:18:30Z",
          "updatedAt": "2022-05-20T21:18:30Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That's a good point, you could make it work for some `k`, but not a chosen value. Scratch the part about removing `P1` then.",
          "createdAt": "2022-05-20T21:23:24Z",
          "updatedAt": "2022-05-20T21:23:24Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closing. Might still consider renaming the H_s and H_d generators.",
          "createdAt": "2022-06-24T21:13:53Z",
          "updatedAt": "2022-06-24T21:13:53Z"
        }
      ]
    },
    {
      "number": 153,
      "id": "I_kwDOF8lax85KPsjt",
      "title": "OctetsToProof and ProofToOctets",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/153",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [
        "BasileiosKal"
      ],
      "labels": [
        "ready-for-pr",
        "core"
      ],
      "body": "With the merge of #147 defining the rules for the signature serialisation we now need to define how to do the corresponding for the proof value outputted by the ProofGen operation and consumed by the ProofVerify operation.",
      "createdAt": "2022-05-23T19:54:04Z",
      "updatedAt": "2022-06-07T23:05:47Z",
      "closedAt": "2022-06-07T23:05:47Z",
      "comments": []
    },
    {
      "number": 157,
      "id": "I_kwDOF8lax85KgOBJ",
      "title": "Integer endianness",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/157",
      "state": "CLOSED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "ready-for-pr",
        "core"
      ],
      "body": "As noted by @mikelodder7,  in the document we don't yet discuss the integers (i.e., scalars mod r) serialization. More specifically, since we have a description for the byte length of those integers (`octet_scalar_length`), what is missing is the byte order.\r\n\r\nIn general i thing little-endian is preferred (it is mostly used in bls libs like the rust crate and blst) but an issue is that I2OSP uses big-endian if im not mistaken.\r\n\r\nThere are 3 options i can think of;\r\n1. We describe them as 32 bytes (or `octet_scalar_length` in general) in little-endian, with a note for I2OSP.\r\n2. We describe them in a way similar to some libs (i.e., four 64 bit parts in little-endian order), but i don't think something like that is suitable. \r\n3. We leave it up for implementers with some notes for guidance.\r\n\r\nAt the moment I'm leaning more towards option 3. Implementations may elect to use any kind of optimization and this will allow for that. \r\n\r\nAlso for what i know of, other specs like ecdsa and eddsa elect to define the integer's endianness but specs like bls-sigs and h2c adopt option 3, so it does not seem to be any \"absolutely correct\" way to do that.",
      "createdAt": "2022-05-26T19:28:52Z",
      "updatedAt": "2023-02-14T22:59:42Z",
      "closedAt": "2023-02-14T22:59:41Z",
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed in the WG call on 2022-06-27. The direction decided is to check available implementations and either ad a note in the definition of OS2IP and I2OSP, describing that they operate in big-endian order (like [H2C](https://www.ietf.org/archive/id/draft-irtf-cfrg-hash-to-curve-16.html#section-4)) or define a `scalar_to_octets` operation, that on input a scalar will return an octet string in litle-endian order (just a definition possible with no explicit procedure).",
          "createdAt": "2022-06-28T18:25:59Z",
          "updatedAt": "2022-06-28T18:26:47Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed on WG call 8th of august, there is currently ambiguity around the endianness of scalar_to_octets that needs to be resolved.",
          "createdAt": "2022-08-08T18:38:34Z",
          "updatedAt": "2022-08-08T18:38:34Z"
        },
        {
          "author": "tmarkovski",
          "authorAssociation": "MEMBER",
          "body": "I ran into this issue as I was going through spec implementation and validating against the provided fixtures. Has there been a decision made? I think at minimum, the fixtures should specify the byte order of the scalar.",
          "createdAt": "2022-10-17T11:41:22Z",
          "updatedAt": "2022-10-17T11:41:22Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In practice, not a decision here, whenever hexits or base64 are given it represents big endian.",
          "createdAt": "2022-10-17T11:43:02Z",
          "updatedAt": "2022-10-17T11:43:02Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If we give the actual bytes then little endian is preferable",
          "createdAt": "2022-10-17T11:44:04Z",
          "updatedAt": "2022-10-17T11:44:04Z"
        },
        {
          "author": "tmarkovski",
          "authorAssociation": "MEMBER",
          "body": "> If we give the actual bytes then little endian is preferable\r\n\r\nThe `SignatureToOctets` does give the actual bytes and for scalars it refers to `i2osp` which specifies them as big-endian. Do you propose that we use little-endian instead for the signature and proof composition?",
          "createdAt": "2022-10-17T16:29:10Z",
          "updatedAt": "2022-10-17T16:29:10Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Let me clarify, in a spec if they give the actual byte sequence it\u2019s almost always little endian, but when encoded like hex or base64, it\u2019s big endian. Since we rarely give the actual byte sequence, I\u2019d propose to use big endian hexits",
          "createdAt": "2022-10-17T16:51:21Z",
          "updatedAt": "2022-10-17T16:51:21Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Related to updates in #221 ",
          "createdAt": "2022-10-17T18:51:25Z",
          "updatedAt": "2022-10-17T18:51:25Z"
        }
      ]
    },
    {
      "number": 159,
      "id": "I_kwDOF8lax85Kj6wO",
      "title": "API Update",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/159",
      "state": "CLOSED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "ready-for-pr",
        "pending-close",
        "core"
      ],
      "body": "Trying to update the API has resulted in mainly two proposals from @andrewwhitehead and @tplooker. The first one using boolean variables to distinquish between revealed and un-revealed messages and the second one using indexes. You can compare the 2 APIs [here](https://github.com/BasileiosKal/dif-bbs-signature-api):\r\n- [API_1](https://github.com/BasileiosKal/dif-bbs-signature-api/tree/main/API_1_Boolean) (using Booleans): [Sign](https://github.com/BasileiosKal/dif-bbs-signature-api/blob/main/API_1_Boolean/draft-bbs-signatures.md#sign), [Verify](https://github.com/BasileiosKal/dif-bbs-signature-api/blob/main/API_1_Boolean/draft-bbs-signatures.md#verify), [ProofGen](https://github.com/BasileiosKal/dif-bbs-signature-api/blob/main/API_1_Boolean/draft-bbs-signatures.md#proofgen), [ProofVerify](https://github.com/BasileiosKal/dif-bbs-signature-api/blob/main/API_1_Boolean/draft-bbs-signatures.md#proofverify)\r\n- [API_2 ](https://github.com/BasileiosKal/dif-bbs-signature-api/tree/main/API_2_Indexes)(using Indexes): [Sign](https://github.com/BasileiosKal/dif-bbs-signature-api/blob/main/API_2_Indexes/draft-bbs-signatures.md#sign), [Verify](https://github.com/BasileiosKal/dif-bbs-signature-api/blob/main/API_2_Indexes/draft-bbs-signatures.md#verify), [ProofGen](https://github.com/BasileiosKal/dif-bbs-signature-api/blob/main/API_2_Indexes/draft-bbs-signatures.md#proofgen), [ProofVerify](https://github.com/BasileiosKal/dif-bbs-signature-api/blob/main/API_2_Indexes/draft-bbs-signatures.md#proofverify)\r\n\r\nWe can somewhat compare the two APIs based on the total number of lines (i.e., everything inside each code block) and the total number of procedure steps,\r\n\r\n### API 1 (Booleans)\r\n\r\n|                  |  lines   | Procedure Steps | \r\n| ----------- | ------ | ----------------- | \r\n| Sign           |   54    |        9                   | \r\n| Verify         |  59     |       11                  | \r\n| ProofGen   |  109   |       26                  | \r\n| ProofVerify |   78    |       14                  | \r\n\r\n### API 2 (Indexes)\r\n\r\n|                   | lines | Procedure Steps |\r\n| ----------   | ---- | ----------------- |\r\n| Sign           |  55  |   10                     |\r\n| Verify         |  59  |   12                     |\r\n| ProofGen   | 101 |    29                    |\r\n| ProofVerify | 81   |   18                     |\r\n\r\nWe can see that there is not much difference between the two or a clear winner. Procedures in API 2 have more steps but the total lines are about the same. So, the choice should be made based on which one is more readable and more tolerant to implementation mistakes.\r\n\r\n### Note:\r\nWhen using API 2 there may be more checks to be done when it comes to the indexes i.e., that are truly between 1 and L. Right now this is only described above the operations. It is important though, especially in `ProofVerify`. \r\n\r\nFor example, if not checked, the prover could reveal an extra message with an \"invalid\" index (like `index = L+1`), and the proof may validate depending on the implementation. So more steps may be needed in `ProofVerify` to make this check explicit.\r\n\r\nCurrently PR #138 proposes the use of API 2. Personally i find that it is a little more clear overall especially when it comes to the ordering of the input lists (see also #117 for some context).",
      "createdAt": "2022-05-27T16:07:02Z",
      "updatedAt": "2022-07-04T18:31:53Z",
      "closedAt": "2022-07-04T18:31:52Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Labeling as pending close ahead of WG call on the 4th of july",
          "createdAt": "2022-07-04T00:58:28Z",
          "updatedAt": "2022-07-04T00:58:28Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed on july 4th WG call resolved via #183 ",
          "createdAt": "2022-07-04T18:31:52Z",
          "updatedAt": "2022-07-04T18:31:52Z"
        }
      ]
    },
    {
      "number": 162,
      "id": "I_kwDOF8lax85K554z",
      "title": "Reducing hash functions",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/162",
      "state": "CLOSED",
      "author": "andrewwhitehead",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "core"
      ],
      "body": "There are several different uses of hash functions within the draft. These generally refer to the `hash` parameter, but some refer to the `xof` parameter, which currently appears independent. For compatibility, every hash function that is used in operations by multiple parties must be referenced in the ciphersuite ID. Because we don't want to list several hash functions here, and because supporting multiple hash functions adds extra dependencies (and implementation cost, platform incompatibilities, potential vulnerabilities) I suggest we try to reduce requirement to a single hash function per ciphersuite. Here are the use current cases I've identified:\r\n\r\n- In `hash_to_scalar`: Used to generate various scalars within signature and proof generation. We have a proposal to add an XMD version to support non-XOF hashes. This is the primary use of the hash function.\r\n- Within `KeyGen`: this one doesn't need to be included in the ciphersuite ID as it has no impact on other parties. Maybe the hash function should become an input parameter? If we want to keep this operation.\r\n- In generator creation:\r\n    - The current method uses an XOF to generate a stream of bytes which is then fed into a hash-to-curve implementation. If we want to support non-XOF hash functions then we might need to define an alternative method (like the one in the old draft).\r\n    - The chosen hash-to-curve suite should be required to use the same hash and a compatible `expand_message` method (XOF or XMD). It must also use `hash_to_curve` not `encode_to_curve` in order to guarantee a uniform distribution, ie. the suite identifier must end with 'RO'.\r\n- Hashing message inputs:\r\n    This one seems a little problematic. It is essential to the security of the signature scheme that all parties understand the encoding used to create the message scalars. Some implementations are going to need type-aware conversion of input values to scalars, which seems beyond the scope of this spec as it implies a dependency on a schema to define the value types. We could completely avoid standardizing message-to-scalar conversion and only use predefined scalars in the test cases. On the other hand, I also believe we need to support the base-level use case of simply signing one or more octet strings, in which case 'MapMessageToScalarAsHash' is sufficient. (In this case, do we want to require that the hash used to convert input messages is the same as the hash used within the other operations?)\r\n    In order to support both the typed-values message encoding use case and the simple hash-and-sign use case, perhaps we could add a simple parameter to the ciphersuite ID to distinguish between the two. We could add an ENC_TAG with two values: RAW (treat all input messages as octet strings), and SCHEMA (validate message inputs according to the associated schema, and apply its rules for converting into message scalars). When the ENC_TAG is SCHEMA, then a schema identifier would need to be included in the header value or somehow implied at the application level \u2013\u00a0I don't think we need to formalize this beyond adding a security guideline.",
      "createdAt": "2022-06-01T18:15:06Z",
      "updatedAt": "2022-06-24T20:17:31Z",
      "closedAt": "2022-06-24T20:17:31Z",
      "comments": [
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "TBH I think the current effort to support non-XOF hash functions is impeding progress, and we should revisit that after a first draft if at all.",
          "createdAt": "2022-06-01T18:17:29Z",
          "updatedAt": "2022-06-01T18:17:29Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Upon consideration, we don't want to use this ENC_TAG within the ciphersuite ID, as then we'd need to define twice as many ciphersuites. Perhaps this can just be left to the application level?",
          "createdAt": "2022-06-01T18:28:24Z",
          "updatedAt": "2022-06-01T18:28:24Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agreed with the direction! IMO a suite should define that whatever hash is used for h2c will be used for everything else ass well (mainly hash_to_scalar, which is also used by `MapMessageToScalarAsHash`). That way the H2C_ID is enough to characterize the suite. \r\n\r\nAs far as usefulness of the non-xof hash_to_scalar I'm (obviously) of the opinion that is needed. The reason is that a lot of times, only supporting an xof has caused issues in the impenetrability of the scheme, for example, when trying to use libs that don't support shake256 (but they do support h2c with sha256 like [blst](https://github.com/supranational/blst) or [noble-bls12-381](https://github.com/paulmillr/noble-bls12-381)). Personally, I would like to push a first draft with two ciphersuites, one using shake256 and one using sha256. That way, it will be very easy to implement bbs+ with bls12-381 libs, that are targeted to bls-sigs (that are most of them AFAIK).\r\n\r\nTo further support the above, I'm also worried that developers will use a lib like the above, with a sha256 based h2c implementation, and just use shake256 for everything else, essentially implementing a wrong suite (which can be dangerous).\r\n\r\nOf-course always more than happy in keep discussing this. If the group feels that the _xmd version of hash_to_scalar is not worth wile right now I'm more than happy to close PR #151.",
          "createdAt": "2022-06-01T20:10:15Z",
          "updatedAt": "2022-06-01T20:10:15Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "When it comes to message encoding, I'm of the opinion that this is not the correct place to describe it. My main reason is that we cannot possibly account for the flexibility an upper layer protocol may require. What if some messages are hashed, and some are zero-centered for example?? I don't see a way that would allow for such flexibility, without raising complexity by a lot. This things are usually defined in appear layer (for example defining raw vs hashed encoding when using [a cloud kms](https://cloud.google.com/kms/docs/reference/rest/v1/projects.locations.keyRings.cryptoKeys.cryptoKeyVersions/asymmetricSign)) eitherway.\r\n\r\nThat said, some guidance will be useful IMO because of the unique features of bbs. I don't know if i would define operations though (other than `MapMessageToScalarAsHash`). IMO this is more suitable for an appendix. We can propose there a way to avoid ubiquity regarding the encoding of messages.\r\n\r\nAlso, because the encoding of the messages will be very dynamic most likely (at the very least, it will be application specific), i don't think that reflecting it in the ciphersuite ID (or in the ciphersuites in general) is appropriate. IMO this should be handled in the application layer.",
          "createdAt": "2022-06-01T20:34:33Z",
          "updatedAt": "2022-06-01T20:34:33Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, I think the key is that a 'raw' BBS signature is unlikely to be encountered in the wild \u2013 it will be wrapped in a JWS, or a VC, or some other container which defines the interpretation (including the ciphersuite) and hopefully protects that associated data using the header. And of course on the verifier side they will often only see a proof of a signature. I do think we want to avoid the perception that input messages are always hashed.\r\n\r\n> Personally, I would like to push a first draft with two ciphersuites, one using shake256 and one using sha256. That way, it will be very easy to implement bbs+ with bls12-381 libs, that are targeted to bls-sigs (that are most of them AFAIK).\r\n\r\nWell.. it will be easy to implement the sha256 version, but that won't help compatibility with libraries that use shake256. Maybe we should be focusing on adding XOF support to those libraries instead of complicating the spec, or defining an XOF-like primitive based on HDKF.",
          "createdAt": "2022-06-01T21:05:03Z",
          "updatedAt": "2022-06-01T21:05:03Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That's true! And definitely something to consider! The two ciphersuites will not be compatible with each other either way though?? (when it comes to the challenge hash for example). So IMO it's fine to have two different suites that target two different groups of implementations. Since the spec is pretty well suited for use with an xof already (which is very much encouraged), I don't see why also supporting a fixed-output-length hash would do more harm than good (when it comes to the compatibility with shake256 supporting libs)?? \r\n\r\nOf-course, raising the complexity of the spec is something that i also want to avoid as much as possible. However, in this case, i think its worth it since,\r\n1. IMO it will allow use of a much wider range of already established implementations + i think it's much easier than trying to add xof support to those libs\r\n2. I don't think complexity will be raised that much. It will be at most 2 more operations (`hash_to_scalar_xmd` and maybe a `compute_generators_xmd`. although i don't think the last one is even needed).\r\n\r\nWhen it comes to HKDF I'm not at all opposed to it. However, it is less efficient. We could also use hash_to_field, although that too is less efficient. In any case I'm fine with the approaches, as long as we have something so we will not make implementing a suite using sha2 next to impossible (as it kinda is right now IMO).\r\n\r\nOf-course i could be convinced otherwise. Lets discuss this more!!\r\n\r\n(Also i do agree that each suite should be able to be used with only 1 hash and I do think it will be possible with the direction the spec is currently going)",
          "createdAt": "2022-06-01T22:38:12Z",
          "updatedAt": "2022-06-01T22:57:14Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It looks like there are two slightly odd cases, KeyGen and MapMessageToScalarAsHash, which are inheriting the suite's hash parameters but don't necessarily need to because they aren't directly involved in signature generation or verification. Favouring simplicity, though, I think it's fine to only define these in terms of the suite's hash parameters. In both cases alternatives can be used instead, so we are only providing a useful default implementation.",
          "createdAt": "2022-06-01T22:49:20Z",
          "updatedAt": "2022-06-01T22:49:20Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That's a great point! I haven't considered those cases. I do agree that those are just suggestions that cater the more \"simple\" use cases so it's fine to define everything based on 1 hash??\r\n\r\nAs a side note. I do start to believe that we overthinking this. Similar considerations could apply to [bls-signatures](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-bls-signature-04#section-2.9) (for the ''Aggregate\" scheme) however they just leave everything to the upper layer, and it makes for a readable spec (they don't even worry about PK and message correspondence and ordering in [AggregateVerify](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-bls-signature-04#section-2.9), which has been a big discussion here).\r\n\r\nPersonally i would leave `KeyGen` as it is with a note that it is optional but if used it must use whatever hash is defined by the suite. Same for `MapMessageToScalarAsHash`. As you [pointed out](https://github.com/decentralized-identity/bbs-signature/issues/162#issuecomment-1144134405), bbs+ will be wrapped to containers that will specify the message encoding. To avoid the perception that each message is hashed, we could move the `MapMessageToScalarAsHash` to the appendix, have a discussion around message encoding in the main part and only point to this operation as an example.",
          "createdAt": "2022-06-02T11:14:47Z",
          "updatedAt": "2022-06-03T09:05:52Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In any case i think we are mostly in agreement here?? Maybe we should start with the xof vs hash discussion on the next call, as i think it's the main issue holding back some progress. Deciding on a direction would be very helpful.\r\n\r\nJust to try and clarify the options:\r\n- **Option 1**: Define everything on the basis of an xof only. This means `hash_to_scalar`, `hash_to_curve` + `createGenerators` and `MapMessageToScalarAsHash`.\r\n    - Advantages: fewer and simpler operations i.e., no need for [hash_to_scalar_xmd](https://github.com/decentralized-identity/bbs-signature/pull/151) or a more complicated `createGenerators` procedure (like the proposals [here](https://github.com/decentralized-identity/bbs-signature/pull/161#discussion_r887355556))\r\n    - Disadvantages (-**IMO**-): making it hard to define a sha2 based suite, and as a result, to use certain libraries like [blst](https://github.com/supranational/blst) and [noble-bls12-381](https://github.com/paulmillr/noble-bls12-381).\r\n- **Option 2**: Add support for fixed-output-length hash functions.\r\n    - Advantages (-**IMO**-): Ability to easier use a wider range of bls-sigs targeted implementations. Ease of defining sha2 based suites, that can give rise to more use cases (like embedding systems or blockchain based ones).\r\n    - Disadvantages: (As described above) higher spec complexity + more time and effort required to add that support, at a time that we maybe should be focusing on other things.\r\n\r\nPlease let me know @andrewwhitehead if the above is not accurate or if i missed something. I'm also very keen to hear others opinion around this!",
          "createdAt": "2022-06-02T11:21:34Z",
          "updatedAt": "2022-06-06T12:41:01Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes I think that's a good summary, and we should definitely hash it out (lol) on the next call.",
          "createdAt": "2022-06-02T16:28:47Z",
          "updatedAt": "2022-06-02T16:28:47Z"
        },
        {
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "One drawback of the xof-only option is that the [hash to curve spec](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-14#appendix-J.10) only defines SHA256 test vectors for BLS. If we adopt the xof method, we'd need to specify these test vectors as well. The implementation point noted above is also important: the lack of library support for this option complicates the implementation. The level of expertise required to implement the low-level pairing primitives vs. the BBS app layer are vastly different; it blocked my own progress on my javascript ref implementation using the noble library.",
          "createdAt": "2022-06-06T12:11:32Z",
          "updatedAt": "2022-06-06T12:11:32Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@andrewwhitehead can we close this now after the merge of #177 and #151??",
          "createdAt": "2022-06-24T14:27:04Z",
          "updatedAt": "2022-06-24T14:27:04Z"
        }
      ]
    },
    {
      "number": 163,
      "id": "I_kwDOF8lax85K6AUg",
      "title": "Structured vs de-structured inputs",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/163",
      "state": "CLOSED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "ready-for-pr",
        "core"
      ],
      "body": "Lately the direction the document is going, is to pass inputs in a structured form (i.e., `octets_to_signature(signature)` vs `octets_to_signature(A, e, s)` etc.). Related to #138 and #155.\r\n\r\nOpening the issue so we can keep track of the update and make notation consistent across the spec.",
      "createdAt": "2022-06-01T18:28:10Z",
      "updatedAt": "2022-06-25T00:30:55Z",
      "closedAt": "2022-06-25T00:30:55Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Im comfortable with passing structured inputs as the convention, I think we should also denote the destructing syntax in the terminology section though e.g (a,b,c) = arg and what it means for clarity",
          "createdAt": "2022-06-02T22:14:01Z",
          "updatedAt": "2022-06-02T22:14:01Z"
        }
      ]
    },
    {
      "number": 164,
      "id": "I_kwDOF8lax85K96VR",
      "title": "Defintions of P1 and P2 in Ciphersuites",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/164",
      "state": "CLOSED",
      "author": "dev0x1",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "ready-for-pr",
        "core"
      ],
      "body": "Since any point on respective cyclic subgroup G1 and G2 can work as P1 and P2.\r\nFor interoperability, I think we should define the values of P1 and P2 in cipher suites. By clubbing this value in ciphersuite, an interoperable implementation has to refer only to cipher suite ID otherwise these have to be communicated on application-level messages or protocols.\r\n\r\nRegarding values for BLS12-381 ciphersuites, fixed base generators defined by pairing-crypto libraries zkcrypto(defined [here](https://github.com/zkcrypto/bls12_381/blob/34dab74ae44cd77dfa867928dd2e6c8383d8dc9d/src/g1.rs#L198) and [here](https://github.com/zkcrypto/bls12_381/blob/34dab74ae44cd77dfa867928dd2e6c8383d8dc9d/src/g2.rs#L212)) and blst(defined [here](https://github.com/supranational/blst/blob/bd8e64f97cb55217df1f7e84d4d73d6d8461e608/src/e1.c#L20) and [here](https://github.com/supranational/blst/blob/bd8e64f97cb55217df1f7e84d4d73d6d8461e608/src/e2.c#L24)) can be used. Both these libraries use same value for fixed base generators.",
      "createdAt": "2022-06-02T06:27:35Z",
      "updatedAt": "2022-10-17T18:50:49Z",
      "closedAt": "2022-10-17T18:50:49Z",
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for raising! This will be very useful to track the issue! I think the (unfortunately **implicit**) assumption is that P1 and P2 will be the base points from the [pairing-friendly curves](https://www.ietf.org/archive/id/draft-irtf-cfrg-pairing-friendly-curves-10.html) spec (that are also used by the libs listed). There are some discussions to maybe use different points though (see #37).\r\n\r\nAnother option could be to go the [bls-signatures](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-bls-signature-04#appendix-A) route and (re-)define the \"curve suite\" in an appendix (really just a mapping between terms). If we decide then to use different base points the update will be very easy.",
          "createdAt": "2022-06-02T11:34:26Z",
          "updatedAt": "2022-06-02T11:35:14Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed on 8th August WG call, we need to explicitly call out P1 and P2 in the cipher suite to resolve this ambiguity.",
          "createdAt": "2022-08-08T18:20:57Z",
          "updatedAt": "2022-08-08T18:20:57Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Options discussed are \r\n\r\n1. Document P1 and P2 as the base points on the underlying curve\r\n2. Document P2 as the base point on the underlying curve and select a single new global (per-curve) value for P1 to preserve the usage of the base point in G1 for private holder binding\r\n3. Use the create generator procedure to output Q1 as P1",
          "createdAt": "2022-08-08T18:32:49Z",
          "updatedAt": "2022-08-08T18:32:49Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Will be resolved by #215",
          "createdAt": "2022-09-19T18:48:25Z",
          "updatedAt": "2022-09-19T18:48:25Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed on WG call 17th of October, closing with merge of #215 ",
          "createdAt": "2022-10-17T18:50:49Z",
          "updatedAt": "2022-10-17T18:50:49Z"
        }
      ]
    },
    {
      "number": 166,
      "id": "I_kwDOF8lax85LMSkE",
      "title": "Uncompressed points data in hash_to_scalar input",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/166",
      "state": "CLOSED",
      "author": "dev0x1",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "`hash_to_scalar` in different procedures accepts concatenation of G1 Points(`PK`, `A_bar`, `A_prime` or `D`) to be given as input. For Bls12-381 based cipher suites, the `point_to_octets_in_g1` method refers Zcash-serialization method as defined [here](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-10#appendix-C), which specifies points can have compressed and uncompressed form of representation. For network transmission and storage, a compressed form is desired but was wondering for input to the hash function, if providing extra data from the uncompressed points can give more randomness and beneficial in this case in any way.\r\n\r\n",
      "createdAt": "2022-06-06T08:20:10Z",
      "updatedAt": "2022-06-08T19:51:13Z",
      "closedAt": "2022-06-08T19:51:13Z",
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That would be definitely nice. Thank you for the suggestion!\r\n\r\nI'm not 100% convinced that the raised complexity will be worth it though. the additional data passed into the hash will be deterministically defined by what is already inputted (the compressed version). So they will not help with brute force attacks etc., or provide much more entropy.",
          "createdAt": "2022-06-06T19:12:54Z",
          "updatedAt": "2022-06-06T19:12:54Z"
        },
        {
          "author": "dev0x1",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for your feedback. I had an impression that while encoding for the compressed form there would be few deterministic metadata bits that will be absent in uncompressed form but this is not the case. Now I get that to keep things simple, using only compressed representation works very well.",
          "createdAt": "2022-06-07T17:51:25Z",
          "updatedAt": "2022-06-07T17:51:25Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Great! Closing the issue since we reached a consensus! (@dev0x1 please re-open if that's not accurate or you feel there's more to discuss)",
          "createdAt": "2022-06-08T19:51:13Z",
          "updatedAt": "2022-06-08T19:51:13Z"
        }
      ]
    },
    {
      "number": 168,
      "id": "I_kwDOF8lax85LlK_d",
      "title": "Explicitly give the number of bytes for the PRF function",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/168",
      "state": "CLOSED",
      "author": "christianpaquin",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "ready-for-pr",
        "core"
      ],
      "body": "The PRF function in `ProofGen` takes the value `8*ceil(log2(r))`. It would be helpful to explicitly define its value for the BLS12-381 ciphersuite to avoid guess work. I assume the value is 256.",
      "createdAt": "2022-06-10T21:20:58Z",
      "updatedAt": "2022-06-25T00:30:56Z",
      "closedAt": "2022-06-25T00:30:56Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Suggestion discussed on WG call is to generalize the `xof_no_of_bytes` parameter for this purpose and parameterize it in the proof gen procedure.",
          "createdAt": "2022-06-13T18:59:07Z",
          "updatedAt": "2022-06-13T18:59:07Z"
        }
      ]
    },
    {
      "number": 171,
      "id": "I_kwDOF8lax85LsOUj",
      "title": "s value is undefined in ProofGen",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/171",
      "state": "CLOSED",
      "author": "christianpaquin",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In (currently) step 11 of ProofGen:\r\n```\r\nB = P1 + H_s * s + H_d * domain + H_1 * msg_1 + ... + H_L * msg_L\r\n```\r\nThe scalar `s` is undefined. Is it supposed to be `s~` generated in step 9?",
      "createdAt": "2022-06-13T19:52:42Z",
      "updatedAt": "2022-06-13T20:22:11Z",
      "closedAt": "2022-06-13T20:22:11Z",
      "comments": [
        {
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ah, that's the `s` from the signature; missed that.",
          "createdAt": "2022-06-13T20:22:11Z",
          "updatedAt": "2022-06-13T20:22:11Z"
        }
      ]
    },
    {
      "number": 172,
      "id": "I_kwDOF8lax85LtfFa",
      "title": "Amend the introduction to attribute the BBS name to the underlying authors",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/172",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "ready-for-pr",
        "core"
      ],
      "body": "Dan Boneh, Xavier Boyen and Hovav Shacham are the original authors of the academic works that the name derives from hence should be appropriately attributed within the spec.",
      "createdAt": "2022-06-14T03:59:00Z",
      "updatedAt": "2022-06-21T22:04:03Z",
      "closedAt": "2022-06-21T22:04:03Z",
      "comments": []
    },
    {
      "number": 173,
      "id": "I_kwDOF8lax85LxUZ9",
      "title": "Consistent ordering of Abar and A'",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/173",
      "state": "CLOSED",
      "author": "dev0x1",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "ready-for-pr",
        "core"
      ],
      "body": "It would be nice to have the same ordering of **Abar** and **A'** in proof serialization/deserialization and during concatenated input to `hash_to_scalar`.\r\nin `ProofGen`,\r\n`19. c = hash_to_scalar((PK || Abar || A' || D || C1 || C2 || ph), 1)`\r\n\r\n`25. proof = (A', Abar, D, c, e^, r2^, r3^, s^, (m^_j1, ..., m^_jU))`\r\n\r\nin `ProofVerify`,\r\n\r\n`4. (A', Abar, D, c, e^, r2^, r3^, s^, (m^_j1,...,m^_jU)) = proof`\r\n\r\n`10. cv = hash_to_scalar((PK || Abar || A' || D || C1 || C2 || ph), 1)`",
      "createdAt": "2022-06-14T18:39:20Z",
      "updatedAt": "2022-06-21T20:59:19Z",
      "closedAt": "2022-06-21T20:59:19Z",
      "comments": []
    },
    {
      "number": 176,
      "id": "I_kwDOF8lax85L3NOF",
      "title": "Specify W in ProofVerify",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/176",
      "state": "CLOSED",
      "author": "christianpaquin",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "ready-for-pr",
        "core"
      ],
      "body": "Step 15 of ProofVerify is:\r\n```\r\n15. if e(A', W) * e(Abar, -P2) != 1, return INVALID\r\n```\r\n\r\n`W` is unspecified in the function; I assume it's the public key point, like in the other functions. If so, we need to add\r\n```\r\nW = octets_to_point_g2(PK)\r\n```\r\n",
      "createdAt": "2022-06-15T21:22:54Z",
      "updatedAt": "2022-06-21T21:18:32Z",
      "closedAt": "2022-06-21T21:18:32Z",
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for raising! This is addressed in PR #165 (with a little bit of a different approach). This is good to keep track of the issue.",
          "createdAt": "2022-06-16T02:30:15Z",
          "updatedAt": "2022-06-16T02:30:15Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Addressed from #165. Closing.",
          "createdAt": "2022-06-21T21:18:32Z",
          "updatedAt": "2022-06-21T21:18:32Z"
        }
      ]
    },
    {
      "number": 178,
      "id": "I_kwDOF8lax85MJQpu",
      "title": "Align language consistency disclose vs reveal",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/178",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "ready-for-pr",
        "core"
      ],
      "body": "We use both the term disclosed messages and revealed messages throughout the draft, considering we offer in the introduction that selective disclosure is one of the key properties enabled by the scheme I suggest we change all usages of the term reveal to disclose in the context of messages.",
      "createdAt": "2022-06-20T23:32:10Z",
      "updatedAt": "2022-06-25T00:33:32Z",
      "closedAt": "2022-06-25T00:33:32Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Somewhat blocked by a resolution to #138 as this makes some modifications to the API.",
          "createdAt": "2022-06-21T21:14:02Z",
          "updatedAt": "2022-06-21T21:14:02Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Closed with merging of #183 ",
          "createdAt": "2022-06-25T00:33:31Z",
          "updatedAt": "2022-06-25T00:33:31Z"
        }
      ]
    },
    {
      "number": 179,
      "id": "I_kwDOF8lax85MJRcJ",
      "title": "Handling subgroup checks",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/179",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "ready-for-pr",
        "pending-close",
        "core"
      ],
      "body": "Currently in the draft there are several key places we need to do subgroup checks on points, for example to validate a public key post de-serialization. However in some places we are implicitly relying on the `octet_to_point` function to perform this role and other places we are doing it as an explicit step in the procedure. We need to make this consistent, the options are\r\n\r\n1) Consistently rely on the `octet_to_point_g*` implementation and add a security consideration that documents this function MUST perform the relevant subgroup check.\r\n2) Explicitly document anywhere in the procedure where a subgroup check is required.\r\n\r\nIMO 2 feels like a safer but more verbose option to me.",
      "createdAt": "2022-06-20T23:36:55Z",
      "updatedAt": "2022-09-19T18:46:53Z",
      "closedAt": "2022-09-19T18:46:53Z",
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Maybe a middle-of-the-road solution would be to define explicitly `octets_to_point` as an operation in the spec, that calls `octets_to_point_g1` and does the checks. For example, something like:\r\n```\r\nresult = octets_to_point_g1(point_octets)\r\n\r\nInputs:\r\n- point_octets, octet string\r\n\r\nParameters:\r\n- SubgroupCheck_g1, a function that on input a point P, returns VALID if P \r\n                    is in the G1 subgroup and INVALID in any other case.\r\n\r\nProcedure:\r\n\r\n1. P = octets_to_point_g1(point_octets)\r\n\r\n2. if P is INVALID, return INVALID\r\n\r\n3. if SubgroupCheck_g1(P) is INVALID, return INVALID\r\n\r\n4. if P = Identity_G1, return INVALID\r\n\r\n5. return P \r\n```\r\n\r\nNote: the identity check is not always necessary above, but it can be nice to have.",
          "createdAt": "2022-06-21T18:20:14Z",
          "updatedAt": "2022-06-21T18:20:14Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Labeling as pending close ahead of WG call on the 4th of july",
          "createdAt": "2022-07-04T00:57:49Z",
          "updatedAt": "2022-07-04T00:57:49Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed on WG 8th August, there is potentially some inconsistencies that we need to address before we can close this issue",
          "createdAt": "2022-08-08T18:15:20Z",
          "updatedAt": "2022-08-08T18:15:20Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed on WG call 20th of September, we believe the major inconsistencies around this check are resolved, closing for now and will re-open if some where missed.",
          "createdAt": "2022-09-19T18:46:53Z",
          "updatedAt": "2022-09-19T18:46:53Z"
        }
      ]
    },
    {
      "number": 180,
      "id": "I_kwDOF8lax85MJRuJ",
      "title": "Add an acknowledgements section",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/180",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "ready-for-pr",
        "core"
      ],
      "body": "As captured in the issue title",
      "createdAt": "2022-06-20T23:38:39Z",
      "updatedAt": "2022-06-27T20:41:56Z",
      "closedAt": "2022-06-27T20:41:56Z",
      "comments": []
    },
    {
      "number": 185,
      "id": "I_kwDOF8lax85MedfE",
      "title": "Elements to be hashed update",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/185",
      "state": "CLOSED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "ready-for-pr",
        "core"
      ],
      "body": "The current [Encoding of Elements to be Hashed](https://identity.foundation/bbs-signature/draft-bbs-signatures.html#name-encoding-of-elements-to-be-) section needs to be updated. The reason is that elements before they are hashed, they are concatenated with other elements in multiple steps. As @andrewwhitehead noted This is not clearly captured by the section yet.\r\n\r\nSome options: \r\n1. Define a helper `encode_for_hash` function (see @andrewwhitehead's comment [here](https://github.com/decentralized-identity/bbs-signature/pull/183#discussion_r905553694))\r\n2. Say something like `Each time elements are concatenated together, they must first be turned to octet strings. Every time an element other than a scalar, a point or a non-negative integer is transformed to an octet string, the length of the resulting octet string must be appended to itself.`\r\n",
      "createdAt": "2022-06-23T23:02:57Z",
      "updatedAt": "2022-07-04T18:15:59Z",
      "closedAt": "2022-07-04T18:15:59Z",
      "comments": [
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "To clarify I think we would change that particular line to something like `domain_prime = encode_for_hash(PK, L, gen_octets, Ciphersuite_ID, header)` - although I'm not sure how we want to handle variadic arguments syntactically.",
          "createdAt": "2022-06-23T23:29:31Z",
          "updatedAt": "2022-06-23T23:29:31Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm fine with this approach as well. We may not need to handle variadic arguments. We just need to make sure everything is < 72 chars. For example, something like,\r\n```\r\n7. d_prime = (PK, L, H_s, H_d, H_1, .., H_L, Ciphersuite_ID, header)\r\n\r\n8. domain = hash_to_scalar(encode_for_hash(d_prime), 1)\r\n```\r\nwould work just fine IMO (everything is < 72 chars above). Similar for the challenge hash etc. Then `encode_for_hash` will take a single argument (like `encode_for_hash(input)`) and the procedure will just loop through the elements of that argument (like `for el in input: ...`)\r\n\r\nSomething to note is that the `encode_for_hash` function cannot be 100% explicit. We will have to say something like `if el is a G1 point` and `if el is an octet string` etc. Personally I\u2019m 100% fine with that.",
          "createdAt": "2022-06-24T14:59:45Z",
          "updatedAt": "2022-06-24T15:02:52Z"
        }
      ]
    },
    {
      "number": 194,
      "id": "I_kwDOF8lax85NFoRb",
      "title": "expand_message domain separation",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/194",
      "state": "CLOSED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "ready-for-pr",
        "core"
      ],
      "body": "The current hash_to_scalar construction does not allow for the calling operation to define the DST that will go into the underlying expand_message used. Some operations that need additional domain separation append the DST to the message.\r\n\r\nThe problem is that we cannot prove indistinguishably that way. For example consider the following, lets assume that in a protocol we call hash_to_scalar in the input `msg ||  I2OSP(length(DST2), 1) || DST2` and get `b_1, b_2, ...` where,\r\n\r\n```\r\nb_0 = H(Z_pad || msg ||  I2OSP(length(DST2), 1) || DST2 || I2OSP(len_in_bytes, 2) || I2OSP(0, 1) || DST_prime)\r\nb_1 = H(b_0 || ...)\r\nb_2 = ....\r\n```\r\nThen, in some other place, the protocol returns `h2 = H(Z_pad || msg || I2OSP(length(DST2), 1) || DST2)`. In that case, after observing `h2` I could do a length-extension attack on H, calculate `b_0` and then `b_1`, `b_2` etc. This is not really a practical issue (it becomes less practical -but not impossible- if we also consider padding), but it does stop us from proving security. It also becomes a larger issue if people use a different expand_message (if they just use sha512 with a counter for example).\r\n\r\n## Proposed Solutions\r\n### Solution A\r\nThe currently proposed solution, discussed in the WG call, would be to define an additional optional argument to hash_to_scalar like `dstInfo` and append that to the DST already defined. i.e., inside hash_to_scalar calculate,\r\n```\r\n4. dst_prime = DST || dstInfo || I2OSP(length(dstInfo), 1)\r\n5. expand_message(msg, dst_prime, len_in_bytes)\r\n```\r\nThis is a bit weird because we are prepending the length everywhere else in the spec. However, if we do the same here and calculate `dst_prime = DST || I2SOP(length(dstIfo), 1) || dstInfo` then for example the pairs `DST1 = [4, 2]`, `dstInfo1 = [2]` and `DST2 = [4]`, `dstInfo2 = [1, 2]` will give the same `dst_prime`. \r\n\r\nSimilarly, we can't just concatenate the 2 (i.e., `dst_prime = DST || dstInfo`) because then for example the pairs `DST1 = [1, 2]`, `dstInfo1 = [3]` and `DST2 = [1]`, `dstInfo2 = [2, 3]` will again give the same `dst_prime`\r\n\r\n### Solution B\r\nDon't define the DST in hash_to_scalar but require it as an input. So whatever operation calls hash_to_scalar will also need to specify a DST value to pass it. This is probably the most efficient approach when it comes to a straight line implementation, but IMO the \"ugliest\" looking when it comes to the spec.",
      "createdAt": "2022-07-04T15:35:54Z",
      "updatedAt": "2022-08-31T02:25:38Z",
      "closedAt": "2022-08-31T02:25:38Z",
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Also, @andrewwhitehead pointed out that the only place that this method of domain separation (i.e., appending the dst to the msg) is currently used, is in [MapMessageToScalarAsHash](https://identity.foundation/bbs-signature/draft-bbs-signatures.html#name-mapmessagetoscalarashash). That said, it will be a useful thing to resolve in general (see for example PR #186).\r\n\r\nAlso for completeness, another solution (that I'm not a huge fan of) is the following:\r\n### Solution C\r\nAppend the length of both the DST and the dstInfo to create dst_prime, i.e., inside hash_to_scalar do, \r\n```\r\n4. dst_prime = I2OSP(length(DST), 1) || DST  || I2OSP(length(dstInfo), 1) || dstInfo\r\n5. expand_message(msg, dst_prime, len_in_bytes)\r\n```\r\nThis is more consistent with the rest of the spec but it is a bit wasteful since, if `dstInfo` is not supplied, we will be prepending the `DST` with its length twice (once outside and once inside `expand_message`).",
          "createdAt": "2022-07-04T15:48:54Z",
          "updatedAt": "2022-07-04T15:48:54Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think a third option is just to add an optional `dst` parameter to `hash_to_scalar`, defaulting to (something like) `BBS_ || ciphersuite_id || HASH_TO_SCALAR`. Then `MapMessageToScalarAsHash` is just `hash_to_scalar` with a DST like `BBS_ || ciphersuite_id || MESSAGE`, and KeyGen could use another DST (with key_info added). Existing uses of `hash_to_scalar` wouldn't need to be updated.",
          "createdAt": "2022-07-04T19:19:19Z",
          "updatedAt": "2022-07-04T19:19:19Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That may be the best solution. I'm not 100% clear as to how a calling operation like MapMessageToScalarAsHash will define the dst for hash_to_scalar?? Will hash_to_scalar be a parameter for that operation and define the dst there?? i.e., something like,\r\n```\r\nresult = MapMessageToScalarAsHash(msg)\r\n\r\nParameters:\r\n\r\n- hash_to_scalar, the hash_to_scalar operation defined in (#hash-to-scalar) with the dst parameter set\r\n                  to \"BBS_ || ciphersuite_id || MESSAGE\"\r\n```\r\nMaybe an easiest option will be to define the dst in hash_to_scalar as an optional input that defaults to `BBS_ || ciphersuite_id || HASH_TO_SCALAR` rather than an optional parameter that does the same?? Or is this more error prone??",
          "createdAt": "2022-07-04T21:52:02Z",
          "updatedAt": "2022-07-04T21:52:02Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "^ Yes, I meant input, not parameter.",
          "createdAt": "2022-07-04T21:53:18Z",
          "updatedAt": "2022-07-04T21:53:18Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Cool! Yea this maybe the best thing to do. I think it is a little more prone to error but that is why we have test vectors. Will give it a shot!",
          "createdAt": "2022-07-04T22:08:09Z",
          "updatedAt": "2022-07-04T22:08:09Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed on WG call on 15th August, issue is ready for PR with consensus to move forward with the approach described by @andrewwhitehead ",
          "createdAt": "2022-08-15T18:40:15Z",
          "updatedAt": "2022-08-15T18:40:15Z"
        }
      ]
    },
    {
      "number": 196,
      "id": "I_kwDOF8lax85NGNBx",
      "title": "Update security considerations",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/196",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "core"
      ],
      "body": "There are multiple security considerations that are now out of date in the specification that should be updated.",
      "createdAt": "2022-07-04T18:28:31Z",
      "updatedAt": "2022-07-04T18:58:13Z",
      "closedAt": "2022-07-04T18:58:13Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Closing as it is a duplicate #111 ",
          "createdAt": "2022-07-04T18:58:13Z",
          "updatedAt": "2022-07-04T18:58:13Z"
        }
      ]
    },
    {
      "number": 204,
      "id": "I_kwDOF8lax85Pazxi",
      "title": "Support for HSMs",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/204",
      "state": "OPEN",
      "author": "andrewwhitehead",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I'm just opening this issue for discussion of whether the current algorithms preclude support for signing by an HSM (hardware security module) or other types of key vaults.\r\n\r\nSome questions that come to mind:\r\n- Is it reasonable to assume that the HSM will compute (or ship with) the required generator points, or would they need to be submitted by the caller?\r\n- Would there need to be a limit on the number of signed messages?\r\n- Should the messages be submitted as scalars in order to support different message encodings?\r\n- Do specific ciphersuites need to be explicitly supported (and perhaps included in the key metadata to prevent reuse across ciphersuites)?\r\n- What would support for blind signing look like?\r\n\r\nAnd in general, are there examples of multi-message signing APIs for comparison?",
      "createdAt": "2022-08-08T21:38:49Z",
      "updatedAt": "2022-08-10T15:09:27Z",
      "closedAt": null,
      "comments": [
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The problem with HSMs is you can only multiply a point by the secret value and they only return the X coordinate which means you have to figure out which Y coordinate to use otherwise it breaks. Until they support returning the full point I\u2019m not sure how the HSM can help. Software enclaves can do much better so perhaps that should be the focus first",
          "createdAt": "2022-08-10T14:52:16Z",
          "updatedAt": "2022-08-10T14:52:16Z"
        }
      ]
    },
    {
      "number": 206,
      "id": "I_kwDOF8lax85QCxsT",
      "title": "create_generators flexibility",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/206",
      "state": "CLOSED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "BasileiosKal"
      ],
      "labels": [
        "ready-for-pr",
        "core"
      ],
      "body": "Currently we allow seeds with different scopes but it is not clear how a signature specific seed is going to be used since it is passed as a parameter to `create_generators` and not as input. Also i think this is a case that we want to reduce optionality (for example we don't want `generator_seed = hash(all_messages)`).\r\n\r\nI think it's best to not allow \"scoped seeds\" but different `create_generators` operations. Each create_generators will accept a `seed` and a `dst` as a parameter and a `count` as input. If one wants signature specific generators they can use the `count` input but nothing else. This will be enough for \"legacy support\". \r\n\r\nThis also makes it easier to describe the requirements of the `create_generators` operations (rather than the requirements for the seed selection).\r\n\r\nIMO there are 2 options:\r\n1. Don't allow different `create_generators` or `scoped_seeds`: No changes are needed, expect to remove the text around \"scoped seeds\".\r\n2. Allow different `create_generators`: In this case IMO we should:\r\n    - Add a `create_generators_operation` parameter in the ciphersuites definition.\r\n    - For the suites defined in the document give the `create_generators_operation` parameter the value of \"`create_generators` with `generator_seed=...`\".\r\n    - Require every create_generators operation to also define a unique ID which will be added to the ciphersuite_id (like EXP_TAG for expand_message in [h2c](https://www.ietf.org/archive/id/draft-irtf-cfrg-hash-to-curve-16.html#name-suite-id-naming-conventions)).\r\n    - Add `create_generators_operation` as a parameter to Sign, Verify etc..\r\n    - Add the requirements for defining a new `create_generators_operation`.\r\n\r\nObviously 1 is the simplest but the least flexible. It also is a \"breaking change\" with previous versions. So my preference will be 2 but I'm also very interested in others thoughts on the matter.",
      "createdAt": "2022-08-18T10:35:22Z",
      "updatedAt": "2023-06-26T18:17:56Z",
      "closedAt": "2023-06-26T18:17:55Z",
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on the WG call of the 22nd of August. Will open a PR with the proposed updates.",
          "createdAt": "2022-08-22T18:59:01Z",
          "updatedAt": "2022-08-22T19:16:14Z"
        }
      ]
    },
    {
      "number": 207,
      "id": "I_kwDOF8lax85QEyxz",
      "title": "ascii and utf8",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/207",
      "state": "CLOSED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "BasileiosKal"
      ],
      "labels": [
        "ready-for-pr",
        "core"
      ],
      "body": "I don't think we are consistent about this. For example we define utf8 as accepting only ascii strings and we don't handle non ascii strings in `encode_for_hash`, even though we have an utf8 encoding. Also, I think \"ASCII character sequence\" is what we meant as \"ascii string\" but is not everywhere clear. \r\n\r\nNot sure what is best here. Should we assume that all the messages are already an octet string (and just mention some ways for transforming a char sequence to octets)?? So the only think that is left is DST's that we can encode with utf8??\r\n\r\nI think this is what most crypto specs do, so i would go with that.",
      "createdAt": "2022-08-18T18:05:33Z",
      "updatedAt": "2022-10-11T21:21:16Z",
      "closedAt": "2022-10-11T21:21:16Z",
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on the WG call of 22nd of August. Will open PR in the described direction + handling Unicode in `encode_for_hash`.",
          "createdAt": "2022-08-22T18:50:55Z",
          "updatedAt": "2022-08-22T19:15:37Z"
        }
      ]
    },
    {
      "number": 212,
      "id": "I_kwDOF8lax85QJZUR",
      "title": "Number of messages upper limmit",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/212",
      "state": "CLOSED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "ready-for-pr",
        "core"
      ],
      "body": "Through the use of `expand_message` we put an upper limit to the number of signed messages.\r\n\r\n`expand_message` aborts if `len_in_bytes` is larger than `2^16 - 1 = 65535`. In our case `len_in_bytes = count * expand_len`. The `count` can be (at most) equal to the number of signed messages (during ProofGen, if we decide to hide all messages). In the current ciphersuite `expand_len = 48`. As a result, the `count` can be at most 1365 which means that the total number of signed messages can also be at most 1365 (or at least a prover cannot choose to not disclose more than 1365 messages).\r\n\r\nThat's quite unfortunate IMO, since the 1365 messages limit seems quite small to me!\r\n\r\n### How to solve this??\r\n\r\nNot sure what the best solution is. The root of the problem is step 9 in [ProofGen](https://identity.foundation/bbs-signature/draft-looker-cfrg-bbs-signatures.html#name-proofgen), i.e., the step:\r\n```\r\n9. (m~_j1, ..., m~_jU) = hash_to_scalar(PRF(prf_len), U)\r\n```\r\nsince U cannot be more than 1365. Should we call `hash_to_scalar` in a loop with multiple calls to the PRF or extent the output length of the PRF to get more seeds if we need more than 1365 scalars?? Or should we define expand_message alternatives with higher output limits (2^32 would be nice, however this would create more implementation barriers comparatively)??",
      "createdAt": "2022-08-19T16:13:53Z",
      "updatedAt": "2022-12-12T19:14:02Z",
      "closedAt": "2022-12-12T19:14:02Z",
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on the WG call of the 22nd of August. One proposed option by @andrewwhitehead is to use the PRF as an input to `proofGen` and iterate through it in a loop to create the different scalars. For testing we can then supply a deterministic PRF (like seeded ChaCha), instead of a seed. Will document the different options and revisit.",
          "createdAt": "2022-08-22T18:43:59Z",
          "updatedAt": "2022-08-22T19:14:04Z"
        },
        {
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As we discussed on the call today, perhaps good to measure the perf difference in practice after prototyping both approaches. ",
          "createdAt": "2022-09-19T18:36:00Z",
          "updatedAt": "2022-09-19T18:36:00Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "To track the conversation here, the currently discussed proposals are,\r\n1. Call PRF in a loop, no hashes.\r\n2. Call `expand_message` in a loop and the PRF once.\r\n3. Call both `expand_message` and the PRF in a loop.\r\n\r\nThe tradeoff (naturally) is between efficiency and simplicity. We also have to consider how testable  [ProofGen](https://identity.foundation/bbs-signature/draft-irtf-cfrg-bbs-signatures.html#name-proofgen) will be.\r\n\r\nBellow the updated proposals for the new messages upper limit are described in detail + their theoretical performance.\r\n\r\n**Note**: When it comes to security, none of them is constant time. However, side chanel attacks will have minimum impact since the number of loops is `O(U)`, where `U` is revealed in each proof.\r\n\r\n## A. PRF in a loop\r\nThe simplest solution, avoiding any hash operation, getting 48 bytes out of the PRF and reducing mod the group order.\r\n```\r\n// U: number of undisclosed messages\r\n// prf_out_len = ceil(log2(r)/8)\r\n1. for i in (1, ..., U):\r\n2.     m~_i = OS2IP(PRF(prf_out_len)) mod r\r\n```\r\n\r\n## B. `expand_message` in a loop\r\nThis solution [proposed by  Riad Wahby](https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/349) (who I thank again!!), uses `expand_message` in a loop with different DST's to guarantee independence. The proposal in the context of our spec is the following,\r\n\r\n```\r\nresult = get_random_bytes(msg, len_in_bytes, dst)\r\n\r\nProcedure:\r\n1.  dst_next = I2OSP(0, 4) || dst\r\n2.  random_bytes = \"\"\r\n\r\n//  Get some random bytes\r\n3.  numexp = floor(len_in_bytes / 7910)\r\n4.  if numexp >= 2^32, ABORT\r\n5.  for j in (1, ..., numexp):   // assumming that if numexp = 0 the loop will not run\r\n6.     tmp = expand_message(msg, dst_next, 8160)\r\n7.     random_bytes = random_bytes || tmp[0..7910]\r\n8.     dst_next = I2OSP(j, 4) || tmp[7910..8160]\r\n\r\n//  Get remaining random bytes (dst_next here MUST be the last one computed in the loop)\r\n9.  tmp = expand_message(msg, dst_next, (len_in_bytes mod 7910))\r\n10. random_bytes = random_bytes || tmp\r\n\r\n11. return random_bytes[0..len_in_bytes]\r\n```\r\nThe above will be used by `hash_to_scalar` to get all the bytes necessary.\r\n\r\n\r\n## C. `expand_message` and PRF in a loop\r\nA combination of the above, using `hash_to_scalar` as a black box, for a \"middle of the road\" solution,\r\n\r\n```\r\nrand_scalars = get_random_scalars(PRF, count, dst)\r\n\r\nProcedure:\r\n1. scalars = []\r\n2. max_count = floor(8160/expand_len)   // 170 for our ciphersuites\r\n3. ell = floor(count/max_count)\r\n4. for i in (1, ..., ell):\r\n5.     rand_scalars = hash_to_scalar(PRF(prf_out_len), max_count, dst)\r\n6.     scalars.push(rand_scalars) // push all elements from rand_scalars to the scalars list \r\n\r\n// Get the remaining random scalars\r\n7. rand_scalars = hash_to_scalar(PRF(prf_out_len), count mod max_count, dst)\r\n8. return scalars.push(rand_scalars)\r\n```\r\n\r\nThen in the ProofGen we can just call\r\n```\r\n8. (1, r2, e~, r2~, r3~, s~, m~_1, ..., m~_U) = get_random_scalars(PRF, 6+U)\r\n```\r\n\r\n##\r\nFor performance I'm using hash function and PRF calls as an indicator. The shown performance is for the \"worst case\" where we using `BLS12381-SHA256` ciphersuit, i.e., `expand_message_xmd` with SHA-256.\r\n- Let `U` be the number of undisclosed messages. Let also for simplicity `U > 170`.\r\n- Let `ell = ceil(U * expand_len / hash_out_len) + 1` the number of hash invocations in `expand_message_xmd`\r\n\r\nNote: The actual formulas for B and C are:\r\n- for A: 0 hash calls\r\n- for B: Hash calls: `floor(U*48/8160) * 256 + ceil((U*48 mod 8160)/32) + 2`\r\n- for C: Hash calls:  `floor(U/170) * 256 + ceil(1.5 * (U mod 170)) + 2`\r\n",
          "createdAt": "2022-11-27T17:21:52Z",
          "updatedAt": "2022-11-28T22:33:20Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "# UPDATES: \r\n1. turns out the limit is lower than expected, i.e., 170 scalars instead of 1365. The reason is that it must hold `(count * expand_len) / h_out < 250` where `h_out` the output len of the hash in bytes (i.e., 32 for sha256). Find the updated operations bellow.\r\n2. Find prototypes and benchmarks [>>> here](https://github.com/BasileiosKal/bbs-issue-212).\r\n3. Some benchmarking results are shown bellow. Find the complete report attached.\r\n\r\n## Performance: \r\n| Option                              | U = 100    | U = 2000  | U = 4000  |\r\n| ----------------------------------- | ---------- | --------- | --------- |\r\n| A. PRF in a loop, no hashes         | 13.632 \u03bcs  | 270.03 \u03bcs | 562.10 \u03bcs |\r\n| B. expand_message in a loop         | 90.851 \u03bcs  | 6.0476 ms | 11.581 ms |\r\n| C. expand_message and PRF in a loop | 87.211 \u00b5s  | 1.8040 ms | 3.3749 ms |\r\n\r\nFrom the above, IMO option A. (i.e., circumvent expand_message all together) seems like the better approach if we can also add a note for avoiding entropy attacks (like using a deterministic PRF with a random seed maybe)??\r\n[benchmarks.zip](https://github.com/decentralized-identity/bbs-signature/files/10105646/benchmarks.zip)",
          "createdAt": "2022-11-27T20:06:09Z",
          "updatedAt": "2022-11-28T22:33:50Z"
        }
      ]
    },
    {
      "number": 217,
      "id": "I_kwDOF8lax85TYYTt",
      "title": "P1 calculation in tooling code",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/217",
      "state": "CLOSED",
      "author": "dev0x1",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "As per spec, P1 is calculated using `create_generators` with a specific `generator_seed`. `create_generators` procedure as described [here](https://identity.foundation/bbs-signature/draft-looker-cfrg-bbs-signatures.html#name-generator-point-computation) starts calculation with `n=1` but below reference reference code in `tooling`  to calculate P1 uses `n=0`. \r\nhttps://github.com/decentralized-identity/bbs-signature/blob/3e69a8b16fd7788993e9d3a8849f311ade47fc5e/tooling/message-generators/src/main.rs#L193\r\nI think the code should be updated as below and then the new values of `P1` also need to be updated in the cipher suites constants section.\r\n```rust \r\nlet extra = 1usize.to_be_bytes()[4..].to_vec();\r\n```\r\n\r\n\r\n",
      "createdAt": "2022-10-06T06:26:33Z",
      "updatedAt": "2022-10-23T20:01:24Z",
      "closedAt": "2022-10-23T20:01:24Z",
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for pointing this out! Addressed in #221.",
          "createdAt": "2022-10-08T23:16:14Z",
          "updatedAt": "2022-10-08T23:16:14Z"
        },
        {
          "author": "tmarkovski",
          "authorAssociation": "MEMBER",
          "body": "Actually, `usize` has variable length on different architectures, so using `u64` is a better option.",
          "createdAt": "2022-10-19T00:22:39Z",
          "updatedAt": "2022-10-19T00:22:39Z"
        }
      ]
    },
    {
      "number": 218,
      "id": "I_kwDOF8lax85Tapch",
      "title": "Preferred method of generating random points",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/218",
      "state": "CLOSED",
      "author": "mikelodder7",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "pending-close"
      ],
      "body": "After inspection of the code, I found some [examples](https://github.com/decentralized-identity/bbs-signature/blob/3e69a8b16fd7788993e9d3a8849f311ade47fc5e/tooling/message-generators/src/main.rs#L117)  where a random scalar is chosen then multiplied by a point. While not inherently insecure, there is the potential side channel attack which allows an attacker to learn the discrete log of the random point.\r\n\r\nGoing forward I propose our new preferred method for creating random points is to draw random bytes and then use hash to curve. The reasoning is even if an attacker learns the random bytes they still do not learn the discrete log of the point and secondly, if the random data is manipulated or has a specific structure, the hashing effectively destroys this.",
      "createdAt": "2022-10-06T12:14:13Z",
      "updatedAt": "2023-06-12T18:40:00Z",
      "closedAt": "2023-06-12T18:40:00Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "It appears that most of this commentary is related to the example implementation in the tooling section of this repository which isn't meant to be a reference implementation?",
          "createdAt": "2022-12-05T19:23:30Z",
          "updatedAt": "2022-12-05T19:23:30Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If I understand this proposal correctly, the only place this could be applicable is when multiplying `s` with `Q_1`. In any other case, the logarithmic format of the operation matters (e.g., we could not replace `A * r1` with `hash_to_curve(r1)`). Since we also plan to remove `s` entirely eitherway not sure how useful this approach would be.\r\n\r\nAlso i don't 100% following the reasoning. The random data is what we try to protect. If an attacker learns them it will not matter that they will not learn the dl of the point. As for the hashing operation destroying structure in the random data, one could just hash the random bytes before multiplying (+ the moding operation should destroy some of the structure eitherway)??\r\n\r\nGiven that neither `hash_to_curve` is constant time, IMO expanding a bit the Side channel attacks security consideration to recommend implementation of arithmetic operations (mainly point, scalar multiplication) in constant time should be enough.",
          "createdAt": "2023-02-15T01:44:38Z",
          "updatedAt": "2023-02-15T01:44:38Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on WG call on 20th of Mar. Will re-visit and consider closing after 1-2 wg calls",
          "createdAt": "2023-03-20T19:44:15Z",
          "updatedAt": "2023-03-20T19:44:15Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "https://github.com/decentralized-identity/bbs-signature/issues/218#issuecomment-1430634237\r\n@mikelodder7",
          "createdAt": "2023-03-20T19:44:44Z",
          "updatedAt": "2023-03-20T19:44:44Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@mikelodder7 we believe this issue is addressed, we intend to close on the next WG meeting if we hear no objections.",
          "createdAt": "2023-05-08T18:18:13Z",
          "updatedAt": "2023-05-08T18:18:13Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Cool let me know if I should look at anything in particular ",
          "createdAt": "2023-05-08T19:32:23Z",
          "updatedAt": "2023-05-08T19:32:23Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "The WG considers this issue resolved please review the most recent editorial draft and re-open an issue if you encounter one.",
          "createdAt": "2023-06-12T18:40:00Z",
          "updatedAt": "2023-06-12T18:40:00Z"
        }
      ]
    },
    {
      "number": 219,
      "id": "I_kwDOF8lax85Tdr3g",
      "title": "Public key format",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/219",
      "state": "CLOSED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "core"
      ],
      "body": "When using the public key as input to Sign, Verify etc., we can define it either as a point of G2 or as an octet string. Rn we do the later, consistent with what the BLS spec does.\r\n\r\nThat said, passing it as a G2 point, will simplify the encode for has operation a bit, since we don't need a \"special clause\" there so we would not append it with it length, since it would be handled like any other point. See also [here](https://github.com/decentralized-identity/bbs-signature/pull/216#discussion_r980354472) for context. \r\n\r\nIMO defining it as an octet string is more intuitive, but Im fine with both.",
      "createdAt": "2022-10-06T20:56:24Z",
      "updatedAt": "2023-03-20T19:38:31Z",
      "closedAt": "2023-03-20T19:38:31Z",
      "comments": [
        {
          "author": "tmarkovski",
          "authorAssociation": "MEMBER",
          "body": "Would it make sense to do the same for the secret key (instead \"non negative integer mod r\") and treat is as scalar, the same way the `messages` are?",
          "createdAt": "2022-10-16T22:57:17Z",
          "updatedAt": "2022-10-16T22:57:17Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "I'm in favour of keeping this as octet string based input.",
          "createdAt": "2022-12-05T19:37:00Z",
          "updatedAt": "2022-12-05T19:37:00Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on WG call on 20th of Mar. Related to #246 and #223. Closing in favor of those issues",
          "createdAt": "2023-03-20T19:38:30Z",
          "updatedAt": "2023-03-20T19:38:30Z"
        }
      ]
    },
    {
      "number": 223,
      "id": "I_kwDOF8lax85UUFfv",
      "title": "Tomislav's comments",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/223",
      "state": "CLOSED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "core"
      ],
      "body": "This is a tracking issue to address [comments](https://github.com/decentralized-identity/bbs-signature/pull/221#issuecomment-1283168657) made by @tmarkovski around test vectors and the spec in general!",
      "createdAt": "2022-10-19T08:39:50Z",
      "updatedAt": "2023-07-10T19:53:38Z",
      "closedAt": "2023-07-10T19:53:38Z",
      "comments": [
        {
          "author": "tmarkovski",
          "authorAssociation": "MEMBER",
          "body": "Posting them here.\r\n\r\nMy thoughts and findings:\r\n\r\n- Most negative tests are hard to validate for the reason they specify. Once my positive tests worked, I only assumed the negative tests are working as well, since they were all failing before. The algorithm doesn't provide ways to test exactly where the failure happened.\r\n- Tests without header and presentation header might be useful as well\r\n- I stumbled on the use of hex and treating messages as encoded scalars, but this has already been addressed I think. Might be useful to add variable length message inputs.\r\n- Why does the Sign algorithm accept SK and PK as input, but doesn't validate if the PK is correct. SkToPk is fairly inexpensive operation, it seems that only SK is needed. Is there a security concern similar to what affected ECDSA?\r\n- Should PK parameters be passed as points to Verify, ProofGen, ProofVerify, instead as octet string? This will simplify the validation and be inline with how we pass the messages as scalars. Same question for SK.",
          "createdAt": "2022-10-19T13:55:19Z",
          "updatedAt": "2022-10-20T20:43:47Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "> Most negative tests are hard to validate for the reason they specify. Once my positive tests worked, I only assumed the negative tests are working as well, since they were all failing before. The algorithm doesn't provide ways to test exactly where the failure happened.\r\n\r\nAgreed, I think even if an implementation does not verify the specific reason for a failure when testing with the negative test vectors, they still provide some value. The \"reason\" for failure is really only there for informational purposes, so we should clarify that.\r\n\r\n> Tests without header and presentation header might be useful as well\r\n\r\n+1\r\n\r\n> I stumbled on the use of hex and treating messages as encoded scalars, but this has already been addressed I think. Might be useful to add variable length message inputs.\r\n\r\nYes I believe this has been addressed \r\n\r\n> Why does the Sign algorithm accept SK and PK as input, but doesn't validate if the PK is correct. SkToPk is fairly inexpensive operation, it seems that only SK is needed. Is there a security concern similar to what affected ECDSA?\r\n\r\nCorrect it is because of performance reasons, not sure which security concern you are referring to with ECDSA, do you mean EdDSA. We have investigated that even without confirming the PK's relationship to the SK in sign there is no security concern, the signature would just fail to validate. Implementations are free to do this validation and we could add in an implementation consideration to that effect?\r\n\r\n> Should PK parameters be passed as points to Verify, ProofGen, ProofVerify, instead as octet string? This will simplify the validation and be inline with how we pass the messages as scalars. Same question for SK.\r\n\r\nI understand this perspective, however I think its good to be consistent, both proofs and signatures are passed in as their encoded form instead of as internal structures and I view PK the same.\r\n\r\n",
          "createdAt": "2022-11-21T19:41:39Z",
          "updatedAt": "2022-11-21T19:41:39Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Related to #7, we may want to merge with that so we dont have a duplicate.",
          "createdAt": "2022-12-05T19:35:10Z",
          "updatedAt": "2022-12-05T19:35:10Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed in the WG call on the 6th of February. Will re-visit after no-header fixtures are added and #239 is merged. Consensus is to check with the CFRG for reasons not to add negative test vectors, and if that is not the case add a limited set of negative cases capturing weird cases.",
          "createdAt": "2023-02-06T19:56:16Z",
          "updatedAt": "2023-02-06T19:56:16Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on WG call on 20th of Mar. No action to take rn. PK encoding related to #246. Will revisit after IETF for v03.",
          "createdAt": "2023-03-20T19:37:24Z",
          "updatedAt": "2023-03-20T19:37:24Z"
        }
      ]
    },
    {
      "number": 224,
      "id": "I_kwDOF8lax85UcSHS",
      "title": "Enhancement proposal: change D sign in the defenition",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/224",
      "state": "CLOSED",
      "author": "jovfer",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "ready-for-pr",
        "core"
      ],
      "body": "The proof gen procedure [defines](https://identity.foundation/bbs-signature/draft-irtf-cfrg-bbs-signatures.html#name-proofgen) `D = B * r1 + Q_1 * r2`.\r\n\r\nEverywhere below it's used with `-`.\r\n\r\nCan we change the sign of the definition and declare `D = -(B * r1 + Q_1 * r2)` ?\r\n\r\nThen the step 17th will be \r\n`17. C2 = D * r3~ + Q_1 * s~ + H_j1 * m~_j1 + ... + H_jU * m~_jU`\r\n\r\nThen proof verification steps 10, 12 will be:\r\n`10. C1 = (Abar + D) * c + A' * e^ + Q_1 * r2^`\r\n`12. C2 = T * c + D * r3^ + Q_1 * s^ + H_j1 * m^_j1 + ... + H_jU * m^_jU`\r\n\r\nUPD:\r\nas @tplooker mentioned in the related MR #226, this is a breaking changes, as D is a part of serialized proof.\r\n",
      "createdAt": "2022-10-20T14:10:23Z",
      "updatedAt": "2022-12-26T16:33:53Z",
      "closedAt": "2022-12-12T22:03:37Z",
      "comments": [
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looks reasonable to me",
          "createdAt": "2022-10-20T16:38:44Z",
          "updatedAt": "2022-10-20T16:38:44Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Addressing this issue is in scope for the latest milestone, as a WG we need to decide whether this procedure change is in fact an improvement on readability of the specification.",
          "createdAt": "2022-12-05T19:54:45Z",
          "updatedAt": "2022-12-05T19:54:45Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "See comment [here](https://github.com/decentralized-identity/bbs-signature/pull/226#issuecomment-1347401998) for rational on why we have elected not to proceed with this change.",
          "createdAt": "2022-12-12T22:03:37Z",
          "updatedAt": "2022-12-12T22:03:37Z"
        },
        {
          "author": "jovfer",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@tplooker I do agree it's a really minor from the readability standpoint and about 0 from efficiency in runtime. The main benefit is the simplification of an implementation, so it will be just more consistent formula and more consistent codebase. Since the spec is still draft, I'm estimating the change as 0-cost and having long-term benefit makes the tradeoff obvious for me.\r\n\r\nPS: re-opening the issue just to increase visibility, fill free to close it back, if the argument above doesn't make sense for you :) \r\nPPS: oops, seems like I can't re-open the issue. Hopefully the notifications work fine.",
          "createdAt": "2022-12-26T16:32:44Z",
          "updatedAt": "2022-12-26T16:33:53Z"
        }
      ]
    },
    {
      "number": 225,
      "id": "I_kwDOF8lax85UhZEB",
      "title": "Encode for hash revision",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/225",
      "state": "CLOSED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "core"
      ],
      "body": "As members of the WG have noted (thanks @christianpaquin, @tmarkovski!!), the current [EncodeForHash](https://identity.foundation/bbs-signature/draft-irtf-cfrg-bbs-signatures.html#name-encodeforhash) section is confusing and prone to error. Especially the part about encoding octet strings.\r\n\r\nA possible solution is to remove entirely the part about appending octet strings with their length. The only place this is actually used is for the `msg` in `MapMsgToScalarAsHash`, for the `header` in the domain hash and the `presentationHeader` in the challenge hash. I believe we can handle those cases in their respected functions. Octet string will then be encoded directly.\r\n\r\n- **Pros**: will make `EncodeForHash` much simpler + no need for the Ciphersuite ID and Public Key exceptions.\r\n- **Cons**: Will add 1-2 additional step to each of the core operations.\r\n\r\nIMO the tradeoff is worth it, but keen hear other approaches as well.",
      "createdAt": "2022-10-21T09:26:49Z",
      "updatedAt": "2023-01-10T06:58:53Z",
      "closedAt": "2023-01-10T06:58:52Z",
      "comments": [
        {
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I would lean on the other side, to prepend all inputs with their lengths (closer to what the text says). Encoding would therefore 1) explain how to transform various input types to octet strings, and 2) how to hash octet strings (len(x) || x). This would keep things simple while providing encoding security where needed (and no bad side effect where it's not).  ",
          "createdAt": "2022-10-21T12:53:15Z",
          "updatedAt": "2022-10-21T12:53:15Z"
        },
        {
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In the `Sign` function, the secret key must also be encoded directly in `e_s_for_hash` without pre-pending its length (like the public key in `dom_for_hash`) for the fixtures to pass. This should also be specified in the hash encoding specification.",
          "createdAt": "2022-10-23T03:08:13Z",
          "updatedAt": "2022-10-23T03:08:13Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Also as raised by @christianpaquin  `cv_for_hash` includes the disclosed index and it isn't stipulated whether the indicies starts from 0 or 1.",
          "createdAt": "2022-10-23T19:54:18Z",
          "updatedAt": "2022-10-23T19:54:18Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Another option may be to avoid mixing fixed-length inputs and variable-length inputs by hashing the variable-length inputs beforehand (specifically `ciphersuite_id`, `header`, and `ph`) and only dealing with scalars, points, and integers in `encode_for_hash`.\r\n\r\n```\r\nProcedure:\r\n\r\n1.  let octets_to_hash be an empty octet string.\r\n2.  for el in input_array:\r\n11.     if el is a Point in G1: el_octs = point_to_octets_g1(el)\r\n12.     else if el is a Point in G2: el_octs = point_to_octets_g2(el)\r\n10.     else if el is a Scalar: el_octs = I2OSP(el, octet_scalar_length)\r\n11.     else if el is a non-negative integer: el_octs = I2OSP(el, 8)\r\n12.     else: return INVALID\r\n13.     octets_to_hash = octets_to_hash || el_octs\r\n14. return octets_to_hash\r\n```\r\n\r\nThen in `Sign`, for example:\r\n\r\n```\r\nDefinitions:\r\n  - ciphersuite_hash, scalar. The result of hash_to_scalar(ciphersuite_id, 1) for the specific ciphersuite.\r\n\r\n1.  header_hash = hash_to_scalar(header, 1)\r\n2.  dom_array = (PK, L, Q_1, Q_2, H_1, ..., H_L, ciphersuite_hash, header_hash)\r\n3.  dom_for_hash = encode_for_hash(dom_array)\r\n4. ...\r\n```\r\n\r\n(and similarly in `Verify`, `ProofGen`, `ProofVerify`).\r\n",
          "createdAt": "2022-11-21T19:44:37Z",
          "updatedAt": "2022-11-21T19:45:20Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I like the simpler `encode_for_hash`. Keeping that the same, not sure why not call,\r\n```\r\n1. header_prime = I2OSP(len(header), 8) || header\r\n2. dom_array = (PK, L, Q_1, Q_2, H_1, ..., H_L, ciphersuite_id, header_prime)\r\n```\r\nto avoid the extra hashes?? (does `ciphersuite_id` need to be appended with its length??)\r\n\r\nAlso IMO, appending everything with their length will not simplify things much more compared to this 2 proposals (will definitely simplify the current text though), other than removing step 1 from above (which i don't think is worth it??)\r\n",
          "createdAt": "2022-11-27T17:32:23Z",
          "updatedAt": "2022-11-27T17:32:23Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes it's probably simpler to just avoid passing any byte arrays through `encode_for_hash` and prepend the length when necessary. How about (renaming `encode_for_hash` to `serialize`):\r\n\r\n```\r\n1. dom_for_hash = serialize((PK, Q_1, Q_2, L, H_1, ..., H_L))\r\n2. if dom_for_hash is INVALID, return INVALID\r\n3. header_prime = I2OSP(len(header), 8) || header\r\n4. domain = hash_to_scalar(dom_for_hash || ciphersuite_id || header_prime, 1)\r\n```\r\n\r\nI also changed the position of `L` to be adjacent to the `L` repeated elements, this seems more natural and consistent with `ProofGen`. We could probably skip the check for INVALID because the types of all inputs are known.\r\n\r\nExample from `ProofGen`:\r\n\r\n```\r\n18. c_array = (A', Abar, D, C1, C2, R, i1, ..., iR,\r\n                       msg_i1, ..., msg_iR, domain)\r\n19. c_for_hash = serialize(c_array)\r\n20. if c_for_hash is INVALID, return INVALID\r\n21. ph_prime = I2OSP(len(presentationHeader), 8) || presentationHeader\r\n22. c = hash_to_scalar(c_for_hash || ph_prime, 1)\r\n```\r\n\r\nIncidentally `SignatureToOctets` could also be implemented in terms of `serialize`.",
          "createdAt": "2022-11-27T18:47:10Z",
          "updatedAt": "2022-11-27T18:47:10Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yea, this seems a good option to me! The \"put all the octet strings at the end\" sounds like a reasonable and simple rule (as long as we mention it in the document).\r\n\r\n+1 for renaming `encode_for_hash` to `serialize` and for updating `SignatureToOctets` (and `ProofToOctets` i guess) to use `serialize`. \r\n\r\nWe will need to have some checks though for INVALID arguments. For example the length of the header needs to be at most 2^8. We can add steps like that in the precomputations though, or as requirements on the inputs?? (in ProofGen/ProofVerify we will need 2 of those tests, for `header` and `ph`).",
          "createdAt": "2022-11-28T16:01:55Z",
          "updatedAt": "2022-11-28T16:01:55Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "`2^8` is definitely not long enough for the header, `2^64` I think?",
          "createdAt": "2022-11-28T17:00:51Z",
          "updatedAt": "2022-11-28T17:00:51Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yea, sorry my bad, 2^64 is correct!",
          "createdAt": "2022-11-28T17:54:31Z",
          "updatedAt": "2022-11-28T17:54:31Z"
        }
      ]
    },
    {
      "number": 227,
      "id": "I_kwDOF8lax85VM9mW",
      "title": "Problem in ProofVerify",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/227",
      "state": "CLOSED",
      "author": "rolfhaenni",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "ready-for-pr",
        "core"
      ],
      "body": "In the current version of ProofVerify, the following problem may arise:\r\n\r\nIf the given parameter L and the number of disclosed messages R=length(disclosed_indexes) are used for computing U=L-R, then this U may be different from the length the vector (m^_j1,...,m^_jU) included in the proof. Without taking further actions, computing the sum-of-products H_j1 * m^_j1 + ... + H_jU * m^_jU  in Line 12 may then fail in an actual implementation, for example with an IndexOutOfBoundException.\r\n\r\nWhat is missing is an additional precondition R + length(m^_j1,...,m^_jU) = L.\r\n\r\nEven a better solution is removing parameter L from the algorithm's parameter list and computing R=length(disclosed_indexes), U=length(m^_j1,...,m^_jU), and L=R+U. This avoids the additional precondition and simplifies the interface. ",
      "createdAt": "2022-10-31T08:32:29Z",
      "updatedAt": "2023-02-10T22:08:00Z",
      "closedAt": "2023-02-10T22:07:59Z",
      "comments": [
        {
          "author": "tmarkovski",
          "authorAssociation": "MEMBER",
          "body": "Good point, the L argument seems redundant, since it can be calculated from the submitted proof and messages input. However, this slightly complicates the logic for extracting the commitments from the proof, since their total number is unknown. Implementers would have to ensure that the total number of commitments in m^_jX is the left-over octet length / scalar length. Not a huge deal, but it may complicate the operation definition a little.\r\n\r\nThis means the integrity of the API method definition is dependent on the encoded data provided inside one of it's arguments. I do tend to favor api definition simplicity, but I'm unsure about this specific case.\r\nAdding the additional precondition seems the most straightforward fix.",
          "createdAt": "2022-10-31T16:25:40Z",
          "updatedAt": "2022-10-31T16:25:40Z"
        },
        {
          "author": "rolfhaenni",
          "authorAssociation": "NONE",
          "body": "I think the tricky part is getting the order of the statements into the right order. What could possibly help is separating deserialisation of the inputs from the main procedure. With this in mind, my proposal without having L as a (redundant) parameter is shown below. I think that would be pretty clean, except for the fact that:\r\n- if Precondition 1 fails, then the length of (msg_i1, ..., msg_iR) in Line 7 would be different from R\r\n- if Precondition 2 fails, then the length of  (j1, ..., jU) in Line 6 would be different from U\r\n\r\nFor consistency reasons, separating deserialisation must then be implemented everywhere, i.e. in Verify and ProofGen.\r\n\r\nWhat do you think?\r\n\r\n```\r\n3.4.4. ProofVerify\r\n******************\r\n\r\nresult = ProofVerify(PK, proof, header, ph, disclosed_messages, disclosed_indexes)\r\n\r\nInputs:\r\n- PK (REQUIRED), an octet string of the form outputted by the SkToPk operation.\r\n- proof (REQUIRED), an octet string of the form outputted by the ProofGen operation.\r\n- header (OPTIONAL), an optional octet string containing context and application specific information. If not supplied, it defaults to an empty string.\r\n- ph (OPTIONAL), octet string containing the presentation header. If not supplied, it defaults to an empty string.\r\n- disclosed_messages (OPTIONAL), a vector of scalars. If not supplied, it defaults to the empty array \"()\".\r\n- disclosed_indexes (OPTIONAL), vector of unsigned integers in ascending order. Indexes of disclosed messages. If not supplied, it defaults to the empty array \"()\".\r\n\r\nParameters:\r\n- ciphersuite_id, ASCII string. The unique ID of the ciphersuite. \r\n- P1, fixed point of G1, defined by the ciphersuite.\r\n\r\nDefinitions:\r\n- R, is the non-negative integer representing the number of disclosed (revealed) messages\r\n- U, is the non-negative integer representing the number of undisclosed (unrevealed) messages\r\n- L, is the non-negative integer representing the number of signed messages, i.e. L = R+U\r\n\r\nOutputs:\r\n- result, either VALID or INVALID. \r\n\r\nDeserialization:\r\n1. proof_result = octets_to_proof(proof)\r\n2. if proof_result is INVALID, return INVALID\r\n3. W = octets_to_pubkey(PK)\r\n4. if W is INVALID, return INVALID\r\n\r\nPrecomputations:\r\n1. (A', Abar, D, c, e^, r2^, r3^, s^, commitments) = proof_result \r\n2. R = length(disclosed_indexes)\r\n3. U = length(commitments)\r\n4. L = R + U\r\n5. (i1, ..., iR) = disclosed_indexes\r\n6. (j1, ..., jU) = range(1, L) \\ disclosed_indexes\r\n7. (msg_i1, ..., msg_iR) = disclosed_messages\r\n8. (m^_j1, ...,m^_jU) = commitments\r\n9. (Q_1, Q_2, MsgGenerators) = create_generators(L+2)\r\n10. (H_1, ..., H_L) = MsgGenerators\r\n11. (H_i1, ..., H_iR) = (MsgGenerators[i1], ..., MsgGenerators[iR]) \r\n12. (H_j1, ..., H_jU) = (MsgGenerators[j1], ..., MsgGenerators[jU])\r\n\r\nPreconditions:\r\n1. if length(disclosed_messages) != R, return INVALID\r\n2. for i in (i1, ..., iR), if i < 1 or i > L, return INVALID \r\n\r\nProcedure:\r\n1. dom_array = (PK, L, Q_1, Q_2, H_1, ..., H_L, ciphersuite_id, header) \r\n2. dom_for_hash = encode_for_hash(dom_array)\r\n3. if dom_for_hash is INVALID, return INVALID\r\n4. domain = hash_to_scalar(dom_for_hash, 1)\r\n5. C1 = (Abar - D) * c + A' * e^ + Q_1 * r2^\r\n6. T = P1 + Q_2 * domain + H_i1 * msg_i1 + ... + H_iR * msg_iR\r\n7. C2 = T * c - D * r3^ + Q_1 * s^ + H_j1 * m^_j1 + ... + H_jU * m^_jU \r\n8. cv_array = (A', Abar, D, C1, C2, R, i1, ..., iR, msg_i1, ..., msg_iR, domain, ph) \r\n9. cv_for_hash = encode_for_hash(cv_array)\r\n10. if cv_for_hash is INVALID, return INVALID 16. cv = hash_to_scalar(cv_for_hash, 1)\r\n11. if c != cv, return INVALID\r\n12. if A' == Identity_G1, return INVALID\r\n13. if e(A', W) * e(Abar, -P2) != Identity_GT, return INVALID \r\n14. return VALID\r\n```",
          "createdAt": "2022-11-02T14:58:37Z",
          "updatedAt": "2022-11-02T14:59:43Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed on WG call 21st of November, the proposal seems like an improvement to the specification. I'm going to mark this issue as ready for PR.",
          "createdAt": "2022-11-21T19:20:02Z",
          "updatedAt": "2022-11-21T19:20:02Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Taking the time to look into this proposal a bit more closely, i do like it. I'm not sure how the current approach has an issue problem. If an error is returned (like an IndexOutOfBoundException) it's not a bad thing necessarily, since in this case the proof is malformed.\r\n\r\nThat said i do like removing `L` from the input of `ProofVerify` as well as separating the deserialization in their own steps. \r\n\r\nJust a minor editorial detail, it seems to me that the `Precomputations` steps loose their purpose a bit (operations to be cached). Maybe we can move more staff to `Deserialization`. Maybe something like:\r\n\r\n\r\n```\r\nresult = ProofVerify(PK, proof, header, ph, disclosed_messages, disclosed_indexes)\r\n\r\nOutputs:\r\n- result, either VALID or INVALID. \r\n\r\nDeserialization:\r\n1.  proof_result = octets_to_proof(proof)\r\n2.  (A', Abar, D, c, e^, r2^, r3^, s^, commitments) = proof_result \r\n3.  if proof_result is INVALID, return INVALID\r\n4.  W = octets_to_pubkey(PK)\r\n5.  if W is INVALID, return INVALID\r\n6.  R = length(disclosed_indexes)\r\n7.  U = length(commitments)\r\n8.  L = R + U\r\n9.  (i1, ..., iR) = disclosed_indexes\r\n10. (j1, ..., jU) = range(1, L) \\ disclosed_indexes\r\n11. (m^_j1, ...,m^_jU) = commitments\r\n\r\nPrecomputations:\r\n1. (Q_1, Q_2, MsgGenerators) = create_generators(L+2)\r\n2. (H_1, ..., H_L) = MsgGenerators\r\n3. (H_i1, ..., H_iR) = (MsgGenerators[i1], ..., MsgGenerators[iR]) \r\n4. (H_j1, ..., H_jU) = (MsgGenerators[j1], ..., MsgGenerators[jU])\r\n\r\nPreconditions:\r\n1. if length(disclosed_messages) != R, return INVALID\r\n2. for i in (i1, ..., iR), if i < 1 or i > L, return INVALID \r\n\r\nProcedure:\r\n1.  dom_array = (PK, L, Q_1, Q_2, H_1, ..., H_L, ciphersuite_id, header) \r\n2.  dom_for_hash = encode_for_hash(dom_array)\r\n3.  if dom_for_hash is INVALID, return INVALID\r\n4.  domain = hash_to_scalar(dom_for_hash, 1)\r\n5.  C1 = (Abar - D) * c + A' * e^ + Q_1 * r2^\r\n6.  T = P1 + Q_2 * domain + H_i1 * msg_i1 + ... + H_iR * msg_iR\r\n7.  C2 = T * c - D * r3^ + Q_1 * s^ + H_j1 * m^_j1 + ... + H_jU * m^_jU \r\n8.  cv_array = (A', Abar, D, C1, C2, R, i1, ..., iR, msg_i1, ..., msg_iR, domain, ph) \r\n9.  cv_for_hash = encode_for_hash(cv_array)\r\n10. if cv_for_hash is INVALID, return INVALID 16. cv = hash_to_scalar(cv_for_hash, 1)\r\n11. if c != cv, return INVALID\r\n12. if A' == Identity_G1, return INVALID\r\n20. if e(A', W) * e(Abar, -P2) != Identity_GT, return INVALID \r\n21. return VALID\r\n```\r\n\r\nThat way is easier to describe `Precomputations` as operations that can be cached??\r\n\r\nWhen it comes to security, since `L` is defined by the Prover, i don't see removing it compromising anything. In other words, if there is an attack that works by manipulating `U` and `R`, then an adversary can manipulate `L` in the current design and achieve the same thing. Just to be safe though, we may want to add `U` in the challenge hash calculation, so the proof value will be committed to it.",
          "createdAt": "2023-01-16T18:54:06Z",
          "updatedAt": "2023-01-16T18:54:06Z"
        }
      ]
    },
    {
      "number": 229,
      "id": "I_kwDOF8lax85XogrP",
      "title": "PRF vs RNG/RBG",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/229",
      "state": "CLOSED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "ready-for-pr",
        "core",
        "editorial"
      ],
      "body": "IMO we are little vague regarding the PRFs in the spec.\r\n\r\nFor example, in RFCs like [IKEv2](https://www.rfc-editor.org/rfc/rfc7296) and [RFC4868](https://www.rfc-editor.org/rfc/rfc4868.html) (which we link to as a reference), PRFs are keyed, accept additional input and return constant size output. However, we do call them just on the required output len.\r\n\r\nYou can build an extendable output PRF, (or PRF* as is called in [[H2010]](https://link.springer.com/content/pdf/10.1007/978-3-642-14623-7_34.pdf)), using a PRF in counter/feedback mode etc., and get something usable by our operations, however we don\u2019t mention that currently.\r\n\r\nI think what we are using is something closer to an RBG or a RNG (or a CSPRBG/CSPRNG more specifically) than a PRF.\r\n\r\nIs there a reason to use a PRF?? The differences are subtle (and of-course you can build RBGs/RNGs on top of PRFs and vice-versa). It seems more confusing and harder to work with to me though. For example, with PR #228 we recommend the use of a seeded ChaCha20 DRNG to avoid some entropy attacks. However, the result is not \"strictly speaking\" a PRF.\r\n\r\nOther specs like [FROST](https://www.ietf.org/archive/id/draft-irtf-cfrg-frost-11.html) or [OPAQUE](https://www.ietf.org/archive/id/draft-irtf-cfrg-opaque-09.html) also use a CSPRNG with both pointing to [RFC4086](https://www.rfc-editor.org/rfc/rfc4086) for requirements.",
      "createdAt": "2022-11-30T21:27:18Z",
      "updatedAt": "2023-02-02T03:49:02Z",
      "closedAt": "2023-02-02T03:49:02Z",
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on WG call 9th of January. Next step is to open PR with the above approach.",
          "createdAt": "2023-01-10T07:14:46Z",
          "updatedAt": "2023-01-10T07:14:46Z"
        }
      ]
    },
    {
      "number": 231,
      "id": "I_kwDOF8lax85Y9d14",
      "title": "Length of octet strings encoding",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/231",
      "state": "CLOSED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "core"
      ],
      "body": "We currently use 8 bytes for the header/ph length (where length = # of bytes), allowing it to be up to 2^64 \u2013 1 meaning that the header can be up to ~10^19 bytes long i.e., roughly 10000 Petabytes. This seems excessive.\r\n\r\nCases where even more than 32 or 64 bytes are needed can just use pre-hashing. IMO, 1 or 2 bytes (or even 3, which would allow for a header of up to 1 Mb) would be enough to encode the length of the header/ph for most applications.\r\n\r\n8 bytes are also used for the total number of messages. I doubt anyone will need to sign 10^19 messages, however, it maybe be nice to have a practically unlimited \"capacity\".\r\n\r\n## Proposal\r\n1. Use 8 bytes for the total number of messages/indexes is fine.\r\n2. Use 2 bytes for the length of octet strings (i.e., header/ph).",
      "createdAt": "2022-12-12T18:33:50Z",
      "updatedAt": "2023-02-06T19:45:25Z",
      "closedAt": "2023-02-06T19:45:25Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "I think the performance benefit here is debatable and creating an inconsistency between the number of bytes pre-appended is a higher cost.",
          "createdAt": "2022-12-19T19:29:02Z",
          "updatedAt": "2022-12-19T19:29:02Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on WG call 9th of January. No consensus seemed to be achieved. Will discuss closing this issue in the next WG call.",
          "createdAt": "2023-01-10T07:13:53Z",
          "updatedAt": "2023-01-10T07:13:53Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on Wg call on the 6th of February. Since there will be no performance advantage will close to not introduce breaking changes.",
          "createdAt": "2023-02-06T19:45:25Z",
          "updatedAt": "2023-02-06T19:45:25Z"
        }
      ]
    },
    {
      "number": 232,
      "id": "I_kwDOF8lax85Y9eiE",
      "title": "Messages length ",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/232",
      "state": "CLOSED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "ready-for-pr",
        "core"
      ],
      "body": "Is there any actual reason to add the length of the messages in [MapMessageToScalarAsHash](https://identity.foundation/bbs-signature/draft-irtf-cfrg-bbs-signatures.html#name-mapmessagetoscalarashash)??\r\n\r\nIt probably doesn\u2019t hurt security even with weak hash functions (especially since the hash is moded), however I don\u2019t think it adds anything either. Most hash-functions (e.g., sha-2 and the Merkle\u2013Damgard functions in general), encode the length of the message either way in the pad.\r\n\r\n\\+ I don\u2019t think we have to worry about length extension attacks, even if they where possible -which are not-.",
      "createdAt": "2022-12-12T18:35:51Z",
      "updatedAt": "2023-02-06T14:35:32Z",
      "closedAt": "2023-02-06T14:35:32Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed on 12th of December WG call, related to #230, rough consensus appeared to be that we could simplify this procedure and not even invoke encode_for_hash, instead take `msg` and called hash_to_scalar directly. We also discussed removing the length check and adding a note around DST lengths.",
          "createdAt": "2022-12-12T23:16:12Z",
          "updatedAt": "2022-12-12T23:16:12Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on WG call 9th of January. Net step is to open PR with the proposed approach to have a solid base for further discussion.",
          "createdAt": "2023-01-10T07:12:37Z",
          "updatedAt": "2023-01-10T07:12:37Z"
        }
      ]
    },
    {
      "number": 233,
      "id": "I_kwDOF8lax85ZljqP",
      "title": "Adding U in the proof value.",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/233",
      "state": "CLOSED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "core"
      ],
      "body": "Opening to track a [suggestion](https://github.com/decentralized-identity/bbs-signature/pull/230#discussion_r1046293817) made by @andrewwhitehead in PR #230.\r\n\r\nThe idea IMU is to add `U` (total number of undisclosed messages) in the proof, i.e.,\r\n\r\n`proof = (A', Abar, D, c, e^, r2^, r3^, s^, *U*, (m^_1, ..., m^_U))`.\r\n\r\nThis will add some redundancy in case the proof gets accidentally truncated (or malformed in general).",
      "createdAt": "2022-12-19T14:05:02Z",
      "updatedAt": "2023-02-08T19:25:25Z",
      "closedAt": "2023-01-23T20:02:56Z",
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Personally not sure how useful this will be above the transport layer however this would potentially make the suggestion in #227 easier to apply.",
          "createdAt": "2022-12-19T14:08:21Z",
          "updatedAt": "2022-12-19T14:08:21Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "I'm a -1 to this proposal for the following reasons\r\n\r\n- It increases the proof size by 8 bytes\r\n- The detection of truncation only works for malformed components beyond U in the proof value e.g `(m^_1, ..., m^_U)`\r\n- For U to be useful in the proof, implementations that are decoding proofs would have to written a certain way to detect a malformed proof.\r\n\r\nThis issue does raise a good point that we could omit L from proof verify and deduce it based on length(m^_1, ..., m^_U) when decoding the proof.",
          "createdAt": "2022-12-19T19:25:05Z",
          "updatedAt": "2022-12-19T19:25:05Z"
        },
        {
          "author": "tmarkovski",
          "authorAssociation": "MEMBER",
          "body": "This was suggested at the start of this work item as well, as the previous implementations of BBS+ used this approach. In my mind, `U` is part of the public proof parameters along with the presentation header `ph`, and does not need to be encoded in the proof itself.",
          "createdAt": "2023-01-02T14:47:06Z",
          "updatedAt": "2023-01-02T14:47:06Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on the WG call 9th of January. Consensus is that rn the added redundancy is useful in some rare cases. Will discuss closing this issue in the next WG call, with the potential of reopening after #227 is resolved",
          "createdAt": "2023-01-10T07:10:27Z",
          "updatedAt": "2023-01-10T07:10:27Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed in the WG call 23d of January. Closing the issue with the potential of reopening after #227. Will also look into adding an implementation note describing this solution as a potential mitigation if one is needed.",
          "createdAt": "2023-01-23T20:02:56Z",
          "updatedAt": "2023-01-23T20:02:56Z"
        },
        {
          "author": "Wind4Greg",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Like this. I was doing something like this in my code but deriving U from the L value.",
          "createdAt": "2023-02-08T19:25:24Z",
          "updatedAt": "2023-02-08T19:25:24Z"
        }
      ]
    },
    {
      "number": 234,
      "id": "I_kwDOF8lax85ZlsSg",
      "title": "Text representation",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/234",
      "state": "CLOSED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "ready-for-pr",
        "core",
        "editorial"
      ],
      "body": "Tracking issue for a [comment](https://github.com/decentralized-identity/bbs-signature/pull/230#discussion_r1047573733) made by @andrewwhitehead in #230.\r\n\r\nIn the draft we are referring to text as ASCII string. This is kinda confusing as often ASCII refers to the characters octet encoding rather than the characters themselves. Alternatives include: Text, String, Character sequences etc.\r\n\r\n**Note**: the only place we actually use this terminology is for encoding the ciphersuite id and the DSTs. \r\n\r\nSome questions are: \r\n- do we want to disallow non-ASCII chars??\r\n- do we want generic \"string\" encoding rules (i.e., as in #230) or we should just define the DSTs and ciphersuite id to be octet strings from the start (i.e., ASCII encoded strings). This is what the h2c and bls curve do AFAIK.",
      "createdAt": "2022-12-19T14:25:43Z",
      "updatedAt": "2023-02-14T22:59:43Z",
      "closedAt": "2023-02-14T22:59:43Z",
      "comments": [
        {
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "body": "`U+1FAE0`",
          "createdAt": "2022-12-19T14:29:05Z",
          "updatedAt": "2022-12-19T14:29:05Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "+1 to the proposal to simplify the specification to state the octet representation of any strings rather than define complex string encoding rules",
          "createdAt": "2022-12-19T19:13:47Z",
          "updatedAt": "2022-12-19T19:13:47Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on WG call 9th of January. Next step is to open PR on this approach (use the octet representation of string rather than the strings).",
          "createdAt": "2023-01-10T07:06:58Z",
          "updatedAt": "2023-01-10T07:06:58Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on WG call 23d of January. Next step is to open PR with example.",
          "createdAt": "2023-01-23T19:58:05Z",
          "updatedAt": "2023-01-23T19:58:05Z"
        }
      ]
    },
    {
      "number": 235,
      "id": "I_kwDOF8lax85aZB8i",
      "title": "Enabling use cases for equalities in proof messages",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/235",
      "state": "CLOSED",
      "author": "tmarkovski",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "enhancement"
      ],
      "body": "## Objective\r\n\r\nAllow the holder to submit multiple proofs that may contain equal message inputs (at same or different index positions), while hiding those messages, but bind them to the proof interaction.\r\n\r\n## Use Cases\r\n\r\nCommon use cases would be showing proofs of identity issued by multiple parties, but link a specific hidden attribute, such as SSN or DOB and prove it's equal in both proofs.\r\nAnother application of message equality is in predicate proofs, where witnesses may be linked together between different proofs, such a between a BBS+ signature and a zk-snark proof.\r\nWitness equalities can also enable linking a BBS message with an accumulator, to enable provable revocation schemes.\r\n\r\n## Requirements\r\n\r\nIn order two satisfy these use cases, the ProofGen should be tweaked to expose the commitment (step 1-22) and challenge response (steps 23-28) phases in a way that they can be influenced externally. There are two tweaks required:\r\n\r\n**Externally generated randomnesses for the message blindings.** In order to compare the schnorr responses in the ProofGen output `(m^_j1, ..., m^_jU)`, the blindings `m~_j1, ..., m~_jU` must be able to be provided as inputs. This will impact the function in step 10 in the ProofGen construction, which currently generates random scalars for each hidden message.\r\n\r\n```\r\n10. (r1, r2, e~, r2~, r3~, s~, m~_j1, ..., m~_jU) = (ell_1, ell_2, ..., ell_(6+U))\r\n```\r\n\r\nWhile this doesn't change the security requirements for `m~_jU`, it does allow them to be created externally of the algorithm so they can be used in multiple proofs.\r\nImportant to note that implementation can still provide this, and still be spec compliant.\r\n\r\n**Externally generated challenge.** This is the second part that should be exposed to external contributions. The value for `c` in ProofGen should be amenable to external contributions such that the holder will control and provide the final value for `c` (this is in addition to and independent of `ph`). This approach will allow the final responses for `m^_jU` to be equal across different proofs, while binding them to that specific proof interaction.\r\n\r\nTo illustrate this, here's a breakdown of actions for two proofs (1) and (2).\r\n\r\n```\r\nProofGen(1) -> generate first proof challenge contribution c(1)\r\nProofGen(2) -> generate second proof challenge contribution c(2)\r\n\r\nHolder combines c(1) and c(2) into a c(12)\r\n\r\nProofGen(1) and ProofGen(2) then continue using c(12) in the remaining steps in the \r\nprocedure, instead of their respective c(1) and c(2):\r\n23. e^ = c * e + e~ mod r\r\n24. r2^ = c * r2 + r2~ mod r\r\n25. r3^ = c * r3 + r3~ mod r\r\n26. s^ = c * s' + s~ mod r\r\n27. for j in (j1, ..., jU): m^_j = c * msg_j + m~_j mod r\r\n28. proof = (A', Abar, D, c, e^, r2^, r3^, s^, (m^_j1, ..., m^_jU))\r\n```\r\n\r\n## Discussion\r\n\r\nCurious to hear everyone's thoughts on this. Happy to give more context on this during the workgroup call.\r\n",
      "createdAt": "2023-01-02T15:32:26Z",
      "updatedAt": "2023-01-19T13:15:25Z",
      "closedAt": "2023-01-19T13:15:25Z",
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Allowing the `m~_j` to be calculated externally and re-used does change the security assumptions of the proof. A BBS proof is ZK as long as the `m~_j` are unique and random. Breaking that breaks security.\r\n\r\nAs an example, consider only one message, `m_1` and 2 different proofs with the same `m~_1` and different challenges `c_1`, `c_2` (i know that this is not the intended use but this is just to illustrate a point).\r\n\r\nThen we have\r\n```\r\nm^_1 = m_1 * c_1 + m~_1\r\nm^_2 = m_1 * c_2 + m~_1\r\n\r\n=> m_1 = (m^_1 - m^_2)/(c_1 - c_2)\r\n```\r\nrevealing the hidden message.\r\n\r\nAllowing for someone to choose the challenge is also dangerous. In a non-interactive setting, the challenge must bind the proof to ALL the public parameters. It would be way to easy for someone to forget to add one of those parameters and break security ([example](https://github.com/decentralized-identity/bbs-signature/issues/74)).\r\n\r\n**--That is not to say it would not work--**. \r\n\r\nMy main concern is that exposing those APIs will be far too dangerous for people to misuse them.\r\n\r\n##  Some options\r\n\r\n1. Use a core and higher level operations structure, like the one in [BLS Signatures](https://datatracker.ietf.org/doc/draft-irtf-cfrg-bls-signature/). The core `ProofGen` would accept the challenge and `m~_i` so it can be used for the above procedure. Not ideal IMO since it would complicate the spec. It can also be [misinterpreted easily](https://drive.google.com/file/d/1-sH-L5EgQNweV7XOlKN_oRCudKYr0Ii5/view).\r\n\r\n2. IMO it would be better to describe this functionality as a separate procedure, accepting 2 (or an arbitrary number of) BBS signatures with their respective messages and generating the desired proof, rather than modifying the current operation.",
          "createdAt": "2023-01-09T18:40:08Z",
          "updatedAt": "2023-01-09T18:40:08Z"
        },
        {
          "author": "tmarkovski",
          "authorAssociation": "MEMBER",
          "body": "Thanks for the clarification. You're right, the challenge construction must be defined in the spec, and in scenarios where multiple proofs are combined and share the same challenge, the system must still define how that challenge is constructed that includes all parameters from all proofs.\r\nIt sounds like a spec extension is the way to go about this. Closing this for now. I'll make a new issue to highlight the proof system use case as enhancement.",
          "createdAt": "2023-01-19T13:15:25Z",
          "updatedAt": "2023-01-19T13:15:25Z"
        }
      ]
    },
    {
      "number": 242,
      "id": "I_kwDOF8lax85dxyUG",
      "title": "hash_to_scalar is overly flexible",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/242",
      "state": "CLOSED",
      "author": "andrewwhitehead",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "ready-for-pr",
        "core"
      ],
      "body": "Because it is no longer used to generate multiple outputs except for a pair of `e` and `s`, we can simplify `hash_to_scalar` to output only a single point instead of a list. In `Sign` we might use the following procedure:\r\n\r\n```\r\n3. e_s_for_hash = serialize((SK, domain, msg_1, ..., msg_L))\r\n4. if e_s_for_hash is INVALID, return INVALID\r\n5. e = hash_to_scalar(e_s_for_hash || I2OSP(0, 1))\r\n6. s = hash_to_scalar(e_s_for_hash || I2OSP(1, 1))\r\n```",
      "createdAt": "2023-02-06T21:41:43Z",
      "updatedAt": "2023-02-22T19:37:32Z",
      "closedAt": "2023-02-22T19:37:31Z",
      "comments": [
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Otherwise, there are a few cases where the result of `hash_to_scalar` is assigned to a scalar variable, although it is actually a list. For example in MapMessageToScalarAsHash:\r\n\r\n```\r\n2. msg_scalar = hash_to_scalar(msg, 1, dst)\r\n```",
          "createdAt": "2023-02-06T21:43:13Z",
          "updatedAt": "2023-02-06T21:43:13Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Another benefit of restricting this complication to `Sign`: if we adopt the new basic signature formulation without `s` then this method can be simplified further (outside of blinded signatures).",
          "createdAt": "2023-02-13T20:16:18Z",
          "updatedAt": "2023-02-13T20:16:18Z"
        }
      ]
    },
    {
      "number": 244,
      "id": "I_kwDOF8lax85eXvih",
      "title": "Plain English section titles",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/244",
      "state": "CLOSED",
      "author": "andrewwhitehead",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "ready-for-pr",
        "core",
        "editorial"
      ],
      "body": "This is a bit subjective, but I think we should adopt plain English titles for (sub)sections in the draft rather than using function names.\r\n\r\nAt the moment section 3 looks like this:\r\n\r\n    3.1.  Parameters\r\n    3.2.  Considerations\r\n      3.2.1.  Subgroup Selection\r\n      3.2.2.  Messages and generators\r\n      3.2.3.  Serializing to octet strings\r\n    3.3.  Key Generation Operations\r\n      3.3.1.  KeyGen\r\n      3.3.2.  SkToPk\r\n    3.4.  Core Operations\r\n      3.4.1.  Sign\r\n      3.4.2.  Verify\r\n      3.4.3.  ProofGen\r\n      3.4.4.  ProofVerify\r\n\r\nAn updated version might look like this:\r\n\r\n    3.1.  Parameters\r\n    3.2.  Considerations\r\n      3.2.1.  Subgroup Selection\r\n      3.2.2.  Messages and generators\r\n      3.2.3.  Serializing to octet strings\r\n    3.3.  Key Generation Operations\r\n      3.3.1.  Secret Key Generation\r\n      3.3.2.  Public Key Calculation\r\n    3.4.  Core Operations\r\n      3.4.1.  Signing\r\n      3.4.2.  Signature Verification\r\n      3.4.3.  Proof Generation\r\n      3.4.4.  Proof Verification\r\n\r\nFor comparison the [VOPRF draft](https://cfrg.github.io/draft-irtf-cfrg-voprf/draft-irtf-cfrg-voprf.html).",
      "createdAt": "2023-02-14T00:23:45Z",
      "updatedAt": "2023-06-12T18:43:30Z",
      "closedAt": "2023-06-12T18:43:29Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Im supportive of this direction I think it improves the readability of the specification.",
          "createdAt": "2023-02-14T22:32:46Z",
          "updatedAt": "2023-02-14T22:32:46Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1 from me as well! Will give it a go if that's ok Andrew.",
          "createdAt": "2023-02-14T23:13:15Z",
          "updatedAt": "2023-02-14T23:13:15Z"
        }
      ]
    },
    {
      "number": 245,
      "id": "I_kwDOF8lax85eeGc9",
      "title": "Message to scalar flexibility",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/245",
      "state": "CLOSED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "core"
      ],
      "body": "Likely, different applications will need different ways to map messages to scalars.\r\n\r\nThings to consider:\r\n\r\n## How flexible we want to be?\r\n\r\nThe most flexible option would be to allow the position of a message to affect its encoding i.e., first message using `hash-to-scalar`, second message is zero centered etc. One way to do this would be with some short of a \"schema\". However an easier way could be to update the `MapMessageToScalar` interface to accept all the messages (instead of having to call that operation for each message separately). Specifically, the generic `MapMessageToScalar` will be defined as,\r\n\r\n```\r\nMapMessageToScalar(messages, dst)\r\n```\r\n\r\nAn application can then define,\r\n\r\n```\r\nAppX_MapMessageToScalar(messages, dst)\r\n\r\nDeserialization:\r\n\r\n1. (msg_1, msg_2, ..., msg_L) = messages\r\n\r\nProcedure:\r\n1. scalar_1 = hash_to_scalar(msg_1)\r\n2. scalar_2 = OS2IP(msg_2) mods r\r\n3. ....\r\n```\r\n\r\nThe `MapMessageToScalarAsHash` operation will then be defined as,\r\n\r\n```\r\nMapMessageToScalarAsHash(messages, dst)\r\n\r\nDeserialization:\r\n\r\n1. (msg_1, msg_2, ..., msg_L) = messages\r\n\r\nPrecondition\r\n\r\n1. If length(msg_i) > 2^64 - 1 for i in (1, ..., L), return INVALID\r\n2. if length(dst) > 255, return INVALID\r\n\r\nProcedure:\r\n\r\n1. for msg in (1, ..., L)\r\n4.     msg_scalar_i = hash_to_scalar(msg_i, dst)\r\n5.     if msg_scalar_i is INVALID, return INVALID\r\n6. return (msg_scalar_1, ...., msg_scalar_L)\r\n```\r\n\r\nThis will allow for that level of flexibility without having to define \"schemas\".\r\n\r\n## Who can define a `MapMessageToScalar` operation\r\n\r\nAssuming that we would require every `MapMessageToScalar` operation to have a unique ID, there are going to be 2 options here:\r\n\r\n### A. Any application can define a new `MapMessageToScalr` operation.\r\nThe operations ID would then be added as a parameter to each of the core operations, and then passed to the `domain` value.\r\n\r\n### B. Only ciphersuites can define a new `MapMessageToScalar` opeartion.\r\nThe operations ID would then just be added to the end of the ciphersuite ID.\r\n\r\nIMO, option B is better. If an application \"needs\" to define a new `MapMessageToScalar` procedure, its likely that they will use it for some cryptographic functionality (like predicate proofs) that would be best to be defined in some document either way (and define its own ciphersuites). The `MapMessageToScalar` operation needs to be defined in a way that would guarantee consistency as much as possible and option B is IMO the best for that.",
      "createdAt": "2023-02-14T22:56:14Z",
      "updatedAt": "2023-07-10T18:31:43Z",
      "closedAt": "2023-07-10T18:31:43Z",
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hope this captured our discussion on the call. Please correct me @tplooker, @andrewwhitehead if I missed anything",
          "createdAt": "2023-02-14T22:56:19Z",
          "updatedAt": "2023-02-14T22:56:19Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on WG call on 20th of Mar. Will ask feedback from IETF and re-visit.",
          "createdAt": "2023-03-20T19:32:13Z",
          "updatedAt": "2023-03-20T19:32:13Z"
        }
      ]
    },
    {
      "number": 246,
      "id": "I_kwDOF8lax85fBMBl",
      "title": "Handle Subroutines ABORT",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/246",
      "state": "OPEN",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "ready-for-pr",
        "core",
        "editorial"
      ],
      "body": "2 sugestions for the Ciphersuite format:\r\n\r\n### A. Points serialization:\r\n\r\nThe point serialization we use is curve agnostic. No reason to be defined in the Ciphersuite. We could simplify things and define them as global parameters.\r\n\r\n### B. `expand_len` definition:\r\n\r\nAfter #243 is merged, we can define `expand_len` in the ciphersuite and impose requirements for its value in a way that `expand_message` will never fail. We can then remove all the `if uniform_bytes is INVALID, return INVALID` steps (and potentially even make `hash_to_scalar` to never fail if we remove the check for 0s).",
      "createdAt": "2023-02-21T21:55:40Z",
      "updatedAt": "2023-10-23T18:48:57Z",
      "closedAt": null,
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on WG on 6th of Mar. Will revisit for draft 03 after we simplify Sign",
          "createdAt": "2023-03-06T19:36:24Z",
          "updatedAt": "2023-03-06T19:36:24Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on WG call on 13th of Mar. The current point serialization cannot be curve agnostic. Will update the test vectors to use un-compressed format and re visit this after.",
          "createdAt": "2023-03-13T19:42:25Z",
          "updatedAt": "2023-03-13T19:42:25Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on WG call 20th of Mar. Will consider having PK as a point, to not restrict key representation.",
          "createdAt": "2023-03-20T19:30:21Z",
          "updatedAt": "2023-03-20T19:30:21Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on WG call on 27th of Mar. Consensus is to define ciphersuite specific encodings with the addition to define PKs as points in the operation's input",
          "createdAt": "2023-03-27T18:41:32Z",
          "updatedAt": "2023-03-27T18:41:32Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on the WG on the 22nd of May. Will address after PR #257 is merged",
          "createdAt": "2023-05-22T18:33:04Z",
          "updatedAt": "2023-05-23T07:01:25Z"
        }
      ]
    },
    {
      "number": 249,
      "id": "I_kwDOF8lax85fvrk3",
      "title": "Incorrect naming of the signature scheme used",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/249",
      "state": "CLOSED",
      "author": "MrM0nkey",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Hi there,\r\n\r\nI am writing a paper describing an anonymous credential scheme that works with BBS+ signatures. Basically, I am migrate the DDA+ protocol from Camenisch, J., Drijvers, M., Lehmann, A. (2016). Anonymous Attestation Using the Strong Diffie Hellman Assumption Revisited on Anonymous Credentials. I plan to refer to the specification https://identity.foundation/bbs-signature/draft-irtf-cfrg-bbs-signatures.html. I noticed that you refer to BBS signatures in the specification, although you specify BBS+ signatures. Would it be possible to change the name from the BBS signature scheme to the BBS+ signature scheme and thus adjust other parts of the specification such as the introduction?\r\n\r\nBest regards\r\nChris\r\n",
      "createdAt": "2023-03-02T08:33:30Z",
      "updatedAt": "2023-03-07T12:41:06Z",
      "closedAt": "2023-03-06T19:30:02Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Hi @MrM0nkey, this question was raised and discussed by the WG early days, see #30. We elected to drop the + mainly for very practical reasons and don't plan to re-introduce it. Further clarification in the introduction may be added to make this association/decision more obvious.",
          "createdAt": "2023-03-02T18:43:50Z",
          "updatedAt": "2023-03-02T18:43:50Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on WG call 6th of Mar. Agreement is that for various practical reasons the WG call will not consider updating the name. See #30. Closing.",
          "createdAt": "2023-03-06T19:30:02Z",
          "updatedAt": "2023-03-06T19:30:02Z"
        },
        {
          "author": "MrM0nkey",
          "authorAssociation": "NONE",
          "body": "Hi @tplooker and @BasileiosKal, thanks for your quick response. I would definitely recommend that you be more explicit in the introduction about BBS+ and why you decided to omit the +. At the moment, your reference to BBS _\"The name BBS is derived from the authors of the original academic work of Dan Boneh, Xavier Boyen and Hovav Shacham where the scheme was first described\"_ is certainly misleading to uninformed readers.\r\n\r\nBest regards\r\nChris",
          "createdAt": "2023-03-07T12:41:06Z",
          "updatedAt": "2023-03-07T12:41:06Z"
        }
      ]
    },
    {
      "number": 252,
      "id": "I_kwDOF8lax85gh8iQ",
      "title": "Unique fixture caseName",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/252",
      "state": "CLOSED",
      "author": "christianpaquin",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "ready-for-pr",
        "core",
        "editorial"
      ],
      "body": "It would be desirable to use unique `caseName` values in the fixtures, to differentiate them while running them in unit test framworks. For example, \"multi-message signature, all messages revealed proof\" appears 11 times in the proof fixture files, and all the signature ones are either name \"single\" or \"multi-message signature\".\r\n\r\nUpdate: I just realized that the spec uses different names for each test, but the fixtures doesn't update all of them (copy-paste leftover, I assume)\r\n ",
      "createdAt": "2023-03-10T19:26:06Z",
      "updatedAt": "2023-06-26T18:19:08Z",
      "closedAt": "2023-06-26T18:19:07Z",
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on WG call on 13th of Mar.\r\n\r\n> It would be desirable to use unique `caseName`\r\n\r\nI imagine this means unique per ciphersuite??\r\n\r\n> Update: I just realized that the spec uses different names for each test, but the fixtures doesn't update all of them (copy-paste leftover, I assume)\r\n\r\nNot sure i follow 100%?? Is there places in the document that should be populated by test vectors but are not??\r\n",
          "createdAt": "2023-03-13T19:28:43Z",
          "updatedAt": "2023-03-13T19:28:43Z"
        },
        {
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I imagine this means unique per ciphersuite??\r\n\r\nYes.\r\n\r\n> Not sure i follow 100%?? Is there places in the document that should be populated by test vectors but are not??\r\n\r\nThe spec is ok, but I'd suggest changing the `caseName` of the signature.json and proof.json files to match the corresponding files. Otherwise the test output looks like you are running the same test over and over again (e.g, for my lib):\r\n```\r\n  \u2713 signature001: single message signature (417 ms)\r\n  \u2713 signature002: single message signature (191 ms)\r\n  \u2713 signature003: single message signature (191 ms)\r\n  \u2713 signature004: multi-message signature (664 ms)\r\n  \u2713 signature005: multi-message signature (502 ms)\r\n  \u2713 signature006: multi-message signature (508 ms)\r\n  \u2713 signature007: multi-message signature (406 ms)\r\n  \u2713 signature008: multi-message signature (354 ms)\r\n  \u2713 signature009: multi-message signature (428 ms)\r\n  \u2713 proof001: single message signature, message revealed proof (251 ms)\r\n  \u2713 proof002: multi-message signature, all messages revealed proof (399 ms)\r\n  \u2713 proof003: multi-message signature, multiple messages revealed proof (512 ms)\r\n  \u2713 proof004: multi-message signature, all messages revealed proof (373 ms)\r\n  \u2713 proof005: multi-message signature, all messages revealed proof (427 ms)\r\n  \u2713 proof006: multi-message signature, all messages revealed proof (423 ms)\r\n  \u2713 proof007: multi-message signature, all messages revealed proof (29 ms)\r\n  \u2713 proof008: multi-message signature, all messages revealed proof (20 ms)\r\n  \u2713 proof009: multi-message signature, all messages revealed proof (292 ms)\r\n  \u2713 proof010: multi-message signature, all messages revealed proof (311 ms)\r\n  \u2713 proof011: multi-message signature, all messages revealed proof (15 ms)\r\n  \u2713 proof012: multi-message signature, all messages revealed proof (342 ms)\r\n  \u2713 proof013: multi-message signature, all messages revealed proof (348 ms) \r\n```\r\nSo for signatures, sig001 is ok, I'd use \"invalid single message signature (modified message)\" for sig002, etc.\r\n\r\nI could printout these descriptions by parsing the validity and reason (for non-valid tests), but that feels like a lot of trouble; I think it'd be nice for each case to have a different name (within a ciphersuite)\r\n",
          "createdAt": "2023-03-13T23:12:38Z",
          "updatedAt": "2023-03-13T23:12:38Z"
        }
      ]
    },
    {
      "number": 253,
      "id": "I_kwDOF8lax85gr2jo",
      "title": "Remove utf8 calls from the draft.",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/253",
      "state": "CLOSED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "BasileiosKal"
      ],
      "labels": [
        "ready-for-pr",
        "core",
        "editorial"
      ],
      "body": "",
      "createdAt": "2023-03-13T19:19:46Z",
      "updatedAt": "2023-06-04T20:28:12Z",
      "closedAt": "2023-06-04T20:28:11Z",
      "comments": []
    },
    {
      "number": 254,
      "id": "I_kwDOF8lax85iBawl",
      "title": "Add an application for plain multi-message signatures",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/254",
      "state": "CLOSED",
      "author": "andrewwhitehead",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "ready-for-pr",
        "core"
      ],
      "body": "At the moment we define [`MapMessageToScalarAsHash`](https://identity.foundation/bbs-signature/draft-irtf-cfrg-bbs-signatures.html#name-mapmessagetoscalarashash) without really linking it to anything, suggesting it as a good default for encoding messages. Instead, I suggest that we explicitly define a 'plain multi-message signature' application, requiring that all messages are UTF-8 strings, and using this encoding rule for each. It could have a simple header value identifying the application, for instance `BbsUtf8TextSignature2023` (the name needs work).\r\n\r\nImplementations could also choose to support a simple API for this signature application, something like: `PlainMultiSign(SK, messages: [String])` and `PlainMultiVerify(Sig, PK, messages)`.",
      "createdAt": "2023-03-28T19:26:18Z",
      "updatedAt": "2023-10-23T18:47:00Z",
      "closedAt": "2023-10-23T18:46:59Z",
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Not opposed to this, just to make sure i get it, you mean defining an API that will use the core operations?? To make it more explicit how `MapMessageToScalarAsHash` is to be used?? So something like what [bls-sigs](https://www.ietf.org/archive/id/draft-irtf-cfrg-bls-signature-05.html#name-api) or [h2c](https://www.ietf.org/archive/id/draft-irtf-cfrg-hash-to-curve-16.html#name-encoding-byte-strings-to-el) does?",
          "createdAt": "2023-04-03T17:33:36Z",
          "updatedAt": "2023-04-03T17:33:36Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closing as completed through #282",
          "createdAt": "2023-10-23T18:46:59Z",
          "updatedAt": "2023-10-23T18:46:59Z"
        }
      ]
    },
    {
      "number": 256,
      "id": "I_kwDOF8lax85jBvxD",
      "title": "Add a privacy consideration around revealed message indicies",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/256",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "core",
        "editorial"
      ],
      "body": "Each message that is signed when producing a signature is associated to a specific generator. This relationship has to persist for revealed messages in any derived proofs, which means the following pieces of information are known to a verifier when verifying a proof.\r\n\r\n1) The total number of messages that were originally signed (even if only a subset are actually revealed).\r\n2) What index each of the revealed messages in a generated proof occupied in the originally signed set.\r\n3) By process of elimination the indicies for all the messages that were not revealed in a derived proof.\r\n\r\nWe should add a privacy consideration that describes this so that implementations can be aware in case it leads to revealing information unintentionally to a verifier.",
      "createdAt": "2023-04-10T21:35:29Z",
      "updatedAt": "2023-12-05T15:47:06Z",
      "closedAt": "2023-12-05T15:47:05Z",
      "comments": [
        {
          "author": "Wind4Greg",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Can we also include impacts on \"linkability\", i.e., fingerprinting type attacks that can result in tracking across verifiers in this privacy section? On the last call some mitigation mechanisms were also discussed, e.g., breaking a long set of messages into smaller batches, etc... \r\nCheers",
          "createdAt": "2023-04-11T03:26:59Z",
          "updatedAt": "2023-04-11T03:26:59Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Yes I think link-ability is a consequence that generally fits as impacting on privacy, I will try capture some text to this effect.",
          "createdAt": "2023-04-12T20:17:51Z",
          "updatedAt": "2023-04-12T20:17:51Z"
        }
      ]
    },
    {
      "number": 261,
      "id": "I_kwDOF8lax85khYxg",
      "title": "BBS draft suggested corrections",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/261",
      "state": "CLOSED",
      "author": "Luckydd99",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "bug",
        "ready-for-pr",
        "editorial"
      ],
      "body": "I leave below some mistakes of this [draft](https://identity.foundation/bbs-signature/draft-irtf-cfrg-bbs-signatures.html):\r\n\r\n- In section 7.5.3 the output signature which appears in the test vector is the one regarding the SHAKE variant of the BBS protocol instead of the SHA-256 one;\r\n- in section 7.5.4.2 the output signature which appears in the test vector is the one regarding the SHAKE variant of the BBS protocol instead of the SHA-256 one;\r\n- section 3.2.2 does no longer contain input messages (they can now be find in section 7.3);\r\n- in section 7.2 there is a typo (BLS12-381-SHA-356 instead of SHA-256).\r\n",
      "createdAt": "2023-04-27T09:27:41Z",
      "updatedAt": "2023-06-04T20:29:02Z",
      "closedAt": "2023-06-04T20:29:01Z",
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks @Luckydd99 for the feedback \ud83d\ude4f  much appreciated!\r\n\r\n> section 3.2.2 does no longer contain input messages (they can now be find in section 7.3);\r\n\r\nNot sure I'm following his one? Section 3.2.2 is not supposed to include test vectors. Is the suggestion for a different title (like Message to scalar maybe)??\r\n\r\nEverything else are addressed in PR #263 ",
          "createdAt": "2023-05-21T16:11:12Z",
          "updatedAt": "2023-05-21T16:11:12Z"
        },
        {
          "author": "Luckydd99",
          "authorAssociation": "NONE",
          "body": "> Not sure I'm following his one? Section 3.2.2 is not supposed to include test vectors. Is the suggestion for a different title (like Message to scalar maybe)??\r\n\r\nThe suggestion was referring to the fact that Section 7.4, Section 7.5, Appendix C.1 and Appendix C.2 always refer to messages contained in Section 3.2.2, which indeed does not contain any message.",
          "createdAt": "2023-05-22T12:54:11Z",
          "updatedAt": "2023-05-22T12:54:11Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Oh I see! Thanks! Fixed in the PR",
          "createdAt": "2023-05-22T17:32:34Z",
          "updatedAt": "2023-05-22T17:32:34Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Fixed in #263 ",
          "createdAt": "2023-06-04T20:29:01Z",
          "updatedAt": "2023-06-04T20:29:01Z"
        }
      ]
    },
    {
      "number": 262,
      "id": "I_kwDOF8lax85kvGB6",
      "title": "Bound BBS signatures",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/262",
      "state": "OPEN",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Hey all!\r\n\r\nPosting a first draft of bound BBS signatures, using BLS key pairs: https://basileioskal.github.io/bbs-bound-signatures/draft-bound-bbs-signatures.html\r\n\r\nYou can find the repo [here](https://github.com/BasileiosKal/bbs-bound-signatures)\r\n\r\n(for context see also #28 and #37)\r\n",
      "createdAt": "2023-04-30T20:17:12Z",
      "updatedAt": "2024-09-01T10:03:22Z",
      "closedAt": null,
      "comments": [
        {
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Can you make the html link show up in the github page fro the repo?",
          "createdAt": "2023-05-01T13:47:51Z",
          "updatedAt": "2023-05-01T13:47:51Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed on WG call 1st of May, In order to better support this draft we have identified a couple of places that the core draft could be better, @BasileiosKal will raise some issues to capture these concepts.",
          "createdAt": "2023-05-01T18:37:01Z",
          "updatedAt": "2023-05-01T18:37:01Z"
        },
        {
          "author": "Wind4Greg",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi Vasilis, I did an initial read. I think the curve BLS12-381 curve library I use has a pretty good BLS signature implementation. Let us know if/when you've got some test vectors and I can try a JavaScript implementation. Cheers Greg",
          "createdAt": "2023-05-02T17:30:02Z",
          "updatedAt": "2023-05-02T17:30:02Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@OR13 made the link available. You can find it [here](https://basileioskal.github.io/bbs-bound-signatures/draft-bound-bbs-signatures.html) or from the [README](https://github.com/BasileiosKal/bbs-bound-signatures/blob/main/README.md). Thank you for the recommendation!",
          "createdAt": "2023-05-02T18:00:48Z",
          "updatedAt": "2023-05-02T18:00:48Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@Wind4Greg That's awesome!! We have an implementation of the draft so we will be able to post some test vectors soon. Thank you!",
          "createdAt": "2023-05-02T18:01:10Z",
          "updatedAt": "2023-05-02T18:01:10Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It seems like the verification is missing a way to pass in the BP_1 generator point to BbsVerify. We might need to add a CoreProofVerify operation which is called by ProofVerify and accepts the list of generators as input.\r\n\r\nI'm a little unsure about just adding `BBS_BOUND` to the header instead of defining a new ciphersuite, since signing is not the same operation.\r\n\r\nFor our applications I think I would also prefer a zero-knowledge proof of key possession and blind signing similar to the old implementation, but that would lose the benefit of delegating to the BLS draft.",
          "createdAt": "2023-05-15T19:13:46Z",
          "updatedAt": "2023-05-15T19:13:46Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for the feedback @andrewwhitehead \ud83d\ude4f \r\n\r\n> It seems like the verification is missing a way to pass in the BP_1 generator point to BbsVerify. \r\n\r\nBbsVerify should be using this `create_generators`. Wouldn't this be enough??\r\n\r\n> I'm a little unsure about just adding BBS_BOUND to the header instead of defining a new ciphersuite, \r\n\r\nI agree. This was a temporally solution until we define a new ciphersuite. The structure of a bound ciphersuite will depend on the flexibility of the core draft, so waiting for that discussion there to move on a bit first.\r\n\r\n> For our applications I think I would also prefer a zero-knowledge proof of key possession and blind signing similar to the old implementation, but that would lose the benefit of delegating to the BLS draft.\r\n\r\nAs an alternative, we could also make one document that encapsulates both generic Schnorr-like commitments and BLS signatures. The flow is the same, so we could define `commitmentGen` in a `commitmentVerify` in a generic way.",
          "createdAt": "2023-05-21T17:08:46Z",
          "updatedAt": "2023-05-21T17:08:46Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> BbsVerify should be using this create_generators. Wouldn't this be enough??\n\nI missed that `create_generators` is redefined, I think that does simplify things.",
          "createdAt": "2023-05-21T18:16:28Z",
          "updatedAt": "2023-05-21T18:16:28Z"
        },
        {
          "author": "matsutakk",
          "authorAssociation": "NONE",
          "body": "Hi, I'm interested in this, any updates??",
          "createdAt": "2024-08-06T05:51:41Z",
          "updatedAt": "2024-08-06T05:51:41Z"
        },
        {
          "author": "matthiasgeihs",
          "authorAssociation": "NONE",
          "body": "hey, does there exist a prototype implementation of this?",
          "createdAt": "2024-08-29T09:18:05Z",
          "updatedAt": "2024-08-29T09:18:05Z"
        },
        {
          "author": "matthiasgeihs",
          "authorAssociation": "NONE",
          "body": "@Wind4Greg have you found the time to code up a prototype?",
          "createdAt": "2024-08-29T09:19:34Z",
          "updatedAt": "2024-08-29T09:19:34Z"
        },
        {
          "author": "Wind4Greg",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi @matthiasgeihs we are using  [Blind BBS Signatures](https://www.ietf.org/archive/id/draft-kalos-bbs-blind-signatures-01.html#) to implement  a  form  of holder  binding  for verifiable credentials [VC-DI=BBS: anonymous holder  binding](https://w3c.github.io/vc-di-bbs/#anonymous-holder-binding).   My  implementation of Blind BBS can be  found at https://github.com/Wind4Greg/grotto-bbs-signatures. Cheers Greg",
          "createdAt": "2024-08-30T15:34:10Z",
          "updatedAt": "2024-08-30T15:34:10Z"
        },
        {
          "author": "matthiasgeihs",
          "authorAssociation": "NONE",
          "body": "Hi @Wind4Greg, thank you for your reply.\r\n\r\nCan the holder secret be used to create signatures on other documents as well?\r\n\r\nUse case: A credential holder wants to sign a different document using the holder secret. The holder also wants to prove that the signature was created by someone who fulfills certain properties certified in the holder credential. The holder doesn't want to reveal anything else about its identity (i.e., signature and proofs should be zero-knowledge).",
          "createdAt": "2024-09-01T10:03:20Z",
          "updatedAt": "2024-09-01T10:03:20Z"
        }
      ]
    },
    {
      "number": 265,
      "id": "I_kwDOF8lax85oNhw8",
      "title": "Andrew's comment",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/265",
      "state": "CLOSED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Tracking Issue for @andrewwhitehead's comment in PR #257: \r\n\r\nComment: https://github.com/decentralized-identity/bbs-signature/pull/257#pullrequestreview-1468296014\r\n",
      "createdAt": "2023-06-08T17:41:26Z",
      "updatedAt": "2023-07-31T18:47:33Z",
      "closedAt": "2023-07-31T18:47:33Z",
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "My own comments on this are; \r\n\r\n> In future I may want to suggest moving c to the end of the serialized proof so that it's easier to remove \r\n\r\nNot opposed to this, but this will affect how de serialization works.\r\n\r\n> also tempted to reorder Abar before Bbar in the equation\r\n\r\nYou mean [here](https://github.com/decentralized-identity/bbs-signature/pull/257/files#diff-af5e5e8fae3b8177ffbea885a6a9b1623c4fb790bc8eeaeef38d92706b30d0d1R550) for `C`??\r\n",
          "createdAt": "2023-06-08T17:44:59Z",
          "updatedAt": "2023-06-08T17:44:59Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> You mean [here](https://github.com/decentralized-identity/bbs-signature/pull/257/files#diff-af5e5e8fae3b8177ffbea885a6a9b1623c4fb790bc8eeaeef38d92706b30d0d1R550) for `C`??\r\n\r\nYep, just because it feels slightly inconsistent when outputting (Abar, Bbar..) in the next line.",
          "createdAt": "2023-06-08T17:47:54Z",
          "updatedAt": "2023-06-08T17:47:54Z"
        }
      ]
    },
    {
      "number": 270,
      "id": "I_kwDOF8lax85pQywO",
      "title": "Signed integers",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/270",
      "state": "CLOSED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Is there a need to sign a signed integer??\r\n\r\nTMU no?? If someone wants a msg to be a signed integer,  they can transform it to an unsigned int before signing/proofGen using something like 2s complements and then back to a signed int after signature/proof verification.\r\n\r\nSame for range proofs. Isn't proving that `-2^(n - 1) < msg < 0` equivalent to proving that `2^(n-1) < msg' < 2^n - 1` where `msg'` the 2's complement of `msg`??\r\n\r\nIs there any use case that would require a message to be a signed integer??",
      "createdAt": "2023-06-20T19:18:02Z",
      "updatedAt": "2023-10-23T18:45:44Z",
      "closedAt": "2023-10-23T18:45:44Z",
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closing as completed",
          "createdAt": "2023-10-23T18:45:44Z",
          "updatedAt": "2023-10-23T18:45:44Z"
        }
      ]
    },
    {
      "number": 278,
      "id": "I_kwDOF8lax85rxo2R",
      "title": "Messages to Scalars",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/278",
      "state": "CLOSED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "core"
      ],
      "body": "Messages need to be mapped to scalar values before they are signed. The criteria on the procedure to do so are flexibility and security.\r\n\r\nTo allow for predicate proofs, blind/ bound signatures etc, we need to allow for messages to be already scalars before passed to the core operations. An approach is the following\r\n\r\n```\r\n                           + --- msg, if msg a scalar \r\n                          /\r\nmessage_to_scalar(msg) = <\r\n                          \\\r\n                           + --- hash_to_scalar(msg), if msg an octet string\r\n```\r\n\r\nThis is not ideal. Assuming that the prover is relaying to the verifier the msg type, for a given octet-string msg `m`, they could reveal `octets: m` or ` scalar: hash_to_scalar(m)` and both would validate.\r\n\r\n# Option A\r\n\r\nIntegrity protect a map between msg index and msg type (octets/scalar). This is inspired by [U-Prove](https://github.com/microsoft/uprove-node-reference/blob/main/doc/U-Prove%20Cryptographic%20Specification%20V1.1%20Revision%205.pdf) that does something very similar, as noted by @christianpaquin [here](https://github.com/decentralized-identity/bbs-signature/pull/268#issuecomment-1629487470).\r\n\r\nSpecifically, let the bit array `enc = enc_1 || enc_2 || ... || enc_L` where `enc_j := msg_j is a scalar`. Then `enc` will be computed in `Sign`, `Verify` and `ProofGen` and added to the `domain`.\r\n\r\nIn `ProofVerify`, the `enc` value cannot be computed (not all messages will be known). There are 2 options,\r\n- Add `enc` to the proof value.\r\n- Add `enc` as an input to `ProofVerify`.\r\n\r\nIn any case, in `ProofVerify`, the disclosed messages type should be checked against `enc`. \r\n\r\n## Advantages\r\n\r\nThis avoids the above issue of the prover revealing msgs as scalars that they where signed as octets.\r\n\r\n## Disadvantages\r\n\r\nA breaking change. It will add a fare amount of steps for something that is an extension point. It will require changes to the proof value or the `ProofVerify` api.\r\n\r\n \r\n# Option B\r\n\r\nSimilar to option A but layered on top of the current core operations. Allow for higher level applications to define schemas that will be passed to the `header` (instead of the `domain` as in option A).\r\n\r\nWe can pass the `header` (that will encode the schema) to the [messages\\_to\\_scalars](https://identity.foundation/bbs-signature/draft-irtf-cfrg-bbs-signatures.html#name-messages-to-scalars) and [map\\_to\\_scalar](https://identity.foundation/bbs-signature/draft-irtf-cfrg-bbs-signatures.html#name-map-to-scalar) operations.\r\n\r\nAssume the schema is encoded as the `enc` bit array defined above, we can set `header = enc || old_header`. Then we will map a msg like\r\n\r\n```\r\nscalar_value = map_to_scalar(msg, idx, header)\r\n\r\nProcedure:\r\n\r\n1. if header[idx] == 1 and msg a scalar: return msg\r\n2. else if header[idx] == 0 and msg an octet string: return hash_to_scalar(msg)\r\n3. else return INVALID\r\n```\r\n\r\n## Advantages\r\n\r\nSolves the issue. Not a breaking change. Minimum updates in general.\r\n\r\n## Disadvantages\r\n\r\nWe can't define the above `map_to_scalar` in the core draft, if we don't want to define the concept of a schema (i.e., of the `enc` bit array that will be added to the `header`).\r\n",
      "createdAt": "2023-07-17T16:51:59Z",
      "updatedAt": "2023-10-23T18:44:19Z",
      "closedAt": "2023-10-23T18:44:18Z",
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Couple of alternatives:\r\n- Relax the [requirements](https://identity.foundation/bbs-signature/draft-irtf-cfrg-bbs-signatures.html#name-define-a-new-map-to-scalar) of `map_to_scalar` to be 1 to 1, and describe that in case that property does not hold, it needs to be clear which message corresponds to a scalar value using external mechanisms (i.e., a schema).\r\n- Define a `map_to_scalar` that only accepts scalar values and manage the mapping to higher level documents/extensions.\r\n\r\nNone of this will require a breaking change (or even a change to a procedure step).",
          "createdAt": "2023-07-17T16:56:16Z",
          "updatedAt": "2023-07-17T16:56:16Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closing after #287 was merged",
          "createdAt": "2023-10-23T18:44:18Z",
          "updatedAt": "2023-10-23T18:44:18Z"
        }
      ]
    },
    {
      "number": 279,
      "id": "I_kwDOF8lax85ryK3Y",
      "title": "Need to add new paper as reference",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/279",
      "state": "CLOSED",
      "author": "Wind4Greg",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "ready-for-pr",
        "core"
      ],
      "body": "We need the new IACR/Eurocrypt paper as a reference since this is the basis for our algorithms now.",
      "createdAt": "2023-07-17T18:09:37Z",
      "updatedAt": "2023-12-18T19:45:12Z",
      "closedAt": "2023-12-18T19:45:12Z",
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on the WG call at the 18th of Dec. Closing as resolved.",
          "createdAt": "2023-12-18T19:45:12Z",
          "updatedAt": "2023-12-18T19:45:12Z"
        }
      ]
    },
    {
      "number": 280,
      "id": "I_kwDOF8lax85tEYs4",
      "title": "Split out CoreSign / CoreVerify / CoreProofGen / CoreProofVerify?",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/280",
      "state": "CLOSED",
      "author": "andrewwhitehead",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This would potentially simplify the mapping of scalars, while providing extension points for applications that reduces ambiguity around the method usage.\r\n\r\n`CoreSign` would accept the secret key, public key, a list of generators, and the list of messages in scalar format only. Callers would be responsible for ensuring the correct mapping from input messages to scalars (added to security considerations). This also allows applications to use an augmented or alternative list of generators, still verified as part of the domain.\r\n\r\n`Sign` would then only accept messages as octet strings, and would pass each message to `hash_to_scalar`. I think it might also make sense to have `Sign` append the mapping method ('HM2S') to the header before passing it to `CoreSign`, and remove the mapping method from the ciphersuite ID (!).\r\n\r\nSimilarly, `CoreVerify`, `CoreProofGen`, and `CoreProofVerify` would accept the list of generators as well as the messages in scalar format.\r\n\r\nI was thinking this might simplify usage in blinded signatures and bound signatures, but supplying a custom `e` value when signing is not supported. Should it be? That would require more security considerations unfortunately.\r\n\r\nPotential benefits:\r\n- No `input_messages` type \u2013 messages are octet strings in one context, and scalars in another. Simper type definitions, which might be compatible with more languages (no union type)\r\n- No `map_to_scalar`, `map_to_scalar_as_hash`\r\n- Would resolve #254 (no need for an application definition) and #278\r\n\r\nDownsides:\r\n- Potential misuse of core operations, not verifying the message mapping\r\n- More methods\r\n- Breaking changes\r\n- Need to outline security considerations for applications using the core methods",
      "createdAt": "2023-07-31T19:20:27Z",
      "updatedAt": "2023-10-23T18:12:35Z",
      "closedAt": "2023-10-23T18:12:35Z",
      "comments": [
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As mentioned on the mailing list there might be a desire to use alternative formats for message indexes. This could also be handled by passing the message indexes to the core operations, or moving them to the header, and defaulting to integer values in Sign/Verify.",
          "createdAt": "2023-07-31T19:30:34Z",
          "updatedAt": "2023-07-31T19:30:34Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Im in favor of this proposal if we can avoid breaking changes. Opened PR #282 to take a shot at it.\r\n\r\nCouple of comments:\r\n\r\n> As mentioned on the mailing list there might be a desire to use alternative formats for message indexes. This could also be handled by passing the message indexes to the core operations, or moving them to the header, and defaulting to integer values in Sign/Verify.\r\n\r\nI'm not sure its worth it. In ProofGen there will be the need for a map between alternative message index -> integer idx to pass it to the CoreProofGen. This will potentially loose the main advantage of the alternative IMO, which is that we will not have to worry about the messages order.\r\n\r\n> Would resolve ... #278\r\n\r\nOnly if we elect to not define a generic map or corresponding the requirements?? It may be useful to at least provide some guidance though?\r\n\r\n> I was thinking this might simplify usage in blinded signatures and bound signatures, but supplying a custom e value when signing is not supported. Should it be? That would require more security considerations unfortunately.\r\n\r\nIMO it should not. Iv added a \"commitment\" value to `CoreSign` in my PR. It adds some complexity in the main document but IMHO it is preferred than adding a custom `e` value.",
          "createdAt": "2023-08-21T16:23:35Z",
          "updatedAt": "2023-08-21T16:23:35Z"
        }
      ]
    },
    {
      "number": 283,
      "id": "I_kwDOF8lax85u2e6E",
      "title": "Update hash-to-curve reference",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/283",
      "state": "CLOSED",
      "author": "andrewwhitehead",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "It's an RFC now: https://datatracker.ietf.org/doc/rfc9380/",
      "createdAt": "2023-08-21T16:56:57Z",
      "updatedAt": "2023-12-18T22:24:09Z",
      "closedAt": "2023-12-18T22:24:09Z",
      "comments": []
    },
    {
      "number": 284,
      "id": "I_kwDOF8lax85v0sTh",
      "title": "BBS with fewer or no pairings",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/284",
      "state": "OPEN",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "As discussed on our WG call, here's a first draft on BBS Signatures with less or no pairing operations:\r\n\r\nhttps://basileioskal.github.io/pairing-free-bbs/draft-vasilis-pairing-free-bbs.html\r\n\r\nYou can find the repo [here](https://github.com/BasileiosKal/pairing-free-bbs). Note that after review, if consensus is achieved, the intention is for the document to become part of this repository.\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "createdAt": "2023-08-31T18:36:21Z",
      "updatedAt": "2024-10-09T03:21:21Z",
      "closedAt": null,
      "comments": [
        {
          "author": "NikZak",
          "authorAssociation": "NONE",
          "body": "Interesting. Can you describe the use case for verification with knowledge of secret key?",
          "createdAt": "2024-10-09T03:21:20Z",
          "updatedAt": "2024-10-09T03:21:20Z"
        }
      ]
    },
    {
      "number": 285,
      "id": "I_kwDOF8lax85xLB26",
      "title": "Use non-zero scalars",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/285",
      "state": "CLOSED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "R.n. in the document we describe inputs (like messages, parts of the signature etc) as \"Scalars\". We should require them to be non-zero though.\r\n\r\nChanging the `scalar` to `non-zero scalar` in the inputs description is probably enough?? (i.e., no need to add the explicit tests during the operation).",
      "createdAt": "2023-09-15T16:05:39Z",
      "updatedAt": "2023-12-18T19:34:50Z",
      "closedAt": "2023-12-18T19:34:50Z",
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on the WG call at the 23rd of Oct. Will need points the non zero check needs to happen.",
          "createdAt": "2023-10-23T18:41:02Z",
          "updatedAt": "2023-10-23T18:41:02Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on the WG call 18th of Dec. Closing as resolved.",
          "createdAt": "2023-12-18T19:34:50Z",
          "updatedAt": "2023-12-18T19:34:50Z"
        }
      ]
    },
    {
      "number": 286,
      "id": "I_kwDOF8lax85xNTc3",
      "title": "Prediccate proofs and revocation",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/286",
      "state": "OPEN",
      "author": "hasinitg",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Hi,\r\n\r\nCan you please provide any information on whether there are any plans for supporting predicate proofs on identity attributes and revocation on credentials alongside the standardization of BBS+ signatures for identity credentials?\r\n\r\nThank you!",
      "createdAt": "2023-09-16T05:58:05Z",
      "updatedAt": "2023-09-16T05:58:05Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 292,
      "id": "I_kwDOF8lax851_Oor",
      "title": "Blind BBS Signatures",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/292",
      "state": "OPEN",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "New (updated) draft on blind signatures: https://basileioskal.github.io/blind-bbs-signatures/draft-bbs-blind-signatures.html\r\n\r\nCouple notes:\r\n- It seems that the commitment value added in `CoreSign` in the main draft is not useful after all. Will probably remove it.\r\n- If agreed, the above would probably replace the current draft and hopefully be submitted at the IETF as well.\r\n- Will add test vectors soon.",
      "createdAt": "2023-11-06T16:03:25Z",
      "updatedAt": "2023-11-27T17:28:20Z",
      "closedAt": null,
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fixtures added: https://github.com/BasileiosKal/blind-bbs-signatures/tree/main/fixtures/fixture_data",
          "createdAt": "2023-11-27T17:28:19Z",
          "updatedAt": "2023-11-27T17:28:19Z"
        }
      ]
    },
    {
      "number": 295,
      "id": "I_kwDOF8lax852V10F",
      "title": "Serialize returns INVALID",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/295",
      "state": "CLOSED",
      "author": "rolfhaenni",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The serialize() algorithm in Section 4.2.4.1 does not include the case where an element of the input array is a string.\r\nHowever, exactly this happens in Lines 4 of coreSign(), where the string comm passed as input value to serialize(). Therefore, currently serialize() would return the value INVALID. Besides, the commitment is missing in Line 2 of CoreVerify().\r\n",
      "createdAt": "2023-11-09T11:36:43Z",
      "updatedAt": "2023-12-18T19:31:09Z",
      "closedAt": "2023-12-18T19:31:09Z",
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This is absolutely correct! Resolved by [PR 297](https://github.com/decentralized-identity/bbs-signature/pull/297). The `commitment` value is removed since it did not seem to serve much its original purpose, which was to support Blind BBS Signatures, now [its own document](https://github.com/decentralized-identity/bbs-signature/issues/292).\r\n\r\nThank you for raising the issue! Will mark it as resolved and close it if there are no objections.",
          "createdAt": "2023-12-04T20:34:26Z",
          "updatedAt": "2023-12-04T20:34:26Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on WG call at the 18th of Dec. Closing as resolved.",
          "createdAt": "2023-12-18T19:31:09Z",
          "updatedAt": "2023-12-18T19:31:09Z"
        }
      ]
    },
    {
      "number": 308,
      "id": "I_kwDOF8lax858YEuo",
      "title": "Misspelling in api_id",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/308",
      "state": "OPEN",
      "author": "roblesjoel",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Hey there,\r\n\r\nFirst some context.\r\nWe are students of the Bern University of Applied Sciences.\r\nWe are making a Java implementation of your Draft as a pre-requisite of our Bachelors thesis.\r\nsee: https://github.com/RockstaYT/P2_BBS_Signature\r\n\r\nAs part of this project we also went over the Draft and saw some spelling errors.\r\nWould be nice if you could fix them if you have time :)\r\n\r\nFirst error is:\r\n\r\n`ciphersuite and and \"H2GHM2S\"` in 3.5. BBS Signature Interface\r\n\r\nShouldn't it be `ciphersuite and and \"H2G_HM2S_\"`?",
      "createdAt": "2024-01-17T17:52:01Z",
      "updatedAt": "2024-01-22T18:58:24Z",
      "closedAt": null,
      "comments": [
        {
          "author": "Wind4Greg",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi @RockstaYT, glad to see another implementation under way. I don't think there is a Java implementation yet. I've been working on a JavaScript only implementation [JavaScript BBS Signatures](https://www.npmjs.com/package/@grottonetworking/bbs-signatures), there are some in TypeScript, and Rust that I know of. \r\n\r\nNote that we have weekly calls Mondays 11AM (PST) via [DIF Applied Crypto WG](https://identity.foundation/working-groups/crypto.html). Also note that DIF is free to join for individuals and gives you access to the zoom calls and slack channel. We go over the latest issues on the call.",
          "createdAt": "2024-01-18T17:42:34Z",
          "updatedAt": "2024-01-18T17:42:34Z"
        },
        {
          "author": "roblesjoel",
          "authorAssociation": "NONE",
          "body": "Hey @Wind4Greg, thank you for the invite!\r\nI was accepted yesterday as an DIF Member, but sadly im not receiving the slack invite.\r\nMaybe you could fix that in todays call.\r\nMy email would either be joel.roblesgasser@proton.me (preffered) or joel.robles@ryu.land\r\nWill delete this comment tomorrow, as it doesnt add anything to the discussion :)",
          "createdAt": "2024-01-22T18:58:23Z",
          "updatedAt": "2024-01-22T18:58:23Z"
        }
      ]
    },
    {
      "number": 309,
      "id": "I_kwDOF8lax858YJUA",
      "title": "Referencing wrong step in pseudocode",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/309",
      "state": "CLOSED",
      "author": "roblesjoel",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "In 3.6.1 CoreSign there is the note\r\n`Note When computing step 12 of`\r\n\r\nbut it should be\r\n`Note When computing step 4 of`\r\n\r\nas there is no step 12.\r\n\r\nIn the same note at the end\r\n\r\n`Implementations MAY elect to check (SK + e) = 0 mod r prior to step 9, and or A != Identity_G1 after step 9`\r\n\r\nshould be\r\n\r\n`Implementations MAY elect to check (SK + e) = 0 mod r prior to step 4, and or A != Identity_G1 after step 4`",
      "createdAt": "2024-01-17T18:02:22Z",
      "updatedAt": "2024-09-19T19:35:17Z",
      "closedAt": "2024-09-19T19:35:17Z",
      "comments": []
    },
    {
      "number": 310,
      "id": "I_kwDOF8lax858Z9V4",
      "title": "Checking wrong number of generators in proof validation",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/310",
      "state": "OPEN",
      "author": "roblesjoel",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "In 3.5.4 Proof verification, U + R + 1 generators are created.\r\nR = number of disclosed index\r\nU = number of commitments + 2 \r\n\r\nThen in 3.7.3, a verification of the number of generators takes place:\r\n`11. if length(generators) != L + 1, return INVALID`\r\n\r\nwhere L = number of commitments + number of disclosed indexes.\r\n\r\nThis is incorrect.\r\nAssuming 0 commitments and 0 disclosed indexes:\r\nR = 0, U = 0 + 2, generators created (U + R + 1) = 3\r\n\r\nL = 0 (as no commitments and no messages to be disclosed), generators checked (L + 1) = 1\r\n\r\nMy proposition:\r\n\r\n**Instead of checking L + 1, it should be L + 3.**",
      "createdAt": "2024-01-17T23:27:17Z",
      "updatedAt": "2024-01-17T23:58:49Z",
      "closedAt": null,
      "comments": [
        {
          "author": "roblesjoel",
          "authorAssociation": "NONE",
          "body": "After tinkering more with the code, wondering why it did not work i found out something more.\r\nThe challenge check in CoreProofVerify was returning INVALID.\r\n\r\nI looked at the objects and saw that init_res was different in the ProofVerify step than the ProofGen Step.\r\n\r\nIn the ProofGen we generate then number of messages + 1 number of generators.\r\nIn the ProofVerify we generate U (number of commitments) + number of disclosed indexes + 2.\r\nThe problem for me lies with:\r\n`1. proof_len_floor = 2 * octet_point_length + 3 * octet_scalar_length`\r\n\r\nThe Proof had 5 Elements + msg scalars, but with the newest draft it was updated to 7 Elements + msg scalars.\r\nso the proof_len_floor value is incorrect, but that is also the value which is used to calculate U.\r\n\r\nThe correct version would be:\r\n`1. proof_len_floor = 3 * octet_point_length + 4 * octet_scalar_length`\r\nWith that U would be correct and represent the number of msg scalars.\r\n\r\nNow there is still an error.\r\n\r\nR + U + 2 is not completely correct.\r\n\r\nRemember in ProofGen we only generate total messages + 1 generators.\r\nR + U should represent the number of total messages (number of disclosed indexes + those messages which are not disclosed).\r\nSo it should be **R + U + 1**\r\n\r\nWith that we generate the correct number of generators.\r\nSo instead of changing L + 1 to L + 3, we need to change the proof_len_floor calc and the amount of generators to be generated.\r\n\r\n",
          "createdAt": "2024-01-17T23:58:49Z",
          "updatedAt": "2024-01-17T23:58:49Z"
        }
      ]
    },
    {
      "number": 311,
      "id": "I_kwDOF8lax858f6gr",
      "title": "Mistake in Test Vector for SHA-256 MsgToScalars",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/311",
      "state": "OPEN",
      "author": "roblesjoel",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "In the Test vector \"[D.2.3. ](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-bbs-signatures-05#appendix-D.2.3)[Hash to Scalar Test Vectors](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-bbs-signatures-05#name-hash-to-scalar-test-vectors-2)\"\r\nthe dst is \"4242535f424c53313233383147315f584d443a5348412d3235365f535357555f524f5f4832475f484d32535f4832535f\"\r\n\r\nin your own [files](https://github.com/decentralized-identity/bbs-signature/blob/main/tooling/fixtures/fixture_data/bls12-381-sha-256/MapMessageToScalarAsHash.json) the used dst is as follows:\r\n\"4242535f424c53313233383147315f584d443a5348412d3235365f535357555f524f5f4832475f484d32535f4d41505f4d53475f544f5f5343414c41525f41535f484153485f\"\r\n\r\nWith the dst in your files the test vector works",
      "createdAt": "2024-01-18T17:23:04Z",
      "updatedAt": "2024-01-18T17:23:04Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 313,
      "id": "I_kwDOF8lax85-SofS",
      "title": "Support Bounded-Memory Implementations with a single Message Pass",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/313",
      "state": "CLOSED",
      "author": "bellebaum",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Hi all,\r\n\r\nI am trying to implement the IETF-draft in C using no dynamically allocated memory, thus suitable for e.g. embedded devices with no heap implementation.\r\n\r\nThere are only a few places in the specification which are troublesome to such an endeavour and I wanted to share these with you, and suggest improvements, should you wish to explicitly support this use case.\r\n\r\nFor efficiency, there are two critical points to consider:\r\n\r\nIdeally, it should be possible to only go over every message once per high level API call (Sign, Verify, ProofGen, ProofVerify). Among other things, this requires being able to generate message scalars individually, given a message's index and optionally the total number of messages (which the current draft supports).\r\n\r\nLikewise, it would be helpful if one could avoid generating the generators more than once during such API calls.\r\n\r\nLet us briefly go over every high-level API function dealing with messages to see how this would work. Below algorithm sketches rely on the ability to incrementally hash arbitrary octet strings, but this is typical with many hashing APIs.\r\n\r\n### Sign\r\n\r\n`Sign` can be implemented with a single message pass. While iterating over the messages, the algorithm would use `B` as an accumulator, and incrementally prepare the input to hash into `e` (as part of `hash_to_scalar`).\r\n\r\n`Sign` does not allow to only generate generators once when doing this: Before adding any messages to be hashed into `e`, the `domain` must be added, for which all generators must already be generated. Then while accumulating `B`, the generators need to be regenerated, as there is no way to store an arbitrary amount of generators in bounded memory.\r\n\r\nA simple fix would be to reorder the inputs to the generation of `e`:\r\n\r\n```\r\n2. e = hash_to_scalar(serialize((SK, msg_1, ..., msg_L, domain)), signature_dst)\r\n```\r\n\r\nThis should not have an effect on security, as `e` is essentially only supposed to be \"random\" but unique for each message. But please double-check :)\r\n\r\n### Verify\r\n\r\n`Verify` can be implemented efficiently due to commutativity of field elements. Essentially, one iterates over the messages, generates generators on the fly, accumulates \"generator * message_scalar\" into `B` while adding the generators to the domain-Hash, and finally adds `Q_1 * domain` to `B`.\r\n\r\n### ProofGen\r\n\r\nOther than some ideas from above, this function runs into two issues, one of which is easily fixed.\r\n\r\n1. The `m_tilde` values need to be generated before the the challenge phase (accumulated into `T2` and hashed into the challenge) and after it (to generate `m_hat`s, which are part of the signature). Fortunately, the values are essentially pseudorandom, and can deterministically be regenerated from a PRG at little to no cost. An algorithm would store the undisclosed message scalars temporarily into the proof, and after the challenge phase multiply it with the challenge and add `m_tilde`.\r\n\r\n2. The challenge calculation hashes first `Bbar` and friends, then the messages. Because the messages are required for the calculation of `B`, an implementation has to iterate over them multiple times. The fix involves a reordering of the inputs to the random oracle, which again should not have an impact on security. The ideal ordering would look like this:\r\n\r\n```\r\n1. c_arr = (R, i1, msg_i1, ..., iR, msg_iR, Abar, Bbar, D, T1, T2, domain)\r\n```\r\n\r\n### ProofVerify\r\n\r\nBesides the problems already mentioned, this function seems fine. In particular, the modified challenge calculation should work here as well.\r\n\r\n## TL;DR\r\n\r\nBy reording a few inputs to hash functions in two places, low-resource implementations can become potentially a lot more efficient. Thanks for reading :)",
      "createdAt": "2024-02-05T15:19:57Z",
      "updatedAt": "2024-06-25T08:30:56Z",
      "closedAt": "2024-06-25T08:30:56Z",
      "comments": [
        {
          "author": "bellebaum",
          "authorAssociation": "NONE",
          "body": "Adding some references for further reading to our implementation:\r\n\r\n### Sign\r\n\r\nWe would like to hash the generators into the domain [here](https://github.com/Fraunhofer-AISEC/libbbs/blob/553a0dab50b1ac95b2c8bf177d3f6a7c20a71b92/src/bbs.c#L283-L285)\r\nBut since at that point we also need to hash the message scalars into e [here](https://github.com/Fraunhofer-AISEC/libbbs/blob/553a0dab50b1ac95b2c8bf177d3f6a7c20a71b92/src/bbs.c#L306), we have to create the generators twice [here](https://github.com/Fraunhofer-AISEC/libbbs/blob/553a0dab50b1ac95b2c8bf177d3f6a7c20a71b92/src/bbs.c#L227) and [here](https://github.com/Fraunhofer-AISEC/libbbs/blob/553a0dab50b1ac95b2c8bf177d3f6a7c20a71b92/src/bbs.c#L265-L282).\r\n\r\n### Verify\r\n\r\nWithin one loop, we calculate the message scalars and generators exactly once [here](https://github.com/Fraunhofer-AISEC/libbbs/blob/553a0dab50b1ac95b2c8bf177d3f6a7c20a71b92/src/bbs.c#L441-L472).\r\n\r\n### ProofGen\r\n\r\nFor any random scalars, we use `hash_to_scalar` as a PRF and derive scalars for undisclosed messages [here](https://github.com/Fraunhofer-AISEC/libbbs/blob/553a0dab50b1ac95b2c8bf177d3f6a7c20a71b92/src/bbs.c#L716-L720) and [here](https://github.com/Fraunhofer-AISEC/libbbs/blob/553a0dab50b1ac95b2c8bf177d3f6a7c20a71b92/src/bbs.c#L917-L920).\r\nWe still need to iterate over the disclosed messages for the challenge twice [here](https://github.com/Fraunhofer-AISEC/libbbs/blob/553a0dab50b1ac95b2c8bf177d3f6a7c20a71b92/src/bbs.c#L682-L698) and [here](https://github.com/Fraunhofer-AISEC/libbbs/blob/553a0dab50b1ac95b2c8bf177d3f6a7c20a71b92/src/bbs.c#L821-L848) for the challenge.",
          "createdAt": "2024-02-16T10:05:08Z",
          "updatedAt": "2024-02-16T10:05:08Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hello, sorry about the lack of feedback here but we did discuss this on the weekly meeting a few weeks ago. Because we have requested a cryptographic review of the draft we are waiting to see what issues might come up there before making any algorithm changes, but we are definitely supportive of such an update.",
          "createdAt": "2024-02-29T18:23:38Z",
          "updatedAt": "2024-02-29T18:23:38Z"
        },
        {
          "author": "bellebaum",
          "authorAssociation": "NONE",
          "body": "Hello Andrew,\r\nthat is great to hear. I have also proposed an alternative [on the CFRG mailing list](https://mailarchive.ietf.org/arch/msg/cfrg/w2Tw5F2sWLHk6aQbML_M2MScHnc/), which would be even more efficient, because it need not hash the messages at all for both `e` and the challenge. That optimization however is something which definitely requires cryptographic review, so one might want to consider pitching the option to the people reviewing the current draft.",
          "createdAt": "2024-03-01T10:16:59Z",
          "updatedAt": "2024-03-01T10:16:59Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The revealed messages were actually added to the presentation challenge hash to avoid this issue: https://github.com/decentralized-identity/bbs-signature/issues/74\r\n\r\nThe draft has changed since then, but I believe the message & index hashing is still necessary in this case. Whether the message hashing is necessary is in the generation of `e` would be a separate issue.",
          "createdAt": "2024-03-04T19:18:41Z",
          "updatedAt": "2024-03-04T19:49:09Z"
        },
        {
          "author": "bellebaum",
          "authorAssociation": "NONE",
          "body": "Let me unravel the value of `T2` in the current draft. Inlining a bunch of calculations in `ProofVerifyInit`, I get that\r\n\r\n```\r\nT2 = P1 * s0 + Q_1 * s1 + H_1 * s2 + H_2 * s3 + ... + H_L * s{L+1}\r\n```\r\n\r\nYou might go on to detail that `s0=c`, `s1=domain*c`, and the other scalars are either prover-chosen \"random\" values or `c*msg_i` values, but importantly for us: They are scalars.\r\n\r\nThe attacks in #74 (and many other attack vectors) crucially rely on not changing the challenge `c`, which (up to collision resistance of the challenge hash function) implies not changing the value `T2`. But this (again, up to some collision resistance) implies not changing the values for the `si` scalars. To see this at a glance (and to point at an actual proof), note that collisions would also break the signature scheme itself. Namely, since the scheme only signs `B`, a collision in the calculation of `B` (which is analogous to the calculation of `T2`) would directly lead to a forgery. This is assuming that the signer and verifier do not hash the messages to scalars, but that was also the point of [this comment](https://github.com/decentralized-identity/bbs-signature/issues/74#issuecomment-1054671606).\r\n\r\nSo if the scalars are fixed, where else could a malicious prover cheat without altering the challenge (which would cause him trouble in the proof finalization stage)? Since `c` is fixed, there is only exactly one value for a message scalar, which would be accepted, namely `si * c^-1`. So to convince a verifier to accept a challenge, the prover has exactly two options per message scalar `si` (i > 1) (besides breaking collision resistance): Publish a message hashing to `si * c^-1` or claim that `si` is a random offset.\r\n\r\nTwo options to address this:\r\n\r\nOption 1: Include the choice of which indexes are disclosed in the challenge. Note that we do not need to include the messages, just their indices.\r\n\r\nOption 2: Rely on the collision resistance of the `hash_to_scalar` function.\r\n\r\nThe main argument for option 1 would be that there seem to be some people who do not want to rely on hashing and want to encode numbers as scalars a different way. Having too broad of a scope for a cryptographic algorithm usually leads to misuse, but I see the argument there to attempt to more easily allow for range proofs and alike. With that in mind, let us look at option 2:\r\n\r\nA malicious prover having generated `Nc` challenges and expecting one of `Nv` values for a message scalar they would like to maliciously disclose will have a chance of (roughly) `Nc * Nv / 2^256` of a useful collision allowing them to pull this off. Take all 64 bit integers as disclosable values and assume the attacker is dedicated to generating `2^80` challenges. Their chance of success is about `2^-112`, which is reasonably small.\r\n\r\nBased on this, I would recommend to go with option 2 if there are no documented use cases beyond \"small\" numbers and hashed messages. If there are, I would recommend option 1. Under no circumstances should it be necessary to hash the messages themselves into the challenge.",
          "createdAt": "2024-03-05T10:29:51Z",
          "updatedAt": "2024-03-05T10:29:51Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hello and thank you for raising the issue!\r\n\r\nRegarding the attack from #74, the point was to show that the unforgeability property does not hold. Indeed, if messages are mapped \"only\" through `hash_to_scalar`, the attack is not very useful. However this is not the only option and the draft allows for alternatives.\r\n\r\nYou already noted the use of range proofs. Consider also the case of [pseudonyms](https://basileoskal.github.io/bbs-per-verifier-id/draft-vasilis-bbs-per-verifier-linkability.html). The prover will be able to use a different pseudonym by forging different prover identifiers with each proof generation. As another example, consider a credential id based revocation (where `credeintial_id := random_scalar`).\r\n\r\nFor option 1, I don't see how hashing the indexes avoids the described attack. We assume that the prover is adversarial, meaning that they can hash whatever indexes they want during proof generation.\r\n\r\nFor option 2, in general, AFAIK, security proofs require the entire transcript of the zk-proof to be included in the challenge hash. Even if we accept that all messages should be \u201chashed to scalars\u201d, avoiding the above issue is not equivalent with proving that the scheme is secure. If you are aware of such a proof I would be more than happy to review it. Otherwise, even disregarding the mentioned use cases, the update seems a bit risky to me.",
          "createdAt": "2024-03-06T20:23:11Z",
          "updatedAt": "2024-03-06T20:23:11Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "For the rest of the updates I'm just going to add a +1 to [Andrew's comment](https://github.com/decentralized-identity/bbs-signature/issues/313#issuecomment-1971707874) ;P\r\n\r\nIn the calculation of `e` I think we can replace the messages with `B`. The reason we did not implement it up until now, was to avoid breaking changes. However, given that we are indent to introduce changes either way in other places, we can consider updating the calculation of `e`.\r\n\r\nI will try to implement them and open a PR soon. Would appreciate your review on that. However, as Andrew mentioned, given that we are going under crypto-panel review at this point, it is not clear when those changes will be incorporated to the IETF document.",
          "createdAt": "2024-03-06T20:28:38Z",
          "updatedAt": "2024-03-06T20:32:23Z"
        },
        {
          "author": "bellebaum",
          "authorAssociation": "NONE",
          "body": "Hello Vasilis :)\r\n\r\n> You already noted the use of range proofs. Consider also the case of [pseudonyms](https://basileoskal.github.io/bbs-per-verifier-id/draft-vasilis-bbs-per-verifier-linkability.html)[^1]. The prover will be able to use a different pseudonym by forging different prover identifiers with each proof generation. As another example, consider a credential id based revocation (where credeintial_id := random_scalar).\r\n\r\n[^1]: This link for some reason did not work for me, but I found the source [here](https://github.com/BasileiosKal/bbs-per-verifier-id/blob/main/draft-vasilis-bbs-per-verifier-linkability.md).\r\n\r\nRight, these are very good points. But, working somewhat closely with your draft, let me highlight a possibly simpler solution for such cases:\r\nIn your draft, you have modified the challenge calculation ([in this section](https://github.com/BasileiosKal/bbs-per-verifier-id/blob/main/draft-vasilis-bbs-per-verifier-linkability.md#challenge-calculation)). Abstracting a bit (and ignoring variable ordering), what you have effectively done there is to build an AND-Proof with a Chaum-Pedersen proof of knowledge of `pid_scalar` applied to the (in this case final) generator, a per-verifier base point and your per-verifier pseudonym[^2]. In fact, since the point of your draft is to not disclose the `pid_scalar` (which would lead to cross-verifier linkability), your draft does not rely on hashing disclosed message scalars at all.\r\n\r\n[^2]: By the way, I love how you reuse the random message scalars here to not increase the size of the proof beyond the addition of one message to the signature scheme. Very clever :)\r\n\r\nWhat you have effectively done is to add the claimed pseudonym, its corresponding proof commitment (`U` in your ProofGen, `Uv` in your ProofVerify) and the verifier specific \"base point\" OP to a kind of \"extended presentation header\", which gets hashed into the challenge.\r\n\r\nNote that this works in general for AND-Proof constructions: Add all commitments of your additional proof to the challenge. If you want to reuse the existing interfaces, treat them as part of an extended presentation header. Beyond the `2^64` numbers example I have given above, this should also extend to range proofs for arbitrary value ranges. This appeals to me because it streamlines security analysis of extensions to this draft.\r\n\r\n> For option 2, in general, AFAIK, security proofs require the entire transcript of the zk-proof to be included in the challenge hash. Even if we accept that all messages should be \u201chashed to scalars\u201d, avoiding the above issue is not equivalent with proving that the scheme is secure. If you are aware of such a proof I would be more than happy to review it. Otherwise, even disregarding the mentioned use cases, the update seems a bit risky to me.\r\n\r\nAll formulations of the zk-proof system I have seen treat the disclosed messages as part of the statement, just like the generators, signer public key etc. and prove knowledge of a valid signature including these messages. The system itself then consists of three rounds: A commitment, a challenge and a response. The Fiat Shamir transform calculates the challenge as a hash of the commitment (and an optional presentation header, if your goal is to create a challenge). These constructions are well researched, and there exist proofs for them. However, this is not what we try to achieve here. The disclosed messages are not part of the commitment (which _is_ the transcript of the zk-Proof part) and thus not hashed in all the formulations I have seen.\r\n\r\nThat said, while there are no additional security properties for the zk proof, there might be some additional benefits in the envisioned use cases, where an adversary might succeed in his goals by constructing a malicious proof for one of potentially many statements (because of many messages the attacker would be comfortable maliciously disclosing). Generally, without hashing the statement, there is a standard reduction claiming that an adversary's advantage will at most increase by a factor of `N` when trying to prove one of `N` false statements. This is why in my example above an adversary can maliciously disclose one of `2^64` messages with probability `2^-(256-80-64)` and not `2^-(256-80)`. I argue that this is still not too much easier than breaking the signature scheme itself.\r\n\r\nBut let us assume that all assumptions fail and for some reason there is a kind of value for which the adversary would be happy to disclose almost any value. I claim that this only applies to very few kinds of messages. For these, there is a very simple solution: Hash exactly these disclosed messages, but none other.",
          "createdAt": "2024-03-07T12:35:14Z",
          "updatedAt": "2024-03-07T12:35:14Z"
        },
        {
          "author": "bellebaum",
          "authorAssociation": "NONE",
          "body": "Actually, here is a quick proof-like argument for why hashed scalar values do not need to be added to the challenge hash:\r\n\r\nPick any bound `b` on the number of invocations of `hash_to_scalar` the adversary is willing to perform, which for this exposition I will model as a random oracle. (That is, the total number of challlenge calculations `Nc` plus message scalar calculations `Ns` satisfies `Nc + Ns = b`.)\r\n\r\nAs a baseline, the adversary could use all their hash invocations to come up with a collision in the message scalar calculation, which would give them a simple way to forge a signature. By a simple birthday bound, their success probability is roughly `b^2 / 2^256`. If the best attack on ProofVerify was not much better than this, then this is the more pressing issue.\r\n\r\nNow assume for a moment that the adversary is unable to find different two vectors of `si` values (see above) resulting in the same value of `T2`. From various proofs on the security of the signature scheme it should be clear that this has negligable probability of occuring and would in fact break a no-Hash version of the BBS signature scheme. Then for each invocation of the challenge `hash_to_scalar`, the adversary gets at most one value of `si * c^-1`, which would be accepted by the verifier as a valid message scalar, amounting to at most `Nc` such (random) values. But since all the messages get hashed, the adversary also holds at most `Ns` values of message scalars for which it knows a message. The chance of a collision is thus at most `Ns * Nc / 2^256`, which is worse than the above attack because `Ns * Nc < (Ns + Nc)^2` (For a collision we have `Nc > 0` and `Ns > 0`).",
          "createdAt": "2024-03-07T14:48:39Z",
          "updatedAt": "2024-03-07T14:48:39Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Those are valid points, but I think there is a disconnect. What I meant to say is not proof that the above attack is not possible (which you outlined clearly), when using `hash_to_scalar` but that there is no possibility for any \"similar\" attack. In other words, can we guarantee that the only way to \"forge\" a valid (disclosed or undisclosed) message is by revealing `si * c ^ -1`??\r\n\r\n(note also that we allow for `2^64` messages to be signed. The adversaries goal can then be to find a suitable `si * c^-1` for any `1 =< i < 2^64`, further increasing their chances of success).\r\n\r\nThis is not to claim that there is not such proof. In fact it may very well exist, just by comparing all the values that go into the challenge hash (i.e.,`D`, `T_2` etc) and showcasing that forged messages can ONLY be of the form `si * c ^ -1` and hence, by using `hash_to_scalar` we avoid that problem.\r\n\r\nEven if that is the case however, not sure how comfortable I am with using non published and peer reviewed security proofs (of course depending on their complexity).\r\n\r\n> The Fiat Shamir transform calculates the challenge as a hash of the commitment (and an optional presentation header, if your goal is to create a challenge).\r\n\r\nI think I caused some confusion mentioning a transcript. To better explain, let's use the sigma protocol formulation you mentioned, with a common input `Y`, a commitment `A`, a challenge `c` and a response `f`. As you noted, that the disclosed messages will not be part of `A`, but of `Y`. In this document, when referring to the Fiat-Shamir heuristic, we are actually using the strong Fiat-Shamir transformation described in [[BPW16]](https://eprint.iacr.org/2016/771.pdf). Using that formulation, both `Y` and `A` must be inputted in the challenge hash to get a secure protocol. Note that we have to use the strong Fiat-Shamir transformation, given that `Y` is partially chosen by the (malicious) prover.\r\n\r\n> For these, there is a very simple solution: Hash exactly these disclosed messages, but none other.\r\n\r\nThis could work, however, IMO this solution increases complexity in a worrying amount, creating the danger for implementation errors. If we fully describe how to do this (which we tried before), we make the document more complicated and restrictive. If we don't, and simply add a note saying that \"if you don't use `hash_to_scalar`, pass the messages to the challenge hash\", we are running the danger of people ignoring it, or implementing it wrong.\r\n\r\nThat to say, that for the (i believe) very small efficiency improvement in most cases, I'm not sure if the added complexity (or IMO risk) is worth it. Is this something that would make a significant difference in your use case?? (note that we are willing to apply the suggested re-arrangements).",
          "createdAt": "2024-03-11T17:01:43Z",
          "updatedAt": "2024-03-11T17:01:43Z"
        },
        {
          "author": "bellebaum",
          "authorAssociation": "NONE",
          "body": "> (note also that we allow for 2^64 messages to be signed. The adversaries goal can then be to find a suitable si * c^-1 for any 1 =< i < 2^64, further increasing their chances of success).\r\n\r\nRight, I guess I missed that there is no domain separation in `hash_to_scalar` for different message indexes. Without it, this is indeed dangerous. Even with domain separation, a formal proof might be pose more challenges.\r\n\r\n> we are actually using the strong Fiat-Shamir transformation described in [[BPW16]](https://eprint.iacr.org/2016/771.pdf).\r\n\r\nAm I missing a proof of Theorem 1 somewhere? I would have liked to see how they tightly handle the case of an A choosing `n` statement-proof pairs more or less randomly, but updating its randomness after each pair by applying SHAKE to its old randomness and all received query responses. My intuition tells me that with the provided query options, K has to start over after extracting each witness, leading to a runtime in `O(n^2)`. This particular case can probably be avoided using partial rewinds, but I cannot tell if there are other corner cases then.\r\n\r\nI have been thinking about possible proofs for the hash_to_scalar case, but so far have not come up with anything, in part because I do not fully understand the tightness of the current proof. A proof _should_ not be too complex to adapt I would think, but I am unsure. For now, I agree that hashing the disclosed messages is the safest way forward.\r\n\r\n> Is this something that would make a significant difference in your use case?? (note that we are willing to apply the suggested re-arrangements).\r\n\r\nIt really depends on where this is used. For credentials, I would guess that signing authorities can get quite busy (which is why the removal of messages in the calculation of `e` is a good thing), but proofs are created by many users with few generated proofs per person. The more pressing issue could be on the proof verifier's side when protecting against DDoS, but even then the serialization and hashing of the message scalars is probably nothing compared to hashing the messages in the first place (at least with SHA).\r\n\r\nSo no, the most important part is the re-arrangement, hence this issue :)\r\n\r\n>  If we fully describe how to do this (which we tried before), we make the document more complicated and restrictive.\r\n\r\nThis is probably a separate issue, but I would really like to see an interface for additional proofs, so that extensions for other proof types have a single correct way to interface with this specification. For example the \"extended presentation header\" idea above could be adapted into a more standard interface or additional argument, so people do not have to redefine core operations for their extensions. \r\n\r\nThe reason I am bringing this up here is that such additional inputs to the challenge are not trivially handled by constant-memory implementations.\r\nThe most efficient place to hash in additional values would usually be the spot in the challenge where the last affected message would be revealed (if we were revealing them).\r\n\r\nFor example, with the pseudonyms idea above, the triple `(Pseudonym, OP, U)` can most efficiently be calculated when processing the (in this case) final message scalar (=the pid_scalar) and its commitment (=pid~). This corresponds to something like this:\r\n\r\n```\r\n1. c_arr = (R, i1, msg_i1, ..., iR, msg_iR, Pseudonym, OP, U, Abar, Bbar, D, T1, T2, domain)\r\n```",
          "createdAt": "2024-03-12T15:16:09Z",
          "updatedAt": "2024-03-12T15:16:09Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hey all!\r\n\r\nOpened PR #319 to address this issue.\r\n\r\nJust a question (sorry if this is obvious). Was wondering if the proposed updates are to increase efficiency and ease of implementation, or are they \"absolutely necessary\"? \r\n\r\nFor example, for the calculation of `e`, could we create a temporal accumulator for the messages, lets say `msg_acc`, go through the messages once, accumulating each `msg` to `msg_acc` (and each generator to the `domain` digest input etc.,) and then calculate `e` as `hash(SK || domain || msg_acc)`??\r\n\r\nSimilar for the challenge hash during proof gen.\r\n\r\nI can see that the proposed alternatives are simpler and more efficient, I'm just curious around the motivation (which will be needed when we present the update to the cfrg).\r\n\r\n> Am I missing a proof of Theorem 1 somewhere?\r\n\r\nSorry @bellebaum  for the delayed reply. AFAIK there is not any generic formal proof for Theorem 1, just security arguments based on counterexamples.\r\n",
          "createdAt": "2024-06-03T14:58:33Z",
          "updatedAt": "2024-06-03T18:17:16Z"
        },
        {
          "author": "bellebaum",
          "authorAssociation": "NONE",
          "body": "Hey Vasilis,\r\n\r\nas far as I can see, the schemes appear to be working without any modifications, since each message scalar is of fixed length and hash_to_scalar is sensitive to the message length. When accumulating message scalars, the accumulator should in any case be collision resistant, and so introducing another cryptographic hash or otherwise universal hash function (using an extra key; this seems to be the most efficient accumulator I can think of right now, I have not thought this through at all) for aggregation appears to have marginal benefit. That is, unless we use `B` as `msg_acc`, which we are calculating anyway, and which is already covered by security proofs. This would save a few hash instructions.\r\n\r\nWhile we are at the calculation of `e`: There is [this draft](https://datatracker.ietf.org/doc/draft-irtf-cfrg-det-sigs-with-noise/) at the CFRG, which aims to introduce some additional randomness into the calculation of their `e`-equivalent to e.g. provide some heuristic fault-tolerance in embedded devices. I don't know of the performance implications, but this might be reasonable to adopt as a heuristic here as well.\r\n\r\nThanks for opening the pull request and working on this :)",
          "createdAt": "2024-06-03T15:26:21Z",
          "updatedAt": "2024-06-03T15:26:50Z"
        }
      ]
    },
    {
      "number": 314,
      "id": "I_kwDOF8lax85--v9c",
      "title": "Missing Argument in ProofChallengeCalculate",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/314",
      "state": "CLOSED",
      "author": "roblesjoel",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "In 3.7.4. ProofChallengeCalculate the domain is used.\r\n`1. c_arr = (Abar, Bbar, D, T1, T2, R, i1, ..., iR,\r\n                                            msg_i1, ..., msg_iR, domain)`\r\n\r\nBut it is not provided as an argument.\r\n`challenge = ProofChallengeCalculate(init_res, disclosed_messages,\r\n                                          disclosed_indexes, ph, api_id)`",
      "createdAt": "2024-02-12T15:30:19Z",
      "updatedAt": "2024-02-12T15:32:47Z",
      "closedAt": "2024-02-12T15:32:47Z",
      "comments": [
        {
          "author": "roblesjoel",
          "authorAssociation": "NONE",
          "body": "Missed that the domain is in the init_res array....",
          "createdAt": "2024-02-12T15:32:47Z",
          "updatedAt": "2024-02-12T15:32:47Z"
        }
      ]
    },
    {
      "number": 315,
      "id": "I_kwDOF8lax85_iGt3",
      "title": "Fixture Proof010.json open to Interpretation",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/315",
      "state": "OPEN",
      "author": "roblesjoel",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "In the fixture proof010.json, there are two identical disclosed indexes.\r\nFor me that also means that in the disclosed messages vector, the same message is present twice.\r\nThere is no check for that.\r\nThe only check is if the length of the disclosed messages is the same as the length of the disclosed indexes.\r\n\r\nOther implementations (see [Greg Bernstein's JS implementation](https://github.com/Wind4Greg/grotto-bbs-signatures)) solve this issue by filtering the fixture messages, so that the messages only appears once in the vector.\r\nIn that case the lengths of the disclosed messages and indexes would mismatch.\r\n\r\nThere should be a check if the disclosed indexes are in order, and  maybe a check if there are duplicate entries in the vectors.",
      "createdAt": "2024-02-16T23:54:22Z",
      "updatedAt": "2024-02-16T23:54:22Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 316,
      "id": "I_kwDOF8lax85_n7Pr",
      "title": "SecretKey KeyGen function using ciphersuiteID instead of api_id",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/316",
      "state": "OPEN",
      "author": "roblesjoel",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "In the generate secret key function (see [here](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-bbs-signatures-05#name-secret-key)) only the cyphersuiteID is used for the key_dst.\r\nInstead the api_id needs to be used.\r\n\r\nSo in the definition of key_dst it should be: \r\n\r\n> Defaults to the octet string ciphersuite_id || \"H2G_HM2S_\" || \"KEYGEN_DST_\" if not supplied",
      "createdAt": "2024-02-18T20:33:34Z",
      "updatedAt": "2024-02-19T20:56:35Z",
      "closedAt": null,
      "comments": [
        {
          "author": "roblesjoel",
          "authorAssociation": "NONE",
          "body": "Additional Information:\r\nThe Error comes from the keypair.json fixture in the SHA folder.\r\nIf \"H2G_HM2S_\" is not included the test fails as it produces a different secret key.\r\nWhen using api_id || \"KEYGEN_DST_\" the secret key is correct.",
          "createdAt": "2024-02-19T20:56:34Z",
          "updatedAt": "2024-02-19T20:56:34Z"
        }
      ]
    },
    {
      "number": 317,
      "id": "I_kwDOF8lax86CDw7a",
      "title": "DST collisions",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/317",
      "state": "CLOSED",
      "author": "bellebaum",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "There is a collision in the domain separation tags in CoreSign (used in the calculation of `e`):\r\n\r\n```\r\n1. signature_dst, an octet string representing the domain separation\r\n                  tag: api_id || \"H2S_\" where \"H2S_\" is an ASCII string\r\n                  comprised of 4 bytes.\r\n```\r\n\r\nAnd in ProofChallengeCalculate:\r\n\r\n```\r\n1. challenge_dst, an octet string representing the domain separation\r\n                  tag: api_id || \"H2S_\" where \"H2S_\" is an ASCII string\r\n                  comprised of 4 bytes.\r\n```\r\n\r\nAnd in calculate_domain:\r\n\r\n```\r\n1. domain_dst, an octet string representing the domain separation tag:\r\n               api_id || \"H2S_\" where \"H2S_\" is an ASCII string\r\n               comprised of 4 bytes.\r\n```\r\n\r\nIs there any particular reason for these collisions?\r\n\r\nI believe the corresponding `hash_to_scalar` invocations represent independent random oracles. If one really wants collisions to save on DSTs, the only place where it seems rather harmless is to make domain_dst equal to map_dst used in messages_to_scalars, since the inputs to calculate_domain then become just another message. But even then, adding additional DSTs does not seem too expensive.\r\n\r\nOne could also argue that the octets representing input to these functions never collide, but this argument seems weaker than to have different DSTs for each of them.",
      "createdAt": "2024-03-12T15:56:31Z",
      "updatedAt": "2024-06-26T08:10:29Z",
      "closedAt": "2024-06-26T08:10:29Z",
      "comments": [
        {
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If the collision is intentional, it should be called out as intentional, otherwise the domain separation should probably include some additional context string.",
          "createdAt": "2024-03-12T16:13:05Z",
          "updatedAt": "2024-03-12T16:13:05Z"
        }
      ]
    },
    {
      "number": 318,
      "id": "I_kwDOF8lax86CzDIx",
      "title": "Per-Key Generators",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/318",
      "state": "OPEN",
      "author": "bellebaum",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "There is a possibility that one day a dedicated entity will find a nontrivial relationship in the generators used for a particular parameter set. This is about as hard as computing a discrete logarithm (about 128 bits of security), as has been proven before, thus we take this impossibility for granted. What worries me is this:\r\n\r\nOnce one or few of such nontrivial relationships are found, they might translate not into an attack on one particular key pair, but into an attack on all key pairs using the same `api_id`, which severely increases the reward for anyone attempting such an attack.\r\n\r\nOne simple fix would be to hash the public key into the initial value of `v` (maybe even into all of them), which would however make caching of generators more expensive and less useful. What do you think about this potential threat? Is it worth it to incorporate measures against it?",
      "createdAt": "2024-03-19T09:13:15Z",
      "updatedAt": "2024-03-19T09:13:15Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 321,
      "id": "I_kwDOF8lax86Rl_Kt",
      "title": "Test Vector for BBS Signatures over BN254 pairing curve",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/321",
      "state": "CLOSED",
      "author": "man2706kum",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The current latest draft includes the test vectors for BBS signature over BLS12-381. Where can i find the test vectors for BBS over BN254?",
      "createdAt": "2024-08-01T14:39:54Z",
      "updatedAt": "2024-12-09T06:49:33Z",
      "closedAt": "2024-12-09T06:49:33Z",
      "comments": [
        {
          "author": "man2706kum",
          "authorAssociation": "NONE",
          "body": "Implemented a generic implmentation of BBS+ supported over both bls12-381 and bn254 which can be found [here](https://github.com/hashcloak/bbs_sign). It passes the test vectors mentioned in the draft. Since this is a generic implementation, the same code works for both bn254 and bls12381 arkworks curve. One only need to implement the `Constants` and `HashToG1` traits which is generic over arkworks `Pairing`. **This implementation gives the flexibility to fit any arkworks pairing friendly curve just by implementing  the `Constants` and `HashToG1` traits.**",
          "createdAt": "2024-12-09T06:49:22Z",
          "updatedAt": "2024-12-09T06:49:22Z"
        }
      ]
    },
    {
      "number": 322,
      "id": "I_kwDOF8lax86SAcXT",
      "title": "Proof Length Floor Computation Inconsistency in Draft",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/322",
      "state": "CLOSED",
      "author": "Wind4Greg",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Spec error in section on  [ProofVerify ](https://www.ietf.org/archive/id/draft-irtf-cfrg-bbs-signatures-06.html#name-proof-verification-proofver) we  have `proof_len_floor = 2 * octet_point_length + 4 * octet_scalar_length` while in section [octets to  proof ](https://www.ietf.org/archive/id/draft-irtf-cfrg-bbs-signatures-06.html#section-4.2.4.5) we  have the  correct computation: `proof_len_floor = 3 * octet_point_length + 4 * octet_scalar_length`. ",
      "createdAt": "2024-08-05T22:36:40Z",
      "updatedAt": "2024-09-19T19:35:16Z",
      "closedAt": "2024-09-19T19:35:16Z",
      "comments": []
    },
    {
      "number": 323,
      "id": "I_kwDOF8lax86Tju9Q",
      "title": "Perfect anonymity of presentations",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/323",
      "state": "CLOSED",
      "author": "mmaker",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "A desirable property for blind schemes is unlinkability. Unlinkability, roughly speaking, says that it should not be possible to link issuance with redemption of a credential. \r\n\r\nConsider the (canonical) scenario where the user wants to sign a random message $m$ (a \"token\"), that is kept hidden at issuance time and revealed upon presentation. \r\nIn the current setup, the server will have at disposal (from issuance):\r\n- $C$, the first message at issuance time, and $(A, e, s'')$, the server response (5.3 blind spec)\r\n- the presentation material $(\\bar A, D, \\bar B , \\pi)$ and the message  (3.7.1 sig spec) satisfying \r\n```math\r\n\\begin{aligned}\r\n\\bar A &= r_1r_2 A  \\\\ \r\nD &= r_2 (G_0 + mG_1 + sG_2) \\\\ \r\n\\bar B &= -e \\bar A + r_1 D \\end{aligned}\r\n```\r\n\r\nA (very strong) attacker can check if the issuance message is linked to the presentation material via the following. Let $B = C + s''G_2 = G_0 + mG_1 + sG_2$ (The first equality can be computed without knowing the message, the second one requires to know $s'$ which seems to be the case in the current spec but can be removed) and compute\r\n\r\n```math\r\n\\begin{aligned}\r\n\\rho_1 = \\log_D(\\bar B - e \\bar A) \\\\\r\n\\rho_2 = \\log_B(D) \\\\\r\n\\textbf{check } \\rho_1\\rho_2 A = \\bar A\r\n\\end{aligned}\r\n```\r\n\r\n#### A legacy alternative\r\nIt is possible to avoid this problem extracting from the BBS+ paper the presentation/show proof, that I'm rewriting here with minor changes for clarity\r\n```math\r\nA' = A + rH \\qquad\r\nE' = eG + r'H\r\n```\r\nand letting \r\n```math\r\n\\pi = \\text{PoK}\\left\\{\r\n(m, e, s, r, r', u, u'): \\begin{array}{c}\r\n[xA]_T - [G_0]_T = m[G_1]_T + s[G_2]_T - e A' \\\\\r\n0G = uG  + u'H  - rE' \\\\\r\nE' = eG + r'H\r\n\\end{array}\r\n\\right\\}\r\n```\r\nwhere $u = er, u' = rr'$\r\nIntuitively, here one is sending two elements, each with its own blinding factor, and so for any presentation material $(A', E', \\pi)$ and any issuance message $(A, e, s'')$ there are uniformly distributed blinding factors $r, r'$ that can relate the two.\r\n\r\n\r\nThe proof is obviously larger, but not too much. For a full disclosure of attributes, while the first one has size $3g + 4s$ ($g$ is the size of a group element, $s$, a scalar), this one has $2g + 6s$ size, which for 256-bit curves is only 32 more bytes.",
      "createdAt": "2024-08-20T13:12:48Z",
      "updatedAt": "2024-08-21T12:29:08Z",
      "closedAt": "2024-08-21T12:29:08Z",
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hey Michele! Thank you very much for that issue!\r\n\r\n\r\n\r\n> $\\rho_1 = \\log_D(\\bar B - e \\bar A)$\r\n\r\nSorry! Just to make sure I don't miss something, I assume you mean $\\rho_1 = \\log_D(\\bar B + e \\bar A)$ here?\r\n\r\nLet me know if the following makes sense. Note that I'm focusing on the non blind case here. If I haven't missed anything, the same results could apply in the blind case as well.\r\n\r\nLets consider a BBS+ signature $\\sigma = (A, e)$ as a signature over the point $B$, so that $(x + e) \\cdot A= B$, where $x$ the Issuer's secret key (note that $B$ is the commitment to the messages).\r\n\r\nLets assume that we have a proof presentation $(\\bar{A}, D, \\bar{B}, \\pi)$ generated using the signature $(A, e)$. Note that $\\bar{B} = x \\cdot \\bar{A}$\r\n\r\nLets consider another signature $\\sigma' = (A', e')$ over the point $B'$, where $\\sigma \\neq \\sigma'$. If $\\sigma'$ is valid, it means that,\r\n\r\n```math\r\n(x + e') \\cdot A'= B' \\qquad \\text{(*)}\r\n```\r\n\r\nFollowing the steps outlined in the original post, using $(\\sigma', B')$ as the input, we will get $\\rho_1$ and $\\rho_2$ so that $D =  \\rho_2 \\cdot B'$ and\r\n\r\n```math\r\n\\bar{B} + e' \\cdot \\bar{A} = (x + e') \\cdot \\bar{A} = \\rho_1 \\cdot D = \\rho_1 \\rho_2 \\cdot B'\r\n```\r\n\r\nSubstituting $B'$ from (*) we get that\r\n\r\n```math\r\n(x + e') \\cdot \\bar{A}= (x + e') \\cdot \\rho_1 \\rho_2 \\cdot A'\r\n```\r\n\r\nMeaning that (assuming $x + e' \\neq 0$),\r\n\r\n```math\r\n\\bar{A} = \\rho_1 \\rho_2 \\cdot A'\r\n```\r\n\r\nThis seems to suggest that the equation the adversary checks always holds? assuming any valid signature as input?",
          "createdAt": "2024-08-20T15:59:52Z",
          "updatedAt": "2024-08-20T15:59:52Z"
        },
        {
          "author": "mmaker",
          "authorAssociation": "NONE",
          "body": "Hey, thanks for the speedy answer here. \r\n\r\nfor the first question: you're right!\r\n\r\nFor the rest of the message, you're also right, thanks for clarifying this! Indeed it looks like all signatures appear the same but, differently from the original BBS+ protocol, it seems that a \"simulator\" for anonymity can't just present a message without having a valid signature to show. I don't think this is a problem at all, so I'm closing this issue for now. \r\n\r\n",
          "createdAt": "2024-08-21T12:29:08Z",
          "updatedAt": "2024-08-21T12:29:08Z"
        }
      ]
    },
    {
      "number": 327,
      "id": "I_kwDOF8lax86ZSrFH",
      "title": "test vectors: inconsistency in random scalars",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/327",
      "state": "OPEN",
      "author": "NikZak",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Hi. When I look at [section 8.4.5.2](https://identity.foundation/bbs-signature/draft-irtf-cfrg-bbs-signatures.html#section-8.4.5.2)\r\nor [section 8.4.5.1](https://identity.foundation/bbs-signature/draft-irtf-cfrg-bbs-signatures.html#section-8.4.5.1)\r\nrandom scalars go as \r\n```\r\nrandom scalars:\r\n    r1 = \"60ca409f6b0563f687fc471c63d2819f446f39c23bb540925d9d4254ac58f3\r\n          37\"\r\n    r2 = \"2ceff4982de0c913090f75f081df5ec594c310bb48c17cfdaab5332a682ef8\r\n          11\"\r\n    e_tilde = \"6101c4404895f3dff87ab39c34cb995af07e7139e6b3847180ffdd1bc\r\n               8c313cd\"\r\n    r1_tilde = \"0dfcffd97a6ecdebef3c9c114b99d7a030c998d938905f357df62822\r\n                dee072e8\"\r\n    r3_tilde = \"639e3417007d38e5d34ba8c511e836768ddc2669fdd3faff5c14ad27\r\n                ac2b2da1\"\r\n```\r\n\r\nWhen I look at [section 8.4.5.3](https://identity.foundation/bbs-signature/draft-irtf-cfrg-bbs-signatures.html#section-8.4.5.3) random scalars are:\r\n```\r\nrandom scalars:\r\n    r1 = \"44679831fe60eca50938ef0e812e2a9284ad7971b6932a38c7303538b712e4\r\n          57\"\r\n    r2 = \"6481692f89086cce11779e847ff884db8eebb85a13e81b2d0c79d6c1062069\r\n          d8\"\r\n    e_tilde = \"721ce4c4c148a1d5826f326af6fd6ac2844f29533ba4127c3a43d222d\r\n               51b7081\"\r\n    r1_tilde = \"1ecfaf5a079b0504b00a1f0d6fe8857291dd798291d7ad7454b39811\r\n                4393f37f\"\r\n    r3_tilde = \"0a4b3d59b34707bb9999bc6e2a6d382a2d2e214bff36ecd88639a141\r\n                24b1622e\"\r\n    m_tilde_scalars:\r\n        m~_1 = \"7217411a9e329c7a5705e8db552274646e2949d62c288d7537dd62bc\r\n                284715e4\"\r\n        m~_3 = \"67d4d43660746759f598caac106a2b5f58ccd1c3eefaec31841a4f77\r\n                d2548870\"\r\n        m~_5 = \"715d965b1c3912d20505b381470ff1a528700b673e50ba89fd287e13\r\n                171cc137\"\r\n        m~_7 = \"4d3281a149674e58c9040fc7a10dd92cb9c7f76f6f0815a1afc3b09d\r\n                74b92fe4\"\r\n        m~_8 = \"438feebaa5894ca0da49992df2c97d872bf153eab07e08ff73b28131\r\n                c46ff415\"\r\n        m~_9 = \"602b723c8bbaec1b057d70f18269ae5e6de6197a5884967b03b933fa\r\n                80006121\"\r\n```\r\n\r\nThere are few issues with it. \r\nFirst:\r\nHow were the first random scalars derived? This is not defined in the standard. I've figured that you can get them by using seeded_random_scalars(SEED, DST, count) where SEED = \"332e313431353932363533353839373933323338343632363433333833323739\" and DST =\r\n\"BBS_BLS12381G1_XMD:SHA-256_SSWU_RO_H2G_HM2S_MOCK_RANDOM_SCALARS_DST_\" but I had to make a few guesses to find that. I think this better be defined in the standard.\r\n\r\nSecond:\r\nHow second random scalars are derived, I don't know\r\n\r\nI mean you may argue that how the random scalars are derived is not necessary to run the tests. But then why defining `seeded_random_scalars` function and saying that it is used to get random scalars. This function can not be used so the whole section about `seeded_random_scalars` is redundant",
      "createdAt": "2024-10-08T00:55:53Z",
      "updatedAt": "2024-10-08T03:59:41Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 328,
      "id": "I_kwDOF8lax86c72aa",
      "title": "Typo in equation [6] of Appendix E?",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/328",
      "state": "OPEN",
      "author": "emlun",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Hi,\r\n\r\nIt looks like there's a typo in [Appendix E of the `07` draft](https://www.ietf.org/archive/id/draft-irtf-cfrg-bbs-signatures-07.html#appendix-E). Equation `[6]` reads:\r\n\r\n```\r\n[6]     P1 + Q_1 * domain + H_i1 * msg_i1 + ... + H_iR * msg_iR =\r\n                        D * r2' - H_ji * msg_j1 - ... - H_jU * msg_jU\r\n```\r\n\r\nwhere I think the `H_ji` on the second line is meant to be `H_j1`?",
      "createdAt": "2024-11-04T14:13:35Z",
      "updatedAt": "2024-11-04T14:13:35Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 329,
      "id": "I_kwDOF8lax86fDzSs",
      "title": " Add TPM supported curves (BN638 and BN256I)",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/329",
      "state": "OPEN",
      "author": "akakou",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Hello, \r\n\r\nMy name is Kosei Akama, and I am a master's student at Keio University. \r\nI am writing to inquire about plans to adopt TPM-supported elliptic curves in the BBS draft.\r\n\r\nThe [BN638 and BN256I curves](https://www.ietf.org/archive/id/draft-irtf-cfrg-pairing-friendly-curves-11.html) are utilized for remote attestation mechanisms, \r\nsuch as Direct Anonymous Attestation (DAA) and Enhanced Privacy ID (EPID), both of which are based on the BBS.\r\n\r\nGiven this context, it seems necessary to specify the BN638 and BN256I as supported curves. \r\nIs there a plan to include these curves in the draft?",
      "createdAt": "2024-11-18T13:33:48Z",
      "updatedAt": "2024-11-18T13:33:48Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 331,
      "id": "I_kwDOF8lax86jyiS7",
      "title": "Implementation Feedback",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/331",
      "state": "OPEN",
      "author": "bellebaum",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "We have implemented the current spec in C: https://github.com/Fraunhofer-AISEC/libbbs\r\n\r\nOur implementation tries to simplify certain constructions. For instance, it avoids to create long arrays and can generally be adapted to provide an incremental API (which is useful if `2^64` messages, or even `2^16`, shall be supported in any application). While the README lists the current performance characteristics for the main interface, we might eventually provide optimized interfaces for e.g. signers.\r\n\r\nSome random feedback from working with the current draft:\r\n\r\n1. The draft layout makes it quite hard to implement the spec in a straight forward way, because what ends up being only a few lines of code is separated into a lot of subroutines, each with (sometimes redundant) deserialization and validation steps. My guess that this was done in preparation for extensions (e.g. blind BBS signatures), but it does slow down development and makes it more likely to overlook crucial validation steps (this happened to me). Where validation steps in subroutines are not meaningful to a standalone implementation, it seems more straightforward to document the assumptions enforced by the validation, and perform necessary validation in the calling functions, e.g. in extensions.\r\n2. This modularity sometimes creates additional work. For instance, during our simplifications I decided to simply not implement the special rules for serializing/deserializing the identity element (instead returning an error). This simplified the code not just in the deserialization, but also made several validation steps obsolete. Unless there are good reasons against it, I would recommend considering this for the draft as well.\r\n3. The deterministic generation of random scalars for the test vectors was a pain, as expected. I ended up implementing a callback for these values, which is a hash-to-scalar-powered PRF from a random 32-byte salt during normal signing, and replaced by the mockup in the draft for the tests. If anything, the random function gives slightly less power to an adversary influencing the OS randomness.\r\n\r\nAs a concrete example of possible \"simplifications\", consider the following procedure for Sign:\r\n\r\n```\r\n1. (msg_1, ..., msg_L) = messages_to_scalars(messages, api_id)\r\n2. (Q_1, H_1, ..., H_L) = create_generators(length(messages)+1, api_id)\r\n\r\n3. domain = calculate_domain(PK, (Q_1,H_1, ..., H_L), header, api_id)\r\n4. e = hash_to_scalar(serialize((SK, msg_1, ..., msg_L, domain)),\r\n                                                     hash_to_scalar_dst)\r\n\r\n5. B = P1 + Q_1 * domain + H_1 * msg_1 + ... + H_L * msg_L\r\n6. A = B * (1 / (SK + e))\r\n\r\n7. return serialize((A, e))\r\n```\r\n\r\nThis is seven steps instead of ten, not counting the superfluous length checks in CoreSign (thus also rendering the INVALID check redundant). Furthermore, the text about a possible identity `A` becomes superfluous if serialization of `A` returns INVALID for the identity, so for an implementer, not much additional text is needed. For good measure, I also removed the `signature_to_octets` wrapper on `serialize`. The same would theoretically be possible for `calculate_domain`. Extensions to the signature scheme can always just restate the missing 3-4 lines of the signing procedure above. \r\nEven greater improvements in readability and conciseness are achievable with other methods, especially `ProofGen`.\r\n\r\nI believe the fastest implementation would have been possible having a draft with code structured roughly as follows:\r\n\r\n1. serialization/deserialization operations for curve points, scalars etc. (opt. excluding the identity element)\r\n2. message scalars (hashed and random) and generators\r\n3. (optional) domain calculation\r\n4. `KeyGen`, `Sign`, `Verify`, `ProofGen`, `ProofVerify`, with everything inlined as much as possible\r\n\r\nThanks for reading :)",
      "createdAt": "2024-12-18T14:11:46Z",
      "updatedAt": "2024-12-18T14:11:46Z",
      "closedAt": null,
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 9,
      "id": "PR_kwDOF8lax84s53qY",
      "title": "Add meeting details to README",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/9",
      "state": "MERGED",
      "author": "andrewwhitehead",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-10-07T16:52:48Z",
      "updatedAt": "2021-10-07T18:46:46Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "8ef9959beab15364dd28e1816d8daa040164608d",
      "headRepository": "andrewwhitehead/bbs-signature",
      "headRefName": "add-meetings",
      "headRefOid": "83ca77c2b6f7cb9155e0b01cb689d41abf3c4642",
      "closedAt": "2021-10-07T18:46:46Z",
      "mergedAt": "2021-10-07T18:46:46Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "580bd262102859b1a06fb82c7089b60771e1a0de"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax84uJnZd",
          "commit": {
            "abbreviatedOid": "83ca77c"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-07T18:46:40Z",
          "updatedAt": "2021-10-07T18:46:40Z",
          "comments": []
        }
      ]
    },
    {
      "number": 12,
      "id": "PR_kwDOF8lax84t5asa",
      "title": "Remove mention of specific of hash function",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/12",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "An attempt to start discussion around #8 in regards to the digest algorithm. \r\n\r\nAt a minimum I am interpreting from that issue we agree that our usage of a digest algorithm should be specified once and referenced throughout the draft. The outstanding issue is whether the draft should just provide guidance around recommended digest algorithms or adopt an approach more akin to EdDSA where a particular digest algorithm forms a core part of the signature specification (e.g implementers MUST use BLAKE2B or SHAKE256)",
      "createdAt": "2021-10-31T22:13:52Z",
      "updatedAt": "2021-11-15T18:28:25Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "580bd262102859b1a06fb82c7089b60771e1a0de",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/hash-function",
      "headRefOid": "7a6d70429d5eb7b9b718de909052ddbea4f6d6fc",
      "closedAt": "2021-11-15T18:28:01Z",
      "mergedAt": "2021-11-15T18:28:01Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "9fc1ef136c2d437d59d11688a3fbaa1632421c75"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax84vW2EV",
          "commit": {
            "abbreviatedOid": "7a6d704"
          },
          "author": "quartzjer",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-11-01T18:26:04Z",
          "updatedAt": "2021-11-01T18:26:04Z",
          "comments": []
        }
      ]
    },
    {
      "number": 13,
      "id": "PR_kwDOF8lax84t5bNx",
      "title": "move ecc signature comparission to appendix",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/13",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "The comparing of bbs signatures to more traditional digital signature schemes like ECDSA is interesting informative content, but it is perhaps better discussed in the appendix rather than forming a core section in the draft, this PR proposes we move it accordingly.",
      "createdAt": "2021-10-31T22:27:06Z",
      "updatedAt": "2021-11-15T18:27:52Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "580bd262102859b1a06fb82c7089b60771e1a0de",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/remove-ecc-signatures-comparison",
      "headRefOid": "0bb0d372ed1cfabd9112eb8dd51d63a5f1e8ee43",
      "closedAt": "2021-11-15T18:27:45Z",
      "mergedAt": "2021-11-15T18:27:45Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "9a9602526a0642ce4816ad472cb50d200eb1c76c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax84vW1hZ",
          "commit": {
            "abbreviatedOid": "0bb0d37"
          },
          "author": "quartzjer",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-11-01T18:23:39Z",
          "updatedAt": "2021-11-01T18:23:39Z",
          "comments": []
        }
      ]
    },
    {
      "number": 14,
      "id": "PR_kwDOF8lax84u4XLB",
      "title": "Changes in the handling of reveled message indexes",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/14",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Changes in spkGen and spkVerify, in the direction discussed in the last WG call, of a more agile spec (aligned with option 1 from @tplooker's comment [here](https://github.com/decentralized-identity/bbs-signature/issues/10#issuecomment-939546272)). Specifically,\r\n\r\n1. Added a revealed message indexes vector in the input to spkVerify\r\n2. Added a recommendation for proof value encoding, similar to the one from ECDSA [RFC6979](https://datatracker.ietf.org/doc/html/rfc6979), with an additional preceding structure (taken from #10 , aligned with option 3 from the same [comment](https://github.com/decentralized-identity/bbs-signature/issues/10#issuecomment-939546272) as above).\r\n3. Changed some of the indexing in spkGen and spkVerify to accommodate the changes above",
      "createdAt": "2021-11-23T00:20:55Z",
      "updatedAt": "2021-12-13T19:14:29Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "91149814047a7c1fe11139bc787c2ea194efc5e0",
      "headRepository": "BasileiosKal/bbs-signature",
      "headRefName": "revealed_msg_indices",
      "headRefOid": "f05fbb24d7e7d4de05c11b6989eab19b00ba8a36",
      "closedAt": "2021-12-13T19:14:29Z",
      "mergedAt": "2021-12-13T19:14:28Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "0914df5a07eb0cf3eff6b4629ec2e34fcd9cc48b"
      },
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Done applying changes!",
          "createdAt": "2021-11-24T23:29:36Z",
          "updatedAt": "2021-11-24T23:29:36Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Waiting for discussion at next working group meeting to merge",
          "createdAt": "2021-11-28T19:30:11Z",
          "updatedAt": "2021-11-28T19:30:11Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax84wmZY6",
          "commit": {
            "abbreviatedOid": "8be003d"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-24T21:01:54Z",
          "updatedAt": "2021-11-24T21:01:54Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "```suggestion\r\n- RIdxs, vector of unsigned integers (indices of revealed messages).\r\n```",
              "createdAt": "2021-11-24T21:01:54Z",
              "updatedAt": "2021-11-24T21:01:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84wmZqm",
          "commit": {
            "abbreviatedOid": "8be003d"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-24T21:03:44Z",
          "updatedAt": "2021-11-24T21:03:44Z",
          "comments": [
            {
              "originalPosition": 106,
              "body": "```suggestion\r\nHow a signature is to be encoded is not covered by this document. (TODO perhaps add some additional information in the appendix)\r\n```",
              "createdAt": "2021-11-24T21:03:44Z",
              "updatedAt": "2021-11-24T21:03:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84wmZu4",
          "commit": {
            "abbreviatedOid": "8be003d"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-24T21:04:11Z",
          "updatedAt": "2021-11-24T21:04:12Z",
          "comments": [
            {
              "originalPosition": 130,
              "body": "```suggestion\r\n- RIdxs, vector of unsigned integers (indices of revealed messages).\r\n```",
              "createdAt": "2021-11-24T21:04:11Z",
              "updatedAt": "2021-11-24T21:04:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84wmZ1a",
          "commit": {
            "abbreviatedOid": "8be003d"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "Looking good, suggested a few changes",
          "createdAt": "2021-11-24T21:04:45Z",
          "updatedAt": "2021-11-24T21:04:45Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax84wpz6n",
          "commit": {
            "abbreviatedOid": "c2909a9"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-11-25T19:40:29Z",
          "updatedAt": "2021-11-25T19:40:29Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax84xgrN6",
          "commit": {
            "abbreviatedOid": "c2909a9"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-13T19:13:37Z",
          "updatedAt": "2021-12-13T19:13:37Z",
          "comments": [
            {
              "originalPosition": 165,
              "body": "```suggestion\r\n13. Y2 = d \\* r3^ + h0 \\* s^ + h\\[i1\\] \\* m^\\[i1\\] + ... + h\\[iR\\] \\* m^\\[iR\\] - T2 \\* c\r\n```",
              "createdAt": "2021-12-13T19:13:37Z",
              "updatedAt": "2021-12-13T19:13:37Z"
            }
          ]
        }
      ]
    },
    {
      "number": 17,
      "id": "PR_kwDOF8lax84vuKnC",
      "title": "Checks for the blind message generators and PoK during signing",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/17",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Related to #16.\r\n\r\n1. Added an explicit use of BlindMessageProofVerify in BlindSign to validate the PoK of committed messages, and a check that the generators used in the commitment are not also used for the known messages.\r\n2. Changed some of the notation to accommodate those changes above. The new notation can be also used more easily if we want to add support for blind signing with multiple commitments.",
      "createdAt": "2021-12-12T10:59:24Z",
      "updatedAt": "2022-01-24T19:12:06Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "8b0709f9e450fb1d37f8952d00dfa5ce4086f36e",
      "headRepository": "BasileiosKal/bbs-signature",
      "headRefName": "commitment_generators_validation",
      "headRefOid": "243d31012ce2b436be31b0be4f54db1f64b18557",
      "closedAt": "2022-01-24T19:12:06Z",
      "mergedAt": "2022-01-24T19:12:05Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "bab36cced182c0a1122b543fb50cefb7078184f0"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed on WG call on 15th of dec @BasileiosKal has an action to make some changes requested by @andrewwhitehead and @mikelodder7 ",
          "createdAt": "2021-12-13T19:23:54Z",
          "updatedAt": "2021-12-13T19:23:54Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree and I updated this pr.  However, it does seem that a wider update to the spec may be needed.  It may also be useful to specify the domain parameters used by each function, similarly to the format from [here](https://www.ietf.org/archive/id/draft-irtf-cfrg-rsa-blind-signatures-02.html).<br/>\r\nIt also seems like [this ](https://github.com/decentralized-identity/bbs-signature/issues/19) issue (#19 ) will be relevant i.e., if we don't change the way the generators are created, it may be confusing to refer to them as domain parameters and have them be both issuer and number of messages specific. ",
          "createdAt": "2021-12-23T23:41:08Z",
          "updatedAt": "2021-12-23T23:43:11Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agreed. Perhaps we use the current spec as an example for creating the domain parameters. The point is they need to be distinct points whose discrete log is unknown ",
          "createdAt": "2021-12-23T23:44:43Z",
          "updatedAt": "2021-12-23T23:44:43Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Related to #19, @andrewwhitehead to supply a review to this PR",
          "createdAt": "2022-01-10T19:39:59Z",
          "updatedAt": "2022-01-10T19:39:59Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think my only objections are around the variable naming. I have an issue open around that, and we can do another pass renaming things later.",
          "createdAt": "2022-01-24T18:10:15Z",
          "updatedAt": "2022-01-24T18:10:15Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed on WG call 24th Jan, resolved to merge",
          "createdAt": "2022-01-24T19:12:00Z",
          "updatedAt": "2022-01-24T19:12:00Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax84xdBbY",
          "commit": {
            "abbreviatedOid": "a13753d"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-13T00:18:43Z",
          "updatedAt": "2021-12-13T00:18:44Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "When we say \"octet string\" here are we meaning a string with some form of defined encoding like hexadecimal or instead are we assuming any parameters that are binary in nature be supplied as byte array?",
              "createdAt": "2021-12-13T00:18:44Z",
              "updatedAt": "2021-12-13T00:18:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84xdBfH",
          "commit": {
            "abbreviatedOid": "a13753d"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-13T00:20:14Z",
          "updatedAt": "2021-12-13T00:20:14Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "Probably should define `ceil` in terminology also even though it probably obvious to most",
              "createdAt": "2021-12-13T00:20:14Z",
              "updatedAt": "2021-12-13T00:20:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84xdFUq",
          "commit": {
            "abbreviatedOid": "a13753d"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-13T01:34:54Z",
          "updatedAt": "2021-12-13T01:34:54Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "My understanding is that currently by octet string we mean just a byte array with no specific encoding, mainly used to represent points in extension fields using the format described [here ](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-10) in [subsection 2.5](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-10#section-2.5), or for representing nonnegative integers using the conversions described [here](https://www.rfc-editor.org/rfc/rfc8017.txt) at section 4.",
              "createdAt": "2021-12-13T01:34:54Z",
              "updatedAt": "2021-12-13T01:34:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84yCdmc",
          "commit": {
            "abbreviatedOid": "5120485"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "The part about the key being 48 * (messages +1) isn\u2019t always accurate. I would like to rename these generators to domain parameters as this is the more common with cryptography. That means the public key has a fixed size of 96 bytes. \r\n\r\nThe reason for the distinction is the domain parameters have no secret meaning vs a public key indicates a secret key behind it",
          "createdAt": "2021-12-23T17:00:40Z",
          "updatedAt": "2021-12-23T17:00:40Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax84zWAYB",
          "commit": {
            "abbreviatedOid": "243d310"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-24T19:11:27Z",
          "updatedAt": "2022-01-24T19:11:27Z",
          "comments": []
        }
      ]
    },
    {
      "number": 18,
      "id": "PR_kwDOF8lax84vuhiv",
      "title": "Blind Sign Flow Example",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/18",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "An example for the flow by which the Holder gets a signature with committed messages. The holder commits U messages using the first U generators from the Issuers PK.",
      "createdAt": "2021-12-12T20:06:51Z",
      "updatedAt": "2021-12-21T20:31:40Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "0914df5a07eb0cf3eff6b4629ec2e34fcd9cc48b",
      "headRepository": "BasileiosKal/bbs-signature",
      "headRefName": "blind_sign_example",
      "headRefOid": "3695dee5e2f4d6b0a3c8fe934ec404913c0c2a2c",
      "closedAt": "2021-12-21T20:31:40Z",
      "mergedAt": "2021-12-21T20:31:40Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "8b0709f9e450fb1d37f8952d00dfa5ce4086f36e"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Informational and in the appendix, no objections on last working group call, merging.",
          "createdAt": "2021-12-21T20:31:35Z",
          "updatedAt": "2021-12-21T20:31:35Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax84xgt51",
          "commit": {
            "abbreviatedOid": "35d9d99"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-13T19:25:20Z",
          "updatedAt": "2021-12-13T19:25:21Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "```suggestion\r\n|        | <-(1)------- nonce ---------- |        |\r\n```",
              "createdAt": "2021-12-13T19:25:20Z",
              "updatedAt": "2021-12-13T19:25:21Z"
            }
          ]
        }
      ]
    },
    {
      "number": 21,
      "id": "PR_kwDOF8lax84wvGmp",
      "title": "Clarified presentation message requirements",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/21",
      "state": "CLOSED",
      "author": "christianpaquin",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Clarified usage of nonce when use in a non-interactive protocol.",
      "createdAt": "2022-01-10T14:03:36Z",
      "updatedAt": "2022-02-07T19:53:42Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "845bf8ad9e9f5eba34f58b579352b775d5011d11",
      "headRepository": "christianpaquin/bbs-signature",
      "headRefName": "nonce-issue-15",
      "headRefOid": "af8fb5542b234ee68c838117d946c2128ef90812",
      "closedAt": "2022-02-07T19:53:42Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Addresses issue #15 ",
          "createdAt": "2022-01-10T19:40:49Z",
          "updatedAt": "2022-01-10T19:40:49Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed on Jan 10th WG call, resolved to merge after 1 day if no further objection or feedback.",
          "createdAt": "2022-01-10T19:45:51Z",
          "updatedAt": "2022-01-10T19:45:51Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm not sure the text `BBS signatures are nondeterministic` is still true depending how the nonces are chosen. It also might be good to refer to `e` and `s` specifically in the context of nonce selection (at least I think those are the relevant nonces?). I'm not sure why a signed document would include a ZKP of a signature rather than the signature itself but maybe there's a use for that.",
          "createdAt": "2022-01-10T22:42:17Z",
          "updatedAt": "2022-01-10T22:42:17Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hm, I also can't imagine how blinded signatures would be used in a non-interactive or deterministic context.",
          "createdAt": "2022-01-10T23:14:04Z",
          "updatedAt": "2022-01-10T23:14:04Z"
        },
        {
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "body": ">I'm not sure why a signed document would include a ZKP of a signature rather than the signature itself but maybe there's a use for that.\r\n\r\nThe use case I referred [here](https://github.com/decentralized-identity/bbs-signature/issues/15#issuecomment-978239178) if you want to sign a statement without identifying yourself, think role-based signature similar to role-based access. A BBS+ cred owner could sign a statement, disclosing some attributes attested by a trusted issuer.\r\n",
          "createdAt": "2022-01-11T14:37:52Z",
          "updatedAt": "2022-01-11T14:37:52Z"
        },
        {
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I also can't imagine how blinded signatures would be used in a non-interactive or deterministic context.\r\n\r\nOne scenario that dates way back to Chaum's credential days was toll booths, where passing cars could present a payment by signing a booth ID + timestamp. Prover just broadcasts the proof to get access to a resource, using a (verifier ID + timestamp + small random value) as the nonce. Verifiers can prevent replays by keeping a local cache of used nonces (deleting as the timestamps get too old).",
          "createdAt": "2022-01-11T14:53:13Z",
          "updatedAt": "2022-01-11T14:53:13Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@andrewwhitehead any concrete proposal that could be suggested here to move this PR along?",
          "createdAt": "2022-01-24T03:26:57Z",
          "updatedAt": "2022-01-24T03:26:57Z"
        },
        {
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Comments from the Jan 24th meeting: yes, the nonce terminology contradicts the deterministic use cases. Perhaps renaming it to something more neutral would help generalize the supported scenarios. In U-Prove, e.g., the `nonce` was called `presentation message`, which could be a nonce (for interactive scenarios), a verifierID+timestamp for user-initiated non-interactive scenarios, or static content for digital signature use cases.",
          "createdAt": "2022-01-24T19:35:25Z",
          "updatedAt": "2022-01-24T19:35:25Z"
        },
        {
          "author": "tmarkovski",
          "authorAssociation": "MEMBER",
          "body": "> Comments from the Jan 24th meeting: yes, the nonce terminology contradicts the deterministic use cases. Perhaps renaming it to something more neutral would help generalize the supported scenarios. In U-Prove, e.g., the `nonce` was called `presentation message`, which could be a nonce (for interactive scenarios), a verifierID+timestamp for user-initiated non-interactive scenarios, or static content for digital signature use cases.\r\n\r\nI think that's a good description of an application of a nonce, when it's used in a deterministic scenario, but not general enough. `Challenge` may be used when interaction is needed in a non-deterministic manner. A `nonce` can then become a `presentation message`, a `challenge`, or even a `pin` to be more specific. This makes me think that `nonce` is indeed a good way that's general enough to refer to this input.",
          "createdAt": "2022-01-24T21:48:16Z",
          "updatedAt": "2022-01-24T21:48:59Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@christianpaquin apologies but we have renamed the spec file name so we leverage existing tooling around managing ID drafts, can you please rebase your PR accordingly?",
          "createdAt": "2022-01-26T00:51:50Z",
          "updatedAt": "2022-01-26T00:51:50Z"
        },
        {
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I've updated the PR, merging with latest changes on main, and removing some mentions of potential use cases causing confusion.  \r\n\r\nThe main use case I have in mind for BBS+ signature is to build anonymous credentials, where the holder is not only given certified attributes, but also holds a private key (in one of the never-disclosed attributes, like in U-Prove and Idemix). Since BBS+ can, in its generalization, be used to encode key-less, bearer-only signatures on arbitrary messages, the previous \"signing the nonce\" text was confusing, so I removed it for now.\r\n\r\nThis being said, where should we specify such a use for BBS+ signature? Should that be a totally different spec (similar to CL sig vs. Idemix?) or a simpler profile?",
          "createdAt": "2022-01-27T22:52:56Z",
          "updatedAt": "2022-01-27T22:52:56Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "> This being said, where should we specify such a use for BBS+ signature? Should that be a totally different spec (similar to CL sig vs. Idemix?) or a simpler profile?\r\n\r\nJust so I can clarify when you say a more opinionated signature scheme what do you mean exactly, one that features holder cryptographic binding or something else?",
          "createdAt": "2022-01-28T00:16:26Z",
          "updatedAt": "2022-01-28T00:16:26Z"
        },
        {
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "body": "how many days with approval before merge for this work item?",
          "createdAt": "2022-01-31T21:47:31Z",
          "updatedAt": "2022-01-31T21:47:31Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Resolved to merge on WG call 7th of Feb, awaiting conflict resolution ",
          "createdAt": "2022-02-07T19:11:22Z",
          "updatedAt": "2022-02-07T19:11:22Z"
        },
        {
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Conflict merge resolution is very confused on my system, so closing this and opening new, cleaner PR #55.",
          "createdAt": "2022-02-07T19:53:42Z",
          "updatedAt": "2022-02-07T19:53:42Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax84yj4t4",
          "commit": {
            "abbreviatedOid": "d23c300"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-10T19:45:02Z",
          "updatedAt": "2022-01-10T19:45:02Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax84zWi6J",
          "commit": {
            "abbreviatedOid": "d23c300"
          },
          "author": "tmarkovski",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-24T21:41:35Z",
          "updatedAt": "2022-01-24T21:41:36Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "While I share the idea that there are very good use cases where deterministic nonce can be used here, I think they make more sense in higher level protocols. Especially, since the wording used here may incorrectly guide implementors to adopt timestamp for a nonce.\r\nI think a shorter guidance describing that this parameter be unique, and random enough would be more appropriate.\r\n\r\nSpecific implementations may still make a conscious choice to use deterministic value where security or risk impact tolerates this. For example: attendees at a conference can prepare a proof by using the room number for a conference where both verifier and presenter know this nonce and require no interaction, thus simplifying the verification experience.",
              "createdAt": "2022-01-24T21:41:36Z",
              "updatedAt": "2022-01-24T21:41:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84zWjfl",
          "commit": {
            "abbreviatedOid": "d23c300"
          },
          "author": "tmarkovski",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-24T21:44:15Z",
          "updatedAt": "2022-01-24T21:44:15Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "I don't know what standard in cryptography is used to reference to good randomness. Maybe [this RFC](https://datatracker.ietf.org/doc/html/rfc4086) may be more appropriate to quote here?",
              "createdAt": "2022-01-24T21:44:15Z",
              "updatedAt": "2022-01-24T21:44:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84zlt6R",
          "commit": {
            "abbreviatedOid": "d498442"
          },
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-27T22:54:09Z",
          "updatedAt": "2022-01-27T22:54:09Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Agreed that we need clearer usage \"profiles\" to scope the implementation choices. Really interested in defining these.",
              "createdAt": "2022-01-27T22:54:09Z",
              "updatedAt": "2022-01-27T22:54:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84zl5wY",
          "commit": {
            "abbreviatedOid": "d498442"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-28T00:18:00Z",
          "updatedAt": "2022-01-28T00:18:01Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "I think somewhere we need to relate the concept of a nonce to a presentation message, is here the most appropriate place to do that?",
              "createdAt": "2022-01-28T00:18:01Z",
              "updatedAt": "2022-01-28T00:18:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84zl8Jf",
          "commit": {
            "abbreviatedOid": "d498442"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-28T00:38:45Z",
          "updatedAt": "2022-01-28T00:38:46Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "Given that we now no longer formally have the concept of a nonce in the draft itself",
              "createdAt": "2022-01-28T00:38:45Z",
              "updatedAt": "2022-01-28T00:38:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84zmQI1",
          "commit": {
            "abbreviatedOid": "d498442"
          },
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-28T03:38:29Z",
          "updatedAt": "2022-01-28T03:38:29Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "> Just so I can clarify when you say a more opinionated signature scheme what do you mean exactly, one that features holder cryptographic binding or something else?\r\n\r\nYes, at a minimum. This could be achieved (I think) by making one of messages the \"private key\" and you shouldn't reveal it. I've seen in another thread someone proposing tying it to the BLS key (?), I need to look into the details of that...",
              "createdAt": "2022-01-28T03:38:29Z",
              "updatedAt": "2022-01-28T03:38:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84zmQUL",
          "commit": {
            "abbreviatedOid": "d498442"
          },
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-28T03:40:47Z",
          "updatedAt": "2022-01-28T03:40:47Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "> I think somewhere we need to relate the concept of a nonce to a presentation message, is here the most appropriate place to do that?\r\n\r\nAh yes, didn't realized that changed already when I merged. I definitely need to update that section to reflect that.",
              "createdAt": "2022-01-28T03:40:47Z",
              "updatedAt": "2022-01-28T03:40:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84zqbRU",
          "commit": {
            "abbreviatedOid": "9cdad00"
          },
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-28T22:19:37Z",
          "updatedAt": "2022-01-28T22:19:38Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "Updated",
              "createdAt": "2022-01-28T22:19:37Z",
              "updatedAt": "2022-01-28T22:19:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84zqe6n",
          "commit": {
            "abbreviatedOid": "9cdad00"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-28T22:47:04Z",
          "updatedAt": "2022-01-28T22:47:04Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "```suggestion\r\nThe signature proofs of knowledge generated in this specification are created using a specified presentation message. A verifier-specified cryptographically random value (e.g., a nonce) featuring in the presentation message provides strong protections against replay attacks, and is RECOMMENDED in most use cases. In some settings, proofs can be generated in a non-interactive fashion, in which case verifiers MUST be able to verify the uniqueness of the presentation message values.\r\n```",
              "createdAt": "2022-01-28T22:47:04Z",
              "updatedAt": "2022-01-28T22:47:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84zw4-J",
          "commit": {
            "abbreviatedOid": "af8fb55"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-31T21:47:08Z",
          "updatedAt": "2022-01-31T21:47:08Z",
          "comments": []
        }
      ]
    },
    {
      "number": 22,
      "id": "PR_kwDOF8lax84wv9WU",
      "title": "Add various comments as FIXMEs",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/22",
      "state": "MERGED",
      "author": "schanzen",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Related to #7 and #8\r\n\r\nDid a pass of the document and was wondering to what degree it is supposed to be normative. If it is **not** supposed to be, it should be made clear(er) what the diff over the respective papers (informative references to those missing) is.\r\nAlso, normative references (such as those to the HKDF) are not required then.\r\n\r\nIf it is supposed to be normative, it requires the definition of (at least) one concrete instantiation (with hash functions/curves) and normative test vectors and wire formats.\r\n\r\nOnce we can clarify those points I can replace the FIXMEs aligning with the target.",
      "createdAt": "2022-01-10T17:50:51Z",
      "updatedAt": "2022-01-25T22:56:11Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "8b0709f9e450fb1d37f8952d00dfa5ce4086f36e",
      "headRepository": "schanzen/bbs-signature",
      "headRefName": "comments",
      "headRefOid": "70c145526d995440b5d876eeedbb537bf85e51da",
      "closedAt": "2022-01-25T22:56:11Z",
      "mergedAt": "2022-01-25T22:56:11Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "56d413acd3d43588c93964ba3f38d88a094a220d"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Purely editorial changes, multiple approvals, discussed on WG, merging, thanks @schanzen ",
          "createdAt": "2022-01-25T22:56:07Z",
          "updatedAt": "2022-01-25T22:56:07Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax84ykm-4",
          "commit": {
            "abbreviatedOid": "daf0b5e"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-10T23:23:57Z",
          "updatedAt": "2022-01-10T23:23:57Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "I think those 680 and 1400 numbers are also in microseconds not milliseconds?",
              "createdAt": "2022-01-10T23:23:57Z",
              "updatedAt": "2022-01-10T23:23:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84ykoYi",
          "commit": {
            "abbreviatedOid": "daf0b5e"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-10T23:34:23Z",
          "updatedAt": "2022-01-10T23:34:24Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Why does it need justification?",
              "createdAt": "2022-01-10T23:34:24Z",
              "updatedAt": "2022-01-10T23:34:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84ykocK",
          "commit": {
            "abbreviatedOid": "daf0b5e"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-10T23:34:49Z",
          "updatedAt": "2022-01-10T23:34:49Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Same here, not sure what the suggested change would be.",
              "createdAt": "2022-01-10T23:34:49Z",
              "updatedAt": "2022-01-10T23:34:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84yl99T",
          "commit": {
            "abbreviatedOid": "daf0b5e"
          },
          "author": "schanzen",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-11T08:23:31Z",
          "updatedAt": "2022-01-11T08:23:31Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Because above it it says \"The scheme features many important properties:\"\r\nIt is unclear why this generic property is important.\r\nI changed this sentence above in the pull request already.\r\nIf this is just a general note then it is not an important property of the scheme I think.",
              "createdAt": "2022-01-11T08:23:31Z",
              "updatedAt": "2022-01-11T08:23:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84yl_T5",
          "commit": {
            "abbreviatedOid": "daf0b5e"
          },
          "author": "schanzen",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-11T08:25:55Z",
          "updatedAt": "2022-01-11T08:25:55Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "It also kind of implies that there is space time tradeoff and that BBS can sign any number of messages in 680/1400ms. So maybe the 3.7 and 5.4 actually refer to ECDSA. Not sure.",
              "createdAt": "2022-01-11T08:25:55Z",
              "updatedAt": "2022-01-11T08:25:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84ymA6S",
          "commit": {
            "abbreviatedOid": "daf0b5e"
          },
          "author": "schanzen",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-11T08:31:11Z",
          "updatedAt": "2022-01-11T08:31:11Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Well let me rephrase it using the words from the (original) text:\r\nHow is \"Verification requires 2 pairing operations.\" a \"[property that] allow[s] the scheme to be used in applications where privacy and data minimization techniques are desired and/or required.\"?\r\nThat is what the text currently says, and it is unclear (to me) where the connection is.",
              "createdAt": "2022-01-11T08:31:11Z",
              "updatedAt": "2022-01-11T08:31:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84ymBz2",
          "commit": {
            "abbreviatedOid": "daf0b5e"
          },
          "author": "schanzen",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-11T08:34:53Z",
          "updatedAt": "2022-01-11T08:34:54Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Also, the \"encoding\" of the signature would usually refer to a normative (interoperable) wire format of the signature. Maybe what is meant here is that the signatures are \"represented\" as a single group element and two field elements?\r\nLater in the text it is also stated that \"How a signature is to be encoded is not covered by this document. (TODO perhaps add some additional information in the appendix)\"",
              "createdAt": "2022-01-11T08:34:53Z",
              "updatedAt": "2022-01-11T08:35:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84yu6b3",
          "commit": {
            "abbreviatedOid": "daf0b5e"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-13T01:16:04Z",
          "updatedAt": "2022-01-13T01:16:04Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "@mikelodder7 I think you originally wrote this could you clarify, IMO this section can likely be removed from the spec as it is entirely non-normative.",
              "createdAt": "2022-01-13T01:16:04Z",
              "updatedAt": "2022-01-13T01:16:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84yu6jN",
          "commit": {
            "abbreviatedOid": "daf0b5e"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-13T01:17:10Z",
          "updatedAt": "2022-01-13T01:17:11Z",
          "comments": [
            {
              "originalPosition": 77,
              "body": "I think I agree with your comment here but could you clarify what you mean by \"wire format\" specifically and what you would take as the definition of encoding format?",
              "createdAt": "2022-01-13T01:17:10Z",
              "updatedAt": "2022-01-13T01:17:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84yu6mI",
          "commit": {
            "abbreviatedOid": "daf0b5e"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-13T01:17:35Z",
          "updatedAt": "2022-01-13T01:17:35Z",
          "comments": [
            {
              "originalPosition": 60,
              "body": "If it is a duplicate then I think we should just remove it",
              "createdAt": "2022-01-13T01:17:35Z",
              "updatedAt": "2022-01-13T01:17:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84yvD8o",
          "commit": {
            "abbreviatedOid": "daf0b5e"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-13T02:41:09Z",
          "updatedAt": "2022-01-13T02:41:09Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "Sure feel free to remove it.",
              "createdAt": "2022-01-13T02:41:09Z",
              "updatedAt": "2022-01-13T02:41:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84yvxZ_",
          "commit": {
            "abbreviatedOid": "daf0b5e"
          },
          "author": "schanzen",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-13T08:23:04Z",
          "updatedAt": "2022-01-13T08:23:05Z",
          "comments": [
            {
              "originalPosition": 77,
              "body": "As an implementer I would expect qualifiers such as \"32 octets\" or \"variable length\" (with a length field) for the members of the tuple and then a normative ordering of them (for example by having a wire format graphic or a concatenation of the octet strings).\r\nThe point is that when I eventually code my structs, I need to know the size of its members and their location.\r\nOtherwise I do not even know how to parse a test vector (if provided).\r\nThis unclarity may have to do with #8 which makes normative statements more difficult to incorporate.",
              "createdAt": "2022-01-13T08:23:04Z",
              "updatedAt": "2022-01-13T08:23:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84y9G62",
          "commit": {
            "abbreviatedOid": "daf0b5e"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-18T01:55:26Z",
          "updatedAt": "2022-01-18T01:55:26Z",
          "comments": [
            {
              "originalPosition": 77,
              "body": "Yeah I think this is covered by issue #2 and we should aim to review it on the next working group call to provide better clarity around the direction the WG would like to take this",
              "createdAt": "2022-01-18T01:55:26Z",
              "updatedAt": "2022-01-18T01:55:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84zSWwH",
          "commit": {
            "abbreviatedOid": "daf0b5e"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-24T03:29:11Z",
          "updatedAt": "2022-01-24T03:29:12Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "@schanzen, could you update your PR to just remove this section entirely from the appendix?",
              "createdAt": "2022-01-24T03:29:12Z",
              "updatedAt": "2022-01-24T03:29:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84zSW4N",
          "commit": {
            "abbreviatedOid": "daf0b5e"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-24T03:30:46Z",
          "updatedAt": "2022-01-24T03:30:47Z",
          "comments": [
            {
              "originalPosition": 60,
              "body": "Have reviewed, @schanzen can you remove the duplicate language around SK, then we can resolve this FIX me",
              "createdAt": "2022-01-24T03:30:46Z",
              "updatedAt": "2022-01-24T03:30:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84zSXAF",
          "commit": {
            "abbreviatedOid": "daf0b5e"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-24T03:32:17Z",
          "updatedAt": "2022-01-24T03:32:17Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "+1 reading the context it does not appear apparent why this needs to be bulleted as it is, I would vote to remove it.",
              "createdAt": "2022-01-24T03:32:17Z",
              "updatedAt": "2022-01-24T03:32:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84zSXDG",
          "commit": {
            "abbreviatedOid": "daf0b5e"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-24T03:32:51Z",
          "updatedAt": "2022-01-24T03:32:51Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "+1 as above I think this should be removed also",
              "createdAt": "2022-01-24T03:32:51Z",
              "updatedAt": "2022-01-24T03:32:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84zb0yS",
          "commit": {
            "abbreviatedOid": "70c1455"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-25T22:23:57Z",
          "updatedAt": "2022-01-25T22:23:57Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax84zb7fj",
          "commit": {
            "abbreviatedOid": "70c1455"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-25T22:55:43Z",
          "updatedAt": "2022-01-25T22:55:43Z",
          "comments": []
        }
      ]
    },
    {
      "number": 23,
      "id": "PR_kwDOF8lax84wwBeS",
      "title": "Check the hash for the challenge of the Fiat-Shamir heuristic",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/23",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Attempts to fix #20\r\n\r\nChanges: \r\n\r\n1. SpkGen returns the computed challenge for Fiat-Shamir.\r\n2. SpkVerify checks that the challenge is correct.",
      "createdAt": "2022-01-10T18:13:34Z",
      "updatedAt": "2022-02-16T00:49:50Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "535d98143d46e10d2c358f76bb985e2c530d018a",
      "headRepository": "BasileiosKal/bbs-signature",
      "headRefName": "issue20-fix",
      "headRefOid": "b3073be5a2bad2ddf6a579b23e8a0b275eab2af3",
      "closedAt": "2022-02-16T00:49:50Z",
      "mergedAt": "2022-02-16T00:49:50Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "82155a81bcbaf86c898851d2c07d83a4c98f963d"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed on WG call Jan 10th, waiting on a review from @mikelodder7 as the underlying issue was raised by him. ",
          "createdAt": "2022-01-10T19:53:34Z",
          "updatedAt": "2022-01-10T19:53:34Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@BasileiosKal apologies but we have renamed the spec file name so we leverage existing tooling around managing ID drafts, can you please rebase your PR accordingly?",
          "createdAt": "2022-01-26T00:58:17Z",
          "updatedAt": "2022-01-26T00:58:17Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed on WG call 7th Feb, awaiting review from @mikelodder7 for progress",
          "createdAt": "2022-02-07T19:13:22Z",
          "updatedAt": "2022-02-07T19:13:22Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It would likely be more efficient to check the challenge hash before doing the pairing operations, in case that fails.",
          "createdAt": "2022-02-07T19:15:55Z",
          "updatedAt": "2022-02-07T19:15:55Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sure it could be. I don\u2019t have a preference ",
          "createdAt": "2022-02-07T19:20:21Z",
          "updatedAt": "2022-02-07T19:20:21Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "updated",
          "createdAt": "2022-02-07T20:10:40Z",
          "updatedAt": "2022-02-07T20:10:40Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@mikelodder7 can you review these latest changes please",
          "createdAt": "2022-02-12T23:02:09Z",
          "updatedAt": "2022-02-12T23:02:09Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "PR open for multiple weeks, discussed on WG call multiple times, multiple approvals, merging.",
          "createdAt": "2022-02-16T00:49:37Z",
          "updatedAt": "2022-02-16T00:49:37Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax84yj6_q",
          "commit": {
            "abbreviatedOid": "b97272e"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-10T19:55:16Z",
          "updatedAt": "2022-01-10T19:55:18Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "These steps are not necessary since they should be handled by the challenge hash.",
              "createdAt": "2022-01-10T19:55:17Z",
              "updatedAt": "2022-01-10T19:55:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84yj7DV",
          "commit": {
            "abbreviatedOid": "b97272e"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-10T19:55:34Z",
          "updatedAt": "2022-01-10T19:55:35Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "I.E 11-16 are not necessary",
              "createdAt": "2022-01-10T19:55:34Z",
              "updatedAt": "2022-01-10T19:55:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84yj7R3",
          "commit": {
            "abbreviatedOid": "b97272e"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-10T19:56:38Z",
          "updatedAt": "2022-01-10T19:56:38Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "See https://hackmd.io/Q587Q9p7T5ab30NTn4MvTA#Change-selective-disclosure-proofs-to-just-be-Schnorr-Proofs-and-Fiat-Shamir",
              "createdAt": "2022-01-10T19:56:38Z",
              "updatedAt": "2022-01-10T19:56:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84ykFGm",
          "commit": {
            "abbreviatedOid": "b97272e"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-10T20:42:52Z",
          "updatedAt": "2022-01-10T20:42:52Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Thank you for the link. It is very interesting. Perhaps I will have to think more about it but it seems to me that some of the steps are needed. If we change the hash calculated at step 9 here to contain Y1 and Y2 instead of C1 and C2 (and of course to be calculated in a later step), perhaps we could remove the checks at steps 15 and 16, and consequently remove C1 and C2 from the spk returned from SpkGen. However, steps 10 to 14 don't seem to me that we could remove them, they are an integral part of the Schnorr proof after all.",
              "createdAt": "2022-01-10T20:42:52Z",
              "updatedAt": "2022-01-10T20:42:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84ykFrQ",
          "commit": {
            "abbreviatedOid": "b97272e"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-10T20:45:25Z",
          "updatedAt": "2022-01-10T20:45:26Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "The problem is it\u2019s being calculated twice. Once for the hash and then again checked for equality which is why I said in my write up they can be removed",
              "createdAt": "2022-01-10T20:45:26Z",
              "updatedAt": "2022-01-10T20:45:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84ykFvs",
          "commit": {
            "abbreviatedOid": "b97272e"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-10T20:45:46Z",
          "updatedAt": "2022-01-10T20:45:46Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "If the values are different, the hash will be too. ",
              "createdAt": "2022-01-10T20:45:46Z",
              "updatedAt": "2022-01-10T20:45:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84zw5hG",
          "commit": {
            "abbreviatedOid": "b97272e"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "There is an implied change request by @mikelodder7 and there are conflicts that need to be addressed.",
          "createdAt": "2022-01-31T21:49:38Z",
          "updatedAt": "2022-01-31T21:49:38Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax840eoqu",
          "commit": {
            "abbreviatedOid": "1a27339"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-11T17:00:19Z",
          "updatedAt": "2022-02-11T17:00:19Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax840rfER",
          "commit": {
            "abbreviatedOid": "b3073be"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Having had the chance to review this PR more closely now, I agree with this approach and how it is algorithmically described. It is consistent with @mikelodder7's original issue described in #20. The PR does appear to have some overlap with #62, however on balance I think the scope of this PR makes it easier to review and merge in first.",
          "createdAt": "2022-02-16T00:48:50Z",
          "updatedAt": "2022-02-16T00:48:50Z",
          "comments": []
        }
      ]
    },
    {
      "number": 32,
      "id": "PR_kwDOF8lax84xlpRj",
      "title": "Add ID tooling, remove redundant scripts",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/32",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "- Add basic tooling for managing this spec as an ID draft based on https://github.com/martinthomson/internet-draft-template.\r\n- Removes some redundant scripts for old tooling.\r\n- Removes old HTML version.\r\n- Minor tweaks to draft naming based on #30 \r\n",
      "createdAt": "2022-01-25T23:22:30Z",
      "updatedAt": "2022-01-26T00:22:23Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "56d413acd3d43588c93964ba3f38d88a094a220d",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/id-tooling-setup",
      "headRefOid": "72f9be671202019daa497969f02efa049266e901",
      "closedAt": "2022-01-26T00:22:20Z",
      "mergedAt": "2022-01-26T00:22:20Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "e77c5ce55cad7274c1c3d35850023205edc702b9"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Merging PR so we can get spec hosting working correctly, no substantive changes to the spec text.",
          "createdAt": "2022-01-26T00:22:15Z",
          "updatedAt": "2022-01-26T00:22:15Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax84zcDqD",
          "commit": {
            "abbreviatedOid": "1fe6a92"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-25T23:55:26Z",
          "updatedAt": "2022-01-25T23:55:26Z",
          "comments": [
            {
              "originalPosition": 2,
              "body": "remove comments?",
              "createdAt": "2022-01-25T23:55:26Z",
              "updatedAt": "2022-01-25T23:55:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84zcD-b",
          "commit": {
            "abbreviatedOid": "1fe6a92"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-25T23:58:00Z",
          "updatedAt": "2022-01-25T23:58:00Z",
          "comments": [
            {
              "originalPosition": 88,
              "body": "Looks like you are no longer using markdown2rfc.... I had to bump the version recently... https://github.com/OR13/markdown2rfc\r\n\r\nI wanted to render latex equations as svgs... ",
              "createdAt": "2022-01-25T23:58:00Z",
              "updatedAt": "2022-01-25T23:58:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84zcEDT",
          "commit": {
            "abbreviatedOid": "1fe6a92"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-25T23:58:43Z",
          "updatedAt": "2022-01-25T23:58:44Z",
          "comments": [
            {
              "originalPosition": 88,
              "body": "I love the idea of github handling this all for you tho, i would still probably want to test it locally.... consider adding some instructions to the readme to help with that? and adding the built assets to git ignore?",
              "createdAt": "2022-01-25T23:58:43Z",
              "updatedAt": "2022-01-25T23:59:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84zcFie",
          "commit": {
            "abbreviatedOid": "1fe6a92"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-26T00:10:32Z",
          "updatedAt": "2022-01-26T00:10:32Z",
          "comments": [
            {
              "originalPosition": 2,
              "body": "It just describes how the tool is run copied directly from the template (https://github.com/martinthomson/internet-draft-template/blob/main/.github/workflows/update.yml#L2)",
              "createdAt": "2022-01-26T00:10:32Z",
              "updatedAt": "2022-01-26T00:10:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84zcFo8",
          "commit": {
            "abbreviatedOid": "1fe6a92"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-26T00:11:26Z",
          "updatedAt": "2022-01-26T00:11:28Z",
          "comments": [
            {
              "originalPosition": 88,
              "body": "Yeah I have seen some other repos that include the ability to do this locally to preview changes in final output form, was going to tackle in a follow up PR",
              "createdAt": "2022-01-26T00:11:27Z",
              "updatedAt": "2022-01-26T00:11:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84zcGTB",
          "commit": {
            "abbreviatedOid": "1fe6a92"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-26T00:17:20Z",
          "updatedAt": "2022-01-26T00:17:20Z",
          "comments": [
            {
              "originalPosition": 1,
              "body": "Have updated this workflow file essentially it is designed to be run once then deletes it self, just sets up tooling around the draft publication",
              "createdAt": "2022-01-26T00:17:20Z",
              "updatedAt": "2022-01-26T00:17:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84zcGWE",
          "commit": {
            "abbreviatedOid": "1fe6a92"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-26T00:17:43Z",
          "updatedAt": "2022-01-26T00:17:43Z",
          "comments": [
            {
              "originalPosition": 88,
              "body": "Note as above this workflow is just designed to be run once also",
              "createdAt": "2022-01-26T00:17:43Z",
              "updatedAt": "2022-01-26T00:17:43Z"
            }
          ]
        }
      ]
    },
    {
      "number": 35,
      "id": "PR_kwDOF8lax84xmKrD",
      "title": "Remove deterministic public key section from the spec",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/35",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Regardless of the outcome of #19 most in the group appear to agree that generators should always be considered an internal cryptographic structure instead of one that forces API consumers to manage externally, with that in mind we can remove any mention of deterministic public keys vs short form public keys and instead simplify to have only 1 type.\r\n\r\nFixes #26 ",
      "createdAt": "2022-01-26T04:49:12Z",
      "updatedAt": "2022-01-27T18:40:50Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "b49728ecb6ec3166ed095151a056869f8a3019f0",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/remove-deterministic-public-key",
      "headRefOid": "bb79edaccb75da28a3fb006db3435b7f286067e2",
      "closedAt": "2022-01-27T18:40:47Z",
      "mergedAt": "2022-01-27T18:40:46Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "ab16db1e228211dc88763060c0013cd70a26df92"
      },
      "comments": [
        {
          "author": "tmarkovski",
          "authorAssociation": "MEMBER",
          "body": "`PK` has two generation paths with equivalent output. What happens with `PK` generation when `SK` isn't available, e.g. by a verifier?",
          "createdAt": "2022-01-26T15:43:44Z",
          "updatedAt": "2022-01-26T15:43:44Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@tmarkovski can you clarify when SK is not available what other option there is to generate PK?",
          "createdAt": "2022-01-26T21:59:41Z",
          "updatedAt": "2022-01-26T21:59:41Z"
        },
        {
          "author": "tmarkovski",
          "authorAssociation": "MEMBER",
          "body": "I misunderstood the initial intent. You're basically suggesting we turn DPK into PK, and hide the generator construction internal the implementation, since these keys don't need to managed externally anyway.",
          "createdAt": "2022-01-26T22:29:33Z",
          "updatedAt": "2022-01-26T22:29:33Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax84zgngW",
          "commit": {
            "abbreviatedOid": "bb79eda"
          },
          "author": "tmarkovski",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-26T22:37:20Z",
          "updatedAt": "2022-01-26T22:37:20Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax84zhCa8",
          "commit": {
            "abbreviatedOid": "bb79eda"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-27T01:53:59Z",
          "updatedAt": "2022-01-27T01:53:59Z",
          "comments": []
        }
      ]
    },
    {
      "number": 36,
      "id": "PR_kwDOF8lax84xmrdL",
      "title": "Rename nonce to presentation message",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/36",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Implements the suggestion documented in issue #33 ",
      "createdAt": "2022-01-26T09:09:20Z",
      "updatedAt": "2022-01-28T00:37:45Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "1552d1b52c0feeb729b7b16640ce0be8a5e24cc4",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/nonce-presentation-message",
      "headRefOid": "e547196281bf67053153b3620fec5504e85a6dd2",
      "closedAt": "2022-01-28T00:37:41Z",
      "mergedAt": "2022-01-28T00:37:41Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "845bf8ad9e9f5eba34f58b579352b775d5011d11"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "PR opened multiple days, discussion was briefly had on last working group call also, multiple approvals, merging",
          "createdAt": "2022-01-28T00:37:36Z",
          "updatedAt": "2022-01-28T00:37:36Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax84zg7dt",
          "commit": {
            "abbreviatedOid": "28b0aaa"
          },
          "author": "tmarkovski",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-27T00:55:46Z",
          "updatedAt": "2022-01-27T00:55:46Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax84zk3WW",
          "commit": {
            "abbreviatedOid": "0299d68"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-27T18:54:33Z",
          "updatedAt": "2022-01-27T18:54:33Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I wouldn't say the PM is protected by the SPK, but it serves to tie the SPK to a specific context, ie. the current session between the prover and verifier.",
              "createdAt": "2022-01-27T18:54:33Z",
              "updatedAt": "2022-01-27T18:54:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84zlCp_",
          "commit": {
            "abbreviatedOid": "0299d68"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-27T19:41:18Z",
          "updatedAt": "2022-01-27T19:45:13Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Wouldn't we also need a nonce here to avoid replay? Or is the intention to use PM as the nonce when necessary?",
              "createdAt": "2022-01-27T19:41:18Z",
              "updatedAt": "2022-01-27T19:45:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84zlEwP",
          "commit": {
            "abbreviatedOid": "0299d68"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-27T19:50:01Z",
          "updatedAt": "2022-01-27T19:50:02Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\n: A message generated and protected by the spk.\r\n```",
              "createdAt": "2022-01-27T19:50:02Z",
              "updatedAt": "2022-01-27T19:50:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84zlFeV",
          "commit": {
            "abbreviatedOid": "0299d68"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-27T19:53:02Z",
          "updatedAt": "2022-01-27T19:53:03Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "The PM is in reality an arbitrary data structure that includes multiple pieces information such as a nonce, the guidance for this I think is best addressed through a revision to @christianpaquin PR #21.",
              "createdAt": "2022-01-27T19:53:02Z",
              "updatedAt": "2022-01-27T19:53:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84zlfSt",
          "commit": {
            "abbreviatedOid": "31dc82c"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-27T21:46:59Z",
          "updatedAt": "2022-01-27T21:46:59Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax84zl7kl",
          "commit": {
            "abbreviatedOid": "31dc82c"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-28T00:33:32Z",
          "updatedAt": "2022-01-28T00:33:32Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\n: A message generated and bound to the context of a specific spk.\r\n```",
              "createdAt": "2022-01-28T00:33:32Z",
              "updatedAt": "2022-01-28T00:33:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84zl7ry",
          "commit": {
            "abbreviatedOid": "e547196"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-28T00:34:31Z",
          "updatedAt": "2022-01-28T00:34:31Z",
          "comments": []
        }
      ]
    },
    {
      "number": 41,
      "id": "PR_kwDOF8lax84xx7lC",
      "title": "Generator demo",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/41",
      "state": "MERGED",
      "author": "mikelodder7",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This is a demo of how the BBS+ message generators can be created in Rust.",
      "createdAt": "2022-01-29T17:09:56Z",
      "updatedAt": "2022-01-29T21:39:24Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "845bf8ad9e9f5eba34f58b579352b775d5011d11",
      "headRepository": "mikelodder7/bbs-signature",
      "headRefName": "main",
      "headRefOid": "cc88bbda82a27cd3c7ef63cc769c38f6b73bf420",
      "closedAt": "2022-01-29T21:39:24Z",
      "mergedAt": "2022-01-29T21:39:24Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "b1d33726979e6660bbf68dd9f42039137729ca06"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Thanks Mike, this is a great foundation, I'll merge this and do a small amount of re-organising so we have space for other tooling in future",
          "createdAt": "2022-01-29T21:39:18Z",
          "updatedAt": "2022-01-29T21:39:18Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax84zrY3E",
          "commit": {
            "abbreviatedOid": "cc88bbd"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-29T21:38:13Z",
          "updatedAt": "2022-01-29T21:38:13Z",
          "comments": []
        }
      ]
    },
    {
      "number": 42,
      "id": "PR_kwDOF8lax84xzVK_",
      "title": "Split out blind sign functionality into a seperate draft",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/42",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Following discussion in the working group chat and conversation in issues #29 and #28. This PR attempts to move this forward by splitting the current draft into two:\r\n\r\n1. Core Draft - Responsible for defining the core BBS Signature Scheme operations sign, verify, spkgen and spkverify\r\n2. Extension Draft - Responsible for defining the blind sign functionality",
      "createdAt": "2022-01-30T23:03:27Z",
      "updatedAt": "2022-02-01T20:20:00Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "38f9001f0202b8481c6f22ec5e59a6e93a3ea1cf",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/split-draft",
      "headRefOid": "8e6742c2a0c794c0f4586fac4c6bef3dd6831439",
      "closedAt": "2022-02-01T20:19:58Z",
      "mergedAt": "2022-02-01T20:19:57Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "2be94728d0fb5e2a281afe2881a7b49cf6e1b9d0"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Multiple approvals, open multiple days, discussed on previous working group call and in #28, no net change in functionality just splitting it across two documents can re-merge later if required, merging.",
          "createdAt": "2022-02-01T20:19:48Z",
          "updatedAt": "2022-02-01T20:19:48Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax84zw5vu",
          "commit": {
            "abbreviatedOid": "359a9b1"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "strong +1 to splitting this... hopefully it can proceed faster.",
          "createdAt": "2022-01-31T21:50:40Z",
          "updatedAt": "2022-01-31T21:50:40Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax84zw_fJ",
          "commit": {
            "abbreviatedOid": "359a9b1"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-31T22:16:35Z",
          "updatedAt": "2022-01-31T22:16:35Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax84z1JAW",
          "commit": {
            "abbreviatedOid": "359a9b1"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-01T17:55:10Z",
          "updatedAt": "2022-02-01T17:55:10Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "This could probably be restructured since there's only 1 point.",
              "createdAt": "2022-02-01T17:55:10Z",
              "updatedAt": "2022-02-01T17:55:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84z178U",
          "commit": {
            "abbreviatedOid": "fdaee11"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-01T20:12:43Z",
          "updatedAt": "2022-02-01T20:12:43Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Have restructured now thanks @andrewwhitehead ",
              "createdAt": "2022-02-01T20:12:43Z",
              "updatedAt": "2022-02-01T20:12:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84z1884",
          "commit": {
            "abbreviatedOid": "8e6742c"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-01T20:17:01Z",
          "updatedAt": "2022-02-01T20:17:01Z",
          "comments": []
        }
      ]
    },
    {
      "number": 44,
      "id": "PR_kwDOF8lax84x0LvY",
      "title": "Add basic usecases section",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/44",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This PR is the start of some documentation around possible usecases for the BBS scheme. Unsure about where it should live or the style these should be written in.",
      "createdAt": "2022-01-31T05:37:14Z",
      "updatedAt": "2022-02-01T20:12:21Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "ceae7fde0b9d557d2778a92dead371ecc7a241f5",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/use-cases",
      "headRefOid": "92e8bc040d6242866fb3a068afdb4f50b4ff19a5",
      "closedAt": "2022-02-01T20:12:18Z",
      "mergedAt": "2022-02-01T20:12:18Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "38f9001f0202b8481c6f22ec5e59a6e93a3ea1cf"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "No normative, informative appendix on the application of the scheme, multiple approvals, merging",
          "createdAt": "2022-02-01T20:12:14Z",
          "updatedAt": "2022-02-01T20:12:14Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax84zw50W",
          "commit": {
            "abbreviatedOid": "bf70e40"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-31T21:50:59Z",
          "updatedAt": "2022-01-31T21:50:59Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax84zy0G5",
          "commit": {
            "abbreviatedOid": "bf70e40"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-01T10:53:32Z",
          "updatedAt": "2022-02-01T10:55:45Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": " +1 for the DPoP comparison, it does seem that not much will change for the auth server though, unless we make whatever holder binding mechanism we agree on optional (which could be worth considering). IMO the biggest advantage will be when it comes to the RS, since they will only have to validate the bbs+ proof, instead of both the JWT and the DPoP.",
              "createdAt": "2022-02-01T10:53:32Z",
              "updatedAt": "2022-02-01T10:55:46Z"
            },
            {
              "originalPosition": 13,
              "body": "It may not be trivial how to sign a token (i.e., JSON) with bbs+. Should we point to JWP here perhaps?",
              "createdAt": "2022-02-01T10:53:36Z",
              "updatedAt": "2022-02-01T10:55:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84zy2Tb",
          "commit": {
            "abbreviatedOid": "bf70e40"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-01T11:01:43Z",
          "updatedAt": "2022-02-01T11:01:43Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Agree, however the nuance here is that a BBS+ signature issued even without holder binding is still better than an ordinary JWT as it gives the ability for the resource server to detect a replay attack. While keeping the protocol relatively simple as the authorization server does not need up front key material from the relying party during an authZ request, nor does the resource server need to validate both a JWT and seperate DPoP.",
              "createdAt": "2022-02-01T11:01:43Z",
              "updatedAt": "2022-02-01T11:01:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84zy2a7",
          "commit": {
            "abbreviatedOid": "bf70e40"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-01T11:02:09Z",
          "updatedAt": "2022-02-01T11:02:09Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Yeah potentially a good idea as a note? Feel free to suggest one",
              "createdAt": "2022-02-01T11:02:09Z",
              "updatedAt": "2022-02-01T11:02:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84z1IHQ",
          "commit": {
            "abbreviatedOid": "bf70e40"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-01T17:53:15Z",
          "updatedAt": "2022-02-01T17:53:33Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "```suggestion\r\nBBS Signatures due to their unique properties removes this source of correlation but maintains the same set of guarantees required by a resource server to validate an access token back to its relevant authority (note that an approach to signing JSON tokens with BBS that may be of relevance is the [JWP](https://json-web-proofs.github.io/json-web-proofs/draft-jmiller-json-web-proof.html) format and serialization). In the context of a protocol like OAuth2.0 the access token issued by the authorization server would feature a BBS Signature, however instead of the relying party providing this access token as issued, in their request to a resource server, they derive a unique proof from the original access token and include that in the request instead, thus removing this vector of correlation.\r\n```",
              "createdAt": "2022-02-01T17:53:15Z",
              "updatedAt": "2022-02-01T19:58:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84z15X2",
          "commit": {
            "abbreviatedOid": "92e8bc0"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-01T20:01:57Z",
          "updatedAt": "2022-02-01T20:01:57Z",
          "comments": []
        }
      ]
    },
    {
      "number": 45,
      "id": "PR_kwDOF8lax84x2rPN",
      "title": "Fixed private key domain to 0 < SK < r",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/45",
      "state": "MERGED",
      "author": "christianpaquin",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "As defined in `KeyGen`, `SK` should not be `0` or `r` in `SkToPk`. The `KeyGen` definition matches selection from `Zp*` from section 4.3 of [Camenisch, Drijvers, Lehmann](https://eprint.iacr.org/2016/663.pdf).",
      "createdAt": "2022-01-31T17:55:11Z",
      "updatedAt": "2022-01-31T21:43:22Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "ceae7fde0b9d557d2778a92dead371ecc7a241f5",
      "headRepository": "christianpaquin/bbs-signature",
      "headRefName": "sk-domain-fix",
      "headRefOid": "0847ffa4578ed029aa37ba84e50295a938735b24",
      "closedAt": "2022-01-31T21:43:22Z",
      "mergedAt": "2022-01-31T21:43:22Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "a5771a42d99466a1e87a06afeb2d1cdf8cec6b5d"
      },
      "comments": [
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Probably shouldn\u2019t be any low value either like `1`",
          "createdAt": "2022-01-31T18:25:00Z",
          "updatedAt": "2022-01-31T18:25:00Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@mikelodder7 can you suggest some spec text if you think this definition should be even more constrained?",
          "createdAt": "2022-01-31T19:25:19Z",
          "updatedAt": "2022-01-31T19:25:19Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Probably shouldn\u2019t be any low value either like `1`\r\n\r\nI don't see a problem if SK is indeed random. This is similar to the way it is defined [here ](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-bls-signature-04#section-2.2) i think.",
          "createdAt": "2022-01-31T19:31:13Z",
          "updatedAt": "2022-01-31T19:31:13Z"
        },
        {
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Probably shouldn\u2019t be any low value either like `1`\r\n\r\nI updated the PR description to point to section 4.3 of CDL, where they pick SK at random from Zp*. This PR is mainly to correct an inconsistency in the spec.",
          "createdAt": "2022-01-31T21:07:49Z",
          "updatedAt": "2022-01-31T21:07:49Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Minor change, aligning to underlying academic work, multiple approvals, merging. Thanks @christianpaquin",
          "createdAt": "2022-01-31T21:43:15Z",
          "updatedAt": "2022-01-31T21:43:15Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax84zwY82",
          "commit": {
            "abbreviatedOid": "0847ffa"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-31T19:27:20Z",
          "updatedAt": "2022-01-31T19:27:20Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax84zwaKs",
          "commit": {
            "abbreviatedOid": "0847ffa"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-31T19:32:08Z",
          "updatedAt": "2022-01-31T19:32:08Z",
          "comments": []
        }
      ]
    },
    {
      "number": 47,
      "id": "PR_kwDOF8lax84x4u7N",
      "title": "Restructure to allow for profile sections",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/47",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Minor restructure to the draft to make room for the concrete definition of a profile for the BBS signature scheme based on BLS12-381. Relevant discussion in #46 ",
      "createdAt": "2022-02-01T08:33:25Z",
      "updatedAt": "2022-02-01T19:57:34Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "a5771a42d99466a1e87a06afeb2d1cdf8cec6b5d",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/restructure-profiles",
      "headRefOid": "29698c97938835987d35cd05730c268ac65a1f2a",
      "closedAt": "2022-02-01T19:56:52Z",
      "mergedAt": "2022-02-01T19:56:51Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "63c561e7851a8e5ce5ee919ba95b5500e64709ae"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Multiple approvals, minor re-structure of doc, blocking further progression of draft, merging.",
          "createdAt": "2022-02-01T19:57:34Z",
          "updatedAt": "2022-02-01T19:57:34Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax84zzkS9",
          "commit": {
            "abbreviatedOid": "29698c9"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-01T13:51:07Z",
          "updatedAt": "2022-02-01T13:51:07Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "we need a spec that does update the JOSE / COSE registry... eventually. \r\nI would prefer if we could do that here.",
              "createdAt": "2022-02-01T13:51:07Z",
              "updatedAt": "2022-02-01T13:51:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84zzkUv",
          "commit": {
            "abbreviatedOid": "29698c9"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-01T13:51:12Z",
          "updatedAt": "2022-02-01T13:51:12Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax84z1KPb",
          "commit": {
            "abbreviatedOid": "29698c9"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-01T17:57:54Z",
          "updatedAt": "2022-02-01T17:57:54Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax84z14E6",
          "commit": {
            "abbreviatedOid": "29698c9"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-01T19:56:44Z",
          "updatedAt": "2022-02-01T19:56:45Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "See #48 ",
              "createdAt": "2022-02-01T19:56:44Z",
              "updatedAt": "2022-02-01T19:56:45Z"
            }
          ]
        }
      ]
    },
    {
      "number": 49,
      "id": "PR_kwDOF8lax84x7daP",
      "title": "Minor rework of abstract",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/49",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-02-01T20:57:36Z",
      "updatedAt": "2022-02-02T18:58:26Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "2be94728d0fb5e2a281afe2881a7b49cf6e1b9d0",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/rework-abstract",
      "headRefOid": "e28c68124f182331bb7ceed74f54701bf973eb92",
      "closedAt": "2022-02-02T18:58:22Z",
      "mergedAt": "2022-02-02T18:58:22Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "b08309ce8aed58d0acfe33bf0e119c69ac54ef5d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax84z2ia8",
          "commit": {
            "abbreviatedOid": "03eb5d8"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-01T23:18:21Z",
          "updatedAt": "2022-02-01T23:18:21Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax84z20ma",
          "commit": {
            "abbreviatedOid": "03eb5d8"
          },
          "author": "bumblefudge",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-02T01:46:31Z",
          "updatedAt": "2022-02-02T01:46:31Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nBBS is a digital signature scheme categorized as a form of short group signature that supports several novel properties. Notably, the scheme supports signing multiple messages whilst producing a single output digital signature. Through this capability, the possessor of a signature is able to derive proofs that selectively reveal subsets of the originally signed set of messages, whilst preserving the verifiable authenticity and integrity of the messages. Furthermore, these derived proofs are said to be zero-knowledge in nature as they do not reveal the underlying signature; instead, what they reveal is a proof of knowledge of the undisclosed signature.\r\n```",
              "createdAt": "2022-02-02T01:46:31Z",
              "updatedAt": "2022-02-02T01:46:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84z20px",
          "commit": {
            "abbreviatedOid": "03eb5d8"
          },
          "author": "bumblefudge",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-02T01:47:05Z",
          "updatedAt": "2022-02-02T01:47:05Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I saw a rare opportunity to be helpful and I jumped on it :D ",
              "createdAt": "2022-02-02T01:47:05Z",
              "updatedAt": "2022-02-02T01:47:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84z22Cw",
          "commit": {
            "abbreviatedOid": "03eb5d8"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-02T02:01:49Z",
          "updatedAt": "2022-02-02T02:01:50Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Much appreciated, thank you!",
              "createdAt": "2022-02-02T02:01:49Z",
              "updatedAt": "2022-02-02T02:01:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84z3Ffp",
          "commit": {
            "abbreviatedOid": "e28c681"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-02T04:54:05Z",
          "updatedAt": "2022-02-02T04:54:05Z",
          "comments": []
        }
      ]
    },
    {
      "number": 50,
      "id": "PR_kwDOF8lax84x7ddn",
      "title": "Minor rework of introduction",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/50",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-02-01T20:57:53Z",
      "updatedAt": "2022-02-07T22:27:00Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "2be94728d0fb5e2a281afe2881a7b49cf6e1b9d0",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/rework-introduction",
      "headRefOid": "77a78a98b95be0e3dd5a8b7f001235ab70410a70",
      "closedAt": "2022-02-07T22:26:42Z",
      "mergedAt": "2022-02-07T22:26:42Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "6f6e986ca4988d6ce12ae6c1a6a4097fa2927b6e"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed on Feb 7th call, multiple approvals, purely editorial, merging",
          "createdAt": "2022-02-07T22:26:38Z",
          "updatedAt": "2022-02-07T22:26:38Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax84z2ihw",
          "commit": {
            "abbreviatedOid": "77a78a9"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-01T23:19:00Z",
          "updatedAt": "2022-02-01T23:19:00Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax840KYMz",
          "commit": {
            "abbreviatedOid": "77a78a9"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-07T19:14:09Z",
          "updatedAt": "2022-02-07T19:14:09Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax840KYRx",
          "commit": {
            "abbreviatedOid": "77a78a9"
          },
          "author": "quartzjer",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-07T19:14:28Z",
          "updatedAt": "2022-02-07T19:14:28Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax840KYZX",
          "commit": {
            "abbreviatedOid": "77a78a9"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-07T19:14:56Z",
          "updatedAt": "2022-02-07T19:14:56Z",
          "comments": []
        }
      ]
    },
    {
      "number": 51,
      "id": "PR_kwDOF8lax84x72b6",
      "title": "Minor tweaks to the terminology",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/51",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Adds a definition for r and splits the notational convention section into two parts",
      "createdAt": "2022-02-01T23:28:34Z",
      "updatedAt": "2022-02-15T08:18:30Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "2be94728d0fb5e2a281afe2881a7b49cf6e1b9d0",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/terminology-section",
      "headRefOid": "5a73c934ece3b8f580355e77ebe1df8c34c4f6b0",
      "closedAt": "2022-02-07T22:23:21Z",
      "mergedAt": "2022-02-07T22:23:21Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "2cd2c0926460561b62543b748ffb67181153e656"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed on 7th Feb call no objections, merging",
          "createdAt": "2022-02-07T22:23:16Z",
          "updatedAt": "2022-02-07T22:23:16Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax84z_yZF",
          "commit": {
            "abbreviatedOid": "5a73c93"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-03T20:12:27Z",
          "updatedAt": "2022-02-03T20:12:27Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax840KYld",
          "commit": {
            "abbreviatedOid": "5a73c93"
          },
          "author": "quartzjer",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-07T19:15:41Z",
          "updatedAt": "2022-02-07T19:15:41Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax840KYmY",
          "commit": {
            "abbreviatedOid": "5a73c93"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-07T19:15:45Z",
          "updatedAt": "2022-02-07T19:15:45Z",
          "comments": []
        }
      ]
    },
    {
      "number": 53,
      "id": "PR_kwDOF8lax84yHwNK",
      "title": "Ensuring SK > 0",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/53",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Update `keyGen` to always return SK>0 and `KeyValidate` to check if SK = 0. \r\n\r\nAnother option would be to point to the [BLS draft](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-bls-signature-04#section-2.3) since the functions are the same. There is useful context for their choices [here](https://github.com/cfrg/draft-irtf-cfrg-bls-signature/issues/25).",
      "createdAt": "2022-02-05T16:23:51Z",
      "updatedAt": "2022-02-07T22:24:06Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "6182a4958889acb673dde16b02762dc05c7062ac",
      "headRepository": "BasileiosKal/bbs-signature",
      "headRefName": "update_keyGen",
      "headRefOid": "1ed06fe84da2a6bb9221555673559869b4e9cf2b",
      "closedAt": "2022-02-07T22:24:05Z",
      "mergedAt": "2022-02-07T22:24:05Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "af5cc53b9ae6d00c2257a669a5ef8a931a658527"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed on Feb 7th WG call, no objections, aligning to changes in underlying spec that the section was born from, merging",
          "createdAt": "2022-02-07T22:24:04Z",
          "updatedAt": "2022-02-07T22:24:04Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax840KaJE",
          "commit": {
            "abbreviatedOid": "1ed06fe"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-07T19:21:05Z",
          "updatedAt": "2022-02-07T19:21:05Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax840LEID",
          "commit": {
            "abbreviatedOid": "1ed06fe"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-07T22:23:33Z",
          "updatedAt": "2022-02-07T22:23:33Z",
          "comments": []
        }
      ]
    },
    {
      "number": 55,
      "id": "PR_kwDOF8lax84yMYMI",
      "title": "Added presentation message selection section.",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/55",
      "state": "MERGED",
      "author": "christianpaquin",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Added presentation message selection section, to clarify randomness recommendations. Addresses issue #15.\r\n\r\nPreviously PR #21, but re-opening cleaner PR here.",
      "createdAt": "2022-02-07T19:52:04Z",
      "updatedAt": "2022-02-07T22:24:55Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "6182a4958889acb673dde16b02762dc05c7062ac",
      "headRepository": "christianpaquin/bbs-signature",
      "headRefName": "nonce-issue-15-redux",
      "headRefOid": "4433d3cad1b511a916b5820cd51a73642fa75a5d",
      "closedAt": "2022-02-07T22:24:55Z",
      "mergedAt": "2022-02-07T22:24:55Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "79346d7ebd8a89476441673e8e68ac91f985e1ef"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed on 7th Feb WG call, no objections, multiple approvals, merging",
          "createdAt": "2022-02-07T22:24:50Z",
          "updatedAt": "2022-02-07T22:24:50Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax840KjhM",
          "commit": {
            "abbreviatedOid": "4433d3c"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-07T19:58:05Z",
          "updatedAt": "2022-02-07T19:58:05Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax840Kl_f",
          "commit": {
            "abbreviatedOid": "4433d3c"
          },
          "author": "quartzjer",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-07T20:08:37Z",
          "updatedAt": "2022-02-07T20:08:37Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax840LET7",
          "commit": {
            "abbreviatedOid": "4433d3c"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-07T22:24:25Z",
          "updatedAt": "2022-02-07T22:24:25Z",
          "comments": []
        }
      ]
    },
    {
      "number": 56,
      "id": "PR_kwDOF8lax84yM5E6",
      "title": "add link to blind sign extension draft",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/56",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "As discussed on Feb 7th WG call, this PR addresses the fact that a link to the blind sign draft was missing from the root readme.",
      "createdAt": "2022-02-07T22:49:59Z",
      "updatedAt": "2022-02-08T00:25:20Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "6f6e986ca4988d6ce12ae6c1a6a4097fa2927b6e",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/update-readme",
      "headRefOid": "e2ba1b5cf036faa801954d05a0a9d554ef8ba813",
      "closedAt": "2022-02-08T00:25:18Z",
      "mergedAt": "2022-02-08T00:25:18Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "2f0f0f5a6b8ba77acd13ea196f74580069b6e13d"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Multiple approvals, facilitates better discovery of output from this WG no changes to actual drafts, merging",
          "createdAt": "2022-02-08T00:25:12Z",
          "updatedAt": "2022-02-08T00:25:12Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax840LKgO",
          "commit": {
            "abbreviatedOid": "e2ba1b5"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-07T22:56:29Z",
          "updatedAt": "2022-02-07T22:56:29Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax840LRfV",
          "commit": {
            "abbreviatedOid": "e2ba1b5"
          },
          "author": "tmarkovski",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-07T23:41:21Z",
          "updatedAt": "2022-02-07T23:41:21Z",
          "comments": []
        }
      ]
    },
    {
      "number": 57,
      "id": "PR_kwDOF8lax84yXyyi",
      "title": "Moving the operations inside a code block",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/57",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Moving the entire function inside a code block to display correctly white spaces etc., in markdown. This is consistent to most other specs like [BLS signatures](https://github.com/cfrg/draft-irtf-cfrg-bls-signature/blob/master/draft-irtf-cfrg-bls-signature.md), [Blind RSA](https://github.com/cfrg/draft-irtf-cfrg-blind-signatures/blob/main/draft-irtf-cfrg-rsa-blind-signatures.md), [Frost](https://github.com/cfrg/draft-irtf-cfrg-frost/blob/master/draft-irtf-cfrg-frost.md) etc.",
      "createdAt": "2022-02-10T11:28:12Z",
      "updatedAt": "2022-02-10T18:48:11Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "2f0f0f5a6b8ba77acd13ea196f74580069b6e13d",
      "headRepository": "BasileiosKal/bbs-signature",
      "headRefName": "markdown_display_tweaks",
      "headRefOid": "79b904bd3f552bcadac28aeb5265b1a85d4a3d88",
      "closedAt": "2022-02-10T18:48:11Z",
      "mergedAt": "2022-02-10T18:48:11Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "535d98143d46e10d2c358f76bb985e2c530d018a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax840aNN7",
          "commit": {
            "abbreviatedOid": "79b904b"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-10T18:34:01Z",
          "updatedAt": "2022-02-10T18:34:01Z",
          "comments": []
        }
      ]
    },
    {
      "number": 58,
      "id": "PR_kwDOF8lax84yoILV",
      "title": "SpkGen alternative high-level description",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/58",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "IMO the SpkGen algorithm on its own is a little hard to understand for someone that doesn\u2019t know how BBS+ work. This is a first attempt for providing an alternative, higher-level description and intuition of SpkGen, in 2 steps: the bbs signature blinding and the generalized Schnorr proof.",
      "createdAt": "2022-02-12T19:15:09Z",
      "updatedAt": "2022-02-16T00:40:56Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "55ba4a292f66e89a31b32793497ebc78b044dfe9",
      "headRepository": "BasileiosKal/bbs-signature",
      "headRefName": "high-level-spkGen",
      "headRefOid": "c94a2dac40cfa21c4c42e6782b24392aec086e1b",
      "closedAt": "2022-02-16T00:40:56Z",
      "mergedAt": "2022-02-16T00:40:56Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "93cc1565a091dffa5067310b01c22bb5a78820b5"
      },
      "comments": [
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Perhaps a follow-up PR to change the following:\r\n\r\n1. Points should be uppercase\r\n2. Scalars should be lowercase",
          "createdAt": "2022-02-14T16:15:27Z",
          "updatedAt": "2022-02-14T16:15:27Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@BasileiosKal are you able to resolve conflicts with this PR?",
          "createdAt": "2022-02-15T07:47:56Z",
          "updatedAt": "2022-02-15T07:47:56Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> @BasileiosKal are you able to resolve conflicts with this PR?\r\n\r\nupdated",
          "createdAt": "2022-02-15T20:38:53Z",
          "updatedAt": "2022-02-15T20:38:53Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Non-normative section, providing a good explanation of this complex algorithm, multiple approvals, PR open multiple days, merging.",
          "createdAt": "2022-02-16T00:40:51Z",
          "updatedAt": "2022-02-16T00:40:51Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax840gT8k",
          "commit": {
            "abbreviatedOid": "1ca240d"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-12T19:45:29Z",
          "updatedAt": "2022-02-12T19:45:29Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "Any commentary we can provide here on what P2 is?",
              "createdAt": "2022-02-12T19:45:29Z",
              "updatedAt": "2022-02-12T19:45:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax840gT-C",
          "commit": {
            "abbreviatedOid": "1ca240d"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-12T19:46:50Z",
          "updatedAt": "2022-02-12T19:46:51Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Assuming r is as defined in terminology? If so, no need to change anything",
              "createdAt": "2022-02-12T19:46:51Z",
              "updatedAt": "2022-02-12T19:46:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax840gT_S",
          "commit": {
            "abbreviatedOid": "1ca240d"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-12T19:48:09Z",
          "updatedAt": "2022-02-12T19:48:09Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "```suggestion\r\n### Algorithmic Explanation\r\n```",
              "createdAt": "2022-02-12T19:48:09Z",
              "updatedAt": "2022-02-12T19:48:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax840gWWS",
          "commit": {
            "abbreviatedOid": "1ca240d"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-12T22:19:59Z",
          "updatedAt": "2022-02-12T22:19:59Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nThe following section provides an explanation of how the Signature Proof Of Knowledge Generation (SpkGen) works. \r\n\r\nLet the prover be in possession of a BBS signature `(A, e, s)` with `A = b * (1/(e + Sk))` where `Sk` the signer's secret key and,\r\n```",
              "createdAt": "2022-02-12T22:19:59Z",
              "updatedAt": "2022-02-12T22:19:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax840g2Lj",
          "commit": {
            "abbreviatedOid": "1ca240d"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-13T17:54:07Z",
          "updatedAt": "2022-02-13T17:54:07Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Yes, r is as defined in the Notation section (the prime order of G1 and G2).",
              "createdAt": "2022-02-13T17:54:07Z",
              "updatedAt": "2022-02-13T17:54:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax840g2ru",
          "commit": {
            "abbreviatedOid": "a5d13a7"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-13T18:17:28Z",
          "updatedAt": "2022-02-13T18:17:28Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "updated",
              "createdAt": "2022-02-13T18:17:28Z",
              "updatedAt": "2022-02-13T18:17:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax840g4vc",
          "commit": {
            "abbreviatedOid": "c09ed88"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2022-02-13T19:48:12Z",
          "updatedAt": "2022-02-13T19:48:12Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax840j0ju",
          "commit": {
            "abbreviatedOid": "c09ed88"
          },
          "author": "tmarkovski",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-14T15:33:13Z",
          "updatedAt": "2022-02-14T15:33:13Z",
          "comments": []
        }
      ]
    },
    {
      "number": 60,
      "id": "PR_kwDOF8lax84ywZ76",
      "title": "Core draft restructure",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/60",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This PR is a proposal to restructure the draft drawing inspiration from the latest [BLS signatures draft](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-bls-signature-04). Essentially the high-level structure of the document after this PR is merged will take the following form.\r\n\r\n- Introduction\r\n    - Terminology\r\n    - Notation\r\n    - Structure of this document\r\n- Conventions\r\n- Scheme Definition\r\n    - Parameters\r\n    - Operations\r\n        - KeyGen\r\n        - SkToPk\r\n        - ....\r\n- Security Considerations\r\n- Profile -> Ciphersuite\r\n    - Format\r\n    - BLS12-381 Ciphersuite\r\n- IANA Considerations\r\n- Appendix\r\n- .....\r\n",
      "createdAt": "2022-02-14T04:10:25Z",
      "updatedAt": "2022-02-15T07:46:40Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "535d98143d46e10d2c358f76bb985e2c530d018a",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/minor-restructure",
      "headRefOid": "397e9636bf785327d8e0647cc1664df56c717b86",
      "closedAt": "2022-02-15T07:46:13Z",
      "mergedAt": "2022-02-15T07:46:13Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "55ba4a292f66e89a31b32793497ebc78b044dfe9"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Multiple approvals, purely editorial, merging",
          "createdAt": "2022-02-15T07:46:40Z",
          "updatedAt": "2022-02-15T07:46:40Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax840j0vm",
          "commit": {
            "abbreviatedOid": "397e963"
          },
          "author": "tmarkovski",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-14T15:33:42Z",
          "updatedAt": "2022-02-14T15:33:42Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax840j4Te",
          "commit": {
            "abbreviatedOid": "397e963"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-14T15:43:33Z",
          "updatedAt": "2022-02-14T15:43:33Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax840kDLg",
          "commit": {
            "abbreviatedOid": "397e963"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-14T16:14:24Z",
          "updatedAt": "2022-02-14T16:14:24Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax840lDF_",
          "commit": {
            "abbreviatedOid": "397e963"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-14T20:03:18Z",
          "updatedAt": "2022-02-14T20:03:18Z",
          "comments": []
        }
      ]
    },
    {
      "number": 61,
      "id": "PR_kwDOF8lax84yzKE8",
      "title": "Add message mapping to scalar",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/61",
      "state": "CLOSED",
      "author": "mikelodder7",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Adds a section describing how to map messages to a scalar that can be cryptographically signed. ",
      "createdAt": "2022-02-14T16:36:19Z",
      "updatedAt": "2022-04-05T01:21:58Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "68f56263eac415e2dc3e022e60bd1544c0d352eb",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "ml/message-mapping",
      "headRefOid": "a9376bfb5b68f28ee886e5b69e171196680149da",
      "closedAt": "2022-03-21T21:11:17Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed briefly on WG call 21st of Feb, one proposal was to have the MapToScalar as a pre-sign pre-spkgen operations for converting messages into their appropriate scalars.",
          "createdAt": "2022-02-21T19:19:48Z",
          "updatedAt": "2022-02-21T19:19:48Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "NONE",
          "body": "@mikelodder7 Is MapToScalar the same extension point where membership values would be encoded such that set (non-)membership proofs can be later generated?",
          "createdAt": "2022-02-21T19:34:58Z",
          "updatedAt": "2022-02-21T19:34:58Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> @mikelodder7 Is MapToScalar the same extension point where membership values would be encoded such that set (non-)membership proofs can be later generated?\r\n\r\nYes",
          "createdAt": "2022-02-22T23:30:07Z",
          "updatedAt": "2022-02-22T23:30:07Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "I understand the use case for the first three encoding methods suggested here, however unsure what value the remaining few provide, could we remove these or elaborate more on their usage.\r\n\r\nI also think this section needs to be restructured formally to be more like the other operations defined in the spec, as currently the numeric encoding options for example describes the algorithm in a paragraph instead of say how the sign operation is performed.\r\n\r\nAlso we have to be very confident in the collision resistant properties of the numeric encoding method to prevent a message forgery attack like what is being discussed in #74.\r\n\r\nAnd guidance needs to be added for the second option around message generator selection/validation which is effectively a committed message, because failure to do so could lead a signer to use a generator twice.",
          "createdAt": "2022-03-01T07:49:50Z",
          "updatedAt": "2022-03-01T07:49:50Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "I'd also note that option 2 is not actually a MapToScalar function as the input is already a scalar so I think we can disregard it from this section of the spec and instead supply appropriate guidance elsewhere.",
          "createdAt": "2022-03-02T04:55:14Z",
          "updatedAt": "2022-03-02T04:55:14Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "NONE",
          "body": "> I understand the use case for the first three encoding methods suggested here, however unsure what value the remaining few provide, could we remove these or elaborate more on their usage.\r\n\r\nI believe these fixed values are intended as a means for the holder to generate a proof about a value that isn't being disclosed.  If the issuer sets the value to null/empty/ignored, that the holder can generate a proof of such to differentiate that message from one that is simply being hidden.\r\n\r\nWhile a similar signaling is also possible at the application level by having encoded values, I believe these are useful to represent when the value itself (encoded or not) is in the given null/empty/ignored state when being signed.  The alternative is to consider that an error, that every message MUST always have a defined value before it can be mapped to a scalar.",
          "createdAt": "2022-03-04T23:28:59Z",
          "updatedAt": "2022-03-04T23:28:59Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "> I believe these fixed values are intended as a means for the holder to generate a proof about a value that isn't being disclosed. If the issuer sets the value to null/empty/ignored, that the holder can generate a proof of such to differentiate that message from one that is simply being hidden.\r\n\r\nThanks @quartzjer makes sense, in that case I understand the potential for having a representation for null or ignored (maybe?). But empty appears to be better addressed at the application layer because not all data types have the concept of empty (e.g numeric data types).\r\n\r\nI continue to be cautious here, in the case of the numeric mapping function it must be as collision resistant as a hash function to be acceptable. ",
          "createdAt": "2022-03-05T00:05:51Z",
          "updatedAt": "2022-03-05T00:05:51Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It doesn\u2019t have to be collision resistant to map to the scalar. My first name will always map to the same value as a null would to another. They don\u2019t even have to be unique. However mapping to a scalar should be a separate discussion in an appendix as guidelines not requirements. ",
          "createdAt": "2022-03-05T00:09:48Z",
          "updatedAt": "2022-03-05T00:09:48Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I\u2019m going to update to be such",
          "createdAt": "2022-03-05T00:10:04Z",
          "updatedAt": "2022-03-05T00:10:04Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "I'd like to hold off merging this PR while we discuss a proposal to break each mapping method out like is shown in #77 ",
          "createdAt": "2022-03-11T04:50:38Z",
          "updatedAt": "2022-03-11T04:50:38Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed on the WG call, going to close this PR in favour of opening seperate ones for each mapping method, if not objection from @mikelodder7 ",
          "createdAt": "2022-03-21T18:21:38Z",
          "updatedAt": "2022-03-21T18:21:38Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Discussed on the WG call, going to close this PR in favour of opening seperate ones for each mapping method, if not objection from @mikelodder7\r\n\r\n\ud83d\udc4d\ud83c\udffb ",
          "createdAt": "2022-03-21T18:30:41Z",
          "updatedAt": "2022-03-21T18:30:41Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax840mz6H",
          "commit": {
            "abbreviatedOid": "f3fefa9"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-15T07:58:01Z",
          "updatedAt": "2022-02-15T07:58:02Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "Think we should talk about usecases elsewhere\r\n\r\n```suggestion\r\nThe following is a list of mappings:\r\n```",
              "createdAt": "2022-02-15T07:58:02Z",
              "updatedAt": "2022-02-15T07:58:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax840m0rn",
          "commit": {
            "abbreviatedOid": "f3fefa9"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-15T08:01:06Z",
          "updatedAt": "2022-02-15T08:01:07Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "```suggestion\r\nData to be signed can be mapped multiple ways depending on how it will be used downstream in various Zero-Knowledge Proof protocols. For example to be able to construct a range proof for a signed message, it must have been encoded in a particular way during the signing procedure.\r\n```",
              "createdAt": "2022-02-15T08:01:07Z",
              "updatedAt": "2022-02-15T08:01:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax840m0wn",
          "commit": {
            "abbreviatedOid": "f3fefa9"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-15T08:01:24Z",
          "updatedAt": "2022-02-15T08:01:25Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "```suggestion\r\n2. **Bytes**: a value that is already in the base field. No mapping method required.\r\n```",
              "createdAt": "2022-02-15T08:01:24Z",
              "updatedAt": "2022-02-15T08:01:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax840m015",
          "commit": {
            "abbreviatedOid": "f3fefa9"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-15T08:01:46Z",
          "updatedAt": "2022-02-15T08:01:47Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "Can you explain the assignment of the value 5?",
              "createdAt": "2022-02-15T08:01:46Z",
              "updatedAt": "2022-02-15T08:01:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax840xBJG",
          "commit": {
            "abbreviatedOid": "f3fefa9"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-16T23:30:34Z",
          "updatedAt": "2022-02-16T23:30:34Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "Its the smallest safe prime. Otherwise there's no other special meaning.",
              "createdAt": "2022-02-16T23:30:34Z",
              "updatedAt": "2022-02-16T23:30:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax840_cKH",
          "commit": {
            "abbreviatedOid": "c214191"
          },
          "author": "quartzjer",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "Very supportive of adding these flexible definitions of different mapping methods.",
          "createdAt": "2022-02-21T19:33:27Z",
          "updatedAt": "2022-02-21T19:33:27Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax841EMh-",
          "commit": {
            "abbreviatedOid": "c214191"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-22T19:54:40Z",
          "updatedAt": "2022-02-22T19:54:40Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "consider adding an issue for the FIXME, so it can be tracked during issue review.",
              "createdAt": "2022-02-22T19:54:40Z",
              "updatedAt": "2022-02-22T19:55:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax841Ei6P",
          "commit": {
            "abbreviatedOid": "c214191"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-22T21:29:23Z",
          "updatedAt": "2022-02-22T21:29:23Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "@OR13 this issue has already been addressed and updated in the latest draft see https://identity.foundation/bbs-signature/draft-bbs-signatures.html#section-1.2 PR is just out of date",
              "createdAt": "2022-02-22T21:29:23Z",
              "updatedAt": "2022-02-22T21:29:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax841xbaa",
          "commit": {
            "abbreviatedOid": "a9376bf"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-07T19:23:13Z",
          "updatedAt": "2022-03-07T19:23:13Z",
          "comments": []
        }
      ]
    },
    {
      "number": 62,
      "id": "PR_kwDOF8lax84yzYBr",
      "title": "Update algorithms for consistency and simplicity",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/62",
      "state": "MERGED",
      "author": "mikelodder7",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This updates `Sign` to be deterministic and includes updating SpkGen and SpkVerify to be mathematically correct and removes superfluous checks in verify and makes it simpler.\r\nSpkGen proof is much smaller now.\r\nSpkVerify has reduced steps but its equally correct and secure.",
      "createdAt": "2022-02-14T17:30:53Z",
      "updatedAt": "2022-02-23T21:43:31Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "68f56263eac415e2dc3e022e60bd1544c0d352eb",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "ml/detsign",
      "headRefOid": "d0394236c672602528e1e122057c1fe678735010",
      "closedAt": "2022-02-23T21:43:28Z",
      "mergedAt": "2022-02-23T21:43:28Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "d02eced2451d4d63fb765ae0c75f44b9365e9d46"
      },
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "For the `spkGen` and `spkVerify` are those essentially the same changes as in PR#23 with different notation?? \r\n\r\nI can close PR#23 since it seems to do the same thing for those functions.",
          "createdAt": "2022-02-14T19:40:06Z",
          "updatedAt": "2022-02-14T19:40:06Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "No there not exactly the same",
          "createdAt": "2022-02-14T19:40:57Z",
          "updatedAt": "2022-02-14T19:40:57Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> No there not exactly the same\r\n\r\nOk. Is there a reason to keep both PRs open then??\r\n\r\nIt does seem that every change in #23 is also here.",
          "createdAt": "2022-02-14T19:50:34Z",
          "updatedAt": "2022-02-14T19:50:34Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "In general im supportive of the direction this PR is taking so thanks @mikelodder7 for submitting it, however it is difficult to review because it is attempting to do many things, including:\r\n\r\n- Updates the sign procedure to be deterministic\r\n- Changing SpkGen procedure, including the resulting serialization of the proof\r\n- Changing SpkVerify procedure, including how it relies on the proof as its input (now uses the challenge supplied)\r\n- Multiple updates to notation including changing terms from r to q? Captializing some notation h -> H And using new notation that isn't completely defined e.g `hash.read()`\r\n\r\n@mikelodder7 have I got the above right as the scope of this PR ^ and if so any way we can break it apart for independent review of each item?",
          "createdAt": "2022-02-15T07:54:41Z",
          "updatedAt": "2022-02-15T07:54:41Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> > No there not exactly the same\r\n> \r\n> Ok. Is there a reason to keep both PRs open then??\r\n> \r\n> It does seem that every change in #23 is also here.\r\n\r\nIt\u2019s not exactly. That PR has the dual commitment equality check that isn\u2019t needed",
          "createdAt": "2022-02-16T00:47:51Z",
          "updatedAt": "2022-02-16T00:47:51Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@mikelodder7 can you address the reviews above and conflicts after merging #23?",
          "createdAt": "2022-02-16T00:54:30Z",
          "updatedAt": "2022-02-16T00:54:30Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> @mikelodder7 can you address the reviews above and conflicts after merging #23?\r\n\r\nPlanning on in the next day or so",
          "createdAt": "2022-02-16T00:56:17Z",
          "updatedAt": "2022-02-16T00:56:17Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I can't get the proof to work out with these changes so far, is there an implementation to compare against?",
          "createdAt": "2022-02-17T20:44:24Z",
          "updatedAt": "2022-02-17T20:44:24Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@mikelodder7 can you update this PR to resolve the conflict?",
          "createdAt": "2022-02-19T03:56:56Z",
          "updatedAt": "2022-02-19T03:56:56Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed on WG call 21st of Feb, unable to progress at this time, PR conflicts need to be resolved",
          "createdAt": "2022-02-21T19:27:40Z",
          "updatedAt": "2022-02-21T19:27:40Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Merging this PR on the understanding that @BasileiosKal and @mikelodder7 are working behind the scenes to ensure that this description of SpkGen is still consistent with academic literature.",
          "createdAt": "2022-02-23T21:43:15Z",
          "updatedAt": "2022-02-23T21:43:15Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax840k_oF",
          "commit": {
            "abbreviatedOid": "489edca"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-14T19:48:53Z",
          "updatedAt": "2022-02-14T19:48:54Z",
          "comments": [
            {
              "originalPosition": 130,
              "body": "`b = P1 + H0 * s + H[1] * msg[1] + ... + H[L] * msg[L]` I think, and probably `msg[1]` instead of `msg[i]` above. Should we capitalize B?",
              "createdAt": "2022-02-14T19:48:53Z",
              "updatedAt": "2022-02-14T19:48:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax840lAM0",
          "commit": {
            "abbreviatedOid": "489edca"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-14T19:51:15Z",
          "updatedAt": "2022-02-14T19:51:16Z",
          "comments": [
            {
              "originalPosition": 209,
              "body": "`+ B * r1` I believe",
              "createdAt": "2022-02-14T19:51:16Z",
              "updatedAt": "2022-02-14T19:51:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax840lAnz",
          "commit": {
            "abbreviatedOid": "489edca"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-14T19:53:01Z",
          "updatedAt": "2022-02-14T19:53:02Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Have we changed all occurances of using r through out this draft?",
              "createdAt": "2022-02-14T19:53:01Z",
              "updatedAt": "2022-02-14T19:53:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax840lCXW",
          "commit": {
            "abbreviatedOid": "489edca"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-14T20:00:13Z",
          "updatedAt": "2022-02-14T20:00:13Z",
          "comments": [
            {
              "originalPosition": 209,
              "body": "Based on `Abar = A'k` checked by the pairing. `Abar = A'(-e) + B*r1 = A'(-e) + A'(e + k) = A'k`",
              "createdAt": "2022-02-14T20:00:13Z",
              "updatedAt": "2022-02-14T20:00:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax840lLyX",
          "commit": {
            "abbreviatedOid": "489edca"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-14T20:40:10Z",
          "updatedAt": "2022-02-14T20:40:11Z",
          "comments": [
            {
              "originalPosition": 115,
              "body": "Assume this should actually be generalized here?\r\n```suggestion\r\n2. h = HASH(SK  || msg[i] || ... || msg[L])\r\n```",
              "createdAt": "2022-02-14T20:40:10Z",
              "updatedAt": "2022-02-14T20:40:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax840lL65",
          "commit": {
            "abbreviatedOid": "489edca"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-14T20:40:45Z",
          "updatedAt": "2022-02-14T20:40:45Z",
          "comments": [
            {
              "originalPosition": 118,
              "body": "Need to document this .read() notation somewhere and what happens on consecutive reads",
              "createdAt": "2022-02-14T20:40:45Z",
              "updatedAt": "2022-02-14T20:41:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax840mx9c",
          "commit": {
            "abbreviatedOid": "489edca"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "See comments above",
          "createdAt": "2022-02-15T07:49:34Z",
          "updatedAt": "2022-02-15T07:49:34Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax840pz3i",
          "commit": {
            "abbreviatedOid": "489edca"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-15T17:31:05Z",
          "updatedAt": "2022-02-15T17:31:15Z",
          "comments": [
            {
              "originalPosition": 293,
              "body": "Why not just check for `e(A', W) == e(Abar, P2)`??",
              "createdAt": "2022-02-15T17:31:05Z",
              "updatedAt": "2022-02-15T17:31:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax840rgCF",
          "commit": {
            "abbreviatedOid": "489edca"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-16T00:56:03Z",
          "updatedAt": "2022-02-16T00:56:03Z",
          "comments": [
            {
              "originalPosition": 293,
              "body": "Because mathematically it\u2019s quicker. You can compute what I put with a single pairing versus two pairings. Most folks don\u2019t know that. It\u2019s also preferable this way.",
              "createdAt": "2022-02-16T00:56:03Z",
              "updatedAt": "2022-02-16T00:56:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax840s4zX",
          "commit": {
            "abbreviatedOid": "489edca"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-16T09:15:10Z",
          "updatedAt": "2022-02-16T09:15:11Z",
          "comments": [
            {
              "originalPosition": 293,
              "body": "Got it, thanks! Maybe we should replace it with `e(A' + Abar, W - P2) != 1` then??",
              "createdAt": "2022-02-16T09:15:10Z",
              "updatedAt": "2022-02-16T11:46:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax840xB-t",
          "commit": {
            "abbreviatedOid": "489edca"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-16T23:36:20Z",
          "updatedAt": "2022-02-16T23:36:21Z",
          "comments": [
            {
              "originalPosition": 209,
              "body": "It matches all the other changes I've made.",
              "createdAt": "2022-02-16T23:36:21Z",
              "updatedAt": "2022-02-16T23:36:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax840xCKV",
          "commit": {
            "abbreviatedOid": "489edca"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-16T23:37:30Z",
          "updatedAt": "2022-02-16T23:37:31Z",
          "comments": [
            {
              "originalPosition": 115,
              "body": "No its different.",
              "createdAt": "2022-02-16T23:37:31Z",
              "updatedAt": "2022-02-16T23:37:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax840xCTf",
          "commit": {
            "abbreviatedOid": "489edca"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-16T23:38:28Z",
          "updatedAt": "2022-02-16T23:38:28Z",
          "comments": [
            {
              "originalPosition": 293,
              "body": "Well its can be written that way but if you were to actually compute it that way it might not work.",
              "createdAt": "2022-02-16T23:38:28Z",
              "updatedAt": "2022-02-16T23:38:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax840xDS8",
          "commit": {
            "abbreviatedOid": "331fd56"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-16T23:45:37Z",
          "updatedAt": "2022-02-16T23:45:38Z",
          "comments": [
            {
              "originalPosition": 293,
              "body": "If that's the case then i don't see the difference with checking for equality. Don't you still compute 2 pairings??",
              "createdAt": "2022-02-16T23:45:37Z",
              "updatedAt": "2022-02-16T23:45:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84016ZL",
          "commit": {
            "abbreviatedOid": "331fd56"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-17T21:03:24Z",
          "updatedAt": "2022-02-17T21:03:24Z",
          "comments": [
            {
              "originalPosition": 115,
              "body": "So you are introducing a dependency on a concrete hash algorithm here? I think previous conversations in the working group and documented in issues like #8 #46 #5 was to have this abstracted away?",
              "createdAt": "2022-02-17T21:03:24Z",
              "updatedAt": "2022-02-17T21:03:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8402cxW",
          "commit": {
            "abbreviatedOid": "681d5b6"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-17T23:51:35Z",
          "updatedAt": "2022-02-17T23:51:35Z",
          "comments": [
            {
              "originalPosition": 293,
              "body": "I can give you a code sample to illustrate ",
              "createdAt": "2022-02-17T23:51:35Z",
              "updatedAt": "2022-02-17T23:51:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8402hoL",
          "commit": {
            "abbreviatedOid": "681d5b6"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-18T00:27:18Z",
          "updatedAt": "2022-02-18T01:01:48Z",
          "comments": [
            {
              "originalPosition": 239,
              "body": "Is this correct?? I don't think that `C1` in spkGen is equal to the `C1` in SpkVerify and i think it is because of the change here.",
              "createdAt": "2022-02-18T00:27:18Z",
              "updatedAt": "2022-02-18T01:01:48Z"
            },
            {
              "originalPosition": 323,
              "body": "Does this hold?? If `T = D * (-r3) + H0 * s' + ...` which is what we try to prove if I'm not mistaken, then i don't think that the `C2` here is equal to the `C2` in `spkGen`. For example if we where to expand the equation, to find the scalar multiplied with `D` we would have to calculate `D * (-r3*c) + D * (-r3^)` which is not equal to `D * (-r3~)` as it appears in `spkGen` in the equation for `C2`, since `r3^ = re~ + c*r3`?",
              "createdAt": "2022-02-18T00:58:38Z",
              "updatedAt": "2022-02-18T01:01:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8402mbW",
          "commit": {
            "abbreviatedOid": "681d5b6"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-18T01:04:43Z",
          "updatedAt": "2022-02-18T01:04:44Z",
          "comments": [
            {
              "originalPosition": 293,
              "body": "Please do!! thanks!!",
              "createdAt": "2022-02-18T01:04:43Z",
              "updatedAt": "2022-02-18T01:04:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8402mj_",
          "commit": {
            "abbreviatedOid": "681d5b6"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-18T01:05:52Z",
          "updatedAt": "2022-02-18T01:05:52Z",
          "comments": [
            {
              "originalPosition": 323,
              "body": "Yes it holds. I have code to prove it",
              "createdAt": "2022-02-18T01:05:52Z",
              "updatedAt": "2022-02-18T01:05:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8402sjg",
          "commit": {
            "abbreviatedOid": "3c01431"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-18T01:57:04Z",
          "updatedAt": "2022-02-18T01:57:04Z",
          "comments": [
            {
              "originalPosition": 323,
              "body": "Great! I would be interested seen the code. Regardless I would also be more at ease if we could prove correctness with math since this PR does not use exactly the formulas from the academic paper (i.e., `s\u2019 = s + r2*r2` instead of `s\u2019 = s - r2*r2` which is used in the paper etc.). But I may be missing something and the code could help.",
              "createdAt": "2022-02-18T01:57:04Z",
              "updatedAt": "2022-02-18T01:57:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8405617",
          "commit": {
            "abbreviatedOid": "3c01431"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-18T17:57:10Z",
          "updatedAt": "2022-02-18T17:57:11Z",
          "comments": [
            {
              "originalPosition": 246,
              "body": "```suggestion\r\n26. for i in RIdxs: m^[i] = m~[i] + c * msg[i]\r\n```",
              "createdAt": "2022-02-18T17:57:10Z",
              "updatedAt": "2022-02-18T17:57:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax841Jcz3",
          "commit": {
            "abbreviatedOid": "d039423"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-23T20:56:23Z",
          "updatedAt": "2022-02-23T20:56:23Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax841JdOS",
          "commit": {
            "abbreviatedOid": "d039423"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-23T20:58:06Z",
          "updatedAt": "2022-02-23T20:58:06Z",
          "comments": []
        }
      ]
    },
    {
      "number": 63,
      "id": "PR_kwDOF8lax84y13MF",
      "title": "Add basic section on subgroup selection for the scheme",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/63",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Fixes #59 ",
      "createdAt": "2022-02-15T08:45:53Z",
      "updatedAt": "2022-02-16T08:59:26Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "55ba4a292f66e89a31b32793497ebc78b044dfe9",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/sub-group-selection",
      "headRefOid": "3dcd450138376a2a741210c333e46165973d281e",
      "closedAt": "2022-02-16T08:59:22Z",
      "mergedAt": "2022-02-16T08:59:21Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "5aa6595ff5789cfa2a5610ed06462986730f0c5b"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Multiple approvals, purely editorial, merging",
          "createdAt": "2022-02-16T08:59:17Z",
          "updatedAt": "2022-02-16T08:59:17Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax840oaDL",
          "commit": {
            "abbreviatedOid": "3dcd450"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-15T13:47:50Z",
          "updatedAt": "2022-02-15T13:47:50Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax840sBgc",
          "commit": {
            "abbreviatedOid": "3dcd450"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-16T04:51:27Z",
          "updatedAt": "2022-02-16T04:51:27Z",
          "comments": []
        }
      ]
    },
    {
      "number": 64,
      "id": "PR_kwDOF8lax84y82b1",
      "title": "Messages and generators notation update for readability",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/64",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "First attempt to close issue #54 (see in the issue for other options).\r\n\r\nThis PR proposes to pass the generators directly to functions instead of their indexes, with the goal of increasing spec readability.\r\n\r\nIMO this simplifies notation. For example, using indexes in spkGen will require notation for 5 different lists of indexes. This can get confusing. By passing the generators as a list, only requires notation for 2 lists of indexes (and one less input argument in SpkGen). Also,\r\n\r\n1. Passing the messages as a map between the message and the index of the generator will still require a lot of notation for indexes.\r\n2. Mentioning that those generators are not necessarily the `L` first elements from the global (or not) generators list, also preserves the flexibility required from the blind signatures.\r\n3. Mentioning that implementations may choose to pass the indexes of the generators instead and pointing to a reference implementation or perhaps a more detailed explanation in the Appendix IMO will be enough to address the efficiency of the applications concerns, while keeping the spec more readable.\r\n\r\nAlso, changes in this PR use the terminology from PR #62 to some places, but I will update it elsewhere after that PR is merged.",
      "createdAt": "2022-02-16T20:41:58Z",
      "updatedAt": "2022-03-02T04:57:46Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "d02eced2451d4d63fb765ae0c75f44b9365e9d46",
      "headRepository": "BasileiosKal/bbs-signature",
      "headRefName": "indexes_notation",
      "headRefOid": "82dc45dca363ad3afa66a893368c50f782f0361d",
      "closedAt": "2022-03-02T04:57:46Z",
      "mergedAt": "2022-03-02T04:57:46Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "cd28c67eccd9327b9349d33011f9564bc436a841"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed on WG call 21st of Feb, awaiting review from other WG members ",
          "createdAt": "2022-02-21T20:08:26Z",
          "updatedAt": "2022-02-21T20:08:26Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "In general I like the direction of this PR, I think the core draft should remain agnostic from any application specific generators such as those proposed in #68 ",
          "createdAt": "2022-02-21T20:09:06Z",
          "updatedAt": "2022-02-21T20:09:06Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@BasileiosKal can you please update this PR to resolve the conflicts?",
          "createdAt": "2022-02-23T21:46:19Z",
          "updatedAt": "2022-02-23T21:46:19Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Multiple approvals, PR open for 2 weeks and discussed on WG call, massive improvement in notation across the spec, merging",
          "createdAt": "2022-03-02T04:57:35Z",
          "updatedAt": "2022-03-02T04:57:35Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax8401MQC",
          "commit": {
            "abbreviatedOid": "c1fb1c8"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Sadly, I am not qualified to review this, but it looks to be a massive improvement in documenting things. \r\n\r\n",
          "createdAt": "2022-02-17T18:07:59Z",
          "updatedAt": "2022-02-17T18:07:59Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax8402nhx",
          "commit": {
            "abbreviatedOid": "c1fb1c8"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-18T01:14:02Z",
          "updatedAt": "2022-02-18T01:14:02Z",
          "comments": [
            {
              "originalPosition": 116,
              "body": "`m~_j` instead of `m~[j]`?",
              "createdAt": "2022-02-18T01:14:02Z",
              "updatedAt": "2022-02-18T01:14:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8402nna",
          "commit": {
            "abbreviatedOid": "c1fb1c8"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-18T01:14:50Z",
          "updatedAt": "2022-02-18T01:14:50Z",
          "comments": [
            {
              "originalPosition": 137,
              "body": "`m^_j` and `m~_j`? Seems inconsistent to sometimes use the `[n]` notation for array indices.",
              "createdAt": "2022-02-18T01:14:50Z",
              "updatedAt": "2022-02-18T01:14:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8402sFT",
          "commit": {
            "abbreviatedOid": "552b9ef"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-18T01:53:04Z",
          "updatedAt": "2022-02-18T01:53:04Z",
          "comments": [
            {
              "originalPosition": 137,
              "body": "Updated. I agree but if we move to `m_c` instead of `m^` for example then it will become `m_c_j` and `m_c_j1, m_c_j2, ...` which I don't know if I like. updated now for consistency.",
              "createdAt": "2022-02-18T01:53:04Z",
              "updatedAt": "2022-02-18T01:53:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84021L1",
          "commit": {
            "abbreviatedOid": "552b9ef"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-18T03:16:51Z",
          "updatedAt": "2022-02-18T03:16:52Z",
          "comments": [
            {
              "originalPosition": 137,
              "body": "I think we can probably keep m~ and m^ now they aren't causing formatting issues.",
              "createdAt": "2022-02-18T03:16:51Z",
              "updatedAt": "2022-02-18T03:16:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax840wvlo",
          "commit": {
            "abbreviatedOid": "552b9ef"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "Couple of minor suggestions",
          "createdAt": "2022-02-16T21:59:54Z",
          "updatedAt": "2022-02-23T09:25:05Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "```suggestion\r\nThroughout the operations of this signature scheme, each message that is signed is paired with a specific generator (point in G1). Specifically, if a generator `H_1` is raised to the power of `msg_1` during signing, then `H_1` should be raised to the power of `msg_1` in all other operations as well (signature verification, proof generation and proof verification). For simplicity, each function will take as input the list of generators to be used with the messages. Those generators can be any distinct element from the generators list `H`. Applications for efficiency can elect to pass the indexes of those generators to the list `H` instead. Care must be taken for the correct generator to be raised to the correct message in that case.\r\n```",
              "createdAt": "2022-02-16T21:59:54Z",
              "updatedAt": "2022-02-23T09:25:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax841cIfp",
          "commit": {
            "abbreviatedOid": "82dc45d"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-01T16:51:07Z",
          "updatedAt": "2022-03-01T16:51:07Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax841eJo0",
          "commit": {
            "abbreviatedOid": "82dc45d"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-02T04:56:16Z",
          "updatedAt": "2022-03-02T04:56:16Z",
          "comments": []
        }
      ]
    },
    {
      "number": 65,
      "id": "PR_kwDOF8lax84y-O5V",
      "title": "Start of population of BLS 12-381 cipher suite",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/65",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Simplifies definition around the point_to_octet and octet_to_point functions including providing a concrete link to the serialization and deserialization procedure for BLS12-381 which starts to address #2. Also documents the digest algorithm agreed in previous working group calls and highlighted in #5.  ",
      "createdAt": "2022-02-17T07:56:30Z",
      "updatedAt": "2022-02-18T00:37:09Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "5aa6595ff5789cfa2a5610ed06462986730f0c5b",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/add-detail-to-cipher-suite",
      "headRefOid": "22eb4faa5a4695cd11d1570d291db73814bc1baa",
      "closedAt": "2022-02-18T00:37:06Z",
      "mergedAt": "2022-02-18T00:37:06Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "dc30bb88bf1491659f325fee1b9ae74394ffff04"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax8400mVh",
          "commit": {
            "abbreviatedOid": "df15dd9"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Suggestion for better readability in html.",
          "createdAt": "2022-02-17T16:11:34Z",
          "updatedAt": "2022-02-17T16:20:21Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "```suggestion\r\n* H\r\n```",
              "createdAt": "2022-02-17T16:11:34Z",
              "updatedAt": "2022-02-17T16:20:21Z"
            },
            {
              "originalPosition": 53,
              "body": "```suggestion\r\n* point\\_to\\_octets\r\n```",
              "createdAt": "2022-02-17T16:12:22Z",
              "updatedAt": "2022-02-17T16:20:21Z"
            },
            {
              "originalPosition": 56,
              "body": "```suggestion\r\n* octets\\_to\\_point\r\n```",
              "createdAt": "2022-02-17T16:12:34Z",
              "updatedAt": "2022-02-17T16:20:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8401oGl",
          "commit": {
            "abbreviatedOid": "b1fce97"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-17T19:45:24Z",
          "updatedAt": "2022-02-17T19:45:24Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax8401sBT",
          "commit": {
            "abbreviatedOid": "b1fce97"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-17T20:00:55Z",
          "updatedAt": "2022-02-17T20:00:55Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax84012L9",
          "commit": {
            "abbreviatedOid": "b1fce97"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-17T20:45:07Z",
          "updatedAt": "2022-02-17T20:45:07Z",
          "comments": []
        }
      ]
    },
    {
      "number": 66,
      "id": "PR_kwDOF8lax84zCEe9",
      "title": "Update signature serialisation",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/66",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Likely not going to be the final notation used in this spec, we will probably abstract away the signature encoding and decoding rules into its own function in time, however in the meantime its important to document how the e and s components are actually sent over the wire.",
      "createdAt": "2022-02-18T00:45:22Z",
      "updatedAt": "2022-02-18T01:09:03Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "dc30bb88bf1491659f325fee1b9ae74394ffff04",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/update-signature-serialization",
      "headRefOid": "b2ddf10a0b8bc4eb2a6e36a6cc62f011387608f9",
      "closedAt": "2022-02-18T01:09:00Z",
      "mergedAt": "2022-02-18T01:09:00Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "17b026f71660b4abe8356df2982c17bc7f61756f"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Minor update providing important clarification around how a signature is actually encoded or decoded, partially addresses #2, multiple approvals, merging",
          "createdAt": "2022-02-18T01:08:56Z",
          "updatedAt": "2022-02-18T01:08:56Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax8402lJN",
          "commit": {
            "abbreviatedOid": "b2ddf10"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-18T00:54:13Z",
          "updatedAt": "2022-02-18T00:54:13Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax8402mVN",
          "commit": {
            "abbreviatedOid": "b2ddf10"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-18T01:03:58Z",
          "updatedAt": "2022-02-18T01:03:58Z",
          "comments": []
        }
      ]
    },
    {
      "number": 67,
      "id": "PR_kwDOF8lax84zIGO7",
      "title": "Add basic test vectors for signature cases",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/67",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Adds a section for test vectors associated to signature generation and verification, includes an automated script that will allow us to update the fixtures via the input JSON files over time.",
      "createdAt": "2022-02-18T22:10:22Z",
      "updatedAt": "2022-02-22T21:12:22Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "17b026f71660b4abe8356df2982c17bc7f61756f",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/signature-fixtures",
      "headRefOid": "080479828e64fbb6658ff3e2d1b83390f8ec60fa",
      "closedAt": "2022-02-22T21:10:51Z",
      "mergedAt": "2022-02-22T21:10:51Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "9b314e03d710ed12a627ec8ed74930ff2c0bd3e5"
      },
      "comments": [
        {
          "author": "quartzjer",
          "authorAssociation": "NONE",
          "body": "Uhm, I like this so much I wonder what license the TS bits are under such that I might reuse them? ;)\r\n\r\n\"Imitation is the sincerest form of flattery\"",
          "createdAt": "2022-02-18T23:47:26Z",
          "updatedAt": "2022-02-18T23:47:26Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looks good to me!",
          "createdAt": "2022-02-18T23:57:17Z",
          "updatedAt": "2022-02-18T23:57:17Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "> Uhm, I like this so much I wonder what license the TS bits are under such that I might reuse them? ;)\r\n> \r\n> \"Imitation is the sincerest form of flattery\"\r\n\r\nFeel free! Glad it is helpful!",
          "createdAt": "2022-02-19T00:28:10Z",
          "updatedAt": "2022-02-19T00:28:10Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@quartzjer I have updated the tooling script to be licensed under apache 2.0 :)",
          "createdAt": "2022-02-19T00:31:34Z",
          "updatedAt": "2022-02-19T00:31:34Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@andrewwhitehead @mikelodder7 would you be able to test these fixtures out against your implementations for correctness?",
          "createdAt": "2022-02-19T03:55:25Z",
          "updatedAt": "2022-02-19T03:55:25Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "A couple of notes about the current set of test fixtures:\r\n- Using the issuer public key derived generators (because we have not merged in the algorithm described in #38 yet\r\n- Deterministic signatures based on #43  ",
          "createdAt": "2022-02-20T20:05:53Z",
          "updatedAt": "2022-02-20T20:05:53Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "I've added a note to the test vectors section that documents the experimental current state of these test vectors",
          "createdAt": "2022-02-20T20:13:30Z",
          "updatedAt": "2022-02-20T20:13:30Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Multiple approvals, test vectors are still marked as experimental, merging",
          "createdAt": "2022-02-22T21:10:45Z",
          "updatedAt": "2022-02-22T21:10:45Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax840_c6x",
          "commit": {
            "abbreviatedOid": "0804798"
          },
          "author": "quartzjer",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-21T19:39:03Z",
          "updatedAt": "2022-02-21T19:39:03Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax841EPgb",
          "commit": {
            "abbreviatedOid": "0804798"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-22T20:06:54Z",
          "updatedAt": "2022-02-22T20:06:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 71,
      "id": "PR_kwDOF8lax84zYJfy",
      "title": "Document generator creation procedure",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/71",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Initial stab at this attempting to document and resolve #38. In general I was keen to define a generic procedure that could take a seed scoped either globally, issuer or signature specific. Detail about the concrete seed we are using the BLS12-381 cipher suite is still missing.",
      "createdAt": "2022-02-24T01:00:31Z",
      "updatedAt": "2022-03-11T03:32:56Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "ba9aa770453f1c99c9c32996c5bdae6af6b20ec2",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/create-generators",
      "headRefOid": "ded91eb78672674a7cc4e9fdff2a5cd0dcb0c625",
      "closedAt": "2022-03-11T03:32:53Z",
      "mergedAt": "2022-03-11T03:32:52Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "94d8d8ebd3c10e7a8b97f0c9db364941eabfeb16"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Multiple approvals, open for two weeks, merging.",
          "createdAt": "2022-03-11T03:32:41Z",
          "updatedAt": "2022-03-11T03:32:41Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax841U5ng",
          "commit": {
            "abbreviatedOid": "473e4c4"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-28T05:44:08Z",
          "updatedAt": "2022-02-28T05:45:38Z",
          "comments": [
            {
              "originalPosition": 107,
              "body": "Maybe `generators_i =`?",
              "createdAt": "2022-02-28T05:44:08Z",
              "updatedAt": "2022-02-28T05:45:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax841WvYH",
          "commit": {
            "abbreviatedOid": "473e4c4"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-28T14:28:40Z",
          "updatedAt": "2022-02-28T14:29:56Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "```suggestion\r\n: The cryptographic hash function that takes as an arbitrary octet string input and returns a point in G1 as defined in [@!I-D.irtf-cfrg-hash-to-curve]. The algorithm first requires selection of the pairing friendly curve and digest algorithm. Once selected, apply the isogeny simplified SWU map to compute a point in G1 using the random oracle method. The domain separation tag value is dst.\r\n```",
              "createdAt": "2022-02-28T14:28:40Z",
              "updatedAt": "2022-02-28T14:29:56Z"
            },
            {
              "originalPosition": 19,
              "body": "Very minor suggestion.",
              "createdAt": "2022-02-28T14:29:49Z",
              "updatedAt": "2022-02-28T14:29:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax841YZF0",
          "commit": {
            "abbreviatedOid": "473e4c4"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-28T20:58:20Z",
          "updatedAt": "2022-02-28T20:58:21Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "I think this is too long. I would just leave it as \r\n\r\n```\r\nThe cryptographic hash function that takes as an arbitrary octet string input and returns a point in G1 as defined in [@!I-D.irtf-cfrg-hash-to-curve].`",
              "createdAt": "2022-02-28T20:58:21Z",
              "updatedAt": "2022-02-28T20:58:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax841eKGJ",
          "commit": {
            "abbreviatedOid": "a383ec4"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-02T05:00:10Z",
          "updatedAt": "2022-03-02T05:00:10Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "It is the same text, however I agree that dropping the last sentence is an improvement",
              "createdAt": "2022-03-02T05:00:10Z",
              "updatedAt": "2022-03-02T05:00:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax841eKJ2",
          "commit": {
            "abbreviatedOid": "a383ec4"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-02T05:00:39Z",
          "updatedAt": "2022-03-02T05:00:40Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "```suggestion\r\n: The cryptographic hash function that takes as an arbitrary octet string input and returns a point in G1 as defined in [@!I-D.irtf-cfrg-hash-to-curve].\r\n```\r\n\r\nAs per @mikelodder7 suggestion",
              "createdAt": "2022-03-02T05:00:39Z",
              "updatedAt": "2022-03-02T05:00:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax841eKYQ",
          "commit": {
            "abbreviatedOid": "17c2886"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-02T05:02:35Z",
          "updatedAt": "2022-03-02T05:02:35Z",
          "comments": [
            {
              "originalPosition": 107,
              "body": "With the merging of #64 agree",
              "createdAt": "2022-03-02T05:02:35Z",
              "updatedAt": "2022-03-02T05:02:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax841eKa5",
          "commit": {
            "abbreviatedOid": "17c2886"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-02T05:02:55Z",
          "updatedAt": "2022-03-02T05:02:56Z",
          "comments": [
            {
              "originalPosition": 107,
              "body": "```suggestion\r\n2. for i in 0 to length: generators_i = hash_to_curve_g1(h.read(64), dst)\r\n```",
              "createdAt": "2022-03-02T05:02:55Z",
              "updatedAt": "2022-03-02T05:02:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax841nvgv",
          "commit": {
            "abbreviatedOid": "8fc637e"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-03T22:49:54Z",
          "updatedAt": "2022-03-03T22:49:54Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax841-gCc",
          "commit": {
            "abbreviatedOid": "ded91eb"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-10T09:50:09Z",
          "updatedAt": "2022-03-10T09:50:09Z",
          "comments": []
        }
      ]
    },
    {
      "number": 72,
      "id": "PR_kwDOF8lax84zYUCG",
      "title": "Auto create message generators",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/72",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Builds on #71 to automate re-creating these and including as test vectors in the specification.",
      "createdAt": "2022-02-24T02:35:06Z",
      "updatedAt": "2022-03-11T23:25:27Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "94d8d8ebd3c10e7a8b97f0c9db364941eabfeb16",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/auto-generate-generators",
      "headRefOid": "594bd48fbc553e36891386a51df378f1a90e5ad5",
      "closedAt": "2022-03-11T23:25:24Z",
      "mergedAt": "2022-03-11T23:25:24Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "2a7a5f756d5a4ca8d8d6cc63052277a8afdc2f33"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Multiple approvals, open over two weeks, builds on #71, merging",
          "createdAt": "2022-03-11T23:25:17Z",
          "updatedAt": "2022-03-11T23:25:17Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax841NwTf",
          "commit": {
            "abbreviatedOid": "577c898"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-24T17:59:26Z",
          "updatedAt": "2022-02-24T17:59:27Z",
          "comments": [
            {
              "originalPosition": 142,
              "body": "This should have an extra underscore on the end",
              "createdAt": "2022-02-24T17:59:26Z",
              "updatedAt": "2022-02-24T17:59:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax841OgoY",
          "commit": {
            "abbreviatedOid": "577c898"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-24T21:03:02Z",
          "updatedAt": "2022-02-24T21:03:02Z",
          "comments": [
            {
              "originalPosition": 142,
              "body": "@andrewwhitehead can you explain why?",
              "createdAt": "2022-02-24T21:03:02Z",
              "updatedAt": "2022-02-24T21:03:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax841OhHh",
          "commit": {
            "abbreviatedOid": "577c898"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-24T21:05:19Z",
          "updatedAt": "2022-02-24T21:05:19Z",
          "comments": [
            {
              "originalPosition": 142,
              "body": "In the code it does :)",
              "createdAt": "2022-02-24T21:05:19Z",
              "updatedAt": "2022-02-24T21:05:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax841W7dP",
          "commit": {
            "abbreviatedOid": "98b53c6"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-28T15:06:56Z",
          "updatedAt": "2022-02-28T15:06:56Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax841YeRL",
          "commit": {
            "abbreviatedOid": "98b53c6"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-28T21:23:25Z",
          "updatedAt": "2022-02-28T21:23:25Z",
          "comments": [
            {
              "originalPosition": 142,
              "body": "In the hash to curve spec they leave an underscore at the end as well. Its mostly for consistency.",
              "createdAt": "2022-02-28T21:23:25Z",
              "updatedAt": "2022-02-28T21:23:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax841YfCr",
          "commit": {
            "abbreviatedOid": "98b53c6"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-28T21:27:03Z",
          "updatedAt": "2022-02-28T21:27:04Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "The values `(A', Abar, d)` are part of the spk and used to prove possession of the BBS signature, without revealing the signature itself. Note that; `e(A', Pk) = e(Abar, P2)` where `Pk` the signer's public key and P2 the base element in G2 (used to create the signer\u2019s `Pk`, see [SkToPk](#sktopk)). This also serves to bind the spk to the signer's `Pk`.",
              "createdAt": "2022-02-28T21:27:03Z",
              "updatedAt": "2022-02-28T21:27:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax842C_xd",
          "commit": {
            "abbreviatedOid": "577c898"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-11T04:33:29Z",
          "updatedAt": "2022-03-11T04:33:30Z",
          "comments": [
            {
              "originalPosition": 142,
              "body": "Have updated this now, thanks",
              "createdAt": "2022-03-11T04:33:30Z",
              "updatedAt": "2022-03-11T04:33:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax842DAQN",
          "commit": {
            "abbreviatedOid": "594bd48"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-11T04:38:17Z",
          "updatedAt": "2022-03-11T04:38:17Z",
          "comments": []
        }
      ]
    },
    {
      "number": 77,
      "id": "PR_kwDOF8lax840AnFf",
      "title": "Initial attempt to document the MapMessageToScalar function",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/77",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This PR is primarily designed to help support conversation around design options we have here, it is also an extension of #61 and related to #76.\r\n\r\nCurrently for the core sign, verify, spkGen and spkVerify operations take the inputed messages as a set of octet strings so we either need to.\r\n\r\n1. Clarify that the messages supplied here can be of abitrary value and that MapMessageToScalar becomes an operation executed within sign, verify, spkGen or spkVerify.\r\n2. OR clarify that the messages supplied here have to be valid scalars and that MapMessageToScalar MUST be called on each message prior to calling sign, verify, spkGen or spkVerify.\r\n\r\nThe complexity we are managing is not just that the messages need to be mapped to scalars its also that they could be mapped in multiple ways (e.g message -> scalar as hash or as number) so where ever this definition occurs will also have to account for this optionality (e.g sign would not only take a list of messages to sign but the mapping method for each message)",
      "createdAt": "2022-03-07T00:21:10Z",
      "updatedAt": "2022-03-15T01:55:17Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "2a7a5f756d5a4ca8d8d6cc63052277a8afdc2f33",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/map-message-generators",
      "headRefOid": "ee7808de7d3f93b7441f391195d3ac89a494eb3f",
      "closedAt": "2022-03-15T01:55:13Z",
      "mergedAt": "2022-03-15T01:55:12Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "dd367470f08c36a9c8e9e0856d85aac22ac59d97"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "This PR needs to be updated to use hash_to_field not hash_to_curve",
          "createdAt": "2022-03-09T04:58:24Z",
          "updatedAt": "2022-03-09T04:58:24Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "PR has been updated to use hash_to_field now",
          "createdAt": "2022-03-11T23:25:56Z",
          "updatedAt": "2022-03-11T23:25:56Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "> Remove the _g1 suffix. Scalars are not part of the g1 subgroup. They are their own field. Scalars can be used in either field to scale g1 or G2 groups.\r\n\r\nAddressed",
          "createdAt": "2022-03-13T20:08:15Z",
          "updatedAt": "2022-03-13T20:08:15Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Multiple reviews and approvals, PR open a week, no objections, merging",
          "createdAt": "2022-03-15T01:55:03Z",
          "updatedAt": "2022-03-15T01:55:03Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax842H19a",
          "commit": {
            "abbreviatedOid": "8b7bab6"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Remove the _g1 suffix. Scalars are not part of the g1 subgroup. They are their own field. Scalars can be used in either field to scale g1 or G2 groups. ",
          "createdAt": "2022-03-12T16:49:06Z",
          "updatedAt": "2022-03-12T16:49:06Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax842NcRc",
          "commit": {
            "abbreviatedOid": "3006617"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-14T23:06:41Z",
          "updatedAt": "2022-03-14T23:06:42Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "This should have its own `dst` value different but similar to hash_to_curve_g1. I propose `BBS_BLS12381FQ_XOF:SHAKE-256_SSWU_RO`",
              "createdAt": "2022-03-14T23:06:42Z",
              "updatedAt": "2022-03-14T23:06:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax842NcWo",
          "commit": {
            "abbreviatedOid": "3006617"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "LGTM except we need a DST for hash_to_field. Good job.",
          "createdAt": "2022-03-14T23:07:15Z",
          "updatedAt": "2022-03-14T23:07:15Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax842Nh4a",
          "commit": {
            "abbreviatedOid": "3006617"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-14T23:50:02Z",
          "updatedAt": "2022-03-14T23:50:02Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "Resolved",
              "createdAt": "2022-03-14T23:50:02Z",
              "updatedAt": "2022-03-14T23:50:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax842NlD2",
          "commit": {
            "abbreviatedOid": "7a6d75a"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-15T00:16:59Z",
          "updatedAt": "2022-03-15T00:16:59Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax842NlZN",
          "commit": {
            "abbreviatedOid": "7a6d75a"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-15T00:19:53Z",
          "updatedAt": "2022-03-15T00:19:53Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "Maybe \"a cryptographic hash function\" as with hash_to_curve?",
              "createdAt": "2022-03-15T00:19:53Z",
              "updatedAt": "2022-03-15T00:19:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax842NtTf",
          "commit": {
            "abbreviatedOid": "7a6d75a"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-15T01:30:44Z",
          "updatedAt": "2022-03-15T01:30:45Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "Cool done",
              "createdAt": "2022-03-15T01:30:45Z",
              "updatedAt": "2022-03-15T01:30:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax842Nvaj",
          "commit": {
            "abbreviatedOid": "ee7808d"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-15T01:49:44Z",
          "updatedAt": "2022-03-15T01:49:44Z",
          "comments": []
        }
      ]
    },
    {
      "number": 81,
      "id": "PR_kwDOF8lax840GCmr",
      "title": "Add hash to curve definition for BLS12-381 SHAKE-256 suite",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/81",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "As described in #80 currently the [latest hash to curve draft](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-14#section-8.8) does not define a suite for BLS12-381 which uses the extendable output function of SHAKE-256 used by this draft in the CreateGenerators operation defined in #71 and the MapMessageToScalar operation defined in #61 for the [BLS12-381 ciphersuite](https://identity.foundation/bbs-signature/draft-bbs-signatures.html#name-bls12-381-ciphersuite), this PR establishes that definition so we can point to it.\r\n\r\nNote I would like to review and merge this PR before proceeding with #71 #61",
      "createdAt": "2022-03-08T09:45:00Z",
      "updatedAt": "2022-03-09T00:42:25Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "1b1f8740747deac1950804aca7743bba9b2ffce5",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/hash-to-curve",
      "headRefOid": "edf9cf1d723c7c91d19276b157212a68031f7ed9",
      "closedAt": "2022-03-09T00:42:21Z",
      "mergedAt": "2022-03-09T00:42:21Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "aee0bb43453a9cd972f5347e04735b13d50abbbb"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Multiple approvals, discussed in issue, merging as it is blocking PR #71 and #61",
          "createdAt": "2022-03-09T00:42:16Z",
          "updatedAt": "2022-03-09T00:42:16Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax8412hGL",
          "commit": {
            "abbreviatedOid": "edf9cf1"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-08T19:29:53Z",
          "updatedAt": "2022-03-08T19:29:53Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax8413CCN",
          "commit": {
            "abbreviatedOid": "edf9cf1"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-08T21:43:09Z",
          "updatedAt": "2022-03-08T21:43:09Z",
          "comments": []
        }
      ]
    },
    {
      "number": 82,
      "id": "PR_kwDOF8lax840JXvf",
      "title": "Add hash to curve definition to ciphersuite format definition and BLS12-381 ciphersuite",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/82",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "As described above in the title, this defines the usage of the hash to curve suite that was defined in #80 ",
      "createdAt": "2022-03-09T03:16:21Z",
      "updatedAt": "2022-03-09T18:54:10Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "aee0bb43453a9cd972f5347e04735b13d50abbbb",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/add-hash-to-curve-bls12381-suite",
      "headRefOid": "34feafbdd5b5f6e746d3a4486b1cb113dd25b6b1",
      "closedAt": "2022-03-09T18:54:06Z",
      "mergedAt": "2022-03-09T18:54:06Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "ba9aa770453f1c99c9c32996c5bdae6af6b20ec2"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Multiple approvals, somewhat blocking progress on other PR's, merging",
          "createdAt": "2022-03-09T18:54:02Z",
          "updatedAt": "2022-03-09T18:54:02Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax84137Xz",
          "commit": {
            "abbreviatedOid": "34feafb"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-09T04:34:02Z",
          "updatedAt": "2022-03-09T04:34:02Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax8416TJh",
          "commit": {
            "abbreviatedOid": "34feafb"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-09T14:50:32Z",
          "updatedAt": "2022-03-09T14:50:32Z",
          "comments": []
        }
      ]
    },
    {
      "number": 83,
      "id": "PR_kwDOF8lax840bvO4",
      "title": "Fixes definition of MapMessageToScalarAsHash",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/83",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Fixes the in-correct definition for this operation introduced in #61 ",
      "createdAt": "2022-03-15T02:11:26Z",
      "updatedAt": "2022-03-15T02:31:02Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "dd367470f08c36a9c8e9e0856d85aac22ac59d97",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/fix-map-message-definition",
      "headRefOid": "7726a4e84d3348de45d9f3cb556d533acba12b2a",
      "closedAt": "2022-03-15T02:30:59Z",
      "mergedAt": "2022-03-15T02:30:59Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "096452940e3ca92a07e25d2bac832252efe2814f"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Minor tweak to PR 61, purely editorial, approved, merging",
          "createdAt": "2022-03-15T02:30:55Z",
          "updatedAt": "2022-03-15T02:30:55Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax842NztK",
          "commit": {
            "abbreviatedOid": "7726a4e"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-15T02:25:29Z",
          "updatedAt": "2022-03-15T02:25:29Z",
          "comments": []
        }
      ]
    },
    {
      "number": 84,
      "id": "PR_kwDOF8lax840b4hN",
      "title": "Change usages of HASH function to use XOF",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/84",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "We currently use a HASH function separate to how we use an XOF function in the KeyGen SpkGen and SpkVerify functions, this provides an updated definition resolving H -> HASH instead of having two notations to describe the same thing AND provides a concrete definition for the BLS12-381 cipher suite including how many bytes we draw for the operations.",
      "createdAt": "2022-03-15T03:37:28Z",
      "updatedAt": "2022-04-12T19:44:22Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "096452940e3ca92a07e25d2bac832252efe2814f",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/update-hash-algorithm-definition",
      "headRefOid": "0667283d9123f94077dec62be55490fe103f2248",
      "closedAt": "2022-04-12T02:48:59Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Please hold on reviewing this PR, I am going to restructure how we use the HASH and XOF functions in the spec.",
          "createdAt": "2022-03-15T18:44:57Z",
          "updatedAt": "2022-03-15T18:44:57Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Have updated this PR to change direction, instead of having both a HASH function and XOF this PR collapses into just using the XOF function.",
          "createdAt": "2022-03-16T03:08:58Z",
          "updatedAt": "2022-03-16T03:08:58Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Will do, thanks @mikelodder7 ",
          "createdAt": "2022-03-17T17:56:50Z",
          "updatedAt": "2022-03-17T17:56:50Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Should we be drawing different number of bytes depending on the EC used since we mod after?? For example, for [bn462](https://www.ietf.org/archive/id/draft-irtf-cfrg-pairing-friendly-curves-10.html#name-bn-curves-for-the-128-bit-s), should we draw at least 74 bytes for 128 bits of security?? (using [this](https://www.ietf.org/archive/id/draft-irtf-cfrg-hash-to-curve-14.html#name-security-considerations) method that @mikelodder7 pointed out and/or lemma 6 from [here](https://eprint.iacr.org/2009/050.pdf))",
          "createdAt": "2022-03-17T20:27:52Z",
          "updatedAt": "2022-03-17T20:27:52Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "> Should we be drawing different number of bytes depending on the EC used since we mod after?? For example, for [bn462](https://www.ietf.org/archive/id/draft-irtf-cfrg-pairing-friendly-curves-10.html#name-bn-curves-for-the-128-bit-s), should we draw at least 74 bytes for 128 bits of security?? (using [this](https://www.ietf.org/archive/id/draft-irtf-cfrg-hash-to-curve-14.html#name-security-considerations) method that @mikelodder7 pointed out and/or lemma 6 from [here](https://eprint.iacr.org/2009/050.pdf))\r\n\r\nThanks, @BasileiosKal lets parameterise this in the cipher suite section, can you clarify the need to draw 74 bytes applies when using the BN 462 curve for key gen? Or also the challenge hash?",
          "createdAt": "2022-03-19T23:20:17Z",
          "updatedAt": "2022-03-19T23:20:17Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "I have opened #87 so we can look at what this would look like",
          "createdAt": "2022-03-21T02:14:06Z",
          "updatedAt": "2022-03-21T02:14:06Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "> The challenge hash needs to draw 64 bytes and be converted to a scalar to complete the proving protocol. Verify should do the same thing. The reason is the challenge is used to compute the schnorr proofs for the hidden messages.\r\n\r\nOk I will file a seperate PR to make this change",
          "createdAt": "2022-03-21T02:15:50Z",
          "updatedAt": "2022-03-21T02:15:50Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "As discussed on the last WG call, we have decided to stick with using the HASH function but define how to use an XOF as the HASH function when defining a concrete cipher suite",
          "createdAt": "2022-04-12T02:48:59Z",
          "updatedAt": "2022-04-12T02:48:59Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax842Uzgh",
          "commit": {
            "abbreviatedOid": "0667283"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "A couple of notes\r\n\r\n- Let\u2019s remove hkdf for the secret key generation since the Xof serves the same purpose and simplifies things.\r\n- There\u2019s no advantage to hashing the salt first. We should just do H = XOF(salt, ikm), okm= H.read(64), sk = okm mod q, if sk=0 read more bytes and reduce again, output sk\r\n- The challenge hash needs to draw 64 bytes and be converted to a scalar to complete the proving protocol. Verify should do the same thing. The reason is the challenge is used to compute the schnorr proofs for the hidden messages.",
          "createdAt": "2022-03-16T10:40:46Z",
          "updatedAt": "2022-03-16T10:40:46Z",
          "comments": []
        }
      ]
    },
    {
      "number": 86,
      "id": "PR_kwDOF8lax840qvRx",
      "title": "BBS spk security against the issuer",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/86",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #75 \r\n\r\nAdding a section to the security considerations to document the fact that a bbs spk is not zero knowledge against the issuer,",
      "createdAt": "2022-03-18T16:45:46Z",
      "updatedAt": "2022-03-21T21:12:35Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "096452940e3ca92a07e25d2bac832252efe2814f",
      "headRepository": "BasileiosKal/bbs-signature",
      "headRefName": "untrusted-issuers-security",
      "headRefOid": "6da61caca8044edc97fa2e9fadaff1aa6dafa654",
      "closedAt": "2022-03-21T21:12:35Z",
      "mergedAt": "2022-03-21T21:12:35Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "7463c8157db02ea81f63af9e5576f5889fe9b3d9"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Multiple approvals, discussed on WG call, purely editorial non-normative content, merging",
          "createdAt": "2022-03-21T21:12:30Z",
          "updatedAt": "2022-03-21T21:12:30Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax842im8Z",
          "commit": {
            "abbreviatedOid": "6da61ca"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "LGTM, thanks!",
          "createdAt": "2022-03-19T23:17:57Z",
          "updatedAt": "2022-03-19T23:17:57Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax842m8UK",
          "commit": {
            "abbreviatedOid": "6da61ca"
          },
          "author": "quartzjer",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-21T18:19:48Z",
          "updatedAt": "2022-03-21T18:19:48Z",
          "comments": []
        }
      ]
    },
    {
      "number": 87,
      "id": "PR_kwDOF8lax840temi",
      "title": "[PROPOSAL] refactor key generation procedure",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/87",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "dont-merge-yet"
      ],
      "body": "Initial proposal to refactor the key generation procedure to just rely upon the XOF rather than a combination of a HASH function and HKDF inline with @mikelodder7 proposal [here](https://github.com/decentralized-identity/bbs-signature/pull/84#pullrequestreview-911423521)\r\n\r\nOutstanding questions\r\n- Do we want to continue to support key_info in the key generation, this PR has removed it for now, however we can re-add it\r\n- What guidance do we need to add to the cipher suite definition about calculating the appropriate value for this?",
      "createdAt": "2022-03-21T02:13:33Z",
      "updatedAt": "2022-04-12T19:44:20Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "bef218f8eab3d0ff830bda5238cc1d85f2bed077",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/update-key-gen",
      "headRefOid": "1d50786b1822e969ebc65fe58e7953b10dbceeb2",
      "closedAt": "2022-04-12T02:48:09Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@BasileiosKal is currently reviewing the usage of HKDF as it would apply here including whether we want to continue to support `key_info` and if so, how.",
          "createdAt": "2022-03-22T01:18:21Z",
          "updatedAt": "2022-03-22T01:18:21Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This will likely be the same for any XOF -> Scalar generation in the spec like the challenge computation. I think we may want to add a generic function to the spec for this (HashToField for instance), implemented over the specific curve parameters.\r\n\r\nThe algorithm is probably more like this...\r\n\r\n    salt = \"BBS-SIG-KEYGEN-SALT-\"\r\n    h = XOF(salt || IKM)\r\n    SK = 0\r\n    while SK == 0:\r\n        OKM = h.read(okm_key_gen_byte_length)\r\n        SK = OS2IP(OKM) mod q\r\n    return SK\r\n",
          "createdAt": "2022-03-22T23:01:24Z",
          "updatedAt": "2022-03-22T23:01:24Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Thanks @andrewwhitehead updated the key gen procedure proposal to be inline with the above.",
          "createdAt": "2022-03-23T04:37:47Z",
          "updatedAt": "2022-03-23T04:37:47Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Please hold off merging this, more detail on the outstanding things to discuss is outlined above.",
          "createdAt": "2022-03-23T21:28:21Z",
          "updatedAt": "2022-03-23T21:28:21Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "As discussed on the last WG call we have elected to stick with the current key generation method but further clarify how to define using an XOF as the HASH function in a concrete cipher suite",
          "createdAt": "2022-04-12T02:48:06Z",
          "updatedAt": "2022-04-12T02:48:06Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax842wT8d",
          "commit": {
            "abbreviatedOid": "1d50786"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-23T11:46:55Z",
          "updatedAt": "2022-03-23T11:46:55Z",
          "comments": []
        }
      ]
    },
    {
      "number": 88,
      "id": "PR_kwDOF8lax840tf8r",
      "title": "[PROPOSAL] generalize map message to scalar operation",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/88",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "dont-merge-yet"
      ],
      "body": "Given we use this mapping procedure in the protocol to map values other than messages to scalars, this PR proposes to generalize that operation so we can use it elsewhere (such as for the challenge value as raised by @mikelodder7 [here](https://github.com/decentralized-identity/bbs-signature/pull/84#pullrequestreview-911423521), the alternative way we could do this instead is to use the underlying function of `hash_to_field` in places like this and leave the MapMessageToScalar as is.",
      "createdAt": "2022-03-21T02:26:35Z",
      "updatedAt": "2022-03-22T01:17:30Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "c4a214d4aa07535af0c0452173e7e06df9d62012",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/generalize-map-value-to-scalar",
      "headRefOid": "384b653852d52be7a25fdecc738a2fb243820f8c",
      "closedAt": "2022-03-22T01:17:25Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed on the WG, we are going to instead leave the definition for MapMessageToScalar as is and just use hash_to_field in required places directly. Therefore dis-regard this PR",
          "createdAt": "2022-03-21T21:30:03Z",
          "updatedAt": "2022-03-21T21:30:03Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Closing this PR now, have opened issue #89 to track the progress of resolving the original issue that brought this PR about in #84 ",
          "createdAt": "2022-03-22T01:17:25Z",
          "updatedAt": "2022-03-22T01:17:25Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 91,
      "id": "PR_kwDOF8lax841VRk1",
      "title": "Updating the spk security consideration",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/91",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Updating and re-closing issue #75 \r\n\r\nBased on the discussion in the above issue, the method originally proposed was wrong and any other method does not work on type 3 pairings. Updating the section accordingly.\r\n",
      "createdAt": "2022-03-30T18:32:28Z",
      "updatedAt": "2022-03-31T20:01:47Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "bef218f8eab3d0ff830bda5238cc1d85f2bed077",
      "headRepository": "BasileiosKal/bbs-signature",
      "headRefName": "issue-75",
      "headRefOid": "2e27cc2b576f6b6e197ecd59e3e3bcf4b92b126a",
      "closedAt": "2022-03-31T20:01:47Z",
      "mergedAt": "2022-03-31T20:01:47Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "cf614ee5157c4e72bfd80f639e110e45261a6299"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Multiple approvals, informational, merging ",
          "createdAt": "2022-03-31T20:01:42Z",
          "updatedAt": "2022-03-31T20:01:42Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax843OjOx",
          "commit": {
            "abbreviatedOid": "2e27cc2"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-30T18:39:38Z",
          "updatedAt": "2022-03-30T18:39:38Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax843Prz3",
          "commit": {
            "abbreviatedOid": "2e27cc2"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-31T00:27:41Z",
          "updatedAt": "2022-03-31T00:27:41Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax843Q8-W",
          "commit": {
            "abbreviatedOid": "2e27cc2"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-31T08:27:20Z",
          "updatedAt": "2022-03-31T08:27:20Z",
          "comments": []
        }
      ]
    },
    {
      "number": 92,
      "id": "PR_kwDOF8lax841VX2u",
      "title": "Collapsing random element generation",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/92",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "A suggestion to group together some of the random element generation, to make the displayed algorithms a little smaller. This is just for readability and displaying purposes.",
      "createdAt": "2022-03-30T18:57:34Z",
      "updatedAt": "2022-04-04T21:15:31Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "bef218f8eab3d0ff830bda5238cc1d85f2bed077",
      "headRepository": "BasileiosKal/bbs-signature",
      "headRefName": "notation-update",
      "headRefOid": "8f9d712803cd597ce2f361b4bc59cf08937349d0",
      "closedAt": "2022-04-04T21:15:31Z",
      "mergedAt": "2022-04-04T21:15:31Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "52db5c7a02f5b8ab82816c923617ed16f95641a9"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed on WG call 04/04/2022, multiple approvals, purely editorial change to improve readability, merging",
          "createdAt": "2022-04-04T21:15:27Z",
          "updatedAt": "2022-04-04T21:15:27Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax843Q8wu",
          "commit": {
            "abbreviatedOid": "6111fbd"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-31T08:26:41Z",
          "updatedAt": "2022-03-31T08:26:41Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax843ep_d",
          "commit": {
            "abbreviatedOid": "6111fbd"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-04-04T18:20:59Z",
          "updatedAt": "2022-04-04T18:20:59Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax843erPf",
          "commit": {
            "abbreviatedOid": "6111fbd"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-04T18:25:35Z",
          "updatedAt": "2022-04-04T18:25:35Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "Can you please add a check for rand_el = 0 like above",
              "createdAt": "2022-04-04T18:25:35Z",
              "updatedAt": "2022-04-04T18:25:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax843e7P_",
          "commit": {
            "abbreviatedOid": "6111fbd"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-04T19:26:58Z",
          "updatedAt": "2022-04-04T19:26:58Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "Done! Thank you!",
              "createdAt": "2022-04-04T19:26:58Z",
              "updatedAt": "2022-04-04T19:26:58Z"
            }
          ]
        }
      ]
    },
    {
      "number": 93,
      "id": "PR_kwDOF8lax841XYXa",
      "title": "Rework of the introduction",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/93",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Adds a rework of the introduction to describe the two key properties enabled by the core scheme, includes a simple asci art diagram to describe how the key operations are used and by who",
      "createdAt": "2022-03-31T03:24:19Z",
      "updatedAt": "2022-04-01T05:06:30Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "bef218f8eab3d0ff830bda5238cc1d85f2bed077",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/rework-intro",
      "headRefOid": "cddb0864a779a0c857df9fad9efac5bd53e68026",
      "closedAt": "2022-04-01T05:06:19Z",
      "mergedAt": "2022-04-01T05:06:19Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "f4067e5f05578d8a6a82f234d1cf63f917e604b1"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Multiple approvals, purely editorial, merging",
          "createdAt": "2022-04-01T05:06:30Z",
          "updatedAt": "2022-04-01T05:06:30Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax843SZCg",
          "commit": {
            "abbreviatedOid": "22409da"
          },
          "author": "tmarkovski",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-31T13:24:22Z",
          "updatedAt": "2022-03-31T13:24:22Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax843SZ2M",
          "commit": {
            "abbreviatedOid": "22409da"
          },
          "author": "tmarkovski",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-31T13:26:29Z",
          "updatedAt": "2022-03-31T13:26:29Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Can be one word `Unlinkable`",
              "createdAt": "2022-03-31T13:26:29Z",
              "updatedAt": "2022-03-31T13:26:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax843Ud1n",
          "commit": {
            "abbreviatedOid": "22409da"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-31T20:01:18Z",
          "updatedAt": "2022-03-31T20:01:18Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax843UeP_",
          "commit": {
            "abbreviatedOid": "22409da"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-31T20:02:55Z",
          "updatedAt": "2022-03-31T20:02:56Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "```suggestion\r\n**Unlinkable Presentations** - The proofs generated by the scheme are known as a signature proof of knowledge meaning a verifying party in receipt of a proof is unable to determine which signature was used to generate the proof.\r\n```",
              "createdAt": "2022-03-31T20:02:55Z",
              "updatedAt": "2022-03-31T20:02:56Z"
            }
          ]
        }
      ]
    },
    {
      "number": 95,
      "id": "PR_kwDOF8lax8418hBU",
      "title": "Add signature dst",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/95",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes Issues #78 and #85 \r\n\r\n### Changes:\r\n1. Adds the number of the revealed messages, the generators, the public key and some ciphersuite specific information to a signature domain separation tag (a signed -always revealed- message).\r\n2. Switches notation from H0 to H_s, as discussed in the WG call\r\n\r\n### Note:\r\nThis PR leaves the cipher suite specific info as optional for the `sig_dst`. The reason is that when it comes to the generators, the total number of messages etc., there are real risks for not adding them to the `sig_dst`.\r\n\r\nThe last one (total number of messages) is not documented in an issue to my knowledge, but I think it is well understood that it is dangerous to not include it. For example, the prover could reveal an additional \u201chidden\u201d attribute by calculating `C1_new = C1 + H_j(U+1) * m~_j(U+1)` and `m^_j(U+1) = m~_j(U+1)` and have the proof be validated ([reproduction](https://github.com/BasileiosKal/dif-bbs-signature-dst-pr/blob/main/src/main.rs)). \r\n\r\n(Including the generators also solves this issue, so we could potentially only include the generators and not the total number of messages. That said, IMO it would be better to be more careful since it does not hurt performance or complexity)\r\n\r\nIn the case of the ciphersuite info though, IMO its good security practice to include it but not necessary?? I\u2019m more than happy to update the pr and make the ciphersuite info mandatory, but to me it seems that the separation between ciphersuites could also happen elsewhere more naturally (in hash-2-curve for example, similarly to what the bls draft does)",
      "createdAt": "2022-04-09T21:42:47Z",
      "updatedAt": "2022-05-03T21:34:56Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "93e6259d6e9b4424d39eae33d2401e4713eb2c04",
      "headRepository": "BasileiosKal/bbs-signature",
      "headRefName": "signature-dst",
      "headRefOid": "6cf4ce1c07ff014794651f99d1b3151f49de1ead",
      "closedAt": "2022-05-03T21:34:56Z",
      "mergedAt": "2022-05-03T21:34:56Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "bf04fa7e8dd1ebee1a6c5f554c38b9a9cb571a87"
      },
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I\u2019ll need to work this in detail to understand why you can manipulate it to add an additional hidden message and still have it verify. I don\u2019t think this is necessary until I convince myself. This seems superfluous. Being able to just arbitrarily add like this seems like the scheme itself is broken\r\n\r\nI'm more than happy to discuss this further. Personally, i don't think that this breaks the scheme. The original proofs of security implicitly require the verifier to trust not only the generators but their number as well (i.e., the specific generators used for this specific signature), which is why IMO they are either in the signers PK or supplied by a trusted third-party CRS authority etc. Creating an arbitrary number of generators from a seed broke the trust to their number and this proposal re-enforces it.\r\n\r\nOf-course this is just my intuition. Really keen to discuss.",
          "createdAt": "2022-04-12T17:20:26Z",
          "updatedAt": "2022-04-12T17:20:26Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "A couple more updates, \r\n1. sig_dst is turned into a scalar using OS2IP and moding after. This leaves open the question of the length of the HASH output, but since this will be parameterized in the ciphersuites, I don\u2019t define it further here\r\n\r\n2. If sig_dst is 0 the sign will abort. We could use an XOF and keep drawing bytes instead of aborting but then verifier and holder should do the same procedure. I think that getting a 0 is so unlikely that just aborting would do fine while not raising the complexity of the draft. That said introducing a \u201chash_to_scalar\u201d function (as I plan to), could also solve this issue without needing to abort.",
          "createdAt": "2022-04-12T17:23:59Z",
          "updatedAt": "2022-04-12T17:23:59Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> If sig_dst is 0 the sign will abort. We could use an XOF and keep drawing bytes instead of aborting but then verifier and holder should do the same procedure. I think that getting a 0 is so unlikely that just aborting would do fine while not raising the complexity of the draft. That said introducing a \u201chash_to_scalar\u201d function (as I plan to), could also solve this issue without needing to abort.\r\n\r\nWhether we abort or keep reading from the XOF, it would be nice to use the same method for both this calculation and the presentation challenge. I don't think that either case risks exposing sensitive information through a timing attack (maybe to some third party monitoring the process, but not to the verifier who will learn the hash inputs anyway?), so rather than aborting the program with a minuscule probability or adding special handing for the error case it seems like simply looping to the next hash output would be the best solution.",
          "createdAt": "2022-04-12T18:18:17Z",
          "updatedAt": "2022-04-12T18:18:17Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't think this is necessary. If you use the same info in the Fiat Shamir heuristic then this avoids the attack mentioned.\r\n\r\nchallenge = HASH(PK || H_s || H_1 || ... || H_L || L || rvl_msgs with indices || C1 || C2 || T1 || T2 || nonce)",
          "createdAt": "2022-04-12T18:55:52Z",
          "updatedAt": "2022-04-12T19:04:01Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Adding the generators to the challenge hash is sufficient, but adding them to the DST is slightly more efficient for the prover, as they can cache the DST scalar and avoid hashing the generators with every presentation. The generators are still included in the Fiat-Shamir hash by virtue of the revealed DST message being hashed. If we agree that a DST message is necessary then I think that is the best place for them.",
          "createdAt": "2022-04-12T19:04:25Z",
          "updatedAt": "2022-04-12T19:04:25Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "> but adding them to the DST is slightly more efficient for the prover, as they can cache the DST scalar and avoid hashing the generators with every presentation.\r\n\r\n+1 that is my perspective also",
          "createdAt": "2022-04-12T19:11:09Z",
          "updatedAt": "2022-04-12T19:11:09Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I disagree. We're adding more work for both sides. How is that saving anything?!? I think we should arrange a time to discuss it. Github isn't the best place for this.",
          "createdAt": "2022-04-12T19:22:48Z",
          "updatedAt": "2022-04-12T19:22:48Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "> I disagree. We're adding more work for both sides. How is that saving anything?!? I think we should arrange a time to discuss it. Github isn't the best place for this.\r\n\r\nJust adding my perspective here as I wont be able to attend the special call on this topic. The proposal is to include these public parameters (generators, total number of signed messages etc) in the signature DST instead of in the challenge computed for the proof. This is slightly more efficient as @andrewwhitehead said because the signature DST value could be cached across multiple proofs where the challenge value cannot. Also these public parameters are set by the issuer so the safest way to prevent these from being manipulated by the holder or any other party, is to just protect them in the original signature produced by the issuer via the signature DST.",
          "createdAt": "2022-04-12T20:39:19Z",
          "updatedAt": "2022-04-14T02:23:33Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Some more updates,\r\n-\tAll suggestions made by @tplooker have been integrated.\r\n-\tAlso proposed by @tplooker, `sig_dst` is passed to the XOF used to calculate `e` and `s`. This has the advantage that signatures on the same messages but under different cipher suites (using the same generators) or application domains, will also be different, which is nice.\r\n-\t`CipherInfo` is changed to `ApplicationInfo`. I like this better since it captures separation between blind and non-blind signatures. Chiphersuite separation will most probably happen with `Ciphersuite_ID` either way. Currently I don\u2019t see any requirement to pass `CipherInfo` in the `sig_dst` but if anyone has a relative use case where both `Ciphersuite_ID` and `CipherInfo` will be useful I will be happy to update the PR.\r\n-\tIf `ApplicationInfo` gets adopted, some guidance will be needed on what this value should be.\r\n",
          "createdAt": "2022-04-15T17:28:38Z",
          "updatedAt": "2022-04-15T17:28:38Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I was imagining different use cases for CipherInfo and ApplicationInfo. CipherInfo would represent standard revealed parameters as required by the cipher suite, while ApplicationInfo would be more of a private extension method for use cases that build on an existing cipher suite.\r\n\r\nWith [ldp-bbs2020](https://w3c-ccg.github.io/ldp-bbs2020/#required-reveal-statements) as an example, the CipherInfo would include at least the `verificationMethod` and `proofPurpose` attributes, no longer encoded as separate messages. Each cipher suite would need to define the procedure for generating an octet string from its parameters, if any, for example it might use `bytes(canonical_json({\"verificationMethod\": ..., \"proofPurpose\": ...}))` in this case. Revocation registry details might be another example of cipher suite-defined parameters that would need to be encoded in this way so that the holder cannot choose not to reveal them.\r\n\r\nApplicationInfo might correspond to the token information field in U-Prove, allowing a way to formalize additional contextual parameters about how the signature can be applied and interpreted:\r\n\r\n> The token information field is used to encode token-specific information that is always disclosed to Verifiers, such as token usage restrictions, a validity period (see Section 3.3), or token metadata.\r\n\r\nAs an example, an issuer might use ApplicationInfo to restrict the presentation of a signature to a specific IP address to which it was issued (this wouldn't be very privacy-preserving). However, since there is no application identifier to restrict the interpretation of ApplicationInfo, it might be better to forget about that concept and require the cipher suite to define these parameters if they are to be supported. If we are only encoding one such parameter then ApplicationInfo seems like a better name.",
          "createdAt": "2022-04-15T18:25:46Z",
          "updatedAt": "2022-04-15T18:25:46Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That's very interesting. I'm kinda conflicted because from the one hand it would be nice for ciphersuites to have the ability to define \"always revealed messages\" but on the other hand i feel it breaks a little the separation between ciphersuite and application layer. For example, a representation layer specification like ldp-pps2020 would have to define a (cryptographic layer) ciphersuite and i don't think its wise (and fair) to ask from the developers of those specifications to have to define a cryptographic suite.\r\n\r\nI wonder if for a spec like ldp-bbs2020 would be enough to use `ApplicationInfo` to force certain messages to be revealed. That said, since it seems that there may exist cases that something like that would be useful, i think it would be better to add it.\r\n\r\nAlso regarding `ApplicationInfo`, i think it would not be hard to give some requirements regarding its contains and meaning, at least to avoid privacy issues. Perhaps `DomainInfo` would be a better name?",
          "createdAt": "2022-04-15T19:22:46Z",
          "updatedAt": "2022-04-15T19:22:46Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "> I was imagining different use cases for CipherInfo and ApplicationInfo. CipherInfo would represent standard revealed parameters as required by the cipher suite, while ApplicationInfo would be more of a private extension method for use cases that build on an existing cipher suite.\r\n\r\nThis raises a good point for me and I tend to resonate with this POV, essentially could we have both one is a parameter \"CipherInfo\" set by the ciphersuite, the other is a parameter that is supplied to the sign, verify, spkGen and spkVerify operations? I can see two different possible applications for ApplicationInfo\r\n\r\n1. Usecases where the signer wants to include information that must always be revealed in the resulting proof\r\n2. Usecases where no selective disclosure is even required, instead all the signed information must always be revealed and instead the scheme is really just been used more for just its group signature properties.\r\n\r\nIf two resonates with folks then I wonder if the messages and generator parameters become optional in this setting?",
          "createdAt": "2022-04-15T20:00:42Z",
          "updatedAt": "2022-04-15T20:02:29Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "The only thing that doesn't quite fit for me is whether ApplicationInfo should form part of a domain separation tag? All other info that goes into the computation of sig_dst seems to fit this model nicely however ApplicationInfo does not? Perhaps thats just a mental model thing however as the only alternative I see is to commit the application info into the signature using a seperate generator which would be in-efficient?",
          "createdAt": "2022-04-15T20:06:32Z",
          "updatedAt": "2022-04-15T20:06:32Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Just to muse on how a proposal to support both the cipher info and application info might work I would suggest the following\r\n\r\n```\r\nsignature = Sign(SK, PK, (msg_1,..., msg_L), (H_1,..., H_L), ApplicationInfo)\r\n\r\nInputs:\r\n\r\n- ApplicationInfo, an optional octet string containing application specific\r\n                   information. If not supplied, it defaults to the empty octet string.\r\n- msg_1,..., msg_L, octet strings. Messages to be signed.\r\n- H_1,..., H_L, points of G1. Generators used to sign the messages.\r\n- SK, a secret key output from KeyGen\r\n- PK, a public key output from SkToPk\r\n\r\nParameters:\r\n\r\n- Ciphersuite_ID, octet string. The unique ID of the ciphersuite.\r\n- CipherInfo, an optional octet string containing context and ciphersuite specific\r\n                   information. If not supplied, it defaults to the empty octet string.\r\n- H_s, point of G1. The generator for the blinding value of the signature.\r\n- H_d, point of G1. The generator used to sign the signature domain separation tag.\r\n\r\nOutputs:\r\n\r\n- signature, an octet string\r\n\r\nProcedure:\r\n\r\n1. (W, H0, H) = octets_to_point(PK)\r\n\r\n2. dst = (PK || L || H_s || H_d || H_1 || ... || H_L || Ciphersuite_ID || CipherInfo)\r\n\r\n3. sig_info = OS2IP(HASH(dst || ApplicationInfo)) mod q\r\n\r\n4. if sig_info is 0, abort\r\n\r\n5. h = XOF(SK  || dst || msg[i] || ... || msg[L])\r\n\r\n6. for element in (e, s) do\r\n\r\n7.      element = OS2IP(h.read(64)) mod q\r\n\r\n8.      if element = 0, go back to step 4\r\n\r\n9. B = P1 + H_s * s + H_d * sig_dst + H_1 * msg_1 + ... + H_L * msg_L\r\n\r\n10. A = B * (1 / (SK + e))\r\n\r\n11. signature = (point_to_octets_min(A), e, s)\r\n\r\n12. return signature\r\n```",
          "createdAt": "2022-04-18T05:48:41Z",
          "updatedAt": "2022-04-18T05:50:47Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I would argue that `CipherInfo` is not needed. This keeps a clear definition of what a ciphersuite is (the definition of a curve, a hash etc) which we should try to keep IMO. I wonder if we should have an additional section of `Optional Inputs` under the not optional ones. Something like,\r\n\r\n```\r\nsignature = Sign(SK, PK, (msg_1,..., msg_L), (H_1,..., H_L))\r\n\r\nInputs:\r\n\r\n- msg_1,..., msg_L, octet strings. Messages to be signed.\r\n- H_1,..., H_L, points of G1. Generators used to sign the messages.\r\n- SK, a secret key output from KeyGen\r\n- PK, a public key output from SkToPk\r\n\r\nOptional Inputs:\r\n\r\n- ApplicationInfo, an optional octet string containing application specific\r\n                    information. If not supplied, it defaults to the empty octet string.\r\n\r\nParameters:\r\n\r\n- Ciphersuite_ID, octet string. The unique ID of the ciphersuite.\r\n- H_s, point of G1. The generator for the blinding value of the signature.\r\n- H_d, point of G1. The generator used to sign the signature domain separation tag.\r\n\r\nOutputs:\r\n\r\n- signature, an octet string\r\n\r\nProcedure:\r\n\r\n1. (W, H0, H) = octets_to_point(PK)\r\n2. ...\r\n```\r\nThis may seem as a lot of text before we define the procedure but,\r\n1. This leaves the definition of each function as simple and as close to known APIs (i.e., ecdsa, rsa etc) as possible.\r\n2.  People that don't care about `ApplicationInfo` can more easily ignore it.\r\n3. Since the `Optional Inputs` and the `Parameters` are the same for all core functions (sign, verify, spkGen and spkVerify) we can move those operations in a separate section (like core signature operations??) and define them only once in the start of this new section.\r\n\r\nI also think that naming the `ApplicationInfo`, `ProtectedInfo` instead, facilitates their usage for always revealed messages and for separation between blind and non-blind signatures, that in my opinion are the 2 main use cases for the additional information. ",
          "createdAt": "2022-04-18T15:29:30Z",
          "updatedAt": "2022-04-19T03:41:21Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "> I would argue that CipherInfo is not needed. This keeps a clear definition of what a ciphersuite is (the definition of a curve, a hash etc) which we should try to keep IMO. I wonder if we should have an additional section of Optional Inputs under the not optional ones\r\n\r\nI still think CipherInfo is worth considering separately, this is distinct from the application level structure \"header\" IMO, CipherInfo is primarily defined to allow those who define new ciphersuites to have a somewhere to include additional public parameters they may define.",
          "createdAt": "2022-04-19T06:03:22Z",
          "updatedAt": "2022-04-19T06:03:22Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "An update to the PR based on the conversations of the WG around notation.\r\n1.\tThe term `domain` is used instead of `sig_dst`.\r\n2.\tThe term `header` is used for the extra info passed to the hash of the domain (ex `sig_dst`)\r\n3.\tThe term `messages` is preserved for now instead of `payloads` since there wasn\u2019t a clear consensus around moving to the `payloads` terminology yet?\r\n4.\tI took a first shot on describing the functionality of the signature\u2019s domain in the Messages and generators subsection (in considerations) but this may need its own section\r\n\r\nNote also that I don\u2019t thing we necessarily need to wait for PRs #97 and #101 to be closed for this PR to be updated. Although its true that those PRs are related, if they are merged, a wider update in the spec may be needed, which would include the changes here, if that PR is merged.\r\n\r\nAlso, the `header` is passed as an input to each operation. To me this is not ideal but making it a parameter IMO doesn\u2019t make much sense either, considering the always revealed messages use-case. I do plan to make another PR with an alternative proposal (like proposal [here](https://github.com/decentralized-identity/bbs-signature/pull/95#issuecomment-1101499779) for an `Optional Input` section) so i think it's fine to move with this approach for now.",
          "createdAt": "2022-04-20T21:53:38Z",
          "updatedAt": "2022-04-20T21:53:38Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@BasileiosKal can you resolve merge conflicts with this PR?",
          "createdAt": "2022-04-21T18:33:54Z",
          "updatedAt": "2022-04-21T18:33:54Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@BasileiosKal can you please resolve conflicts?",
          "createdAt": "2022-05-03T19:54:28Z",
          "updatedAt": "2022-05-03T19:54:28Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Open three weeks, several reviews and discussion on WG calls, multiple approvals now, merging",
          "createdAt": "2022-05-03T21:34:51Z",
          "updatedAt": "2022-05-03T21:34:51Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax8433G4m",
          "commit": {
            "abbreviatedOid": "30dcb4d"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-10T02:40:21Z",
          "updatedAt": "2022-04-10T02:40:21Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Im still pondering whether we make H_s and H_d cipher suite defined values rather than picking two generators and setting these as global fixed generators for all cipher suites, this would reduce this API's complexity by not having to supply them.",
              "createdAt": "2022-04-10T02:40:21Z",
              "updatedAt": "2022-04-10T02:40:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8433G5C",
          "commit": {
            "abbreviatedOid": "30dcb4d"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-10T02:41:02Z",
          "updatedAt": "2022-04-10T02:41:02Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "What makes cipherinfo a parameter and not an input here?",
              "createdAt": "2022-04-10T02:41:02Z",
              "updatedAt": "2022-04-10T02:41:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8433Pq3",
          "commit": {
            "abbreviatedOid": "30dcb4d"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-10T08:23:12Z",
          "updatedAt": "2022-04-10T08:23:13Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Need to specify the form of `PK` and other parameters e.g octets_to_point",
              "createdAt": "2022-04-10T08:23:13Z",
              "updatedAt": "2022-04-10T08:23:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8433PtH",
          "commit": {
            "abbreviatedOid": "30dcb4d"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-10T08:24:35Z",
          "updatedAt": "2022-04-10T08:24:35Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Apologies, ignore, saw the definition above r.e PK is the existing definition for L etc?",
              "createdAt": "2022-04-10T08:24:35Z",
              "updatedAt": "2022-04-10T08:28:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8433VZf",
          "commit": {
            "abbreviatedOid": "30dcb4d"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-10T11:30:11Z",
          "updatedAt": "2022-04-10T11:30:11Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Agreed. To that end, I updated the PR to define two more generator seeds for `H_s` and `H_d`. I also prefer this way. Since those generators are no longer calculated exactly the same as the message generators we may not need to pass them as input, as it was raised to the WG call.",
              "createdAt": "2022-04-10T11:30:11Z",
              "updatedAt": "2022-04-10T11:35:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8433Vbw",
          "commit": {
            "abbreviatedOid": "30dcb4d"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-10T11:31:25Z",
          "updatedAt": "2022-04-10T11:31:26Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "My thinking was that if cipherinfo is optional (which i think it should), that can be cached for different calls of the operations using the same ciphersuite, IMO it is suited for a parameter. This way, the inputs are only the values necessary for the core \"mathematical\" operations (in contrast, cipherinfo is only used for the sig_dst). This is similar to what `keyGen` does with `key_info`.",
              "createdAt": "2022-04-10T11:31:26Z",
              "updatedAt": "2022-04-10T11:31:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8433Vhe",
          "commit": {
            "abbreviatedOid": "30dcb4d"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-10T11:34:33Z",
          "updatedAt": "2022-04-10T11:34:33Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "That's a good point. L is implicitly defined as the total number of signed messages (based on that the input to sign is (msg_1, ..., msg_L)). I did notice though that the definition of L in terminology is different. Updated the definition of L to \"the total number of signed messages\" (there are still some inconsistencies with the definition of L even beyond this PR. I will submit a different PR to fix them).",
              "createdAt": "2022-04-10T11:34:33Z",
              "updatedAt": "2022-04-10T11:34:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8433ug-",
          "commit": {
            "abbreviatedOid": "be0a8ee"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-10T23:17:48Z",
          "updatedAt": "2022-04-10T23:17:49Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "Do h_s and h_d now have to listed as parameters here?",
              "createdAt": "2022-04-10T23:17:48Z",
              "updatedAt": "2022-04-10T23:17:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8433ujX",
          "commit": {
            "abbreviatedOid": "be0a8ee"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-10T23:19:06Z",
          "updatedAt": "2022-04-10T23:19:07Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "Ok understood and is consistent as you said with keyGen",
              "createdAt": "2022-04-10T23:19:07Z",
              "updatedAt": "2022-04-10T23:19:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8433unU",
          "commit": {
            "abbreviatedOid": "be0a8ee"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-10T23:21:12Z",
          "updatedAt": "2022-04-10T23:21:12Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Ok but do we need to convert L to bytes here? using I2OSP? Same for the other parameters too we need to make sure we fully define the form they are in to compute this hash",
              "createdAt": "2022-04-10T23:21:12Z",
              "updatedAt": "2022-04-10T23:21:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8433x3A",
          "commit": {
            "abbreviatedOid": "30dcb4d"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-11T00:32:04Z",
          "updatedAt": "2022-04-11T00:32:05Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "That's true. Note that the same consideration holds for the challenge hash in spkGen/verify. Also, the current approach is consistent with what the [Schnorr NIZK proofs RFC](https://datatracker.ietf.org/doc/html/rfc8235#section-2.3) does. That said, i would like to be more specific but i don't really like adding `point_to_octets` for every argument (for aesthetic reasons only). Another option could be a note that specifies the correct transformations for each element to be hashed (`point_to_octets` for points, `I2OSP` for numbers). This is similar (to a lesser extent) with what UProve does if im not mistaken without the `<>` notation that we could also add (i'm thinking of section 2.2 [here](https://github.com/microsoft/uprove-csharp-sdk/blob/master/docs/U-Prove%20Cryptographic%20Specification%20V1.1%20Revision%203.pdf)). I added such note in the definition to the HASH function in the Parameters section for review. \r\n\r\nIf this approach is preferred we can also add the use of the `<>` notation (`<>` representing values to be hashed after they are properly encoded i.e., `<H_1>` would represent the result of `octets_to_points(H_1)` etc.). We could also move the descriptions of the encodings for each element type to a different section if we decide on this direction, but this may be better suited for a different PR?? (I'm more than happy to include it in this PR as well).",
              "createdAt": "2022-04-11T00:32:05Z",
              "updatedAt": "2022-04-11T00:56:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8433x5n",
          "commit": {
            "abbreviatedOid": "be0a8ee"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-11T00:33:00Z",
          "updatedAt": "2022-04-11T00:33:00Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "IMO not technically since they are defined in the terminology and are not optional. We could add them for clarity in the parameters also though.",
              "createdAt": "2022-04-11T00:33:00Z",
              "updatedAt": "2022-04-11T00:33:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84342YA",
          "commit": {
            "abbreviatedOid": "9df0d2c"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-11T08:34:31Z",
          "updatedAt": "2022-04-11T08:34:31Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "Ok so we are saying that parameters differ from inputs in that they are optional? IMO I think it is clearer to have them defined here also.",
              "createdAt": "2022-04-11T08:34:31Z",
              "updatedAt": "2022-04-11T08:34:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84344X4",
          "commit": {
            "abbreviatedOid": "9df0d2c"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-11T08:41:07Z",
          "updatedAt": "2022-04-11T08:41:07Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "I like your current approach which is to make the conversion implicit in the definition of the HASH function.",
              "createdAt": "2022-04-11T08:41:07Z",
              "updatedAt": "2022-04-11T08:41:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84344m8",
          "commit": {
            "abbreviatedOid": "9df0d2c"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-11T08:41:52Z",
          "updatedAt": "2022-04-11T08:41:52Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "I also noted this recommendation in the RFC you referenced is this something we should consider?\r\n\r\n```\r\nWithin the hash function, there must be a clear boundary between any\r\n   two concatenated items.  It is RECOMMENDED that one should always\r\n   prepend each item with a 4-byte integer that represents the byte\r\n   length of that item.  OtherInfo may contain multiple subitems.  In\r\n   that case, the same rule shall apply to ensure a clear boundary\r\n   between adjacent subitems.\r\n```",
              "createdAt": "2022-04-11T08:41:52Z",
              "updatedAt": "2022-04-11T08:41:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8435uEf",
          "commit": {
            "abbreviatedOid": "30dcb4d"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-11T11:50:00Z",
          "updatedAt": "2022-04-11T11:50:01Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Thank you! Yes I think we should. I opened up an [issue](https://github.com/decentralized-identity/bbs-signature/issues/96) to discuss some of the options. I will make another PR to move the spec to this direction.",
              "createdAt": "2022-04-11T11:50:00Z",
              "updatedAt": "2022-04-11T11:50:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8435uNW",
          "commit": {
            "abbreviatedOid": "be0a8ee"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-11T11:50:29Z",
          "updatedAt": "2022-04-11T11:50:29Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "Done.",
              "createdAt": "2022-04-11T11:50:29Z",
              "updatedAt": "2022-04-11T11:50:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8438YsD",
          "commit": {
            "abbreviatedOid": "30dcb4d"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-11T20:52:03Z",
          "updatedAt": "2022-04-11T20:52:03Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "See PR #97 for a proposal moving towards this direction. The addition to the definition of HASH is removed from this PR and re-introduced extended to #97.",
              "createdAt": "2022-04-11T20:52:03Z",
              "updatedAt": "2022-04-11T20:52:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax843_EwA",
          "commit": {
            "abbreviatedOid": "ed5d101"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "I\u2019ll need to work this in detail to understand why you can manipulate it to add an additional hidden message and still have it verify. I don\u2019t think this is necessary until I convince myself. This seems superfluous. Being able to just arbitrarily add like this seems like the scheme itself is broken",
          "createdAt": "2022-04-12T09:59:21Z",
          "updatedAt": "2022-04-12T10:06:37Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "This implies that H_d is always used but the comments say it\u2019s optional. Can we update the text to reflect that?",
              "createdAt": "2022-04-12T09:59:21Z",
              "updatedAt": "2022-04-12T10:06:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax844BbN7",
          "commit": {
            "abbreviatedOid": "30dcb4d"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-12T17:20:40Z",
          "updatedAt": "2022-04-12T17:20:40Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Thank you! I added some text to reflect that both H_s and H_d are mandatory, in their definitions in Terminology. Does this address your review?",
              "createdAt": "2022-04-12T17:20:40Z",
              "updatedAt": "2022-04-12T17:20:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax844BmwQ",
          "commit": {
            "abbreviatedOid": "30dcb4d"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-12T17:56:30Z",
          "updatedAt": "2022-04-12T17:56:31Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "In regards to adding the length to hashed items, I do think it is necessary in a couple cases but not for all elements.\r\n\r\nThe current formula is `sig_dst = HASH(PK || L || H_s || H_d || H_1 || ... || H_L || CipherInfo)`. Here the encoded length of the PK and the generator points is known for the associated curve, and `L` serves to disambiguate the number of following generator points (perhaps it should be L+2 here). Prepending CipherInfo with its length helps to avoid any length extension attacks (although I don't believe SHAKE-256 suffers from that issue). If we added ApplicationInfo after CipherInfo, then adding a length to each would also help avoid any confusion around the boundaries between the two.",
              "createdAt": "2022-04-12T17:56:30Z",
              "updatedAt": "2022-04-12T17:56:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax844Bspd",
          "commit": {
            "abbreviatedOid": "30dcb4d"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-12T18:18:17Z",
          "updatedAt": "2022-04-12T18:18:17Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Thank you! Agreed. IMO it should be scalars (like the messages), integers (like L) and generic octet strings (like cipherInfo) that need to be prepended with their length (see PR #97 and issue #96 also). Regarding L specifically i do agree it may not be strictly necessary in `spk_dst` since it comes after PK and is followed by H_s, both of which have well defined lengths, but i think in general non-negative integers should be prepended with their length as a good practice.\r\n\r\n(note that this is not only to avoid length extension which even if it was possible i don't think it is that dangerous against `spk_dst`, since the hash value would most likely change under this attack)\r\n\r\nI also think i prefer `L` to `L+2` for aesthetic reason mainly and to more clearly reflect the number of signed messages. Since `H_s` and `H_d` are always supplied, essentially what might change is `L` either way.",
              "createdAt": "2022-04-12T18:18:17Z",
              "updatedAt": "2022-04-12T18:18:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax844Bu1p",
          "commit": {
            "abbreviatedOid": "30dcb4d"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-12T18:26:17Z",
          "updatedAt": "2022-04-12T18:26:18Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Scalars would also be encoded with a fixed length, and integers can be by defining the width of the field in the spec (f.ex. 4 bytes is plenty for the number of signed messages). For things like the revealed messages values in the challenge, that can be prepended by the number of following elements, each element being a pair of a 4-byte integer position and scalar value. In any case this is probably over-thinking things, but I suppose it doesn't hurt to be careful.",
              "createdAt": "2022-04-12T18:26:17Z",
              "updatedAt": "2022-04-12T18:26:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax844B111",
          "commit": {
            "abbreviatedOid": "30dcb4d"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-12T18:51:36Z",
          "updatedAt": "2022-04-12T18:51:36Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "We're getting into encoding layers and I don't think we should. That should be avoided. I2OSP and OSP2I are fine since they specify the length in bytes but that's all we should be using.",
              "createdAt": "2022-04-12T18:51:36Z",
              "updatedAt": "2022-04-12T18:51:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax844B671",
          "commit": {
            "abbreviatedOid": "30dcb4d"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-12T19:09:08Z",
          "updatedAt": "2022-04-12T19:09:08Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "@mikelodder7 we have to sufficiently describe the encoding of elements as they pertain to operations within the scheme to promote interoperability",
              "createdAt": "2022-04-12T19:09:08Z",
              "updatedAt": "2022-04-12T19:09:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax844CLxJ",
          "commit": {
            "abbreviatedOid": "30dcb4d"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-12T20:16:47Z",
          "updatedAt": "2022-04-12T20:16:48Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "I also feel that describing the formats of the messages to be hashed would be advantageous and is consistent with what other specs that deal with this stuff do. But I do also agree that going into too much detail and be too much restrictive is not a good thing. The minimum specification to achieve security must be preferred.",
              "createdAt": "2022-04-12T20:16:47Z",
              "updatedAt": "2022-04-12T20:16:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax844CMQU",
          "commit": {
            "abbreviatedOid": "30dcb4d"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-12T20:18:41Z",
          "updatedAt": "2022-04-12T20:18:41Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "> Scalars would also be encoded with a fixed length, and integers can be by defining the width of the field in the spec (f.ex. 4 bytes is plenty for the number of signed messages). For things like the revealed messages values in the challenge, that can be prepended by the number of following elements, each element being a pair of a 4-byte integer position and scalar value. In any case this is probably over-thinking things, but I suppose it doesn't hurt to be careful.\r\n\r\nWhen it comes to integers I agree and i updated PR #96 accordingly. When it comes to scalars there is two options i see,\r\n\r\n1. Their length will be defined by the ciphersuite. This means that confusion regarding the used ciphersuite may lead to confusion regarding the scalars length.\r\n2. The spec will define a fixed xLen to be used by all ciphersuites as an input to I2OSP.\r\n\r\nIMO 2. seems too restrictive. Also spec extensions may define a different value for xLen which would lead to the same problem as option 1. For that reason, i prefer 1. and the proposed approach to prepend the lengths to scalars, although i don't feel that strongly about it and i would also go with option 2. or another proposal.",
              "createdAt": "2022-04-12T20:18:41Z",
              "updatedAt": "2022-04-12T20:18:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax844COL0",
          "commit": {
            "abbreviatedOid": "30dcb4d"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-12T20:26:30Z",
          "updatedAt": "2022-04-12T20:26:30Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "If there is confusion over the ciphersuite being used then there would be big problems, that must be validated either through the DST or the generator creation process. I think we just say that scalars have a fixed length encoding defined by the ciphersuite.",
              "createdAt": "2022-04-12T20:26:30Z",
              "updatedAt": "2022-04-12T20:26:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax844CR2i",
          "commit": {
            "abbreviatedOid": "b694a71"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-12T20:40:49Z",
          "updatedAt": "2022-04-12T20:40:49Z",
          "comments": [
            {
              "originalPosition": 67,
              "body": "Can we also add in the ciphersuite ID here too? as the first argument? e.g the unique string that identifies the cipher suite",
              "createdAt": "2022-04-12T20:40:49Z",
              "updatedAt": "2022-04-12T20:40:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax844CkKN",
          "commit": {
            "abbreviatedOid": "b694a71"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-12T21:57:16Z",
          "updatedAt": "2022-04-12T21:57:17Z",
          "comments": [
            {
              "originalPosition": 67,
              "body": "Done! Just a note, Ciphersuite_ID is not currently defined in ciphersuites. Will make an additional PR to add the definition.",
              "createdAt": "2022-04-12T21:57:17Z",
              "updatedAt": "2022-04-12T21:57:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax844Cl_Y",
          "commit": {
            "abbreviatedOid": "30dcb4d"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-12T22:07:56Z",
          "updatedAt": "2022-04-12T22:07:57Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "That's true. Well personally I would prefer even when ciphersuites define the length of the scalar, to be more careful and also enforce it here even if it is redundant, but im fine with the alternative. I will also be very interested in @christianpaquin input on that issue, since UProve seems to have taken this route. ",
              "createdAt": "2022-04-12T22:07:56Z",
              "updatedAt": "2022-04-12T22:07:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax844Cq-Y",
          "commit": {
            "abbreviatedOid": "9c471fc"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-12T22:40:23Z",
          "updatedAt": "2022-04-12T22:40:23Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "```suggestion\r\n- CipherInfo, an optional octet string containing ciphersuite specific information.\r\n```",
              "createdAt": "2022-04-12T22:40:23Z",
              "updatedAt": "2022-04-12T22:40:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax844HsyQ",
          "commit": {
            "abbreviatedOid": "30dcb4d"
          },
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-13T20:50:24Z",
          "updatedAt": "2022-04-13T20:50:24Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "> I will also be very interested in @christianpaquin input on that issue, since UProve seems to have taken this route.\r\n\r\nJust one thing I'd like to point out: currently the `H_d` generator is multiplied with a random `s` value. In U-Prove, we set that message value to the hash of various elements (issuer params, and an always-disclosed \"token information\" attribute). This allows issuers to encode a message that should always be disclosed (e.g., validity period, signature metadata, usage restrictions, etc.) when presenting the signature, without \"wasting\" another message for that purpose if needed. Maybe something to consider here? \r\n\r\n",
              "createdAt": "2022-04-13T20:50:24Z",
              "updatedAt": "2022-04-13T20:50:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax844Huw_",
          "commit": {
            "abbreviatedOid": "9c471fc"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-13T20:59:09Z",
          "updatedAt": "2022-04-13T20:59:10Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "side note that tripped me up here rand_el implies that the resulting values for e and s are entirely random when they are not should we name this something else?",
              "createdAt": "2022-04-13T20:59:09Z",
              "updatedAt": "2022-04-13T20:59:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax844HwFE",
          "commit": {
            "abbreviatedOid": "9c471fc"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-13T21:05:10Z",
          "updatedAt": "2022-04-13T21:05:10Z",
          "comments": [
            {
              "originalPosition": 117,
              "body": "Considering we are talking about having the parmeters suitable implicitly converted would the same make sense to the ouput of the HASH function e.g always returns the form of OS2IP?",
              "createdAt": "2022-04-13T21:05:10Z",
              "updatedAt": "2022-04-13T21:05:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax844HyXs",
          "commit": {
            "abbreviatedOid": "30dcb4d"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-13T21:15:34Z",
          "updatedAt": "2022-04-13T21:15:34Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Thank you very much for your input! That is interesting. In bbs+ the `s` value is never revealed (the paper goes to great lengths actually to keep it secret, see issue #70  for some context). This is to avoid correlation. And from the conversation in the issue i linked to, it seems that there is no getting around the fact that we need `s` to be random and we need it to be secret. That said, it is a very interesting idea and definitely worth thinking more about it.",
              "createdAt": "2022-04-13T21:15:34Z",
              "updatedAt": "2022-04-13T21:15:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax844IEbx",
          "commit": {
            "abbreviatedOid": "9c471fc"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-13T23:05:39Z",
          "updatedAt": "2022-04-13T23:05:40Z",
          "comments": [
            {
              "originalPosition": 117,
              "body": "Thank you! That's a good point. I opened PR #101 which is towards this direction and if adopted will replace the OS2IP(HASH(...)) here.",
              "createdAt": "2022-04-13T23:05:39Z",
              "updatedAt": "2022-04-13T23:05:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax844IZVy",
          "commit": {
            "abbreviatedOid": "9c471fc"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-14T02:24:45Z",
          "updatedAt": "2022-04-14T02:24:46Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "```suggestion\r\n: A generator for the blinding value in the signature. The value of H_s is defined by each ciphersuite and must always be supplied to the operations listing it as a parameter.\r\n```",
              "createdAt": "2022-04-14T02:24:46Z",
              "updatedAt": "2022-04-14T02:24:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax844IZYb",
          "commit": {
            "abbreviatedOid": "9c471fc"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-14T02:25:14Z",
          "updatedAt": "2022-04-14T02:25:15Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "```suggestion\r\n: A generator for the signature domain separation tag (sig_dst), which binds both signature and proof to a specific domain. The value of H_d is defined by each ciphersuite and must always be supplied to the operations listing it as a parameter.\r\n```",
              "createdAt": "2022-04-14T02:25:15Z",
              "updatedAt": "2022-04-14T02:25:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax844IZiz",
          "commit": {
            "abbreviatedOid": "9c471fc"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-14T02:26:56Z",
          "updatedAt": "2022-04-14T02:26:56Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "How about `element` or `item` instead?",
              "createdAt": "2022-04-14T02:26:56Z",
              "updatedAt": "2022-04-14T02:26:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax844IZlk",
          "commit": {
            "abbreviatedOid": "9c471fc"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-14T02:27:24Z",
          "updatedAt": "2022-04-14T02:27:24Z",
          "comments": [
            {
              "originalPosition": 103,
              "body": "```suggestion\r\n- CipherInfo, an optional octet string containing ciphersuite specific information.\r\n```",
              "createdAt": "2022-04-14T02:27:24Z",
              "updatedAt": "2022-04-14T02:27:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax844IZmm",
          "commit": {
            "abbreviatedOid": "9c471fc"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-14T02:27:34Z",
          "updatedAt": "2022-04-14T02:27:34Z",
          "comments": [
            {
              "originalPosition": 138,
              "body": "```suggestion\r\n- CipherInfo, an optional octet string containing ciphersuite specific information.\r\n```",
              "createdAt": "2022-04-14T02:27:34Z",
              "updatedAt": "2022-04-14T02:27:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax844IZnt",
          "commit": {
            "abbreviatedOid": "9c471fc"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-14T02:27:45Z",
          "updatedAt": "2022-04-14T02:27:46Z",
          "comments": [
            {
              "originalPosition": 218,
              "body": "```suggestion\r\n- CipherInfo, an optional octet string containing ciphersuite specific information.\r\n```",
              "createdAt": "2022-04-14T02:27:45Z",
              "updatedAt": "2022-04-14T02:27:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax844kZKh",
          "commit": {
            "abbreviatedOid": "30dcb4d"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-21T18:32:15Z",
          "updatedAt": "2022-04-21T18:32:16Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Feels like everything has been addressed in this thread, resolving the conversation, re-open if need be",
              "createdAt": "2022-04-21T18:32:15Z",
              "updatedAt": "2022-04-21T18:32:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax844kZ_o",
          "commit": {
            "abbreviatedOid": "c4a2892"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-21T18:35:45Z",
          "updatedAt": "2022-04-21T18:35:45Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "```suggestion\r\n2. generators =  (H_s || H_d || H_1 || ... || H_L)\r\n```\r\n\r\nfor case consistency",
              "createdAt": "2022-04-21T18:35:45Z",
              "updatedAt": "2022-04-21T18:35:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax844kaDj",
          "commit": {
            "abbreviatedOid": "c4a2892"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-21T18:36:01Z",
          "updatedAt": "2022-04-21T18:36:01Z",
          "comments": [
            {
              "originalPosition": 128,
              "body": "```suggestion\r\n5. generators =  (H_s || H_d || H_1 || ... || H_L)\r\n```\r\n\r\nfor case consistency",
              "createdAt": "2022-04-21T18:36:01Z",
              "updatedAt": "2022-04-21T18:36:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax844kaJi",
          "commit": {
            "abbreviatedOid": "c4a2892"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-21T18:36:24Z",
          "updatedAt": "2022-04-21T18:36:25Z",
          "comments": [
            {
              "originalPosition": 176,
              "body": "```suggestion\r\n6. generators =  (H_s || H_d || H_1 || ... || H_L)\r\n```\r\n\r\nfor case consistency",
              "createdAt": "2022-04-21T18:36:25Z",
              "updatedAt": "2022-04-21T18:36:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax844kaOH",
          "commit": {
            "abbreviatedOid": "c4a2892"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-21T18:36:45Z",
          "updatedAt": "2022-04-21T18:36:45Z",
          "comments": [
            {
              "originalPosition": 180,
              "body": "```suggestion\r\n8. for element in (r1, r2, e~, r2~, r3~, s~, m~_j1, ..., m~_jU): \r\n```",
              "createdAt": "2022-04-21T18:36:45Z",
              "updatedAt": "2022-04-21T18:36:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax844kaRD",
          "commit": {
            "abbreviatedOid": "c4a2892"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-21T18:36:56Z",
          "updatedAt": "2022-04-21T18:36:57Z",
          "comments": [
            {
              "originalPosition": 183,
              "body": "```suggestion\r\n9.      element = HASH(PRF(8*ceil(log2(q)))) mod q\r\n```",
              "createdAt": "2022-04-21T18:36:56Z",
              "updatedAt": "2022-04-21T18:36:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax844kaTz",
          "commit": {
            "abbreviatedOid": "c4a2892"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-21T18:37:05Z",
          "updatedAt": "2022-04-21T18:37:06Z",
          "comments": [
            {
              "originalPosition": 186,
              "body": "```suggestion\r\n10.      if element = 0, go back to step 7\r\n```",
              "createdAt": "2022-04-21T18:37:05Z",
              "updatedAt": "2022-04-21T18:37:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax844kaZx",
          "commit": {
            "abbreviatedOid": "c4a2892"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-21T18:37:29Z",
          "updatedAt": "2022-04-21T18:37:30Z",
          "comments": [
            {
              "originalPosition": 269,
              "body": "```suggestion\r\n5. generators =  (H_s || H_d || H_1 || ... || H_L)\r\n```",
              "createdAt": "2022-04-21T18:37:29Z",
              "updatedAt": "2022-04-21T18:37:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax844kahj",
          "commit": {
            "abbreviatedOid": "c4a2892"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "A couple more minor tweaks, getting there!",
          "createdAt": "2022-04-21T18:37:53Z",
          "updatedAt": "2022-04-21T18:37:53Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax845JKh4",
          "commit": {
            "abbreviatedOid": "ef659fb"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-02T04:28:41Z",
          "updatedAt": "2022-05-02T04:28:41Z",
          "comments": [
            {
              "originalPosition": 75,
              "body": "I like doing element access via the square bracket syntax as you have done here, but is this not in consistent with line 434? I'd prefer we do it this way but it needs to be the same throughout the doc",
              "createdAt": "2022-05-02T04:28:41Z",
              "updatedAt": "2022-05-02T04:28:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845JKmy",
          "commit": {
            "abbreviatedOid": "ef659fb"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-02T04:29:47Z",
          "updatedAt": "2022-05-02T04:29:48Z",
          "comments": [
            {
              "originalPosition": 113,
              "body": "```suggestion\r\n          information. If not supplied, it defaults to an empty string.\r\n```",
              "createdAt": "2022-05-02T04:29:48Z",
              "updatedAt": "2022-05-02T04:29:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845K5Wy",
          "commit": {
            "abbreviatedOid": "ef659fb"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-02T14:41:03Z",
          "updatedAt": "2022-05-02T14:41:03Z",
          "comments": [
            {
              "originalPosition": 113,
              "body": "Updated. Thanks!",
              "createdAt": "2022-05-02T14:41:03Z",
              "updatedAt": "2022-05-02T14:41:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845L2ic",
          "commit": {
            "abbreviatedOid": "12744d1"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-02T18:29:48Z",
          "updatedAt": "2022-05-02T18:29:48Z",
          "comments": [
            {
              "originalPosition": 75,
              "body": "```suggestion\r\n5. h = XOF(SK  || domain || msg_1 || ... || msg_L)\r\n```",
              "createdAt": "2022-05-02T18:29:48Z",
              "updatedAt": "2022-05-02T18:29:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845Mby3",
          "commit": {
            "abbreviatedOid": "6a9a1f2"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-02T21:01:01Z",
          "updatedAt": "2022-05-02T21:01:01Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax845QCG_",
          "commit": {
            "abbreviatedOid": "6a9a1f2"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-03T14:46:29Z",
          "updatedAt": "2022-05-03T14:46:29Z",
          "comments": []
        }
      ]
    },
    {
      "number": 97,
      "id": "PR_kwDOF8lax842B47S",
      "title": "Encodings for elements to be hashed",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/97",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "First approach to close issue #96\r\n\r\nEncodings suggestion of elements to be hashed (similar to the ones used by [U-Prove](https://github.com/microsoft/uprove-csharp-sdk/blob/master/docs/U-Prove%20Cryptographic%20Specification%20V1.1%20Revision%203.pdf)). \r\n\r\nThis PR follows option 2 from the above issue, i.e., the encoding of elements to be hashed is described in a separate section and used implicitly throughout the document. See PR #95  for more context.\r\n\r\nI also suggest that scalars, non-negative integers, and generic octet strings must always be prepended with their length while it is only recommended for EC points.",
      "createdAt": "2022-04-11T20:48:28Z",
      "updatedAt": "2022-04-22T03:42:16Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "52db5c7a02f5b8ab82816c923617ed16f95641a9",
      "headRepository": "BasileiosKal/bbs-signature",
      "headRefName": "hash-input-encoding",
      "headRefOid": "87d114ad3d8e85f8dfeeae7d437f7e77434478ab",
      "closedAt": "2022-04-22T03:42:16Z",
      "mergedAt": "2022-04-22T03:42:16Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "d9b3a351c79900ee50a94ca632e345df81175909"
      },
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Updates proposed by @mikelodder7 and @andrewwhitehead  during the WG call of 18/ 4/2022:\r\n1.\tLengths are extended to 8 bytes (for non-DST\u2019s octet strings). Non-negative integers are also updated to be represented with 8 bytes, to be consistent with the representation of the lengths of octet strings (which are also non-negative integers). \r\n2.\tThe second paragraph is updated to make use of I2OSP (instead of zero-extensions).\r\n3.\tThe example is updated accordingly.",
          "createdAt": "2022-04-20T22:28:43Z",
          "updatedAt": "2022-04-20T22:28:43Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Multiple reviews and now approvals, open 10 days, discussed on latest WG call, merging",
          "createdAt": "2022-04-22T03:42:11Z",
          "updatedAt": "2022-04-22T03:42:11Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax8439SBU",
          "commit": {
            "abbreviatedOid": "ba2ea60"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-12T02:42:51Z",
          "updatedAt": "2022-04-12T02:42:52Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "```suggestion\r\nTo avoid ambiguity, each element passed to the HASH or the XOF function (either by itself or concatenated with other elements), must first be encoded to an appropriate format, depending on its type. Specifically, \r\n```\r\n\r\nI believe ambiguity might be a better word here?",
              "createdAt": "2022-04-12T02:42:51Z",
              "updatedAt": "2022-04-12T02:42:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8439SdR",
          "commit": {
            "abbreviatedOid": "ba2ea60"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-12T02:46:49Z",
          "updatedAt": "2022-04-12T02:46:49Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Where would this be normatively define whether this recommendation is in use to promote interoperability, would it be defined in the cipher suite whether G1 or G2 points are using this length prefix?",
              "createdAt": "2022-04-12T02:46:49Z",
              "updatedAt": "2022-04-14T02:29:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax844Bffk",
          "commit": {
            "abbreviatedOid": "ba2ea60"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-12T17:36:19Z",
          "updatedAt": "2022-04-12T17:36:19Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Thank you! I haven't considered that. IMO it would be part of the suites but it's not worth raising the complexity since the length of the `points_to_octets` output is determined but its value either way. The recommendation was just to be extra careful. Removed for know.",
              "createdAt": "2022-04-12T17:36:19Z",
              "updatedAt": "2022-04-12T17:36:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax844BgEV",
          "commit": {
            "abbreviatedOid": "ba2ea60"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-12T17:37:36Z",
          "updatedAt": "2022-04-12T17:37:36Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Thanks! Updated.",
              "createdAt": "2022-04-12T17:37:36Z",
              "updatedAt": "2022-04-12T17:37:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax844IZ4i",
          "commit": {
            "abbreviatedOid": "3fc0395"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-14T02:30:17Z",
          "updatedAt": "2022-04-14T02:30:18Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "```suggestion\r\nTo avoid ambiguity, each element passed to the HASH or the XOF function, either by itself or concatenated with other elements, must first be encoded to an appropriate format, depending on its type. Specifically, \r\n```",
              "createdAt": "2022-04-14T02:30:17Z",
              "updatedAt": "2022-04-14T02:30:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax844IaCo",
          "commit": {
            "abbreviatedOid": "3fc0395"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-14T02:31:45Z",
          "updatedAt": "2022-04-14T02:31:45Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "```suggestion\r\n- Points in G1 or G2 must be encoded using the `point_to_octets` implementation for a particular ciphersuite.\r\n```",
              "createdAt": "2022-04-14T02:31:45Z",
              "updatedAt": "2022-04-14T02:31:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax844Iarn",
          "commit": {
            "abbreviatedOid": "3fc0395"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-14T02:37:53Z",
          "updatedAt": "2022-04-14T02:37:54Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "```suggestion\r\nAfter encoding, scalars and octet strings MUST be prepended with a value representing the length of their binary representation in the form of the number of bytes. This length's binary value must be zero-extended to 32 bits. The combined value (encoded value + length prefix) binary representation is then encoded as a single octet string. For example, the string `0x14d` will be encoded as `0x00000002014d`. Similarly, the number `236195248387` will be encoded as `0x0000000536fe557903`. Values larger than 2^32 - 1, MUST be rejected.\r\n```",
              "createdAt": "2022-04-14T02:37:54Z",
              "updatedAt": "2022-04-14T02:37:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax844IavL",
          "commit": {
            "abbreviatedOid": "3fc0395"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-14T02:38:29Z",
          "updatedAt": "2022-04-14T02:38:29Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Wonder to make this 100% clear whether we should give an example of this transform?\r\n",
              "createdAt": "2022-04-14T02:38:29Z",
              "updatedAt": "2022-04-14T02:38:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax844MQ6X",
          "commit": {
            "abbreviatedOid": "3fc0395"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-14T19:58:21Z",
          "updatedAt": "2022-04-14T19:58:21Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Done.",
              "createdAt": "2022-04-14T19:58:21Z",
              "updatedAt": "2022-04-14T19:58:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax844MQ7L",
          "commit": {
            "abbreviatedOid": "3fc0395"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-14T19:58:24Z",
          "updatedAt": "2022-04-14T19:58:25Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Done.",
              "createdAt": "2022-04-14T19:58:25Z",
              "updatedAt": "2022-04-14T19:58:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax844MRA8",
          "commit": {
            "abbreviatedOid": "3fc0395"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-14T19:58:49Z",
          "updatedAt": "2022-04-14T19:58:49Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Thanks! Updated this section following your suggestions.",
              "createdAt": "2022-04-14T19:58:49Z",
              "updatedAt": "2022-04-14T19:58:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax844MRVi",
          "commit": {
            "abbreviatedOid": "3fc0395"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-14T20:00:14Z",
          "updatedAt": "2022-04-14T20:00:14Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Added an example dealing with a \"octet string\" (an ascii message) and a number. There are other options to include (points etc.) but then we may want to move the example to an appendix since it will likely be more extensive.",
              "createdAt": "2022-04-14T20:00:14Z",
              "updatedAt": "2022-04-14T20:00:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax844f5FH",
          "commit": {
            "abbreviatedOid": "823e834"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM now",
          "createdAt": "2022-04-20T23:25:04Z",
          "updatedAt": "2022-04-20T23:25:04Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax844kbO5",
          "commit": {
            "abbreviatedOid": "823e834"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-04-21T18:40:34Z",
          "updatedAt": "2022-04-21T18:40:34Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax844kcfS",
          "commit": {
            "abbreviatedOid": "823e834"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-21T18:44:02Z",
          "updatedAt": "2022-04-21T18:44:02Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "I think we need to clarify that the encoding rules defined below are per-element, suggested language tweak to make this clearer.\r\n\r\n```suggestion\r\nTo avoid ambiguity, each element passed to the HASH or the XOF function, including situations when multiple elements are supplied in a concatenated form, must first be encoded to an appropriate format, depending on its type. Specifically,\r\n```",
              "createdAt": "2022-04-21T18:44:02Z",
              "updatedAt": "2022-04-21T18:44:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax844lHiw",
          "commit": {
            "abbreviatedOid": "823e834"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-21T21:56:10Z",
          "updatedAt": "2022-04-21T21:56:10Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Thanks! Updated.",
              "createdAt": "2022-04-21T21:56:10Z",
              "updatedAt": "2022-04-21T21:56:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax844ln0y",
          "commit": {
            "abbreviatedOid": "87d114a"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-04-22T02:45:36Z",
          "updatedAt": "2022-04-22T02:45:36Z",
          "comments": []
        }
      ]
    },
    {
      "number": 101,
      "id": "PR_kwDOF8lax842NG7x",
      "title": "Adding a hash-to-scalar function",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/101",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR introduces a `hash_to_scalar` function as discussed in the WG call. The goal is for the function to replace some of the hashing to scalars happening internally in the operations, i.e., for the `e`, `s` calculation in `sign`, in the random elements in `spkGen` and potentially for the challenge value and the `sig_dst` if we decide to use that (see PR #95). The function is not inserted yet in those operations to not block #95. If that is resolved first i will update this PR.\r\n\r\n### Note:\r\n`hash_to_field` is removed with this PR (from `MapMessageToScalarAsHash`) and is replaced with `hash_to_scalar`. Note that this will also close issue #100 since `hash_to_scalar` checks if an element is 0. My reasoning is that `hash-to-scalar` serves the same functionality while been able to be used for the cases detailed above, without needing to worry about dst's etc. Note that aside from the use of dst, `hash-to-scalar` is almost exactly `hash-to-field` using `expand-message-xof` and with `m` (the fields extension degree) = 1. \r\n\r\nAlso the dst is not removed from `MapMessageToScalarAsHash` (where it is useful). A note is also added stating that people can use `hash-to-field` if they want. However, i feel that the current construction is more flexible to serve the needs of the spec, but really keen to discuss alternatives and other proposals.",
      "createdAt": "2022-04-13T22:19:20Z",
      "updatedAt": "2022-05-05T19:07:53Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "bf04fa7e8dd1ebee1a6c5f554c38b9a9cb571a87",
      "headRepository": "BasileiosKal/bbs-signature",
      "headRefName": "hash-to-scalar",
      "headRefOid": "bb32dcb581b900fdafffbafc4138e8f46fbb1ece",
      "closedAt": "2022-05-05T19:07:53Z",
      "mergedAt": "2022-05-05T19:07:53Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "7691a42b2eab7834999966620479d6dd8285307a"
      },
      "comments": [
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'd prefer to see the lengths prepended in MapMessageToScalarAsHash, maybe like this?\r\n\r\n    1. If len(dst) > 2^8-1 or len(msg) > 2^32-1, abort\r\n    2. dst_prime = I2OSP(len(dst), 1) || dst\r\n    3. msg_prime = I2OSP(len(msg), 4) || msg\r\n    4. result = hash_to_scalar(dst_prime || msg_prime, 1)\r\n    5. return result\r\n",
          "createdAt": "2022-04-13T22:31:45Z",
          "updatedAt": "2022-04-13T22:31:45Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I'd prefer to see the lengths prepended in MapMessageToScalarAsHash, maybe like this?\r\n\r\nThank you! I updated the PR based on your suggestion.\r\n\r\nIMO this brings also an interesting point for PR #97, i.e., it makes little sense to have a dst be appended with a 4 bytes length (as #97 suggests). Maybe an \"unless otherwise stated\" is needed.",
          "createdAt": "2022-04-14T16:24:02Z",
          "updatedAt": "2022-04-14T16:24:02Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes adding the DST length seems to just add an unnecessary restriction in this case.",
          "createdAt": "2022-04-14T16:49:45Z",
          "updatedAt": "2022-04-14T16:49:45Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That's true. Just to make sure i understand. Is your preference to remove the addition of the DST length from this PR or remove/update the descriptions of PR #97.\r\n\r\nIf it is the first case, maybe a better option would be to remove the lengths of both the message and the dst from `MapMessageToScalarAsHash` and just point to the recommendation in PR #97.",
          "createdAt": "2022-04-14T17:44:01Z",
          "updatedAt": "2022-04-14T17:44:01Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Update: I added the dst handling in PR #97, so now the two PRs are consistent. If we decide to go that route, the only thing that will neet to be updated IMO is noting that the transformation descried in #97 ...\"-**may**- happen implicitly, but they MUST precede every call to the HASH or XOF function.\"",
          "createdAt": "2022-04-14T20:29:19Z",
          "updatedAt": "2022-04-14T20:29:19Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Following the [updates](https://github.com/decentralized-identity/bbs-signature/pull/97#issuecomment-1104519302) on PR #97, extended the length of a msg to be mapped to a scalar as hash to 8 bytes max.",
          "createdAt": "2022-04-20T22:39:16Z",
          "updatedAt": "2022-04-20T22:39:16Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Same here @BasileiosKal can you resolve conflicts?",
          "createdAt": "2022-05-03T21:36:15Z",
          "updatedAt": "2022-05-03T21:36:15Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Same here @BasileiosKal can you resolve conflicts?\r\n\r\nYeap. Done! Thanks!",
          "createdAt": "2022-05-03T21:42:43Z",
          "updatedAt": "2022-05-03T21:42:43Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Multiple approvals, discussed on WG call, open 3 weeks, merging",
          "createdAt": "2022-05-05T19:07:44Z",
          "updatedAt": "2022-05-05T19:07:44Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax844Ia7R",
          "commit": {
            "abbreviatedOid": "2bcc064"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-14T02:40:03Z",
          "updatedAt": "2022-04-14T02:40:04Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "```suggestion\r\nThis operation describes how to hash an arbitrary octet string to `n` scalar values in the multiplicative group of integers mod q. This procedure acts as a helper function, and it used internally in various places within the operation described in the spec. To map a message to a scalar that would be passed as input to the [Sign](#sign), [Verify](#verify), [spkGen](#spkgen) and [spkVerify](#spkverify) functions, one must use [MapMessageToScalarAsHash](#mapmessagetoscalar) instead.\r\n```",
              "createdAt": "2022-04-14T02:40:03Z",
              "updatedAt": "2022-04-14T02:40:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax844Lanv",
          "commit": {
            "abbreviatedOid": "2bcc064"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-14T16:22:39Z",
          "updatedAt": "2022-04-14T16:22:39Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Thanks! Done.",
              "createdAt": "2022-04-14T16:22:39Z",
              "updatedAt": "2022-04-14T16:22:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax844kdQY",
          "commit": {
            "abbreviatedOid": "718672f"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-21T18:46:59Z",
          "updatedAt": "2022-04-21T18:47:00Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "I assume whether you are using an XOF vs a conventional HASH alg is a decision for the ciphersuite, how is that captured?",
              "createdAt": "2022-04-21T18:47:00Z",
              "updatedAt": "2022-04-21T18:47:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax844lGYH",
          "commit": {
            "abbreviatedOid": "718672f"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-21T21:49:00Z",
          "updatedAt": "2022-04-21T21:49:01Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Thanks! That's a good point! Added an additional option in the ciphersuites: `hashing_elements_to_scalars`, to capture the two options.\r\n\r\n(My thinking: When it comes to hash-to-scalar, i don't think it needs to be captured in the ciphersuite, since it will be used by the sign and spkGen operations, i.e., no-need to communicate the use of HASH vs XOF to a verifying/relying party. For MapMessageToScallarAsHash (that uses hash-to-scalar), again it may not be necessary (since it's use should be agreed in a higher level at some extent e.g., to which messages it applies) but better be careful.)",
              "createdAt": "2022-04-21T21:49:00Z",
              "updatedAt": "2022-04-21T22:03:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845McJB",
          "commit": {
            "abbreviatedOid": "dd96d20"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-02T21:02:38Z",
          "updatedAt": "2022-05-02T21:02:38Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax845cSLA",
          "commit": {
            "abbreviatedOid": "bb32dcb"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Looks good, #116 will need to be updated if this is merged.",
          "createdAt": "2022-05-05T17:24:07Z",
          "updatedAt": "2022-05-05T17:25:10Z",
          "comments": []
        }
      ]
    },
    {
      "number": 104,
      "id": "PR_kwDOF8lax842cy8F",
      "title": "Add Vasileios as editor",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/104",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "In light of contributions to the spec and agreement from the WG, this PR adds Vasileios as an editor to the core spec.",
      "createdAt": "2022-04-19T20:40:02Z",
      "updatedAt": "2022-04-21T17:59:12Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "506d70c0d266a3b04cb8e8a58796008d5284fd2e",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/update-editors",
      "headRefOid": "db5239f61f7eb54e73b3746928dca44cd99fec25",
      "closedAt": "2022-04-21T17:59:09Z",
      "mergedAt": "2022-04-21T17:59:09Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "f8eb48a8a1fa6d734409bdad81daffd4b23e3939"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Multiple approvals, discussed in WG slack, no objections, merging.",
          "createdAt": "2022-04-21T17:59:04Z",
          "updatedAt": "2022-04-21T17:59:04Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax844dscW",
          "commit": {
            "abbreviatedOid": "db5239f"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-04-20T14:54:31Z",
          "updatedAt": "2022-04-20T14:54:31Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax844j_Mf",
          "commit": {
            "abbreviatedOid": "db5239f"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-04-21T17:19:13Z",
          "updatedAt": "2022-04-21T17:19:13Z",
          "comments": []
        }
      ]
    },
    {
      "number": 105,
      "id": "PR_kwDOF8lax842c0HQ",
      "title": "Clarify keygen optional",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/105",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Resolves #98 plus some minor editorial changes",
      "createdAt": "2022-04-19T20:46:40Z",
      "updatedAt": "2022-04-21T23:23:55Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "506d70c0d266a3b04cb8e8a58796008d5284fd2e",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/editorial-pass",
      "headRefOid": "f25567b2518a0d43cc8ec7ff1bc1bf897623560d",
      "closedAt": "2022-04-21T23:23:51Z",
      "mergedAt": "2022-04-21T23:23:51Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "c03dc25eee84a50dbb56d6faeaf8a24ec2127ce8"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Ready for re-review @andrewwhitehead @BasileiosKal (GH wont let me request re-review)",
          "createdAt": "2022-04-21T17:26:48Z",
          "updatedAt": "2022-04-21T17:26:48Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Minor editorial changes, multiple approvals, issue discussed on prior WG call, merging.",
          "createdAt": "2022-04-21T23:23:47Z",
          "updatedAt": "2022-04-21T23:23:47Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax844duEg",
          "commit": {
            "abbreviatedOid": "2a15be1"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-20T14:58:38Z",
          "updatedAt": "2022-04-20T14:58:39Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "Maybe we can tighten up 'of the equivalent form'. I think the main requirement is that it chooses keys uniformly from the key space (the scalar field).",
              "createdAt": "2022-04-20T14:58:38Z",
              "updatedAt": "2022-04-20T14:58:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax844eRR3",
          "commit": {
            "abbreviatedOid": "2a15be1"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-20T16:38:48Z",
          "updatedAt": "2022-04-20T16:38:49Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "Agreed. Maybe \"...provided that the secret key is statistically close to uniformly random\" (taken from the [bls_spec](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-bls-signature-04#section-2.3)) or \"...provided that the secret key is infeasible to guess\"?? I think the second one covers most security requirements (in the first wording one may wonder how close to uniform is enough, although maybe I'm overthinking it)??",
              "createdAt": "2022-04-20T16:38:49Z",
              "updatedAt": "2022-04-20T16:38:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax844kB7g",
          "commit": {
            "abbreviatedOid": "2a15be1"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-21T17:25:02Z",
          "updatedAt": "2022-04-21T17:25:03Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "Thanks, I missed that section in the BLS sig section have updated accordingly.",
              "createdAt": "2022-04-21T17:25:03Z",
              "updatedAt": "2022-04-21T17:25:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax844k4Jo",
          "commit": {
            "abbreviatedOid": "57bc47d"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2022-04-21T20:39:36Z",
          "updatedAt": "2022-04-21T20:39:36Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax844k-ow",
          "commit": {
            "abbreviatedOid": "21f6628"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-21T21:08:27Z",
          "updatedAt": "2022-04-21T21:08:27Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "We could reference http://www.csl.sri.com/papers/vcdm-did-crypto-recs/crypto-review-and-recs-for-VCDM-and-DIDs-implems-FINAL-20211015.pdf here, estimating the strength at 117-120 bits. It's definitely less than 128 bits, but still \"virtually one million times stronger than BN-254\"",
              "createdAt": "2022-04-21T21:08:27Z",
              "updatedAt": "2022-04-21T21:08:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax844lRw3",
          "commit": {
            "abbreviatedOid": "21f6628"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-21T23:09:10Z",
          "updatedAt": "2022-04-21T23:09:10Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Thanks have updated, what do you think?",
              "createdAt": "2022-04-21T23:09:10Z",
              "updatedAt": "2022-04-21T23:09:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax844lSbt",
          "commit": {
            "abbreviatedOid": "f25567b"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-04-21T23:14:59Z",
          "updatedAt": "2022-04-21T23:14:59Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax844lSew",
          "commit": {
            "abbreviatedOid": "21f6628"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-21T23:15:18Z",
          "updatedAt": "2022-04-21T23:15:18Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Good enough for me :)",
              "createdAt": "2022-04-21T23:15:18Z",
              "updatedAt": "2022-04-21T23:15:19Z"
            }
          ]
        }
      ]
    },
    {
      "number": 106,
      "id": "PR_kwDOF8lax842c0c6",
      "title": "Add section on scoped proofs",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/106",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Attempts to resolve #103, open to feedback on alternative ways to describe this functionality",
      "createdAt": "2022-04-19T20:48:40Z",
      "updatedAt": "2022-04-22T03:44:10Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "506d70c0d266a3b04cb8e8a58796008d5284fd2e",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/replay-attack-blurb",
      "headRefOid": "06a3bb25cc75b2b7fa97934ad6badaa53f5b20d1",
      "closedAt": "2022-04-22T03:43:53Z",
      "mergedAt": "2022-04-22T03:43:53Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "ea08561758d49171c62a5baca084595e9309dfb2"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "ready for re-review @andrewwhitehead @BasileiosKal ",
          "createdAt": "2022-04-21T18:25:22Z",
          "updatedAt": "2022-04-21T18:25:22Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Multiple approvals, purely editorial, merging",
          "createdAt": "2022-04-22T03:43:49Z",
          "updatedAt": "2022-04-22T03:43:49Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax844eEdr",
          "commit": {
            "abbreviatedOid": "e2b9842"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-20T15:58:18Z",
          "updatedAt": "2022-04-20T15:58:18Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Maybe 'prevent' a replay attack? Assuming the verifier chooses a sufficiently unique presentation message, a replayed proof would simply fail to verify, but the verifier wouldn't know the reason for the mismatch in the hash.",
              "createdAt": "2022-04-20T15:58:18Z",
              "updatedAt": "2022-04-20T15:58:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax844ePiA",
          "commit": {
            "abbreviatedOid": "e2b9842"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-20T16:33:07Z",
          "updatedAt": "2022-04-20T16:33:15Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I don't know if we can claim that **Scoped Proofs** are a \"new property\". Simple non interactive Schnorr proofs described in [RFC8235](https://www.rfc-editor.org/rfc/rfc8235.html#section-3) would have the same property. They just call it OtherInfo and not a presentation message. Maybe we should remove the \"new\" or substitute it with \"interesting\"??",
              "createdAt": "2022-04-20T16:33:07Z",
              "updatedAt": "2022-04-20T18:00:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax844kFLG",
          "commit": {
            "abbreviatedOid": "e2b9842"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-21T17:31:06Z",
          "updatedAt": "2022-04-21T17:31:07Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "I like detect because its what you choose to do with that information that leads to prevention. The scheme only provides you a way to be able to detect and therefore prevent.",
              "createdAt": "2022-04-21T17:31:07Z",
              "updatedAt": "2022-04-21T17:31:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax844kFVq",
          "commit": {
            "abbreviatedOid": "e2b9842"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-21T17:31:27Z",
          "updatedAt": "2022-04-21T17:31:28Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Nice! good catch, yes will update.",
              "createdAt": "2022-04-21T17:31:27Z",
              "updatedAt": "2022-04-21T17:31:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax844lG51",
          "commit": {
            "abbreviatedOid": "06a3bb2"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-04-21T21:52:22Z",
          "updatedAt": "2022-04-21T21:52:22Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax844lm1k",
          "commit": {
            "abbreviatedOid": "06a3bb2"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-04-22T02:35:54Z",
          "updatedAt": "2022-04-22T02:35:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 108,
      "id": "PR_kwDOF8lax842j1cP",
      "title": "Add generator point in G1 in BlindSign",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/108",
      "state": "MERGED",
      "author": "alessandroguggino",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Updated the Blind BBS Signature Extension draft.\r\nFixes #107 + little updates for consistency to core draft, still many to do.",
      "createdAt": "2022-04-21T13:35:13Z",
      "updatedAt": "2022-04-22T22:35:45Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "ea08561758d49171c62a5baca084595e9309dfb2",
      "headRepository": "alessandroguggino/bbs-signature",
      "headRefName": "blindsign",
      "headRefOid": "a97d54f9cd21edb574ed4fddfc0557c330bd02d5",
      "closedAt": "2022-04-22T22:35:45Z",
      "mergedAt": "2022-04-22T22:35:45Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "9d7bb7d050f7751e50c137707512c05fdb5a713e"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Thanks for the PR @alessandroguggino!",
          "createdAt": "2022-04-21T18:31:27Z",
          "updatedAt": "2022-04-21T18:31:27Z"
        },
        {
          "author": "alessandroguggino",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Added the reference to the core draft as suggested by @tplooker. Thanks! ",
          "createdAt": "2022-04-22T10:27:03Z",
          "updatedAt": "2022-04-22T10:27:03Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Purely editorial changes to update the blind sign draft, merging.",
          "createdAt": "2022-04-22T22:35:41Z",
          "updatedAt": "2022-04-22T22:35:41Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax844kYlf",
          "commit": {
            "abbreviatedOid": "c3891e8"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-21T18:29:49Z",
          "updatedAt": "2022-04-21T18:29:49Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Can we replace the TODO and add a reference to the core draft using this link (https://identity.foundation/bbs-signature/draft-bbs-signatures.html) using the reference syntax shown at the bottom here https://raw.githubusercontent.com/decentralized-identity/bbs-signature/main/draft-bbs-signatures.md",
              "createdAt": "2022-04-21T18:29:49Z",
              "updatedAt": "2022-04-21T18:29:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax844nZD6",
          "commit": {
            "abbreviatedOid": "c3891e8"
          },
          "author": "alessandroguggino",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-22T10:21:51Z",
          "updatedAt": "2022-04-22T10:21:52Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Ok, I am going to commit it",
              "createdAt": "2022-04-22T10:21:51Z",
              "updatedAt": "2022-04-22T10:21:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax844qbAu",
          "commit": {
            "abbreviatedOid": "a97d54f"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2022-04-22T22:34:20Z",
          "updatedAt": "2022-04-22T22:34:20Z",
          "comments": []
        }
      ]
    },
    {
      "number": 112,
      "id": "PR_kwDOF8lax842qh-q",
      "title": "More editorial tweaks",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/112",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "- Minor cleanup of language / syntax\r\n- Fixed some broken references\r\n- Shifted the algorithmic explanation to the appendix",
      "createdAt": "2022-04-23T03:46:37Z",
      "updatedAt": "2022-05-02T19:57:55Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "9d7bb7d050f7751e50c137707512c05fdb5a713e",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/editorial-tweaks",
      "headRefOid": "0ff10a86d28bd1df659761e0355966d99a90f168",
      "closedAt": "2022-05-02T19:57:29Z",
      "mergedAt": "2022-05-02T19:57:29Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "36b40005733294e344e1724688616df51e43ef0c"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "- Removed the use of context security consideration because it is addressed in other considerations and context is an undefined term in the spec\r\n- tweaked the language around the recommendations for KeyValidation.",
          "createdAt": "2022-05-02T04:45:19Z",
          "updatedAt": "2022-05-02T04:45:19Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed on 2nd May WG call, resolved to merge, multiple approvals",
          "createdAt": "2022-05-02T19:57:25Z",
          "updatedAt": "2022-05-02T19:57:25Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax845KWb3",
          "commit": {
            "abbreviatedOid": "f1384f9"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-02T12:37:41Z",
          "updatedAt": "2022-05-02T12:43:42Z",
          "comments": [
            {
              "originalPosition": 84,
              "body": "```suggestion\r\nBBS proofs (SPK's) are nondeterministic, meaning care must be taken against attacks arising from using bad randomness, for example, the nonce reuse attack on ECDSA [@HDWH12]. It is RECOMMENDED that the presentation messages used in this specification contain a nonce chosen at random from a trusted source of randomness, see the (#presentation-message-selection) for additional considerations.\r\n```\r\n\r\nThis may be a little confusing. Signatures as described in the spec are (or can be) deterministic. Also, the presentation message appears in spkGen and not in sign. For that i suggest making the consideration about the BBS+ proofs instead of the signatures.\r\n\r\nThe term nonce is also not used in the spec, but the intent is for the nonce to be contained in the presentation message. I think the suggested change reflects that.",
              "createdAt": "2022-05-02T12:37:41Z",
              "updatedAt": "2022-05-02T12:43:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845L18B",
          "commit": {
            "abbreviatedOid": "0ff10a8"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-02T18:27:17Z",
          "updatedAt": "2022-05-02T18:27:17Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax845MB9t",
          "commit": {
            "abbreviatedOid": "0ff10a8"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-02T19:17:00Z",
          "updatedAt": "2022-05-02T19:17:00Z",
          "comments": []
        }
      ]
    },
    {
      "number": 115,
      "id": "PR_kwDOF8lax843JQXi",
      "title": "Update KeyValidate operation",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/115",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Fixes #109 ",
      "createdAt": "2022-05-02T03:50:11Z",
      "updatedAt": "2022-05-09T18:17:36Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "2abab63c75fb113468dfb33a5fd2395d99852c0e",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/update-key-validate",
      "headRefOid": "dede00f4ef69ad4b0fc4fef15641dccaecec9ee0",
      "closedAt": "2022-05-09T18:17:26Z",
      "mergedAt": "2022-05-09T18:17:25Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "697d7b46568a6e27ae6793bb3d99b48462c97729"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Best to merge #95 ahead of this PR",
          "createdAt": "2022-05-02T03:51:27Z",
          "updatedAt": "2022-05-02T03:51:27Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@andrewwhitehead @BasileiosKal ",
          "createdAt": "2022-05-02T03:51:59Z",
          "updatedAt": "2022-05-02T03:51:59Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "> As i https://github.com/decentralized-identity/bbs-signature/issues/109#issuecomment-1114727062 in issue https://github.com/decentralized-identity/bbs-signature/issues/109, I would just remove keyValidate from spkGen (which is also covered by PR https://github.com/decentralized-identity/bbs-signature/pull/112). That said, not really very strong opinionated about it, so I\u2019m fine with what the WG decides.\r\n\r\nOk shall we also remove the sub-group check for A and then add it as a security consideration that signature verification should be performed prior to SpkGen?",
          "createdAt": "2022-05-02T21:41:28Z",
          "updatedAt": "2022-05-02T21:41:28Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": " >Ok shall we also remove the sub-group check for A and then add it as a security consideration that signature verification should be performed prior to SpkGen?\r\n \r\nYeap that makes sense to me. For now, at least. Something like @andrewwhitehead's proposal in the WG call may change this approach so i think it would be fine to merge the PR as is also. Since the goal was to update KeyValidate, i think this covers it.",
          "createdAt": "2022-05-02T21:59:49Z",
          "updatedAt": "2022-05-02T21:59:49Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Reviewed on WG call, multiple approvals, merging",
          "createdAt": "2022-05-09T18:17:21Z",
          "updatedAt": "2022-05-09T18:17:21Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax845KGyD",
          "commit": {
            "abbreviatedOid": "5b13c39"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "As i [commended](https://github.com/decentralized-identity/bbs-signature/issues/109#issuecomment-1114727062) in issue #109, I would just remove keyValidate from spkGen (which is also covered by PR #112). That said, not really very strong opiniated about it, so I\u2019m fine with what the WG decides.",
          "createdAt": "2022-05-02T11:14:00Z",
          "updatedAt": "2022-05-02T14:32:31Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax845K3gk",
          "commit": {
            "abbreviatedOid": "5b13c39"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-02T14:35:36Z",
          "updatedAt": "2022-05-02T14:35:36Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "We need to add the key validation check to verify. The Point at infinity will allow any signature to verify. `subgroup_check` won't catch this since the point at infinity is in the subgroup. Should I submit a fix to this or do you want to change it?",
              "createdAt": "2022-05-02T14:35:36Z",
              "updatedAt": "2022-05-02T14:35:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845K3zI",
          "commit": {
            "abbreviatedOid": "5b13c39"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-02T14:36:29Z",
          "updatedAt": "2022-05-02T14:36:29Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "We need to add checks that `e` and `s` are not zero to avoid creating a signature at infinity which will validate against any public key. Should I create another PR to this one or do you want to fix it?",
              "createdAt": "2022-05-02T14:36:29Z",
              "updatedAt": "2022-05-02T14:36:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845K4X4",
          "commit": {
            "abbreviatedOid": "5b13c39"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-02T14:38:22Z",
          "updatedAt": "2022-05-02T14:38:22Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "I'm noticing this everywhere but curious about the best approach. All points and scalars that will be used in pairing operations should be checked in verify functions for zero and infinity to avoid returning true for invalid signatures when this is the case. How should we add this method check?",
              "createdAt": "2022-05-02T14:38:22Z",
              "updatedAt": "2022-05-02T14:38:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845LB88",
          "commit": {
            "abbreviatedOid": "5b13c39"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-02T15:10:01Z",
          "updatedAt": "2022-05-02T15:10:01Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "I don't think this PR removes KeyValidate from verify??",
              "createdAt": "2022-05-02T15:10:01Z",
              "updatedAt": "2022-05-02T15:10:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845LB_k",
          "commit": {
            "abbreviatedOid": "5b13c39"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-02T15:10:09Z",
          "updatedAt": "2022-05-02T15:10:10Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "Don't really see how the signature validates with any PK even if e, s are 0. The signature will just become P1* SK. You will still need the correct PK to validate it?? \r\n\r\nThat said, strong +1 for adding the checks for e and s to be non 0 in validate. ",
              "createdAt": "2022-05-02T15:10:10Z",
              "updatedAt": "2022-05-02T15:10:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845LCAJ",
          "commit": {
            "abbreviatedOid": "5b13c39"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-02T15:10:11Z",
          "updatedAt": "2022-05-02T15:10:12Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "That's a good point. So that means A, B, A' and Abar then (since W is already checked for 0 and infinity)?? Maybe a security consideration or an addition to the considerations section describing that all elements passed to the pairings must be checked accordingly (similar to the hash inputs lengths)??",
              "createdAt": "2022-05-02T15:10:12Z",
              "updatedAt": "2022-05-02T15:10:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845LywS",
          "commit": {
            "abbreviatedOid": "5b13c39"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-02T18:14:03Z",
          "updatedAt": "2022-05-02T18:14:03Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Swap so we do the subgroup_check before checking the public key does not equal Identity_G2",
              "createdAt": "2022-05-02T18:14:03Z",
              "updatedAt": "2022-05-02T18:14:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845L2-j",
          "commit": {
            "abbreviatedOid": "5b13c39"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-02T18:31:39Z",
          "updatedAt": "2022-05-02T18:31:40Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "I'm not saying it does. I'm saying we should add it.",
              "createdAt": "2022-05-02T18:31:40Z",
              "updatedAt": "2022-05-02T18:31:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845L3fr",
          "commit": {
            "abbreviatedOid": "5b13c39"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-02T18:33:39Z",
          "updatedAt": "2022-05-02T18:33:40Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "That's a good start. For SpkVerify this means A', Abar, and D and scalars. For verify this means A and scalars. The public key should always be checked.",
              "createdAt": "2022-05-02T18:33:39Z",
              "updatedAt": "2022-05-02T18:33:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845MOXI",
          "commit": {
            "abbreviatedOid": "5b13c39"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-02T20:01:59Z",
          "updatedAt": "2022-05-02T20:01:59Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "But the function already has it?",
              "createdAt": "2022-05-02T20:01:59Z",
              "updatedAt": "2022-05-02T20:02:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845MjH0",
          "commit": {
            "abbreviatedOid": "5b13c39"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-02T21:37:36Z",
          "updatedAt": "2022-05-02T21:37:36Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Addressed",
              "createdAt": "2022-05-02T21:37:36Z",
              "updatedAt": "2022-05-02T21:37:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845PDt8",
          "commit": {
            "abbreviatedOid": "2ebef0c"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-03T11:53:11Z",
          "updatedAt": "2022-05-03T11:53:11Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "Should key validate check for infinity and do the subgroup, on curve checks? That would allow a common check. Or maybe we add a function called `IsValidPoint` and use that to perform all the checks and reuse it where necessary ",
              "createdAt": "2022-05-03T11:53:11Z",
              "updatedAt": "2022-05-03T11:53:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845PD6A",
          "commit": {
            "abbreviatedOid": "2ebef0c"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-03T11:54:04Z",
          "updatedAt": "2022-05-03T11:54:05Z",
          "comments": [
            {
              "originalPosition": 91,
              "body": "Need to check Abar != 1",
              "createdAt": "2022-05-03T11:54:04Z",
              "updatedAt": "2022-05-03T11:54:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845QyOe",
          "commit": {
            "abbreviatedOid": "2ebef0c"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-03T17:04:43Z",
          "updatedAt": "2022-05-03T17:04:43Z",
          "comments": [
            {
              "originalPosition": 91,
              "body": "Can you clarify why this check is needed?? If it's to avoid passing 1 in the parings i suggest even removing the A' != 1 check and have a more unified way of performing this check for all elements.",
              "createdAt": "2022-05-03T17:04:43Z",
              "updatedAt": "2022-05-03T17:04:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845QzO7",
          "commit": {
            "abbreviatedOid": "2ebef0c"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-03T17:08:28Z",
          "updatedAt": "2022-05-03T17:08:28Z",
          "comments": [
            {
              "originalPosition": 91,
              "body": "Yes that\u2019s why. I agree to the unified method",
              "createdAt": "2022-05-03T17:08:28Z",
              "updatedAt": "2022-05-03T17:08:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845dfLC",
          "commit": {
            "abbreviatedOid": "5b13c39"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-05T22:54:26Z",
          "updatedAt": "2022-05-05T22:54:26Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "Have raised #126 to capture this",
              "createdAt": "2022-05-05T22:54:26Z",
              "updatedAt": "2022-05-05T22:54:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845dfM6",
          "commit": {
            "abbreviatedOid": "5b13c39"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-05T22:54:40Z",
          "updatedAt": "2022-05-05T22:54:40Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "Have raised #127 to capture this",
              "createdAt": "2022-05-05T22:54:40Z",
              "updatedAt": "2022-05-05T22:54:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845dfVQ",
          "commit": {
            "abbreviatedOid": "5b13c39"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-05T22:55:41Z",
          "updatedAt": "2022-05-05T22:55:41Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "Referenced in #126 ",
              "createdAt": "2022-05-05T22:55:41Z",
              "updatedAt": "2022-05-05T22:55:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845dfZd",
          "commit": {
            "abbreviatedOid": "2ebef0c"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-05T22:56:00Z",
          "updatedAt": "2022-05-05T22:56:01Z",
          "comments": [
            {
              "originalPosition": 91,
              "body": "Referenced in #126 ",
              "createdAt": "2022-05-05T22:56:01Z",
              "updatedAt": "2022-05-05T22:56:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845nfC_",
          "commit": {
            "abbreviatedOid": "dede00f"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-09T18:16:58Z",
          "updatedAt": "2022-05-09T18:16:58Z",
          "comments": []
        }
      ]
    },
    {
      "number": 116,
      "id": "PR_kwDOF8lax843JSvR",
      "title": "Parameterize the drawn bytes for generator creation",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/116",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Fixes #94, note this is a first pass at the PR, please check the wording particularly around the parameters r and k. Also is there ever a case where the bytes drawn from the XOF for generator creation would be different to the bytes drawn to calculate the e and s components of the signature in the [sign operation](https://identity.foundation/bbs-signature/draft-bbs-signatures.html#name-sign) because if not we could generalize/share this parameter.\r\n\r\nAlso note I think #101 needs to be merged ahead of this\r\n\r\n",
      "createdAt": "2022-05-02T04:11:37Z",
      "updatedAt": "2022-05-05T22:41:50Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "7691a42b2eab7834999966620479d6dd8285307a",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/parameterize-drawn-bytes",
      "headRefOid": "ffabec558ba01d279fc6ee6b41a0536918f58038",
      "closedAt": "2022-05-05T22:41:35Z",
      "mergedAt": "2022-05-05T22:41:35Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "2abab63c75fb113468dfb33a5fd2395d99852c0e"
      },
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think that the parameter could be shared. The collision resistance security of shake goes up to a certain level either way, so it will be no advantage drawing a larger number of bytes when creating the generators either way (e.g., more than 64 for shake256 or 32 for shake128) even if you need a lot of generators. In general, you would need 2^256 generators to have around 40% chance of a collision, so the danger is practically non-existent IMO.",
          "createdAt": "2022-05-02T14:02:13Z",
          "updatedAt": "2022-05-02T14:02:13Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed on WG call 2nd of May, will update to have a common variable that covers drawing bytes from XOF for e and s generation case",
          "createdAt": "2022-05-02T18:09:16Z",
          "updatedAt": "2022-05-02T18:09:16Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Multiple approvals, discussed on previous WG call, merging.",
          "createdAt": "2022-05-05T22:41:26Z",
          "updatedAt": "2022-05-05T22:41:26Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax845Kti4",
          "commit": {
            "abbreviatedOid": "652107e"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-02T14:03:08Z",
          "updatedAt": "2022-05-02T14:31:56Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "```suggestion\r\n: Number of bytes to draw from the XOF when creating generators as per the operation documented in (#creategenerators). It is RECOMMENDED this value be set to one greater than `ceil(log2(p)+k)/8` for the ciphersuite, where `p` and `k` are parameters from the underlying pairing friendly curve being used.\r\n```\r\n\r\nNo need to introduce a new parameter (r) IMO.",
              "createdAt": "2022-05-02T14:03:08Z",
              "updatedAt": "2022-05-02T14:31:56Z"
            },
            {
              "originalPosition": 22,
              "body": "```suggestion\r\n- generator_no_of_bytes\r\n```",
              "createdAt": "2022-05-02T14:06:10Z",
              "updatedAt": "2022-05-02T14:31:56Z"
            },
            {
              "originalPosition": 23,
              "body": "```suggestion\r\n: Number of bytes to draw from the XOF when creating generators as per the operation documented in (#creategenerators). It is RECOMMENDED this value be set to one greater than `ceil(r+k)/8` for the ciphersuite, where `p` the prime characteristic of the G1 and G2 subgroups and `k` the targeted security level (in bits) of the ciphersuite. \r\n```\r\nSince we don't describe `p` and `k` anywhere else (they are defined in the ciphersuites we reference, however this must be fixed to be clearer, opened issue #118 for that) added here a suggestion for quick explanation of what they are. This may be nice to have even if #118 is closed, since those parameters will most likely only be defined as references.",
              "createdAt": "2022-05-02T14:30:42Z",
              "updatedAt": "2022-05-02T14:31:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845LssY",
          "commit": {
            "abbreviatedOid": "b3fda95"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-02T17:51:13Z",
          "updatedAt": "2022-05-02T17:51:14Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "```suggestion\r\n- generator_no_of_bytes\r\n: Number of bytes to draw from the XOF when creating generators as per the operation documented in (#creategenerators). It is RECOMMENDED this value be set to one greater than `ceil(r+k)/8` for the ciphersuite, where `p` the prime characteristic of the G1 and G2 subgroups and `k` the targeted security level (in bits) of the ciphersuite.\r\n```",
              "createdAt": "2022-05-02T17:51:14Z",
              "updatedAt": "2022-05-02T17:51:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845Lsy5",
          "commit": {
            "abbreviatedOid": "d4128c6"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-02T17:51:38Z",
          "updatedAt": "2022-05-02T17:51:39Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "```suggestion\r\n: Number of bytes to draw from the XOF when creating generators as per the operation documented in (#creategenerators). It is RECOMMENDED this value be set to one greater than `ceil(r+k)/8` for the ciphersuite, where `p` the prime characteristic of the G1 and G2 subgroups and `k` the targeted security level (in bits) of the ciphersuite.\r\n\r\n```",
              "createdAt": "2022-05-02T17:51:39Z",
              "updatedAt": "2022-05-02T17:51:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845MnYa",
          "commit": {
            "abbreviatedOid": "9863fb9"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2022-05-02T22:02:43Z",
          "updatedAt": "2022-05-02T22:02:43Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax845dcvL",
          "commit": {
            "abbreviatedOid": "ffabec5"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-05T22:35:40Z",
          "updatedAt": "2022-05-05T22:35:40Z",
          "comments": []
        }
      ]
    },
    {
      "number": 120,
      "id": "PR_kwDOF8lax843Mq0i",
      "title": "Rename presentation message to presentation header",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/120",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Resolves #110 ",
      "createdAt": "2022-05-02T23:48:17Z",
      "updatedAt": "2022-05-03T19:53:17Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "bc258eec172e974073b5279176119249b84fff2c",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/rename-presentation-message",
      "headRefOid": "90efb6af98bec82315891299c53adb91b446474c",
      "closedAt": "2022-05-03T19:53:13Z",
      "mergedAt": "2022-05-03T19:53:13Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "93e6259d6e9b4424d39eae33d2401e4713eb2c04"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Multiple approvals, discussed on WG call, merging.",
          "createdAt": "2022-05-03T19:52:57Z",
          "updatedAt": "2022-05-03T19:52:57Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax845PERm",
          "commit": {
            "abbreviatedOid": "2b9f6e9"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM. Maybe we add an example in another PR of the header",
          "createdAt": "2022-05-03T11:55:52Z",
          "updatedAt": "2022-05-03T11:55:52Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax845Qy4R",
          "commit": {
            "abbreviatedOid": "2b9f6e9"
          },
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Good to remove the ambiguity around the \"message\" term.",
          "createdAt": "2022-05-03T17:07:09Z",
          "updatedAt": "2022-05-03T17:07:09Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax845Q5mc",
          "commit": {
            "abbreviatedOid": "2b9f6e9"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-03T17:23:00Z",
          "updatedAt": "2022-05-03T17:23:01Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "```suggestion\r\nA signature proof of knowledge generating algorithm that creates a zero-knowledge proof of knowledge of a signature while selectively disclosing messages from a signature given a vector of messages, a vector of indices of the revealed messages, the signer's public key, and a presentation header (see [Presentation header selection](#presentation-header-selection) for more details).\r\n```",
              "createdAt": "2022-05-03T17:23:00Z",
              "updatedAt": "2022-05-03T17:23:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845Q5_f",
          "commit": {
            "abbreviatedOid": "2b9f6e9"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM.",
          "createdAt": "2022-05-03T17:24:31Z",
          "updatedAt": "2022-05-03T17:24:44Z",
          "comments": []
        }
      ]
    },
    {
      "number": 122,
      "id": "PR_kwDOF8lax843NUhf",
      "title": "Rename spk -> proof",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/122",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Fixes #121, this PR renames spk to proof for the two spk based operations",
      "createdAt": "2022-05-03T05:39:07Z",
      "updatedAt": "2022-05-03T19:47:07Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "48e70fbbc8d258abdc50654eb6c42a05ad0dea61",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/spk-to-proof",
      "headRefOid": "cbacb9c4690145fe2204e9a7c9365e1be383b96a",
      "closedAt": "2022-05-03T19:47:04Z",
      "mergedAt": "2022-05-03T19:47:04Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "bc258eec172e974073b5279176119249b84fff2c"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Multiple approvals discussed on WG call, minor nits responded to with one of them to be addressed in a subsequent PR for #114, merging",
          "createdAt": "2022-05-03T19:46:58Z",
          "updatedAt": "2022-05-03T19:46:58Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax845PEzp",
          "commit": {
            "abbreviatedOid": "cbacb9c"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-03T11:58:21Z",
          "updatedAt": "2022-05-03T11:58:21Z",
          "comments": [
            {
              "originalPosition": 122,
              "body": "Minor nit: Many crypto papers use unrevealed instead of undisclosed. Should align with the literature?",
              "createdAt": "2022-05-03T11:58:21Z",
              "updatedAt": "2022-05-03T11:58:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845PE7y",
          "commit": {
            "abbreviatedOid": "cbacb9c"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-03T11:58:57Z",
          "updatedAt": "2022-05-03T11:58:58Z",
          "comments": [
            {
              "originalPosition": 143,
              "body": "D should be a capital since our syntax says points are capitalized.",
              "createdAt": "2022-05-03T11:58:58Z",
              "updatedAt": "2022-05-03T11:58:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845PFKl",
          "commit": {
            "abbreviatedOid": "cbacb9c"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Looks good. Just two minor nits ",
          "createdAt": "2022-05-03T11:59:31Z",
          "updatedAt": "2022-05-03T11:59:31Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax845Qw9Z",
          "commit": {
            "abbreviatedOid": "cbacb9c"
          },
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "These changes improve readability.",
          "createdAt": "2022-05-03T17:00:09Z",
          "updatedAt": "2022-05-03T17:00:09Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax845QxcF",
          "commit": {
            "abbreviatedOid": "cbacb9c"
          },
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-03T17:01:54Z",
          "updatedAt": "2022-05-03T17:01:54Z",
          "comments": [
            {
              "originalPosition": 122,
              "body": "\"Selective disclosure\" is a common expression for this feature, which naturally leads to \"undisclosed\" messages; I'd prefer keeping this as is.",
              "createdAt": "2022-05-03T17:01:54Z",
              "updatedAt": "2022-05-03T17:01:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845Q0ES",
          "commit": {
            "abbreviatedOid": "cbacb9c"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-03T17:11:26Z",
          "updatedAt": "2022-05-03T17:11:27Z",
          "comments": [
            {
              "originalPosition": 143,
              "body": "Agreed. This whole section needs updating though. I just haven't gotten to it yet. I suggest we leave it for another PR (hopefully one that i will make very soon).",
              "createdAt": "2022-05-03T17:11:27Z",
              "updatedAt": "2022-05-03T17:11:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845Q4EA",
          "commit": {
            "abbreviatedOid": "cbacb9c"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2022-05-03T17:18:27Z",
          "updatedAt": "2022-05-03T17:18:27Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax845Rm8N",
          "commit": {
            "abbreviatedOid": "cbacb9c"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-03T19:42:56Z",
          "updatedAt": "2022-05-03T19:42:56Z",
          "comments": [
            {
              "originalPosition": 122,
              "body": "I agree with @christianpaquin in most contexts I've seen the term selective disclosure is now quite well understood I'd prefer we stay aligned to this consensus",
              "createdAt": "2022-05-03T19:42:56Z",
              "updatedAt": "2022-05-03T19:43:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845RnWt",
          "commit": {
            "abbreviatedOid": "cbacb9c"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-03T19:44:39Z",
          "updatedAt": "2022-05-03T19:44:39Z",
          "comments": [
            {
              "originalPosition": 143,
              "body": "Yeap thanks @mikelodder7 I think if we apply the rules that @BasileiosKal has suggested in #114 via a seperate PR then we can resolve these nits",
              "createdAt": "2022-05-03T19:44:39Z",
              "updatedAt": "2022-05-03T19:44:39Z"
            }
          ]
        }
      ]
    },
    {
      "number": 123,
      "id": "PR_kwDOF8lax843S769",
      "title": "Hash usage harmonization",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/123",
      "state": "MERGED",
      "author": "christianpaquin",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Harmonized use of hash function (use `HASH` vs `H`), clarified starting salt value in KeyGen, fixed broken MD links and some typos.",
      "createdAt": "2022-05-04T14:40:16Z",
      "updatedAt": "2022-05-05T20:00:21Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "6a335d07695b9e58b3a96273f79485273c498fc4",
      "headRepository": "christianpaquin/bbs-signature",
      "headRefName": "hash-clarifications",
      "headRefOid": "5235e40e4179c026ba9262a865cb3aafc56f7e7e",
      "closedAt": "2022-05-05T19:06:34Z",
      "mergedAt": "2022-05-05T19:06:34Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "f834e4ab06bfb3c9729c25fc6e6ebc0f5f31de4a"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Multiple approvals, purely editorial, merging",
          "createdAt": "2022-05-05T19:06:31Z",
          "updatedAt": "2022-05-05T19:06:31Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax845WqS3",
          "commit": {
            "abbreviatedOid": "80758d7"
          },
          "author": "brentzundel",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-04T17:33:04Z",
          "updatedAt": "2022-05-04T17:33:04Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax845XiFe",
          "commit": {
            "abbreviatedOid": "80758d7"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-04T19:52:52Z",
          "updatedAt": "2022-05-04T19:52:52Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "I think its great to have the octet string here explicitly however I was also thinking that we could update the encoding of elements to be hashed section to include more generally how string based values should be encoded prior to hashing?",
              "createdAt": "2022-05-04T19:52:52Z",
              "updatedAt": "2022-05-04T19:54:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845XjC9",
          "commit": {
            "abbreviatedOid": "80758d7"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-04T19:53:31Z",
          "updatedAt": "2022-05-04T19:53:31Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "Just a note we need to come back here and define how many bytes are drawn because this is an extendable output function",
              "createdAt": "2022-05-04T19:53:31Z",
              "updatedAt": "2022-05-04T19:53:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845Xjpb",
          "commit": {
            "abbreviatedOid": "80758d7"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-04T19:53:54Z",
          "updatedAt": "2022-05-04T19:54:17Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "Thank you @christianpaquin. Just a nit. I wonder if it would be better to \"enforce\" the utf-8 encoding in the [Encoding of elements to be hashed](https://github.com/decentralized-identity/bbs-signature/blob/main/draft-bbs-signatures.md#encoding-of-elements-to-be-hashed) section?? Maybe by adding the following line,\r\n```\r\n- Strings must be encoded to octets using the UTF-8 representation and zero-extending the result to a length that is a multiple of 8 bits.\r\n```\r\nThat way the UTF-8 representation will be used not only for the salt in keyGen but for any string that needs to be hashed (for example a DST or the Ciphersuite_ID).",
              "createdAt": "2022-05-04T19:53:54Z",
              "updatedAt": "2022-05-04T19:54:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845XkoU",
          "commit": {
            "abbreviatedOid": "80758d7"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-04T19:54:58Z",
          "updatedAt": "2022-05-04T19:54:58Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "Do you think you could address this in this PR?",
              "createdAt": "2022-05-04T19:54:58Z",
              "updatedAt": "2022-05-04T19:54:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845XmzQ",
          "commit": {
            "abbreviatedOid": "80758d7"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-04T19:57:49Z",
          "updatedAt": "2022-05-04T19:57:49Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "A sorry. I just saw @tplooker's [comment](https://github.com/decentralized-identity/bbs-signature/pull/123#discussion_r865265607) above with the same proposal. Sorry about that.",
              "createdAt": "2022-05-04T19:57:49Z",
              "updatedAt": "2022-05-04T19:57:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845Xm1e",
          "commit": {
            "abbreviatedOid": "80758d7"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-04T19:57:52Z",
          "updatedAt": "2022-05-04T19:57:53Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "If so I would update this section as follows.\r\n\r\n```suggestion\r\n- INITSALT the string value of \"BBS-SIG-KEYGEN-SALT-\", for the avoidance of doubt as per the rules outlined in (#encoding-of-elements-to-be-hashed) the octet string based representation past to the `HASH` function is \"0x4242532d5349472d4b455947454e2d53414c542d\".\r\n```",
              "createdAt": "2022-05-04T19:57:52Z",
              "updatedAt": "2022-05-04T19:57:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845XnSC",
          "commit": {
            "abbreviatedOid": "80758d7"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "Couple of minor suggested changes, thanks for the PR @christianpaquin!",
          "createdAt": "2022-05-04T19:58:27Z",
          "updatedAt": "2022-05-04T19:58:27Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax845YMJj",
          "commit": {
            "abbreviatedOid": "80758d7"
          },
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-04T21:08:58Z",
          "updatedAt": "2022-05-04T21:08:59Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "I didn't see other usage of ASCII strings in the text; all other references (unless I missed something?) take octet string as input (aka byte arrays, right?), which made me think that encoding for these were application-specific. This being said, if we want to make these ASCII strings, then yes, this section should define the transformation.",
              "createdAt": "2022-05-04T21:08:58Z",
              "updatedAt": "2022-05-04T21:27:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845YMi3",
          "commit": {
            "abbreviatedOid": "80758d7"
          },
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-04T21:10:42Z",
          "updatedAt": "2022-05-04T21:10:42Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "As I commented above, the rest of the spec expects octet strings, making it sound like the encoding was done at the application level. If we want to make these input ASCII strings, then we should indeed specify how to transform them in this section.",
              "createdAt": "2022-05-04T21:10:42Z",
              "updatedAt": "2022-05-04T21:10:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845YOxZ",
          "commit": {
            "abbreviatedOid": "80758d7"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-04T21:21:13Z",
          "updatedAt": "2022-05-04T21:21:13Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "Good catch IMO I think DST should stay as an octet string as the underlying data could be any information not just a string value but we should update the CipherSuite_ID parameter to be a string and therfore its encoding would follow the rule defined above.",
              "createdAt": "2022-05-04T21:21:13Z",
              "updatedAt": "2022-05-04T21:21:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845YO5F",
          "commit": {
            "abbreviatedOid": "80758d7"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-04T21:21:51Z",
          "updatedAt": "2022-05-04T21:21:51Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "Right, good catch, I have noted below I think the CipherSuite_ID input value type should be updated to be of type string and therefore would use this rule",
              "createdAt": "2022-05-04T21:21:51Z",
              "updatedAt": "2022-05-04T21:21:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845YwkA",
          "commit": {
            "abbreviatedOid": "80758d7"
          },
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-05T01:24:03Z",
          "updatedAt": "2022-05-05T01:24:03Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "> If so I would update this section as follows.\r\n\r\nIf we had the ASCII encoding rules to the hash section (which I'll do), I don't think having the explicit value is necessary in that section (feels repetitive? and a precedent to doubly-explain hash procedure everywhere else..) ",
              "createdAt": "2022-05-05T01:24:03Z",
              "updatedAt": "2022-05-05T01:24:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845YxtE",
          "commit": {
            "abbreviatedOid": "5235e40"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2022-05-05T01:40:12Z",
          "updatedAt": "2022-05-05T01:40:12Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax845YxwW",
          "commit": {
            "abbreviatedOid": "5235e40"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-05T01:40:57Z",
          "updatedAt": "2022-05-05T01:40:57Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Quick question, are these rendering as a list for you in the HTML? they dont appear to be in the published version right now?",
              "createdAt": "2022-05-05T01:40:57Z",
              "updatedAt": "2022-05-05T01:40:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845YzL3",
          "commit": {
            "abbreviatedOid": "5235e40"
          },
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-05T02:01:49Z",
          "updatedAt": "2022-05-05T02:01:50Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Yes they are ([here](https://identity.foundation/bbs-signature/draft-bbs-signatures.html#name-encoding-of-elements-to-be-))",
              "createdAt": "2022-05-05T02:01:50Z",
              "updatedAt": "2022-05-05T02:01:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845YzhO",
          "commit": {
            "abbreviatedOid": "5235e40"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-05T02:06:38Z",
          "updatedAt": "2022-05-05T02:06:38Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Ah my mistakes was looking at an old version.",
              "createdAt": "2022-05-05T02:06:38Z",
              "updatedAt": "2022-05-05T02:06:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845cJCO",
          "commit": {
            "abbreviatedOid": "5235e40"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LG",
          "createdAt": "2022-05-05T16:50:32Z",
          "updatedAt": "2022-05-05T16:50:32Z",
          "comments": []
        }
      ]
    },
    {
      "number": 124,
      "id": "PR_kwDOF8lax843T1Sj",
      "title": "markdown fixes and documentation generation info",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/124",
      "state": "MERGED",
      "author": "christianpaquin",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "* Added text/html doc generation instructions in README; fixes #34 \r\n* Added empty line in blind spec (fixes mmark error)\r\n* Added empty line before bullet lists to fix HTML rendering\r\n* Added missing periods for inputs/outputs bullet lists, for consistency",
      "createdAt": "2022-05-04T18:52:44Z",
      "updatedAt": "2022-05-05T00:57:56Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "7b24c5f4237268a45035ea94e25149c2ebb8f74c",
      "headRepository": "christianpaquin/bbs-signature",
      "headRefName": "md-fixes-and-doc-gen-info",
      "headRefOid": "8d8a6a40cc647dd0ade1decc1d09ae7c5d15fee8",
      "closedAt": "2022-05-05T00:57:56Z",
      "mergedAt": "2022-05-05T00:57:55Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "6a335d07695b9e58b3a96273f79485273c498fc4"
      },
      "comments": [
        {
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> LGTM, looks like there are a couple of conflicts to resolve though?\r\n\r\nResolved.",
          "createdAt": "2022-05-05T00:55:12Z",
          "updatedAt": "2022-05-05T00:55:12Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Multiple approvals, purely editorial, merging.",
          "createdAt": "2022-05-05T00:57:40Z",
          "updatedAt": "2022-05-05T00:57:51Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax845Xohr",
          "commit": {
            "abbreviatedOid": "33faf59"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM. Thank you @christianpaquin!",
          "createdAt": "2022-05-04T19:59:50Z",
          "updatedAt": "2022-05-04T19:59:50Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax845Xokz",
          "commit": {
            "abbreviatedOid": "33faf59"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "LGTM, looks like there are a couple of conflicts to resolve though?",
          "createdAt": "2022-05-04T19:59:52Z",
          "updatedAt": "2022-05-04T19:59:52Z",
          "comments": []
        }
      ]
    },
    {
      "number": 128,
      "id": "PR_kwDOF8lax843YmXk",
      "title": "Adding revealed messages to challenge hash",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/128",
      "state": "CLOSED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #74 \r\n\r\nAdding the revealed messages as well as the signature domain value to the challenge hash in ProofGen and ProofVerify.",
      "createdAt": "2022-05-05T23:08:43Z",
      "updatedAt": "2022-06-26T17:44:50Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "2abab63c75fb113468dfb33a5fd2395d99852c0e",
      "headRepository": "BasileiosKal/bbs-signature",
      "headRefName": "revealed_messages",
      "headRefOid": "ab604a0cfb8439d3a76713880ec1cf2d9e6c4d26",
      "closedAt": "2022-06-26T17:44:49Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Couple of updates, \r\n1. Per @tplooker suggestion the R value (number of revealed messages) is added to the challenge hash.\r\n2. Removed the PK from the challenge hash since it is already part of the domain value.",
          "createdAt": "2022-05-05T23:23:26Z",
          "updatedAt": "2022-05-05T23:23:26Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Will be addressed after merging of #138 ",
          "createdAt": "2022-05-23T18:30:18Z",
          "updatedAt": "2022-05-23T18:30:18Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Replaced by #188. Closing.",
          "createdAt": "2022-06-26T17:44:49Z",
          "updatedAt": "2022-06-26T17:44:49Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax845djay",
          "commit": {
            "abbreviatedOid": "09e1557"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2022-05-05T23:09:55Z",
          "updatedAt": "2022-05-05T23:09:55Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax845djrk",
          "commit": {
            "abbreviatedOid": "09e1557"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-05T23:12:07Z",
          "updatedAt": "2022-05-05T23:12:08Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "One minor question do we want to include `R` alongside the actual revealed messages like we include L alongside the generators in the domain?",
              "createdAt": "2022-05-05T23:12:07Z",
              "updatedAt": "2022-05-05T23:12:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845dlCk",
          "commit": {
            "abbreviatedOid": "09e1557"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-05T23:23:42Z",
          "updatedAt": "2022-05-05T23:23:42Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "Done. Thanks!",
              "createdAt": "2022-05-05T23:23:42Z",
              "updatedAt": "2022-05-05T23:23:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845jCFK",
          "commit": {
            "abbreviatedOid": "5cf69fe"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-08T22:09:11Z",
          "updatedAt": "2022-05-08T22:09:11Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "On further thought with ProofGen, where is (msg_i1, .., msg_iR) defined?",
              "createdAt": "2022-05-08T22:09:11Z",
              "updatedAt": "2022-05-08T22:09:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845jCnq",
          "commit": {
            "abbreviatedOid": "5cf69fe"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-08T22:37:34Z",
          "updatedAt": "2022-05-08T22:37:34Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "We need to add a step to this procedure that computes msg_i1 ... msg_iR from msg and RevealedIndexes",
              "createdAt": "2022-05-08T22:37:34Z",
              "updatedAt": "2022-05-08T22:37:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845jEBw",
          "commit": {
            "abbreviatedOid": "69808f2"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-08T23:37:29Z",
          "updatedAt": "2022-05-08T23:37:29Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "```suggestion\r\n                   This vector MUST be ordered from the lowest to the highest value.\r\n```",
              "createdAt": "2022-05-08T23:37:29Z",
              "updatedAt": "2022-05-08T23:37:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845jECG",
          "commit": {
            "abbreviatedOid": "69808f2"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-08T23:37:40Z",
          "updatedAt": "2022-05-08T23:37:41Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "```suggestion\r\n                   This vector MUST be ordered from the lowest to the highest value.\r\n```",
              "createdAt": "2022-05-08T23:37:40Z",
              "updatedAt": "2022-05-08T23:37:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845nf2N",
          "commit": {
            "abbreviatedOid": "ab604a0"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "Have updated with a comment about a way to make the procedure clearer",
          "createdAt": "2022-05-09T18:20:03Z",
          "updatedAt": "2022-05-09T18:20:03Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax845xO1p",
          "commit": {
            "abbreviatedOid": "ab604a0"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-11T11:57:53Z",
          "updatedAt": "2022-05-11T11:57:53Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "We should add the messages too and not just the indices. We need them both. If that\u2019s already the case it\u2019s not clear to me how that is so given revealed_msgs appears to just include indices",
              "createdAt": "2022-05-11T11:57:53Z",
              "updatedAt": "2022-05-11T11:57:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845xiys",
          "commit": {
            "abbreviatedOid": "ab604a0"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-11T12:46:09Z",
          "updatedAt": "2022-05-11T12:46:09Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "Thank you! Currently the PR only includes the revealed messages (note that `revealed_msgs =  (msg_i1 || msg_i2 || ... || msg_iR)` where `msg_i1, ..., msg_iR` the revealed messages in the current notation). Including the revealed indices also makes sense to me but there are proposals to remove the indices notion altogether (see for example issue #117 for some context). For that reason, I made the PR a draft for now, until a proper notation is decided.",
              "createdAt": "2022-05-11T12:46:09Z",
              "updatedAt": "2022-05-11T12:46:09Z"
            }
          ]
        }
      ]
    },
    {
      "number": 129,
      "id": "PR_kwDOF8lax843Z09j",
      "title": "Editorial pass",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/129",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "- Adds a paragraph to handle when optional elements pash to a HASH or XOF function\r\n- Clarifies which inputs/parameters are required vs optional\r\n- Fixes some un-escaped underscores\r\n- Tweaks some language for each operation description\r\n- Reorders parameters in all the operations so required ones are first",
      "createdAt": "2022-05-06T09:35:59Z",
      "updatedAt": "2022-05-09T21:54:30Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "89a259b1c2a5eba2218d8418931080d024a68830",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/editorial-pass-1",
      "headRefOid": "d649c4f937e49314c90d86cd7869639d1bc15347",
      "closedAt": "2022-05-09T21:54:24Z",
      "mergedAt": "2022-05-09T21:54:24Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "ced07fdf5e3afe2cefef2b42732286690e54b738"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Multiple approvals, discussed on last WG call, merging.",
          "createdAt": "2022-05-09T21:54:28Z",
          "updatedAt": "2022-05-09T21:54:28Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax845ffXu",
          "commit": {
            "abbreviatedOid": "5707399"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "I really like the direction of this PR. Just some minor comments.",
          "createdAt": "2022-05-06T12:05:21Z",
          "updatedAt": "2022-05-06T12:21:59Z",
          "comments": [
            {
              "originalPosition": 107,
              "body": "Not really a big fun of defining the messages as \"Application specific\". It's definitely correct, however, it may raise the question of \"what other messages are there??\"",
              "createdAt": "2022-05-06T12:05:21Z",
              "updatedAt": "2022-05-06T12:21:59Z"
            },
            {
              "originalPosition": 126,
              "body": "Although i like the simpler API with not having to supply the PK this may add unnecessary computations?? The PK will most likely be cached. It doesn't really guard against un trusted issuers either (they can just skip this step).",
              "createdAt": "2022-05-06T12:08:51Z",
              "updatedAt": "2022-05-06T12:21:59Z"
            },
            {
              "originalPosition": 245,
              "body": "```suggestion\r\nThis operation checks that a proof is valid for a header, vector of revealed messages (along side their index corresponding to their original position when signed) and presentation header against a public key (PK).\r\n```\r\nJust a minor suggestion though the original is also completely fine. So really not necessary to use the alternative.",
              "createdAt": "2022-05-06T12:14:27Z",
              "updatedAt": "2022-05-06T12:21:59Z"
            },
            {
              "originalPosition": 13,
              "body": "```suggestion\r\nOptional input/parameters to operations that feature in a call to a HASH or XOF function, that are not supplied to the operation should default to an empty octet string. For example, if X is an optional input/parameter that is not supplied, whilst A and B are required, then the procedural step of `HASH(A || X || B)` MUST be evaluated to `HASH(A || \"\" || B)`.\r\n```\r\nSince, in some places where we hash optional values we specify that if not supplied they default to the empty string, the above suggestion might be a little more accurate??",
              "createdAt": "2022-05-06T12:19:52Z",
              "updatedAt": "2022-05-07T21:53:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845hfEq",
          "commit": {
            "abbreviatedOid": "5707399"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-06T18:50:50Z",
          "updatedAt": "2022-05-06T18:50:55Z",
          "comments": [
            {
              "originalPosition": 330,
              "body": "```suggestion\r\n- (scalar_1, ..., scalar_n), a list of scalars. A list of non-zero scalars mod q.\r\n```",
              "createdAt": "2022-05-06T18:50:50Z",
              "updatedAt": "2022-05-06T18:50:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845iIt1",
          "commit": {
            "abbreviatedOid": "5707399"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-06T23:18:54Z",
          "updatedAt": "2022-05-06T23:18:54Z",
          "comments": [
            {
              "originalPosition": 126,
              "body": "Im happy to keep supplying the public key to the operation API, provided we add a consideration that implementations SHOULD validate the relationship between SK and PK, does that work as a compromise?",
              "createdAt": "2022-05-06T23:18:54Z",
              "updatedAt": "2022-05-06T23:18:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845iJhd",
          "commit": {
            "abbreviatedOid": "d1e974d"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-06T23:31:04Z",
          "updatedAt": "2022-05-06T23:31:05Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "What about empty octet string to be more specific?",
              "createdAt": "2022-05-06T23:31:04Z",
              "updatedAt": "2022-05-06T23:31:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845iZMS",
          "commit": {
            "abbreviatedOid": "5707399"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-07T10:13:35Z",
          "updatedAt": "2022-05-07T10:13:35Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Yeap. That sounds better.",
              "createdAt": "2022-05-07T10:13:35Z",
              "updatedAt": "2022-05-07T10:13:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845iZb6",
          "commit": {
            "abbreviatedOid": "5707399"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-07T10:27:26Z",
          "updatedAt": "2022-05-07T10:27:26Z",
          "comments": [
            {
              "originalPosition": 126,
              "body": "If we are worried about issuers making mistakes then yes a consideration sounds as a better option. Maybe another option could also be to make the relationship clear in the definition of the inputs in Sign? Something like;\r\n\r\n```\r\n- SK (REQUIRED), an octet string of the form outputted by the KeyGen operation.\r\n- PK (REQUIRED), an octet string encoded public key output from SkToPk on input the above SK.\r\n```",
              "createdAt": "2022-05-07T10:27:26Z",
              "updatedAt": "2022-05-07T10:27:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845ilQK",
          "commit": {
            "abbreviatedOid": "5707399"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-07T22:06:38Z",
          "updatedAt": "2022-05-07T22:06:39Z",
          "comments": [
            {
              "originalPosition": 107,
              "body": "Have removed for now, we can further refine this language later.",
              "createdAt": "2022-05-07T22:06:39Z",
              "updatedAt": "2022-05-07T22:06:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845kA1J",
          "commit": {
            "abbreviatedOid": "20dbbba"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Minor nit",
          "createdAt": "2022-05-09T08:00:17Z",
          "updatedAt": "2022-05-09T08:23:06Z",
          "comments": [
            {
              "originalPosition": 114,
              "body": "```suggestion\r\n**Note** This operation is the RECOMMENDED way of generating a secret key, but its use is not required for compatibility, and implementations MAY use a different KeyGen procedure. For security, such an alternative MUST output a secret key that is statistically close to uniformly random in the range 0 < SK < r.\r\n```\r\nWe use the 0 < SK < r noation above i think.",
              "createdAt": "2022-05-09T08:00:17Z",
              "updatedAt": "2022-05-09T08:23:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845mo3P",
          "commit": {
            "abbreviatedOid": "82ce1cb"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-09T16:10:11Z",
          "updatedAt": "2022-05-09T16:10:12Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "The correct method is actually \r\n```\r\nq * P == 1\r\n```\r\nnot p * P",
              "createdAt": "2022-05-09T16:10:12Z",
              "updatedAt": "2022-05-09T16:10:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845mpoN",
          "commit": {
            "abbreviatedOid": "82ce1cb"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Just a small correction but otherwise LGTM",
          "createdAt": "2022-05-09T16:11:59Z",
          "updatedAt": "2022-05-09T16:11:59Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax845nh5g",
          "commit": {
            "abbreviatedOid": "82ce1cb"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-09T18:27:46Z",
          "updatedAt": "2022-05-09T18:27:47Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "```suggestion\r\n: returns VALID when the point P is an element of the subgroup of order p, and INVALID otherwise. This function can always be implemented by checking that q \\* P is equal to the identity element.  In some cases, faster checks may also exist, e.g., [@Bowe19].\r\n```",
              "createdAt": "2022-05-09T18:27:46Z",
              "updatedAt": "2022-05-09T18:27:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845niNL",
          "commit": {
            "abbreviatedOid": "2b38d07"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-09T18:28:59Z",
          "updatedAt": "2022-05-09T18:29:00Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "```suggestion\r\n: returns VALID when the point P is an element of the subgroup of order q, and INVALID otherwise. This function can always be implemented by checking that q \\* P is equal to the identity element.  In some cases, faster checks may also exist, e.g., [@Bowe19].\r\n```",
              "createdAt": "2022-05-09T18:28:59Z",
              "updatedAt": "2022-05-09T18:29:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845oTB8",
          "commit": {
            "abbreviatedOid": "b2c58f2"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-09T21:44:49Z",
          "updatedAt": "2022-05-09T21:44:49Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax845oToW",
          "commit": {
            "abbreviatedOid": "b2c58f2"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-09T21:48:12Z",
          "updatedAt": "2022-05-09T21:48:12Z",
          "comments": []
        }
      ]
    },
    {
      "number": 130,
      "id": "PR_kwDOF8lax843bTqJ",
      "title": "Added escape char before some underscores to fix MD rendering <eom>",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/130",
      "state": "MERGED",
      "author": "christianpaquin",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-05-06T16:51:55Z",
      "updatedAt": "2022-05-07T04:33:57Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "2abab63c75fb113468dfb33a5fd2395d99852c0e",
      "headRepository": "christianpaquin/bbs-signature",
      "headRefName": "fix-md-escaping",
      "headRefOid": "e7d8f35fc82a2a5ebed1308c722c418db84800d6",
      "closedAt": "2022-05-07T04:33:57Z",
      "mergedAt": "2022-05-07T04:33:57Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "e6fdff409942c7924fb69bd0f69b5c7fb5e66442"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Minor editorial changes, multiple approvals, merging",
          "createdAt": "2022-05-07T04:33:53Z",
          "updatedAt": "2022-05-07T04:33:53Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax845iIpV",
          "commit": {
            "abbreviatedOid": "17a00db"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-06T23:17:50Z",
          "updatedAt": "2022-05-06T23:17:51Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I dont think these need to be escaped do they? just the ones outside of a code block?",
              "createdAt": "2022-05-06T23:17:50Z",
              "updatedAt": "2022-05-06T23:17:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845iOoP",
          "commit": {
            "abbreviatedOid": "17a00db"
          },
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-07T01:39:15Z",
          "updatedAt": "2022-05-07T01:39:15Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Good catch. Fixed (here and in CreateGenerators)",
              "createdAt": "2022-05-07T01:39:15Z",
              "updatedAt": "2022-05-07T01:39:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845iRe0",
          "commit": {
            "abbreviatedOid": "e7d8f35"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2022-05-07T03:46:42Z",
          "updatedAt": "2022-05-07T03:46:42Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax845iR02",
          "commit": {
            "abbreviatedOid": "e7d8f35"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-07T04:06:01Z",
          "updatedAt": "2022-05-07T04:06:01Z",
          "comments": []
        }
      ]
    },
    {
      "number": 132,
      "id": "PR_kwDOF8lax843dKsr",
      "title": "Update hash and xof function to lower case for consistency with other declared functions",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/132",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Currently for most functions declared by this spec we are following a syntax of lower case / snake_case name based convention, this PR proposes to change HASH -> hash and XOF -> xof, related discussion in #114 ",
      "createdAt": "2022-05-08T02:49:32Z",
      "updatedAt": "2022-05-09T21:48:21Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "697d7b46568a6e27ae6793bb3d99b48462c97729",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/update-hash-fn-syntax",
      "headRefOid": "75c9b9aee4b109a41941a45f1aff4e59789aeb20",
      "closedAt": "2022-05-09T21:48:19Z",
      "mergedAt": "2022-05-09T21:48:18Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "89a259b1c2a5eba2218d8418931080d024a68830"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax845mqOr",
          "commit": {
            "abbreviatedOid": "7cd06df"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-09T16:13:16Z",
          "updatedAt": "2022-05-09T16:13:16Z",
          "comments": [
            {
              "originalPosition": 113,
              "body": "needs `mod q` otherwise `c` is not correct.",
              "createdAt": "2022-05-09T16:13:16Z",
              "updatedAt": "2022-05-09T16:13:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845mqWC",
          "commit": {
            "abbreviatedOid": "7cd06df"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-09T16:13:31Z",
          "updatedAt": "2022-05-09T16:13:32Z",
          "comments": [
            {
              "originalPosition": 113,
              "body": "This actually should be hash_to_scalar",
              "createdAt": "2022-05-09T16:13:31Z",
              "updatedAt": "2022-05-09T16:13:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845mqdP",
          "commit": {
            "abbreviatedOid": "7cd06df"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-09T16:13:45Z",
          "updatedAt": "2022-05-09T16:13:45Z",
          "comments": [
            {
              "originalPosition": 131,
              "body": "hash_to_scalar",
              "createdAt": "2022-05-09T16:13:45Z",
              "updatedAt": "2022-05-09T16:13:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845mq9z",
          "commit": {
            "abbreviatedOid": "7cd06df"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-09T16:14:54Z",
          "updatedAt": "2022-05-09T16:14:54Z",
          "comments": [
            {
              "originalPosition": 176,
              "body": "not sure what's the difference here between `hash_to_scalar` and `hash_to_field`?",
              "createdAt": "2022-05-09T16:14:54Z",
              "updatedAt": "2022-05-09T16:14:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845nRQe",
          "commit": {
            "abbreviatedOid": "7cd06df"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-09T17:38:01Z",
          "updatedAt": "2022-05-09T17:38:01Z",
          "comments": [
            {
              "originalPosition": 176,
              "body": "If I\u2019m not mistaken hash_to_field does not check if the field element is 0. Also hash_to_scalar does not worry about DST's etc that are not needed for the intended use cases.",
              "createdAt": "2022-05-09T17:38:01Z",
              "updatedAt": "2022-05-09T17:45:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845nUSv",
          "commit": {
            "abbreviatedOid": "7cd06df"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-09T17:44:34Z",
          "updatedAt": "2022-05-09T17:44:34Z",
          "comments": [
            {
              "originalPosition": 113,
              "body": "I am working on a PR to make this update everywhere it needs to happen (although we can also make the update here if we want to)",
              "createdAt": "2022-05-09T17:44:34Z",
              "updatedAt": "2022-05-09T18:03:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845njyx",
          "commit": {
            "abbreviatedOid": "7cd06df"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-09T18:34:34Z",
          "updatedAt": "2022-05-09T18:34:34Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax845oS1-",
          "commit": {
            "abbreviatedOid": "7cd06df"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-09T21:43:47Z",
          "updatedAt": "2022-05-09T21:43:47Z",
          "comments": [
            {
              "originalPosition": 113,
              "body": "yes deferring to @BasileiosKal PR that will address this seperately.",
              "createdAt": "2022-05-09T21:43:47Z",
              "updatedAt": "2022-05-09T21:43:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845oTKd",
          "commit": {
            "abbreviatedOid": "7cd06df"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-09T21:45:32Z",
          "updatedAt": "2022-05-09T21:45:32Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax845oTbz",
          "commit": {
            "abbreviatedOid": "7cd06df"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-09T21:47:02Z",
          "updatedAt": "2022-05-09T21:47:02Z",
          "comments": [
            {
              "originalPosition": 131,
              "body": "Will be addressed by @BasileiosKal's PR",
              "createdAt": "2022-05-09T21:47:02Z",
              "updatedAt": "2022-05-09T21:47:02Z"
            }
          ]
        }
      ]
    },
    {
      "number": 133,
      "id": "PR_kwDOF8lax843d5Ox",
      "title": "Signature encoding/decoding rules",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/133",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "~~A draft PR to document the encoding decoding rules for a signature, very early stage, keen for feedback~~\r\n\r\nAdds an encoding and decoding function for signatures, fixes #127 ",
      "createdAt": "2022-05-09T00:03:09Z",
      "updatedAt": "2022-05-13T21:53:36Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "5fba426d415b85b6156a0c001e605482bdf3b770",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/signature-encoding",
      "headRefOid": "c5fc59d71f512868ed9505001b4aaee2e71bec23",
      "closedAt": "2022-05-12T23:13:10Z",
      "mergedAt": "2022-05-12T23:13:10Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "c3c65347050125751165dd627e7d52f029d143f5"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Multiple reviews, discussed on last WG call, multiple approvals, merging.",
          "createdAt": "2022-05-12T23:13:05Z",
          "updatedAt": "2022-05-12T23:13:05Z"
        },
        {
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ha, glad this was merged! I had an older HTML spec version opened in my browser, and was about to ask how to serialize the signature :)",
          "createdAt": "2022-05-13T21:53:35Z",
          "updatedAt": "2022-05-13T21:53:35Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax845kIo9",
          "commit": {
            "abbreviatedOid": "2a925de"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-09T08:27:26Z",
          "updatedAt": "2022-05-09T08:41:10Z",
          "comments": [
            {
              "originalPosition": 211,
              "body": "I would suggest that yes. Sinse this will be a helper function it does not need to be able to handle generic inputs. The signature values will be well formed when creating the signature in Sign.",
              "createdAt": "2022-05-09T08:27:26Z",
              "updatedAt": "2022-05-09T08:41:10Z"
            },
            {
              "originalPosition": 219,
              "body": "Maybe use concatenation instead of spred??",
              "createdAt": "2022-05-09T08:30:06Z",
              "updatedAt": "2022-05-09T08:41:10Z"
            },
            {
              "originalPosition": 188,
              "body": "Maybe add a line here like???\r\n```\r\nIsVaidPoint(A) or IsValidScalar(e) or IsValidScalar(s) are INVALID, return INVALID\r\n```\r\nWhere IsValidScalar(x) checks if the scalar x is 0 < x < q?? Another option could be to validate the signature after de-serializing??",
              "createdAt": "2022-05-09T08:38:31Z",
              "updatedAt": "2022-05-09T08:41:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845msJm",
          "commit": {
            "abbreviatedOid": "2a925de"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-09T16:17:38Z",
          "updatedAt": "2022-05-09T16:17:38Z",
          "comments": [
            {
              "originalPosition": 188,
              "body": "If we assume implementations always represent valid signatures after deserialization then this could work by only checking it there. However, we should keep it anyway to prevent side-channel attacks where the signature is modified after deserialization in memory and the check is missing.",
              "createdAt": "2022-05-09T16:17:38Z",
              "updatedAt": "2022-05-09T16:17:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845msVk",
          "commit": {
            "abbreviatedOid": "2a925de"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-09T16:18:05Z",
          "updatedAt": "2022-05-09T16:18:05Z",
          "comments": [
            {
              "originalPosition": 211,
              "body": "Yes agree",
              "createdAt": "2022-05-09T16:18:05Z",
              "updatedAt": "2022-05-09T16:18:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845nlRS",
          "commit": {
            "abbreviatedOid": "2a925de"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-09T18:39:54Z",
          "updatedAt": "2022-05-09T18:39:55Z",
          "comments": [
            {
              "originalPosition": 173,
              "body": "This is incorrect, the compressed size of the scalar needs to be captured and denoted correctly.",
              "createdAt": "2022-05-09T18:39:54Z",
              "updatedAt": "2022-05-09T18:39:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845nmHM",
          "commit": {
            "abbreviatedOid": "2a925de"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-09T18:42:58Z",
          "updatedAt": "2022-05-09T18:42:59Z",
          "comments": [
            {
              "originalPosition": 179,
              "body": "Subgroup check, also check whether this covers the infinity check.",
              "createdAt": "2022-05-09T18:42:59Z",
              "updatedAt": "2022-05-09T18:42:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845nmSq",
          "commit": {
            "abbreviatedOid": "2a925de"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-09T18:43:41Z",
          "updatedAt": "2022-05-09T18:43:41Z",
          "comments": [
            {
              "originalPosition": 183,
              "body": "Check e is non zero",
              "createdAt": "2022-05-09T18:43:41Z",
              "updatedAt": "2022-05-09T18:43:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845nmU6",
          "commit": {
            "abbreviatedOid": "2a925de"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-09T18:43:50Z",
          "updatedAt": "2022-05-09T18:43:51Z",
          "comments": [
            {
              "originalPosition": 187,
              "body": "Check s is non zero",
              "createdAt": "2022-05-09T18:43:50Z",
              "updatedAt": "2022-05-09T18:43:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845nm8K",
          "commit": {
            "abbreviatedOid": "2a925de"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-09T18:46:20Z",
          "updatedAt": "2022-05-09T18:46:21Z",
          "comments": [
            {
              "originalPosition": 199,
              "body": "If we assume A e and s are well formed then we are implicitly assuming well formed inputs vs untrusted inputs on the OctetsToSignature operation",
              "createdAt": "2022-05-09T18:46:21Z",
              "updatedAt": "2022-05-09T18:46:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845noVi",
          "commit": {
            "abbreviatedOid": "2a925de"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-09T18:51:22Z",
          "updatedAt": "2022-05-09T18:51:23Z",
          "comments": [
            {
              "originalPosition": 199,
              "body": "Add a note that documents this is the case because only invocation of this operation is via the Sign method which already checks A e and s.",
              "createdAt": "2022-05-09T18:51:22Z",
              "updatedAt": "2022-05-09T18:51:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845uRha",
          "commit": {
            "abbreviatedOid": "6481ca1"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-10T21:29:51Z",
          "updatedAt": "2022-05-10T22:41:23Z",
          "comments": [
            {
              "originalPosition": 168,
              "body": "```suggestion\r\n- octet_point_length, the length in bytes of the octet string output by the point_to_octets function\r\n- scalar_length, the length in bytes of the scalar encoded octet string output by the IP2OSP function\r\n```\r\nI think the scalar length may also need to be defined in the parameter (not necessarily with the above syntax)",
              "createdAt": "2022-05-10T21:29:51Z",
              "updatedAt": "2022-05-10T22:41:23Z"
            },
            {
              "originalPosition": 216,
              "body": "```suggestion\r\n- octet\\_scalar\\_length: Number of bytes required to represent a scalar value as an octet string. It is RECOMMENDED this value be set to `ceil(log2(q)/8)`.\r\n- octet\\_point\\_length, the length in bytes of the octet string output by the point_to_octets function. It is RECOMMENDED that this value is set to `ceil(log(p)/8)`.\r\n```\r\nTwo things:\r\n1. It seems that the operation also uses the octet_point_length constant. For consistency we may want to also define that constant in the ciphersuite\r\n2. If we do define octet_point_length in the suites then the naming must be consistent so i suggest scalar_length -> octet_scalar_length (or octet_point_length -> point_length)",
              "createdAt": "2022-05-10T21:35:48Z",
              "updatedAt": "2022-05-10T22:41:23Z"
            },
            {
              "originalPosition": 188,
              "body": "```suggestion\r\n1. A_octets = point_to_octets(A)\r\n```\r\nMaybe use capital A to be more clear what that is??",
              "createdAt": "2022-05-10T21:40:38Z",
              "updatedAt": "2022-05-10T22:41:23Z"
            },
            {
              "originalPosition": 18,
              "body": "```suggestion\r\n12. signature_octets = signature_to_octets(A, e, s)\r\n```\r\nJust to through an idea. Maybe use signature_octets?? That way in Verify we will have `signature = octets_to_signature(signature_octets)` which i thing is better?? This means that we will need to pass signature_octets as an input to Verify though. So both have tradeoffs.",
              "createdAt": "2022-05-10T22:23:16Z",
              "updatedAt": "2022-05-10T22:41:23Z"
            },
            {
              "originalPosition": 178,
              "body": "```suggestion\r\n- e (REQUIRED), a non-negative, non-zero, and less than q integer representing a valid scalar value (0 < e < q).\r\n```",
              "createdAt": "2022-05-10T22:32:28Z",
              "updatedAt": "2022-05-10T22:41:23Z"
            },
            {
              "originalPosition": 179,
              "body": "```suggestion\r\n- s (REQUIRED), a non-negative, non-zero, and less than q integer representing a valid scalar value (0 < s < q).\r\n```",
              "createdAt": "2022-05-10T22:32:48Z",
              "updatedAt": "2022-05-10T22:41:23Z"
            },
            {
              "originalPosition": 177,
              "body": "```suggestion\r\n- A (REQUIRED), a valid point in the G1 subgroup, different than the point at infinity. // TODO need to qualify this more?\r\n```\r\nI think that the above suggestion covers everything we need to specify for A.",
              "createdAt": "2022-05-10T22:36:55Z",
              "updatedAt": "2022-05-10T22:41:23Z"
            },
            {
              "originalPosition": 134,
              "body": "```suggestion\r\n- signature_octets (REQUIRED), octet string, output from signature_to_octets on input a valid BBS+ signature (one created by the Sign operation)\r\n```\r\nMaybe make it more explicit here??",
              "createdAt": "2022-05-10T22:39:25Z",
              "updatedAt": "2022-05-10T22:41:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845urDO",
          "commit": {
            "abbreviatedOid": "3ba94fd"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-11T00:11:42Z",
          "updatedAt": "2022-05-11T00:11:43Z",
          "comments": [
            {
              "originalPosition": 168,
              "body": "Do we need to redefine it when its available at the cipher suite definition level? I think we need to figure out the scoping otherwise there would be loads of parameters in every definition?",
              "createdAt": "2022-05-11T00:11:42Z",
              "updatedAt": "2022-05-11T00:11:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845uube",
          "commit": {
            "abbreviatedOid": "16378a8"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-11T00:43:24Z",
          "updatedAt": "2022-05-11T00:43:24Z",
          "comments": [
            {
              "originalPosition": 134,
              "body": "```suggestion\r\n- signature_octets (REQUIRED), octet string of the form output from signature_to_octets operation\r\n```",
              "createdAt": "2022-05-11T00:43:24Z",
              "updatedAt": "2022-05-11T00:43:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845u5oj",
          "commit": {
            "abbreviatedOid": "e549a9f"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-11T02:20:56Z",
          "updatedAt": "2022-05-11T02:20:57Z",
          "comments": [
            {
              "originalPosition": 188,
              "body": "I've inlined the check for now, however happy to add a seperate operation to encapsulate this instead.",
              "createdAt": "2022-05-11T02:20:57Z",
              "updatedAt": "2022-05-11T02:20:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845u5tA",
          "commit": {
            "abbreviatedOid": "e549a9f"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-11T02:21:36Z",
          "updatedAt": "2022-05-11T02:21:36Z",
          "comments": [
            {
              "originalPosition": 150,
              "body": "Whats the best syntax for checking whether A is infinity or not?",
              "createdAt": "2022-05-11T02:21:36Z",
              "updatedAt": "2022-05-11T02:21:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845u5yD",
          "commit": {
            "abbreviatedOid": "e549a9f"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-11T02:22:23Z",
          "updatedAt": "2022-05-11T02:22:23Z",
          "comments": [
            {
              "originalPosition": 226,
              "body": "Isn't this actually specific to the sub-group?",
              "createdAt": "2022-05-11T02:22:23Z",
              "updatedAt": "2022-05-11T02:22:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845u502",
          "commit": {
            "abbreviatedOid": "e549a9f"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-11T02:22:43Z",
          "updatedAt": "2022-05-11T02:22:43Z",
          "comments": [
            {
              "originalPosition": 226,
              "body": "if so we should just update the definition",
              "createdAt": "2022-05-11T02:22:43Z",
              "updatedAt": "2022-05-11T02:22:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845xMac",
          "commit": {
            "abbreviatedOid": "e549a9f"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-11T11:52:12Z",
          "updatedAt": "2022-05-11T11:52:12Z",
          "comments": [
            {
              "originalPosition": 150,
              "body": "We usually denote it as `A != 1_G1`",
              "createdAt": "2022-05-11T11:52:12Z",
              "updatedAt": "2022-05-11T11:52:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845xNW5",
          "commit": {
            "abbreviatedOid": "e549a9f"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-11T11:54:28Z",
          "updatedAt": "2022-05-11T11:54:29Z",
          "comments": [
            {
              "originalPosition": 226,
              "body": "It\u2019s not that it\u2019s recommended it\u2019s the actual field size. This is curve dependent so we should specify as a system parameter with the curve",
              "createdAt": "2022-05-11T11:54:29Z",
              "updatedAt": "2022-05-11T11:54:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845xNvX",
          "commit": {
            "abbreviatedOid": "e549a9f"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-11T11:55:26Z",
          "updatedAt": "2022-05-11T11:55:27Z",
          "comments": [
            {
              "originalPosition": 97,
              "body": "I think we\u2019re fixing what goes into the hash in another PR right? If not I\u2019ll create one that does",
              "createdAt": "2022-05-11T11:55:27Z",
              "updatedAt": "2022-05-11T11:55:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845xklW",
          "commit": {
            "abbreviatedOid": "3ba94fd"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-11T12:50:54Z",
          "updatedAt": "2022-05-11T12:50:54Z",
          "comments": [
            {
              "originalPosition": 168,
              "body": "We could include anything used in an operation and defined in a ciphersuite as a parameter (this is the route that the h2c spec has taken). However, if we don\u2019t want to define a lot of parameters, I would suggest to either remove both (i.e., the  octet_point_length and the scalar_length) or add them both for now (until we decide on what should be a parameter).",
              "createdAt": "2022-05-11T12:50:54Z",
              "updatedAt": "2022-05-11T12:50:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845xn9o",
          "commit": {
            "abbreviatedOid": "e549a9f"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-11T12:58:58Z",
          "updatedAt": "2022-05-11T12:58:58Z",
          "comments": [
            {
              "originalPosition": 226,
              "body": "We may want to leave it as a recommendation for applications that may want to apply some custom optimization?? Although i do agree that most cases will use that method. It is also true that the number itself is only base field depended so IMO the definition is fine as it is.",
              "createdAt": "2022-05-11T12:58:58Z",
              "updatedAt": "2022-05-11T12:58:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8450PgW",
          "commit": {
            "abbreviatedOid": "e549a9f"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-11T21:00:13Z",
          "updatedAt": "2022-05-11T21:00:13Z",
          "comments": [
            {
              "originalPosition": 150,
              "body": "So define `1_G1` as the point at infinity for the G1 subgroup?",
              "createdAt": "2022-05-11T21:00:13Z",
              "updatedAt": "2022-05-11T21:00:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8450Pr9",
          "commit": {
            "abbreviatedOid": "e549a9f"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-11T21:00:56Z",
          "updatedAt": "2022-05-11T21:00:56Z",
          "comments": [
            {
              "originalPosition": 97,
              "body": "Yeap we are",
              "createdAt": "2022-05-11T21:00:56Z",
              "updatedAt": "2022-05-11T21:00:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8450nNI",
          "commit": {
            "abbreviatedOid": "5a81e18"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-11T23:17:48Z",
          "updatedAt": "2022-05-11T23:17:48Z",
          "comments": [
            {
              "originalPosition": 150,
              "body": "Using `Identity_G1` instead here as it already exists",
              "createdAt": "2022-05-11T23:17:48Z",
              "updatedAt": "2022-05-11T23:17:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845065y",
          "commit": {
            "abbreviatedOid": "e549a9f"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-12T02:07:55Z",
          "updatedAt": "2022-05-12T02:07:55Z",
          "comments": [
            {
              "originalPosition": 150,
              "body": "\ud83d\udc4d\ud83c\udffb ",
              "createdAt": "2022-05-12T02:07:55Z",
              "updatedAt": "2022-05-12T02:07:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8455Ec9",
          "commit": {
            "abbreviatedOid": "1595e50"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM ",
          "createdAt": "2022-05-12T18:02:43Z",
          "updatedAt": "2022-05-12T18:02:43Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax8455G21",
          "commit": {
            "abbreviatedOid": "1595e50"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-12T18:11:15Z",
          "updatedAt": "2022-05-12T18:11:16Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Should probably clarify if the range is inclusive or exclusive",
              "createdAt": "2022-05-12T18:11:15Z",
              "updatedAt": "2022-05-12T18:11:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8455HN-",
          "commit": {
            "abbreviatedOid": "1595e50"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-12T18:12:39Z",
          "updatedAt": "2022-05-12T18:12:40Z",
          "comments": [
            {
              "originalPosition": 224,
              "body": "log or log2?",
              "createdAt": "2022-05-12T18:12:39Z",
              "updatedAt": "2022-05-12T18:12:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8455Heu",
          "commit": {
            "abbreviatedOid": "1595e50"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-12T18:13:41Z",
          "updatedAt": "2022-05-12T18:13:41Z",
          "comments": [
            {
              "originalPosition": 270,
              "body": "`ceil(log2(p)/8)` I think",
              "createdAt": "2022-05-12T18:13:41Z",
              "updatedAt": "2022-05-12T18:13:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8456CmI",
          "commit": {
            "abbreviatedOid": "1595e50"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-12T22:22:38Z",
          "updatedAt": "2022-05-12T22:22:38Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "@andrewwhitehead good point, please check the updated text",
              "createdAt": "2022-05-12T22:22:38Z",
              "updatedAt": "2022-05-12T22:22:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8456Duz",
          "commit": {
            "abbreviatedOid": "cf3b342"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-12T22:30:28Z",
          "updatedAt": "2022-05-12T22:30:29Z",
          "comments": [
            {
              "originalPosition": 156,
              "body": "Oops, bracket mismatch",
              "createdAt": "2022-05-12T22:30:28Z",
              "updatedAt": "2022-05-12T22:30:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8456D4K",
          "commit": {
            "abbreviatedOid": "cf3b342"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-12T22:31:32Z",
          "updatedAt": "2022-05-12T22:31:32Z",
          "comments": [
            {
              "originalPosition": 158,
              "body": "I believe OS2IP always returns a non-negative integer?",
              "createdAt": "2022-05-12T22:31:32Z",
              "updatedAt": "2022-05-12T22:31:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8456EAo",
          "commit": {
            "abbreviatedOid": "cf3b342"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-12T22:32:26Z",
          "updatedAt": "2022-05-12T22:32:26Z",
          "comments": [
            {
              "originalPosition": 139,
              "body": "Seems a bit redundant?",
              "createdAt": "2022-05-12T22:32:26Z",
              "updatedAt": "2022-05-12T22:32:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8456Ecr",
          "commit": {
            "abbreviatedOid": "cf3b342"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-12T22:35:45Z",
          "updatedAt": "2022-05-12T22:35:45Z",
          "comments": [
            {
              "originalPosition": 158,
              "body": "Yea that's correct. Maybe it should be e != 0 then?",
              "createdAt": "2022-05-12T22:35:45Z",
              "updatedAt": "2022-05-12T22:35:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8456EjD",
          "commit": {
            "abbreviatedOid": "cf3b342"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-12T22:36:30Z",
          "updatedAt": "2022-05-12T22:36:30Z",
          "comments": [
            {
              "originalPosition": 139,
              "body": "Not sure I understand what you mean here, the description is redundant?",
              "createdAt": "2022-05-12T22:36:30Z",
              "updatedAt": "2022-05-12T22:36:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8456FDh",
          "commit": {
            "abbreviatedOid": "cf3b342"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-12T22:40:28Z",
          "updatedAt": "2022-05-12T22:40:28Z",
          "comments": [
            {
              "originalPosition": 139,
              "body": "IMO although the non-negative part is not really needed i would like to keep it to highlight the fact that e can be un signed integer. But removing it and leaving it as \r\n\r\n```\r\n- e, an integer representing a valid scalar value with the range of 0 < e < q.\r\n```\r\nIs also correct.",
              "createdAt": "2022-05-12T22:40:28Z",
              "updatedAt": "2022-05-12T22:40:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8456Fhr",
          "commit": {
            "abbreviatedOid": "30ed5a9"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-12T22:44:10Z",
          "updatedAt": "2022-05-12T22:44:14Z",
          "comments": [
            {
              "originalPosition": 158,
              "body": "```suggestion\r\n7. if e = 0 OR e >= q, return INVALID\r\n```\r\nI think we do need to check if e and s are zero right?? @andrewwhitehead??",
              "createdAt": "2022-05-12T22:44:10Z",
              "updatedAt": "2022-05-12T22:44:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8456F7u",
          "commit": {
            "abbreviatedOid": "30ed5a9"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-12T22:47:22Z",
          "updatedAt": "2022-05-12T22:48:21Z",
          "comments": [
            {
              "originalPosition": 222,
              "body": "```suggestion\r\n- octet\\_scalar\\_length: Number of bytes to represent a scalar value, in the multiplicative group of integers mod q, encoded as an octet string. It is RECOMMENDED this value be set to `ceil(log2(q)/8)`.\r\n```\r\nMaybe we need to make it a little more explicit here so that the ceil(log2(q)/8) recommendation makes more sense",
              "createdAt": "2022-05-12T22:47:22Z",
              "updatedAt": "2022-05-12T22:48:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8456GUM",
          "commit": {
            "abbreviatedOid": "30ed5a9"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-12T22:50:13Z",
          "updatedAt": "2022-05-12T22:50:14Z",
          "comments": [
            {
              "originalPosition": 158,
              "body": "`s` could potentially be zero for an unblinded signature if `s' + s'' = 0`. If an issuer wants to use `s = 0` or `e = 0` then they could, but I don't think it's great from a security perspective",
              "createdAt": "2022-05-12T22:50:13Z",
              "updatedAt": "2022-05-12T22:50:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8456G54",
          "commit": {
            "abbreviatedOid": "30ed5a9"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-12T22:54:50Z",
          "updatedAt": "2022-05-12T22:54:50Z",
          "comments": [
            {
              "originalPosition": 158,
              "body": "Addressed for e and s",
              "createdAt": "2022-05-12T22:54:50Z",
              "updatedAt": "2022-05-12T22:54:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8456G9B",
          "commit": {
            "abbreviatedOid": "30ed5a9"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-12T22:55:14Z",
          "updatedAt": "2022-05-12T22:55:15Z",
          "comments": [
            {
              "originalPosition": 222,
              "body": "Thanks, addressed",
              "createdAt": "2022-05-12T22:55:15Z",
              "updatedAt": "2022-05-12T22:55:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8456HFH",
          "commit": {
            "abbreviatedOid": "30ed5a9"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-12T22:56:18Z",
          "updatedAt": "2022-05-12T22:56:18Z",
          "comments": [
            {
              "originalPosition": 158,
              "body": "That's true. Although i don't really see any security problems with having either e or s be 0 on the top of my head the paper does define them in the multiplicative group mod q so i would prefer if they where non 0 just for that. ",
              "createdAt": "2022-05-12T22:56:18Z",
              "updatedAt": "2022-05-12T22:57:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8456Hi4",
          "commit": {
            "abbreviatedOid": "30ed5a9"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-12T23:00:01Z",
          "updatedAt": "2022-05-12T23:00:02Z",
          "comments": [
            {
              "originalPosition": 158,
              "body": "The point about blind signatures is also very interesting. If we decide to disallow 0 `s` we may have a problem there (not really saying to change it in the core draft, just that it is something we will have to consider when updating the blind signatures spec).",
              "createdAt": "2022-05-12T23:00:01Z",
              "updatedAt": "2022-05-12T23:00:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8456Hko",
          "commit": {
            "abbreviatedOid": "c5fc59d"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-12T23:00:14Z",
          "updatedAt": "2022-05-12T23:00:14Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax8456H7y",
          "commit": {
            "abbreviatedOid": "c5fc59d"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-12T23:03:03Z",
          "updatedAt": "2022-05-12T23:03:03Z",
          "comments": []
        }
      ]
    },
    {
      "number": 135,
      "id": "PR_kwDOF8lax843rwK0",
      "title": "Updates the sign procedure",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/135",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "dont-merge-yet"
      ],
      "body": "This PR updates the sign procedure to account for the case when `(SK + e) = 0 mod q` which is invalid and therefore requires us to re-compute a new `e` value if it were to occur.\r\n\r\nNote @BasileiosKal and I also discussed whether we need to check for `A != Identity_G1` however we believe it is impossible for this case to exist based on how the procedure is documented therefore the additional check is not required.",
      "createdAt": "2022-05-11T23:05:37Z",
      "updatedAt": "2022-05-23T18:09:09Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "49b0b3aeeeeabcb41331f1af107182e13d60513c",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/sign-procedure",
      "headRefOid": "111ab03128894951313549b570a51b290ab83ed6",
      "closedAt": "2022-05-23T18:09:05Z",
      "mergedAt": "2022-05-23T18:09:05Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "2c03f9309a34190c9d9881eabdcd83757044bd66"
      },
      "comments": [
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "While this is incredibly unlikely to happen, it also doesn't seem like a good solution to just abort the program if it does occur. However I worry a little about the possibility of a side-channel attack in comparing e to the SK.",
          "createdAt": "2022-05-12T00:29:53Z",
          "updatedAt": "2022-05-12T00:29:53Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@andrewwhitehead is right. We shouldn\u2019t abort or return to step 10 we should do something else like e - 1 as a conditional move to avoid leaking sk via timing attacks. ",
          "createdAt": "2022-05-12T00:56:20Z",
          "updatedAt": "2022-05-12T00:56:20Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "To tease this out further I think we agree the following\r\n\r\n1) The risk of `(SK + e) = 0 mod q` condition being meet is very low\r\n2) The risk however does exist therefore we do need to account for it by providing some guidance in the procedure to implementers on what to do if the case occurred\r\n3) the risk of a timing attack is not in the computation of `(SK + e) = 0 mod q` it self instead its due to the branch condition existing on the outcome of this computation e.g going back to step 10.\r\n\r\nIf we see risk in the computation of the `(SK + e) = 0 mod q` check itself (which I dont think we do?), we could instead just check `A != Identity_G1` after step 13 however the branch of going back and re-computing e would still exist therefore the remote possibility of some timing information leaking from a sign operation could still exist?",
          "createdAt": "2022-05-12T01:43:54Z",
          "updatedAt": "2022-05-12T01:43:54Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Another option to remove the branching logic is to pre-compute an alternative value for e and use that if the condition is met, removing the possibility of the timing attack @mikelodder7 I believe this was your suggestion in our conversation?",
          "createdAt": "2022-05-12T01:44:59Z",
          "updatedAt": "2022-05-12T01:44:59Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "if we do e - 1 or e + 1 shouldn't we then re-check if the new e is 0 again?? unless we specify SK > 1 it seems that we may end up with a similar problem??",
          "createdAt": "2022-05-12T09:29:50Z",
          "updatedAt": "2022-05-12T09:48:18Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Note also just aborting or not performing this check at all (current state of spec), also risks leaking information about the SK so we need to address it regardless, I think @mikelodder7 @BasileiosKal suggestion of pre-computing an alternative value for e we can use when this condition is meet, is the most appropriate solution",
          "createdAt": "2022-05-12T19:52:29Z",
          "updatedAt": "2022-05-12T19:52:55Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Note also just aborting or not performing this check at all (current state of spec), also risks leaking information about the SK so we need to address it regardless, I think @mikelodder7 @BasileiosKal suggestion of pre-computing an alternative value for e we can use when this condition is meet, is the most appropriate solution\r\n\r\nThat being said, current libraries for ECDSA do NOT check their nonce for secret key incompatibility because the likelihood is so low. The ECDSA spec as written in NIST doesn't even discuss it either. So perhaps we are over engineering this.",
          "createdAt": "2022-05-12T20:03:57Z",
          "updatedAt": "2022-05-12T20:03:57Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm happy to have a small note in the security considerations instead of producing a valid signature in this one unlikely case. I don't think we can just return (A=1, e, s) though because then SK can be easily calculated from e.",
          "createdAt": "2022-05-12T20:10:03Z",
          "updatedAt": "2022-05-12T20:10:03Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agreed. Isn't the possibility of the attack even being effective the same as an attacker trying random secret keys and finding the correct one?? So even if the attack is feasible i don't thing that the overall security level of the scheme actually declines.",
          "createdAt": "2022-05-12T20:12:16Z",
          "updatedAt": "2022-05-12T20:12:16Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "> That being said, current libraries for ECDSA do NOT check their nonce for secret key incompatibility because the likelihood is so low. The ECDSA spec as written in NIST doesn't even discuss it either. So perhaps we are over engineering this.\r\n\r\nInteresting does that mean in deterministic variations of ECDSA there is at least one combination of SK + payload that you could just never sign as it would always fail because the nonce is derived from the input deterministically?\r\n\r\nIf thats the case then one strategy is to just follow that precedent",
          "createdAt": "2022-05-12T20:51:53Z",
          "updatedAt": "2022-05-12T20:52:34Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes the standard is RFC6979 which makes ECDSA deterministic. ",
          "createdAt": "2022-05-12T20:53:26Z",
          "updatedAt": "2022-05-12T20:53:26Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed on WG call today, we have multiple options here I think we need to firm up more\r\n\r\nIn general we need to decide whether we want the strategy with sign to be:\r\n\r\n1. In all cases even when say `(SK + e) = 0 mod r` that the procedure should still produce a valid signature (e.g therefore compute an alternative value for e)\r\n2. OR abort the sign procedure\r\n\r\nWe also need to decide, what checks we need\r\n\r\n1. Is `(SK + e) = 0 mod r` all we need to check?\r\n2. OR is `A != Identity_G1` a substitute?\r\n3. OR do we need to perform both e.g `A != Identity_G1` AND `(SK + e) = 0 mod r`\r\n4. OR are either of these checks just over complicating the procedure because the likely-hood of this occuring is so statistically improbable and therefore we should just adopt what ECDSA has done and not mention it?\r\n5. OR should we discuss this case in the considerations and or text around the procedure instead of making it an explicit step in the procedure?",
          "createdAt": "2022-05-17T01:29:48Z",
          "updatedAt": "2022-05-17T01:29:48Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "For the `(SK+e) = 0 mod r` vs `A = 1_G1` argument i think @andrewwhitehead's point (and please correct me if I'm wrong) was that\r\n```\r\nA = B*(1/(SK+e)) = inverse(B * (SK + e))\r\n```\r\nAs a result, `SK + e = 0 mod r => A = 1_G1`. \r\n\r\nI don't think it holds though?? (i.e., i think that `P * (1 / x) != inverse(P * x)`).\r\n\r\nWhat do you think @mikelodder7??? ^",
          "createdAt": "2022-05-17T12:42:11Z",
          "updatedAt": "2022-05-17T12:42:11Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It does hold though. B^-0 or T=inverse(sk+e) then B^T all produce zero. Especially in practice. All implementations I know if you call invert on 0 either abort or return 0. My preference is to call out the possibility (ever so small) that this could happen but the odds are so far out we don\u2019t implement it when signing",
          "createdAt": "2022-05-17T12:48:29Z",
          "updatedAt": "2022-05-17T12:48:29Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ok i understand better now. Thanks! So it is an implementation issue and not something that holds in general. So if we are to add the check i would still prefer to just check for `(SK+e) = 0`.\r\n\r\nThat said, i agree with @mikelodder7 in not having the check and just adding a sort security consideration. In any operation taking a signature as input we can specify that the signature must be valid then. IMO this is the most readable and at the same time \"correct\" approach. ",
          "createdAt": "2022-05-17T12:56:25Z",
          "updatedAt": "2022-05-17T12:58:10Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In verify we should perform checks that the signature values are not zero and the public key is not zero either. Anywhere these are used we should be checking them. Always validate inputs. We can assume values generated during the function from hash methods or PRFs are valid",
          "createdAt": "2022-05-17T13:36:34Z",
          "updatedAt": "2022-05-17T13:36:34Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "I have revert the changes to sign procedure and added a note, ready for re-review.",
          "createdAt": "2022-05-21T01:49:25Z",
          "updatedAt": "2022-05-21T01:49:25Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Multiple reviews and approvals, discussed on multiple WG calls, merging.",
          "createdAt": "2022-05-23T18:08:39Z",
          "updatedAt": "2022-05-23T18:08:39Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Multiple reviews and approvals, discussed on multiple WG calls, merging.",
          "createdAt": "2022-05-23T18:08:39Z",
          "updatedAt": "2022-05-23T18:08:39Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax846dv4_",
          "commit": {
            "abbreviatedOid": "0d33d89"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Minor suggestion to drive the point home about how small the probability of getting a 0 actually is. LGTM otherwise",
          "createdAt": "2022-05-21T20:51:24Z",
          "updatedAt": "2022-05-21T20:53:01Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "```suggestion\r\n**Note** When computing step 11 of the above procedure there is an extremely small probability (around `2^(-r)`) that the condition `(SK + e) = 0 mod r` will be met. How implementations evaluate the inverse of the scalar value `0` may vary, with some returning an error and others returning `0` as a result. If the returned value from the inverse operation `1/(SK + e)` does evalute to `0` the value of `A` will equal `Identity_G1` thus an invalid signature. Implementations MAY elect to check `(SK + e) = 0 mod r` prior to step 11, and or `A != Identity_G1` after step 11 to prevent the production of invalid signatures.\r\n```",
              "createdAt": "2022-05-21T20:51:24Z",
              "updatedAt": "2022-05-21T22:03:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846emAE",
          "commit": {
            "abbreviatedOid": "111ab03"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-23T03:16:20Z",
          "updatedAt": "2022-05-23T03:16:20Z",
          "comments": []
        }
      ]
    },
    {
      "number": 136,
      "id": "PR_kwDOF8lax843vs3I",
      "title": "Fix typo around ciphersuite",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/136",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Addresses an inconsistency raised by @christianpaquin w.r.t the input data type of Ciphersuite_ID",
      "createdAt": "2022-05-12T20:41:11Z",
      "updatedAt": "2022-05-12T22:19:34Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "e871c69645d6031d615bc53b570fce9edecb38fb",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/cipher-suite-typo",
      "headRefOid": "1c6953a240613f493d24f670115d3b7771ef6019",
      "closedAt": "2022-05-12T22:19:27Z",
      "mergedAt": "2022-05-12T22:19:27Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "1e463ea474eb0aaa14fa9eed721ba5b4b3fe8ac7"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Minor editorial tweak, multiple approvals, merging",
          "createdAt": "2022-05-12T22:19:23Z",
          "updatedAt": "2022-05-12T22:19:23Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax84553yn",
          "commit": {
            "abbreviatedOid": "1c6953a"
          },
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-12T21:22:04Z",
          "updatedAt": "2022-05-12T21:22:04Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax8455_XC",
          "commit": {
            "abbreviatedOid": "1c6953a"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-12T22:03:04Z",
          "updatedAt": "2022-05-12T22:03:04Z",
          "comments": []
        }
      ]
    },
    {
      "number": 137,
      "id": "PR_kwDOF8lax843xUCY",
      "title": "Ciphersuite ID definition",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/137",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Defines the Ciphersuite ID format and supplies a value for the BLS12-381 suite, partially addresses #118 ",
      "createdAt": "2022-05-13T09:13:25Z",
      "updatedAt": "2022-05-20T04:23:18Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "c3c65347050125751165dd627e7d52f029d143f5",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/ciphersuite_id",
      "headRefOid": "ea8969c76ee3feb31f80ef5f29ba21914ed712d5",
      "closedAt": "2022-05-20T04:23:11Z",
      "mergedAt": "2022-05-20T04:23:11Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "0e11e405c1d33d3566c65f949131c97664bdf8df"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Multiple approvals, reviewed on last WG call, merging",
          "createdAt": "2022-05-20T04:23:07Z",
          "updatedAt": "2022-05-20T04:23:07Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax8457wTw",
          "commit": {
            "abbreviatedOid": "2940cf7"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-13T09:39:27Z",
          "updatedAt": "2022-05-13T09:39:38Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "```suggestion\r\n  \"BBS_\" || H2C_SUITE_ID || ADD_INFO || \"_\"\r\n```\r\nIt may be better to define the ID to end with a `_` so we will not have to define that ADD_INFO MUST end with an `_`. Also there is an `_` that is needed after the h2c id i think.",
              "createdAt": "2022-05-13T09:39:27Z",
              "updatedAt": "2022-05-19T23:53:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846FXLK",
          "commit": {
            "abbreviatedOid": "2940cf7"
          },
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-16T19:45:49Z",
          "updatedAt": "2022-05-16T19:46:04Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "> between 0x21 and 0x7e (inclusive)\r\n\r\nWhy this range? Why not just alphanumeric?\r\n\r\n> other than ~as~ the last character the string MUST not contain any other underscores (0x5f).\r\n\r\nTypo: remove \"as\"",
              "createdAt": "2022-05-16T19:45:49Z",
              "updatedAt": "2022-05-16T19:46:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846GKkc",
          "commit": {
            "abbreviatedOid": "2940cf7"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-17T00:22:22Z",
          "updatedAt": "2022-05-17T00:22:23Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "I think most of the H2C_SUITE_ID's follow with an `_` already? hence I was just following the pattern established by the BLS spec?",
              "createdAt": "2022-05-17T00:22:23Z",
              "updatedAt": "2022-05-17T00:22:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846GKlZ",
          "commit": {
            "abbreviatedOid": "2940cf7"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-17T00:22:29Z",
          "updatedAt": "2022-05-17T00:22:30Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "See https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-14#section-8.8",
              "createdAt": "2022-05-17T00:22:29Z",
              "updatedAt": "2022-05-17T00:22:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846GKpi",
          "commit": {
            "abbreviatedOid": "2940cf7"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-17T00:23:06Z",
          "updatedAt": "2022-05-17T00:23:06Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "```suggestion\r\n  *  ADD\\_INFO is an optional string indicating any additional information used to uniquely qualify the ciphersuite. When present this value MUST only contain ASCII characters between 0x21 and 0x7e (inclusive), and MUST end with an underscore (0x5f), other than the last character the string MUST not contain any other underscores (0x5f).\r\n```",
              "createdAt": "2022-05-17T00:23:06Z",
              "updatedAt": "2022-05-17T00:23:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846X_v8",
          "commit": {
            "abbreviatedOid": "2940cf7"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-19T23:38:06Z",
          "updatedAt": "2022-05-19T23:38:07Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "@christianpaquin includes symbols too, its inline with how bls-signatures has defined it, we can narrow to just alphanumeric if we would rather https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-bls-signature-04#section-4.1",
              "createdAt": "2022-05-19T23:38:06Z",
              "updatedAt": "2022-05-19T23:38:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846YBgk",
          "commit": {
            "abbreviatedOid": "2940cf7"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-19T23:54:37Z",
          "updatedAt": "2022-05-19T23:54:38Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "quite right! my apologies. So the _ after the H2C_SUITE_ID is not needed. I updated the suggestion.",
              "createdAt": "2022-05-19T23:54:38Z",
              "updatedAt": "2022-05-19T23:54:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846YCyF",
          "commit": {
            "abbreviatedOid": "ea8969c"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Minor nit. Otherwise LGTM",
          "createdAt": "2022-05-20T00:06:33Z",
          "updatedAt": "2022-05-20T00:06:33Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax846YC6e",
          "commit": {
            "abbreviatedOid": "ea8969c"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-20T00:07:52Z",
          "updatedAt": "2022-05-20T00:07:53Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "What about if ADD_INFO is not supplied though? Then it would be a double underscore would it not?",
              "createdAt": "2022-05-20T00:07:52Z",
              "updatedAt": "2022-05-20T00:07:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846YEGB",
          "commit": {
            "abbreviatedOid": "2940cf7"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-20T00:18:22Z",
          "updatedAt": "2022-05-20T00:18:22Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Yea, which could provide a way for a verifier to know when ADD_INFO was not supplied?? I do realize that this is unconventional so Im fine with the current approach also.",
              "createdAt": "2022-05-20T00:18:22Z",
              "updatedAt": "2022-05-20T00:18:22Z"
            }
          ]
        }
      ]
    },
    {
      "number": 138,
      "id": "PR_kwDOF8lax843y_lL",
      "title": "API update",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/138",
      "state": "CLOSED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Updating the way that the messages and generators are passed to the operations, using @andrewwhitehead's proposal of passing them in pairs. \r\n\r\nThe main purpose of the PR is to have a concrete base of discussion about what the best API will be. For alternatives see #117. For some more context see PR #128 (the motivation was \u201chow we get the revealed messages from the (msg_1, \u2026, msg_L) list and the revealed indexes).\r\n\r\nIMO all approaches have trade-offs. Although I like the proposal seen in this PR a lot and it makes things more explicit, I wonder if it is more error prone?? That said, it may provide the best balance between being explicit and easy to read. Interested on the WG feedback.\r\n",
      "createdAt": "2022-05-13T16:32:18Z",
      "updatedAt": "2022-06-22T22:37:10Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "849e6d96b895615d460f92bf0b1d7efbb8f62519",
      "headRepository": "BasileiosKal/bbs-signature",
      "headRefName": "api_update",
      "headRefOid": "153452be23d5bbd4cf2a76f29000982605e23618",
      "closedAt": "2022-06-22T22:37:10Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for that, it looks pretty readable to me although maybe we can find a better way to describe the ordering of the generators.",
          "createdAt": "2022-05-13T16:51:57Z",
          "updatedAt": "2022-05-13T16:51:57Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Updated API based on the discussion on the  WG call of 16/5/2022.\r\n\r\nThe main change is the proposal of the `[(H_i, msg_i), for revealed_i = 1]` etc notation. It may not be 100% formally defined but IMO it is \u201cclear enough\u201d while avoiding some of the issues we discussed on the call. \r\n\r\nMy biggest concern here is that the order of the revealed messages supplied to ProofVerify is not clearly enough defined. But we \r\nmay be able to solve this with some additional text?\r\n\r\nInterested on the WG\u2019s thoughts. c.c. @tplooker, @andrewwhitehead ^\r\n",
          "createdAt": "2022-05-16T23:21:11Z",
          "updatedAt": "2022-05-16T23:21:11Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Couple of updates:\r\n1. Updates based on the reviews.\r\n2. Since the description for the list of (generator, message) pairs in the Input section for the ProofGen and ProofVerify operations was getting longer and longer, i changed the description to something more \"minimal\" and added a \"see above for requirements\" to point to the description above the each operation, where the input lists are explained clearly along with an example.",
          "createdAt": "2022-05-25T15:39:12Z",
          "updatedAt": "2022-05-25T15:39:12Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think ProofGen turns out simpler if we don't try to combine the revealed message flags with the generators and message values. It means introducing more syntax plus the concept of boolean variables. For comparison...\r\n\r\n> - [(H_1, msg_1, revealed_1), ..., (H_L, msg_L, revealed_L)] (OPTIONAL), a list of tuples containing a generator (point on G1), a non-zero scalar mod r representing a message, and a boolean value indicating if the message will be revealed or not (see above for requirements)\r\n>\r\n> ...\r\n>\r\n> - L, is the non-negative integer representing the number of signed messages i.e., length([(H_1, msg_1, revealed_1), ..., (H_L, msg_L, revealed_L)]). Note if the list of (generator, message boolean) tuples is not supplied, the value of L MUST evaluate to zero (0).\r\n> - R, is the non-negative integer representing the number of revealed messages i.e., R is the number of the boolean values: revealed_1, ..., revealed_L, that are \"true\". If no revealed messages are supplied as an input to this operation, the value of R MUST evaluate to zero (0).\r\n> - U, is the non-negative integer representing the number of un-revealed messages i.e., U = L-R. If no un-revealed messages are supplied as an input to this operation (i.e., if R = L), the value of U MUST evaluate to zero (0).\r\n>\r\n> ...\r\n>\r\n> 1. Let (H_i1, msg_i1), ..., (H_iR, msg_iR), be the pairs containing the\r\n>    first 2 elements from the tuples (H_i, msg_i, revealed_i),\r\n>    i = 1, ..., L, for which it holds that revealed_i = true, in the same\r\n>    order (i.e., the (generator, message) pairs corresponding to the\r\n>    revealed messages).\r\n> 2. Let (H_j1, msg_j1), ..., (H_jU, msg_jU), be the pairs containing the\r\n>    first 2 elements from the tuples (H_i, msg_i, revealed_i),\r\n>    i = 1, ..., L, for which it holds that revealed_i = false, (i.e., the\r\n>    (generator, message) pairs corresponding to the\r\n>    un-revealed messages).\r\n\r\n- [(H_1, msg_1), ..., (H_L, msg_L)] (OPTIONAL), a list of tuples containing a generator (point on G1), a non-zero scalar mod r representing a message.\r\n- RevealedIndexes (OPTIONAL), an ordered list of distinct message indexes to be revealed. Each member of this list must be an integer such that 1 <= index <= L.\r\n\r\n- L, is the non-negative integer representing the number of signed messages i.e., length([(H_1, msg_1), ..., (H_L, msg_L)]). In the absence of a list of (generator, message) tuples, this value is zero (0).\r\n- R, is the non-negative integer representing the number of revealed messages i.e., length(RevealedIndexes). In the absence of a list of revealed message indexes, this value is zero (0).\r\n- U, is the non-negative integer representing the number of un-revealed messages i.e., U = L-R.\r\n\r\nEdit: This might also be clearer if we gave the 'list of (generator, message) tuples' input a name like 'AllMessages' and specified the format later.",
          "createdAt": "2022-05-26T19:04:20Z",
          "updatedAt": "2022-05-26T19:34:54Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As a follow-up to that suggestion, here it is with the variable alias:\r\n\r\nproof = ProofGen(PK, signature, header, ph, signed=[], revealed=[])\r\n\r\nInputs:\r\n...\r\n- signed (OPTIONAL), a list of 2-tuples containing a generator (point on G1) and a message scalar (non-zero integer mod r), taking the form [(H_1, msg_1), ..., (H_L, msg_L)]. When unspecified, defaults to an empty list ([]).\r\n- revealed (OPTIONAL), an ordered list of distinct message indexes to be revealed along with the proof. Each member of this list must be an integer such that 1 <= index <= L. When unspecified, defaults to an empty list ([]).\r\n\r\n...\r\n\r\n- L, a non-negative integer representing the number of signed messages, equal to length(signed).\r\n- R, a non-negative integer representing the number of revealed messages, equal to length(revealed).\r\n- U, a non-negative integer representing the number of un-revealed messages, equal to L-R.\r\n",
          "createdAt": "2022-05-26T19:46:50Z",
          "updatedAt": "2022-05-26T19:48:00Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thank you! I'm not opposed to this. Just couple of notes:\r\n1. The ordering of the \"signed\" generator/message pairs is still needed. The reason is that ProofGen must calculate the domain value so the generators must be in the correct order. ProofGen must also pass the revealed message to the challenge hash (i.e. PR #128) with the \"correct\" order as well (the last one is not necessary, we could just pass (generator, message) pairs to the challenge hash and solve issue #74, but it would be more work since the ordering of the generators is needed either way).\r\n2. The syntax is simpler but there will be more additional steps added in the operation (like step 7 and 8 from [this comment](https://github.com/decentralized-identity/bbs-signature/issues/117#issuecomment-1126227125)).\r\n3. It may be \"awkward\" to use L in the inputs (for describing `revealed`) before it is \"defined\".\r\n\r\nThat said the descriptions are indeed simpler. I will take a shot at this and update the PR so we can compare.",
          "createdAt": "2022-05-26T20:08:53Z",
          "updatedAt": "2022-05-26T20:08:53Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "PR updated based on @andrewwhitehead's above proposal^ and ready for re-review. See #159 for considerations and comparisons between the two choices (boolean variables vs indexes).",
          "createdAt": "2022-05-27T16:09:40Z",
          "updatedAt": "2022-05-27T16:09:40Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for the update! In general I do find this more understandable, but I'd like to hear what others think.",
          "createdAt": "2022-05-27T18:14:59Z",
          "updatedAt": "2022-05-27T18:14:59Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thank you @andrewwhitehead for the reviews. Updated based on your comments. \r\n\r\nCouple of additional changes:\r\n1. added some more guidance on Sign and Verify on how the generators and the messages are to be supplied.\r\n2. added an additional check on ProofVerify for the \"correctness\" of the indexes.",
          "createdAt": "2022-05-29T11:17:17Z",
          "updatedAt": "2022-05-29T15:58:27Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "#### NOTE:\r\nWaiting a little on resolution on #161 (or a consensus) to update this PR.",
          "createdAt": "2022-06-02T12:07:19Z",
          "updatedAt": "2022-06-02T12:07:19Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closing since updates are addressed by PR #183",
          "createdAt": "2022-06-22T22:37:10Z",
          "updatedAt": "2022-06-22T22:37:10Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax84597II",
          "commit": {
            "abbreviatedOid": "cc934f6"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-13T16:47:16Z",
          "updatedAt": "2022-05-13T16:47:17Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "The list MUST be ordered based on the index of the generators?",
              "createdAt": "2022-05-13T16:47:17Z",
              "updatedAt": "2022-05-13T16:47:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84597Wq",
          "commit": {
            "abbreviatedOid": "cc934f6"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-13T16:48:14Z",
          "updatedAt": "2022-05-13T16:48:14Z",
          "comments": [
            {
              "originalPosition": 60,
              "body": "Not sure why these two are required and can't default to [] as well",
              "createdAt": "2022-05-13T16:48:14Z",
              "updatedAt": "2022-05-13T16:48:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84597ky",
          "commit": {
            "abbreviatedOid": "cc934f6"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-13T16:49:10Z",
          "updatedAt": "2022-05-13T16:49:10Z",
          "comments": [
            {
              "originalPosition": 77,
              "body": "RevealedIndexes doesn't exist anymore",
              "createdAt": "2022-05-13T16:49:10Z",
              "updatedAt": "2022-05-13T16:49:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845_vAu",
          "commit": {
            "abbreviatedOid": "cc934f6"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-14T11:48:20Z",
          "updatedAt": "2022-05-14T11:48:20Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "This does make sense considering how the generators are created but that order is harder to be \"verified\" unless the verifier re-creates all the generators (not really a security issue I think, it's just that the proof will not validate). \r\n\r\nUsed the suggestion for now and opened issue #141 to discuss more. ",
              "createdAt": "2022-05-14T11:48:20Z",
              "updatedAt": "2022-05-14T11:48:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845_vD5",
          "commit": {
            "abbreviatedOid": "cc934f6"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-14T11:51:12Z",
          "updatedAt": "2022-05-14T11:51:13Z",
          "comments": [
            {
              "originalPosition": 60,
              "body": "My thinking was that if both lists are optional, it would allow both to be empty at the same time (which it should not if the original signed list is also non-empty). \r\n\r\nThat said, I added a note in the description of ProofGen to highlight this fact and made the lists optional. I agree that this way is better from having the lists be required.",
              "createdAt": "2022-05-14T11:51:13Z",
              "updatedAt": "2022-05-14T15:16:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax845_vEP",
          "commit": {
            "abbreviatedOid": "cc934f6"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-14T11:51:32Z",
          "updatedAt": "2022-05-14T11:51:33Z",
          "comments": [
            {
              "originalPosition": 77,
              "body": "Thanks! Addressed.",
              "createdAt": "2022-05-14T11:51:33Z",
              "updatedAt": "2022-05-14T11:51:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846AGRB",
          "commit": {
            "abbreviatedOid": "c191a18"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-14T22:25:33Z",
          "updatedAt": "2022-05-14T22:25:34Z",
          "comments": [
            {
              "originalPosition": 245,
              "body": "```suggestion\r\n- [H_h1, ..., H_hU] (OPTIONAL), a list of points in G1. Generators corresponding to \r\n     un-revealed messages. If not supplied, the list will default to the empty \r\n     array (\"[]\"). The list MUST be ordered based on the index of the generators.\r\n```\r\n\r\nI think reveal vs un-reveal is better language than adding in another term \"hidden\"?",
              "createdAt": "2022-05-14T22:25:33Z",
              "updatedAt": "2022-05-14T22:25:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846AGUp",
          "commit": {
            "abbreviatedOid": "c191a18"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-14T22:30:37Z",
          "updatedAt": "2022-05-14T22:30:38Z",
          "comments": [
            {
              "originalPosition": 258,
              "body": "```suggestion\r\n- U, is the non-negative integer representing the number of un-revealed messages e.g.,\r\n```",
              "createdAt": "2022-05-14T22:30:37Z",
              "updatedAt": "2022-05-14T22:30:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846E0bJ",
          "commit": {
            "abbreviatedOid": "c191a18"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-16T17:42:54Z",
          "updatedAt": "2022-05-16T17:42:54Z",
          "comments": [
            {
              "originalPosition": 245,
              "body": "Thanks! Addressed",
              "createdAt": "2022-05-16T17:42:54Z",
              "updatedAt": "2022-05-16T17:42:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846E-wY",
          "commit": {
            "abbreviatedOid": "62dcc38"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-16T18:17:50Z",
          "updatedAt": "2022-05-16T18:17:50Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "will need to be mod r if #140 is merged first",
              "createdAt": "2022-05-16T18:17:50Z",
              "updatedAt": "2022-05-16T18:17:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846E-wX",
          "commit": {
            "abbreviatedOid": "62dcc38"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-16T18:17:50Z",
          "updatedAt": "2022-05-16T18:17:51Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "will need to be mod r if #140 is merged first",
              "createdAt": "2022-05-16T18:17:50Z",
              "updatedAt": "2022-05-16T18:17:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846FA9P",
          "commit": {
            "abbreviatedOid": "62dcc38"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-16T18:26:15Z",
          "updatedAt": "2022-05-16T18:26:15Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "[(H_1, msg_1, reveal?) ... (H_L, msg_L, reveal?)] an alternative syntax suggestion",
              "createdAt": "2022-05-16T18:26:15Z",
              "updatedAt": "2022-05-16T18:26:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846FA9R",
          "commit": {
            "abbreviatedOid": "62dcc38"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-16T18:26:15Z",
          "updatedAt": "2022-05-16T18:26:15Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "[(H_1, msg_1, reveal?) ... (H_L, msg_L, reveal?)] an alternative syntax suggestion",
              "createdAt": "2022-05-16T18:26:15Z",
              "updatedAt": "2022-05-16T18:26:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846FBak",
          "commit": {
            "abbreviatedOid": "62dcc38"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-16T18:28:01Z",
          "updatedAt": "2022-05-16T18:28:02Z",
          "comments": [
            {
              "originalPosition": 224,
              "body": "```suggestion\r\nresult = ProofVerify(PK, proof, header, ph,          \r\n                 [H_1, ..., H_L], \r\n                 [(index, msg_x), ..., (index, msg_x)])\r\n```\r\n\r\nAlternative syntax suggestion\r\n```suggestion\r\nresult = ProofVerify(PK, proof, header, ph,          \r\n                 [(H_1, reveal?, msg_1 || NULL), ..., (H_L, reveal?, msg_L || NULL)]\r\n```\r\n\r\nAnother option is [(generator, false) || (generator, true, msg_x)] e.g Polymorphic array",
              "createdAt": "2022-05-16T18:28:01Z",
              "updatedAt": "2022-05-16T18:39:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846FBal",
          "commit": {
            "abbreviatedOid": "62dcc38"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-16T18:28:01Z",
          "updatedAt": "2022-05-16T18:28:02Z",
          "comments": [
            {
              "originalPosition": 224,
              "body": "```suggestion\r\nresult = ProofVerify(PK, proof, header, ph,          \r\n                 [H_1, ..., H_L], \r\n                 [(index, msg_x), ..., (index, msg_x)])\r\n```\r\n\r\nAlternative syntax suggestion\r\n```suggestion\r\nresult = ProofVerify(PK, proof, header, ph,          \r\n                 [(H_i1, msg_i1), ..., (H_iR, msg_iR)], \r\n                 [H_h1, ..., H_hU])\r\n```",
              "createdAt": "2022-05-16T18:28:01Z",
              "updatedAt": "2022-05-16T18:28:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846GJ5i",
          "commit": {
            "abbreviatedOid": "321476e"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-17T00:16:06Z",
          "updatedAt": "2022-05-17T00:16:07Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "```suggestion\r\n- [(H_1, msg_1, revealed_1), ..., (H_L, msg_L, revealed_L)] (OPTIONAL), a list of tuples consisting of a generator, the message and a boolean value indicating if the message will be revealed or not. Generators must be G1 points, messages must be non-zero scalars mod r and the variable indicating if that message will be revealed must be boolean. If not supplied, the list will default to the empty array (\"[]\"). The list MUST be ordered based on the index of the generators.\r\n```\r\n```suggestion\r\n- [(H_1, msg_1, revealed_1), ..., (H_L, msg_L, revealed_L)] (OPTIONAL), a list of tuples consisting by a generator, the message and a variable indicating if the message will be revealed or not. Generators must be G1 points, messages must be non-zero scalars mod r and the variable indicating if that message will be revealed must be boolean. If not supplied, the list will default to the empty array (\"[]\"). The list MUST be ordered based on the index of the generators.\r\n```",
              "createdAt": "2022-05-17T00:16:06Z",
              "updatedAt": "2022-05-17T00:16:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846GJ5j",
          "commit": {
            "abbreviatedOid": "321476e"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-17T00:16:06Z",
          "updatedAt": "2022-05-17T00:16:07Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "```suggestion\r\n- [(H_1, msg_1, revealed_1), ..., (H_L, msg_L, revealed_L)] (OPTIONAL), a list of tuples consisting of a generator, the message and a boolean value indicating if the message will be revealed or not. Generators must be G1 points, messages must be non-zero scalars mod r and the variable indicating if that message will be revealed must be boolean. If not supplied, the list will default to the empty array (\"[]\"). The list MUST be ordered based on the index of the generators.\r\n```\r\n```suggestion\r\n- [(H_1, msg_1, revealed_1), ..., (H_L, msg_L, revealed_L)] (OPTIONAL), a list of tuples consisting by a generator, the message and a variable indicating if the message will be revealed or not. Generators must be G1 points, messages must be non-zero scalars mod r and the variable indicating if that message will be revealed must be boolean. If not supplied, the list will default to the empty array (\"[]\"). The list MUST be ordered based on the index of the generators.\r\n```",
              "createdAt": "2022-05-17T00:16:06Z",
              "updatedAt": "2022-05-17T00:16:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846GJ9i",
          "commit": {
            "abbreviatedOid": "321476e"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-17T00:16:45Z",
          "updatedAt": "2022-05-17T00:16:45Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "The last statement here around the ordering I still dont think is 100% clear, but I think in general this PR is a great improvement.",
              "createdAt": "2022-05-17T00:16:45Z",
              "updatedAt": "2022-05-17T00:16:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846GJ9j",
          "commit": {
            "abbreviatedOid": "321476e"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-17T00:16:45Z",
          "updatedAt": "2022-05-17T00:16:45Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "The last statement here around the ordering I still dont think is 100% clear, but I think in general this PR is a great improvement.",
              "createdAt": "2022-05-17T00:16:45Z",
              "updatedAt": "2022-05-17T00:16:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846GKFy",
          "commit": {
            "abbreviatedOid": "321476e"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-17T00:17:54Z",
          "updatedAt": "2022-05-17T00:17:54Z",
          "comments": [
            {
              "originalPosition": 99,
              "body": "I think this syntax needs to be explained more, in general we could elect to do more of a filter or map style function?",
              "createdAt": "2022-05-17T00:17:54Z",
              "updatedAt": "2022-05-17T00:17:54Z"
            },
            {
              "originalPosition": 99,
              "body": "I think this syntax needs to be explained more, in general we could elect to do more of a filter or map style function?",
              "createdAt": "2022-05-17T00:17:54Z",
              "updatedAt": "2022-05-17T00:17:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846GKNL",
          "commit": {
            "abbreviatedOid": "321476e"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-17T00:19:05Z",
          "updatedAt": "2022-05-17T00:19:05Z",
          "comments": [
            {
              "originalPosition": 99,
              "body": "```suggestion\r\n2. [(H_i1, msg_i1), ..., (H_iR, msg_iR)] = [(H_i, msg_i), if revealed_i = 1]\r\n```\r\n```suggestion\r\n2. [(H_i1, msg_i1), ..., (H_iR, msg_iR)] = [(H_1, msg_1, revealed_1), ..., (H_L, msg_L, revealed_L)].filter(item => item.revealed_i == true)\r\n```",
              "createdAt": "2022-05-17T00:19:05Z",
              "updatedAt": "2022-05-17T00:19:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846GKNK",
          "commit": {
            "abbreviatedOid": "321476e"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-17T00:19:05Z",
          "updatedAt": "2022-05-17T00:19:06Z",
          "comments": [
            {
              "originalPosition": 99,
              "body": "```suggestion\r\n2. [(H_i1, msg_i1), ..., (H_iR, msg_iR)] = [(H_i, msg_i), if revealed_i = 1]\r\n```\r\n```suggestion\r\n2. [(H_i1, msg_i1), ..., (H_iR, msg_iR)] = [(H_1, msg_1, revealed_1), ..., (H_L, msg_L, revealed_L)].filter(item => item.revealed_i == true)\r\n```",
              "createdAt": "2022-05-17T00:19:05Z",
              "updatedAt": "2022-05-17T00:19:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846eVBs",
          "commit": {
            "abbreviatedOid": "321476e"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-22T23:18:45Z",
          "updatedAt": "2022-05-22T23:18:45Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "Changed the statement a bit (now the ordering needs to follow the ordering of the input to Sign) and provided some examples to make it more clear.",
              "createdAt": "2022-05-22T23:18:45Z",
              "updatedAt": "2022-05-22T23:18:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846eVCE",
          "commit": {
            "abbreviatedOid": "321476e"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-22T23:18:59Z",
          "updatedAt": "2022-05-22T23:18:59Z",
          "comments": [
            {
              "originalPosition": 99,
              "body": "I think that the complexity of having to define a filter function will outweigh the advantages of the current API??? In my last push I've described in \"clear text\" the operation of getting `(H_i1, msg_i1), ..., (H_iR, msg_iR)` etc., Thoughts on the alternative???",
              "createdAt": "2022-05-22T23:18:59Z",
              "updatedAt": "2022-05-22T23:18:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846eVMt",
          "commit": {
            "abbreviatedOid": "321476e"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-22T23:24:26Z",
          "updatedAt": "2022-05-22T23:24:26Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "Done! Thanks!",
              "createdAt": "2022-05-22T23:24:26Z",
              "updatedAt": "2022-05-22T23:24:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846eyml",
          "commit": {
            "abbreviatedOid": "1b00ba4"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-23T05:18:39Z",
          "updatedAt": "2022-05-23T05:18:40Z",
          "comments": [
            {
              "originalPosition": 95,
              "body": "```suggestion\r\n- R, is the non-negative integer representing the number of revealed messages, R = revealed_1 + revealed_2 + ... + revealed_L. In the calculation of R its assumed that the boolean value of true evaluates to a non-negative integer value of 1 whereas the boolean value of false evaluates to a non-negative integer value of 0.  If no messages are supplied as an input to this operation, the value of R MUST evaluate to zero (0).\r\n```",
              "createdAt": "2022-05-23T05:18:40Z",
              "updatedAt": "2022-05-23T05:20:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846eysJ",
          "commit": {
            "abbreviatedOid": "1b00ba4"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-23T05:19:19Z",
          "updatedAt": "2022-05-23T05:19:19Z",
          "comments": [
            {
              "originalPosition": 95,
              "body": "Trying to clarify that effectively we are casting boolean values in the calculation of R to an integer?",
              "createdAt": "2022-05-23T05:19:19Z",
              "updatedAt": "2022-05-23T05:19:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846ey69",
          "commit": {
            "abbreviatedOid": "1b00ba4"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-23T05:21:05Z",
          "updatedAt": "2022-05-23T05:21:05Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "```suggestion\r\n- L, is the non-negative integer representing the number of signed messages, L = length([(H_1, msg_1, revealed_1), ..., (H_L, msg_L, revealed_L)]). Note if no messages are signed, the value of L MUST evaluate to zero (0).\r\n```",
              "createdAt": "2022-05-23T05:21:05Z",
              "updatedAt": "2022-05-23T05:21:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846ezAJ",
          "commit": {
            "abbreviatedOid": "1b00ba4"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-23T05:21:41Z",
          "updatedAt": "2022-05-23T05:21:41Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "Its not an example IMO so we should drop the e.g",
              "createdAt": "2022-05-23T05:21:41Z",
              "updatedAt": "2022-05-23T05:21:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846ezBx",
          "commit": {
            "abbreviatedOid": "1b00ba4"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-23T05:21:53Z",
          "updatedAt": "2022-05-23T05:21:54Z",
          "comments": [
            {
              "originalPosition": 96,
              "body": "```suggestion\r\n- U, is the non-negative integer representing the number of un-revealed messages, U = L-R. If no non-revealed messages are supplied as an input to this operation (i.e., if R = L), the value of U MUST evaluate to zero (0).\r\n```",
              "createdAt": "2022-05-23T05:21:53Z",
              "updatedAt": "2022-05-23T05:21:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846iP-R",
          "commit": {
            "abbreviatedOid": "1b00ba4"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-23T16:22:31Z",
          "updatedAt": "2022-05-23T16:22:32Z",
          "comments": [
            {
              "originalPosition": 95,
              "body": "Good point! Updated to a different wording that it is sorter but may not be as clear?? If yes i will update to the suggestion.",
              "createdAt": "2022-05-23T16:22:31Z",
              "updatedAt": "2022-05-23T16:22:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846iQAn",
          "commit": {
            "abbreviatedOid": "1b00ba4"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-23T16:22:38Z",
          "updatedAt": "2022-05-23T16:22:38Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "Good catch! Updated to use i.e., I think this is more appropriate??",
              "createdAt": "2022-05-23T16:22:38Z",
              "updatedAt": "2022-05-23T16:22:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846jEIz",
          "commit": {
            "abbreviatedOid": "329c9b7"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-23T19:45:16Z",
          "updatedAt": "2022-05-23T19:45:17Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "```suggestion\r\n- [(H_1, msg_1),..., (H_L, msg_L)] (OPTIONAL), a list of generator and message pairs corresponding to messages to be signed. Generators must be G1 points, and the messages must be non-zero scalars mod r. If not supplied, it will default to the empty array (\"[]\").\r\n```\r\n\r\nDo we need the last sentence here?",
              "createdAt": "2022-05-23T19:45:17Z",
              "updatedAt": "2022-05-23T19:47:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846jEcc",
          "commit": {
            "abbreviatedOid": "329c9b7"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-23T19:46:37Z",
          "updatedAt": "2022-05-23T19:46:38Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "```suggestion\r\n- L, is the non-negative integer representing the number of messages to be signed i.e., length([(H_1, msg_1),..., (H_L, msg_L)]).  Note if the list of generator and message pairs are not supplied as an input to this operation, the value of L MUST evaluate to zero (0).\r\n```",
              "createdAt": "2022-05-23T19:46:38Z",
              "updatedAt": "2022-05-23T19:47:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846jEvx",
          "commit": {
            "abbreviatedOid": "329c9b7"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-23T19:47:50Z",
          "updatedAt": "2022-05-23T19:47:50Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "```suggestion\r\n- [(H_1, msg_1),..., (H_L, msg_L)] (OPTIONAL), a list of generator and message pairs corresponding to signed messages. Generators must be G1 points, and the messages must be non-zero scalars mod r. If not supplied, it will default to the empty array (\"[]\").\r\n```",
              "createdAt": "2022-05-23T19:47:50Z",
              "updatedAt": "2022-05-23T19:47:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846jE5Z",
          "commit": {
            "abbreviatedOid": "329c9b7"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-23T19:48:30Z",
          "updatedAt": "2022-05-23T19:48:31Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "```suggestion\r\n- L, is the non-negative integer representing the number of messages to be signed i.e., length([(H_1, msg_1),..., (H_L, msg_L)]). Note if the list of generator and message pairs are not supplied as an input to this operation, the value of L MUST evaluate to zero (0).\r\n```",
              "createdAt": "2022-05-23T19:48:30Z",
              "updatedAt": "2022-05-23T19:48:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846tobn",
          "commit": {
            "abbreviatedOid": "329c9b7"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-25T15:33:54Z",
          "updatedAt": "2022-05-25T15:33:55Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Indeed we don't. Thanks! Updated.",
              "createdAt": "2022-05-25T15:33:54Z",
              "updatedAt": "2022-05-25T15:33:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846tofq",
          "commit": {
            "abbreviatedOid": "329c9b7"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-25T15:34:06Z",
          "updatedAt": "2022-05-25T15:34:06Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "Done.",
              "createdAt": "2022-05-25T15:34:06Z",
              "updatedAt": "2022-05-25T15:34:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846tomh",
          "commit": {
            "abbreviatedOid": "329c9b7"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-25T15:34:23Z",
          "updatedAt": "2022-05-25T15:34:23Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "Thanks! Updated",
              "createdAt": "2022-05-25T15:34:23Z",
              "updatedAt": "2022-05-25T15:34:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846topa",
          "commit": {
            "abbreviatedOid": "329c9b7"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-25T15:34:30Z",
          "updatedAt": "2022-05-25T15:34:30Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "Done!",
              "createdAt": "2022-05-25T15:34:30Z",
              "updatedAt": "2022-05-25T15:34:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846uGJ_",
          "commit": {
            "abbreviatedOid": "417b554"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-25T16:44:40Z",
          "updatedAt": "2022-05-25T16:44:41Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nThroughout the operations of this signature scheme, each message that is signed is paired with a specific generator (point in G1). Specifically, if a generator `H_1` is multiplied with `msg_1` during signing, then `H_1` MUST be multiplied with `msg_1` in all other operations (signature verification, proof generation and proof verification).\r\n```",
              "createdAt": "2022-05-25T16:44:40Z",
              "updatedAt": "2022-05-25T16:44:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846uGc0",
          "commit": {
            "abbreviatedOid": "417b554"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-25T16:45:42Z",
          "updatedAt": "2022-05-25T16:45:42Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "What\u2019s the reason for not supplying any messages?",
              "createdAt": "2022-05-25T16:45:42Z",
              "updatedAt": "2022-05-25T16:45:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846uG5G",
          "commit": {
            "abbreviatedOid": "417b554"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-25T16:47:13Z",
          "updatedAt": "2022-05-25T16:47:14Z",
          "comments": [
            {
              "originalPosition": 98,
              "body": "```suggestion\r\n- U, is the non-negative integer representing the number of un-revealed messages i.e., U = L-R. If no un-revealed messages are supplied as an input to this operation (i.e., if R = L), the value of U MUST evaluate to zero (0).\r\n```",
              "createdAt": "2022-05-25T16:47:14Z",
              "updatedAt": "2022-05-25T16:47:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846zbaJ",
          "commit": {
            "abbreviatedOid": "417b554"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-26T17:30:25Z",
          "updatedAt": "2022-05-26T17:30:26Z",
          "comments": [
            {
              "originalPosition": 98,
              "body": "Thanks! Updated!",
              "createdAt": "2022-05-26T17:30:25Z",
              "updatedAt": "2022-05-26T17:30:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846zdQu",
          "commit": {
            "abbreviatedOid": "417b554"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-26T17:37:05Z",
          "updatedAt": "2022-05-26T17:37:05Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Done! Thanks!",
              "createdAt": "2022-05-26T17:37:05Z",
              "updatedAt": "2022-05-26T17:37:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846znI7",
          "commit": {
            "abbreviatedOid": "417b554"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-26T18:13:59Z",
          "updatedAt": "2022-05-26T18:14:00Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "There is non! other than it is not \"technically required\", after the adoption of the signature domain.\r\n\r\nThat said, there may be use-cases where people want to use the un-linkable presentations part of bbs and not the selective showing one (like OAuth bearer tokens for example??)",
              "createdAt": "2022-05-26T18:13:59Z",
              "updatedAt": "2022-05-26T18:14:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8464kru",
          "commit": {
            "abbreviatedOid": "813d420"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-27T18:03:14Z",
          "updatedAt": "2022-05-27T18:03:15Z",
          "comments": [
            {
              "originalPosition": 253,
              "body": "Currently unused, but I guess it will be when the revealed messages and indexes are hashed",
              "createdAt": "2022-05-27T18:03:14Z",
              "updatedAt": "2022-05-27T18:03:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8464lCb",
          "commit": {
            "abbreviatedOid": "813d420"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-27T18:04:46Z",
          "updatedAt": "2022-05-27T18:04:47Z",
          "comments": [
            {
              "originalPosition": 333,
              "body": "*ProofVerify",
              "createdAt": "2022-05-27T18:04:47Z",
              "updatedAt": "2022-05-27T18:04:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8464l_x",
          "commit": {
            "abbreviatedOid": "813d420"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-27T18:08:00Z",
          "updatedAt": "2022-05-27T18:08:00Z",
          "comments": [
            {
              "originalPosition": 335,
              "body": "It seems a bit more natural to use (index, message) to me given that in many languages that makes the list naturally sortable, sorting by the first and then the second element",
              "createdAt": "2022-05-27T18:08:00Z",
              "updatedAt": "2022-05-27T18:08:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8464mgL",
          "commit": {
            "abbreviatedOid": "813d420"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-27T18:10:21Z",
          "updatedAt": "2022-05-27T18:10:21Z",
          "comments": [
            {
              "originalPosition": 418,
              "body": "Shadows the previous `generators` variable",
              "createdAt": "2022-05-27T18:10:21Z",
              "updatedAt": "2022-05-27T18:10:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8464nBO",
          "commit": {
            "abbreviatedOid": "813d420"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-27T18:12:40Z",
          "updatedAt": "2022-05-27T18:12:40Z",
          "comments": [
            {
              "originalPosition": 412,
              "body": "This should probably remain near the beginning?",
              "createdAt": "2022-05-27T18:12:40Z",
              "updatedAt": "2022-05-27T18:12:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846_G4p",
          "commit": {
            "abbreviatedOid": "9e7f4d4"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-30T18:43:13Z",
          "updatedAt": "2022-05-30T18:43:13Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Can remove the notion of (REQUIRED) here as all parameters are required",
              "createdAt": "2022-05-30T18:43:13Z",
              "updatedAt": "2022-05-30T18:43:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax847EhfM",
          "commit": {
            "abbreviatedOid": "9e7f4d4"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-31T19:20:37Z",
          "updatedAt": "2022-05-31T19:20:37Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "There is only one parameter that i know of that is optional (`key_info`  in KeyGen). Although everything else are required, it may be inconsistent to not define them as such because of that one parameter??",
              "createdAt": "2022-05-31T19:20:37Z",
              "updatedAt": "2022-05-31T19:20:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax847EhuB",
          "commit": {
            "abbreviatedOid": "9e7f4d4"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-31T19:21:31Z",
          "updatedAt": "2022-05-31T19:21:32Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "I'm happy to make the change if people thing that to not be that big of an issue.",
              "createdAt": "2022-05-31T19:21:32Z",
              "updatedAt": "2022-05-31T19:21:32Z"
            }
          ]
        }
      ]
    },
    {
      "number": 140,
      "id": "PR_kwDOF8lax8430euF",
      "title": "Change q to r",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/140",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Change the notation from `q` to `r` for the G1 and G2 order, for consistency with specs like bls-signatures, pfc etc.",
      "createdAt": "2022-05-14T10:08:52Z",
      "updatedAt": "2022-05-16T19:37:54Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "c3c65347050125751165dd627e7d52f029d143f5",
      "headRepository": "BasileiosKal/bbs-signature",
      "headRefName": "notation-update",
      "headRefOid": "1fc045340442058bc266db2709e94f3bb0e8211d",
      "closedAt": "2022-05-16T19:37:54Z",
      "mergedAt": "2022-05-16T19:37:54Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "170c0463d8ed75c9d8ba5eab1f67f7391c8e820a"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "For context, academia often denotes modular arithmetic with `q` however the BLS signatures draft and and pairing friendly drafts use `r`, given this draft references those directly it is more important to be consistent with these rather than academia.",
          "createdAt": "2022-05-16T19:37:17Z",
          "updatedAt": "2022-05-16T19:37:17Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Multiple approvals, discussed on WG call, merging",
          "createdAt": "2022-05-16T19:37:48Z",
          "updatedAt": "2022-05-16T19:37:48Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax846AGK2",
          "commit": {
            "abbreviatedOid": "1fc0453"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-14T22:16:51Z",
          "updatedAt": "2022-05-14T22:16:51Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax846E-rn",
          "commit": {
            "abbreviatedOid": "1fc0453"
          },
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "I'm more used to seeing `q` for scalar arithmetic, but I'm ok to use `r` to be consistent with the BLS spec.",
          "createdAt": "2022-05-16T18:17:34Z",
          "updatedAt": "2022-05-16T18:17:34Z",
          "comments": []
        }
      ]
    },
    {
      "number": 142,
      "id": "PR_kwDOF8lax8435a3k",
      "title": "Use of hash_to_scalar",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/142",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Update the spec to use hash_to_scalar where needed. Fixes #89\r\n\r\n### Note:\r\nThe way that random elements are generated in ProofGen will change. Right now, each element is generated by calling a PRF for each one separately. The proposed alternative is to call the PRF once and use the result as a seed to an XOF (in hash_to_scalar). The reasons are two: \r\n1. We can replace the PRF with a seed that will be passed as an argument to the ProofGen function. This will help with test vectors, and we can make a requirement that this seed will be the output of a PRF in any other situation aside from testing. \r\n2. The proposed alternative is more efficient and since we already assume that the XOF is secure (otherwise the deterministic signatures will be insecure), we will not have to change our security model when it comes to the XOF. \r\n\r\nMy question is: Is there a reason to avoid this route?? Is there any security reason for which we would not want to use this alternative??\r\n\r\nAlso, e and s generation is not changed because PR #135 proposes an alternative.\r\n",
      "createdAt": "2022-05-16T17:50:58Z",
      "updatedAt": "2022-05-23T18:11:21Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "49b0b3aeeeeabcb41331f1af107182e13d60513c",
      "headRepository": "BasileiosKal/bbs-signature",
      "headRefName": "hash-to-scalar-usage",
      "headRefOid": "6bedd7f136b0d9abbd193dd3f860221a3a2e00cd",
      "closedAt": "2022-05-23T18:11:21Z",
      "mergedAt": "2022-05-23T18:11:20Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "7568d6a95044c12f75e5ef19077eb5a7f6046063"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Looking good to me as a direction, few tweaks based on the merging of #140, also looks like there are conflicts to resolve",
          "createdAt": "2022-05-17T00:13:29Z",
          "updatedAt": "2022-05-17T00:13:29Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Looking good to me as a direction, few tweaks based on the merging of #140, also looks like there are conflicts to resolve",
          "createdAt": "2022-05-17T00:13:29Z",
          "updatedAt": "2022-05-17T00:13:29Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Conflicts also need to be resolved.",
          "createdAt": "2022-05-20T01:54:57Z",
          "updatedAt": "2022-05-20T01:54:57Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Multiple reviews and approvals, open 7 days, merging.",
          "createdAt": "2022-05-23T18:11:16Z",
          "updatedAt": "2022-05-23T18:11:16Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax846GJWp",
          "commit": {
            "abbreviatedOid": "4ebc70c"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-17T00:10:59Z",
          "updatedAt": "2022-05-17T00:10:59Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "```suggestion\r\n7.      element = OS2IP(h.read(xof_no_of_bytes)) mod r\r\n```\r\n```suggestion\r\n7.      element = OS2IP(h.read(xof_no_of_bytes)) mod q\r\n```",
              "createdAt": "2022-05-17T00:10:59Z",
              "updatedAt": "2022-05-17T00:10:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846GJWq",
          "commit": {
            "abbreviatedOid": "4ebc70c"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-17T00:10:59Z",
          "updatedAt": "2022-05-17T00:10:59Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "```suggestion\r\n7.      element = OS2IP(h.read(xof_no_of_bytes)) mod r\r\n```\r\n```suggestion\r\n7.      element = OS2IP(h.read(xof_no_of_bytes)) mod q\r\n```",
              "createdAt": "2022-05-17T00:10:59Z",
              "updatedAt": "2022-05-17T00:10:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846GJgz",
          "commit": {
            "abbreviatedOid": "4ebc70c"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-17T00:12:22Z",
          "updatedAt": "2022-05-17T00:12:23Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "```suggestion\r\n9. (r1, r2, e~, r2~, r3~, s~) = hash_to_scalar(PRF(8*ceil(log2(r))), 6)\r\n```\r\n```suggestion\r\n9. (r1, r2, e~, r2~, r3~, s~) = hash_to_scalar(PRF(8*ceil(log2(q))), 6)\r\n```",
              "createdAt": "2022-05-17T00:12:22Z",
              "updatedAt": "2022-05-17T00:12:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846GJg0",
          "commit": {
            "abbreviatedOid": "4ebc70c"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-17T00:12:22Z",
          "updatedAt": "2022-05-17T00:12:23Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "```suggestion\r\n9. (r1, r2, e~, r2~, r3~, s~) = hash_to_scalar(PRF(8*ceil(log2(r))), 6)\r\n```\r\n```suggestion\r\n9. (r1, r2, e~, r2~, r3~, s~) = hash_to_scalar(PRF(8*ceil(log2(q))), 6)\r\n```",
              "createdAt": "2022-05-17T00:12:22Z",
              "updatedAt": "2022-05-17T00:12:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846GJhw",
          "commit": {
            "abbreviatedOid": "4ebc70c"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-17T00:12:29Z",
          "updatedAt": "2022-05-17T00:12:30Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "```suggestion\r\n10. (m~_j1, ..., m~_jU) =  hash_to_scalar(PRF(8*ceil(log2(r))), U)\r\n```\r\n```suggestion\r\n10. (m~_j1, ..., m~_jU) =  hash_to_scalar(PRF(8*ceil(log2(q))), U)\r\n```",
              "createdAt": "2022-05-17T00:12:29Z",
              "updatedAt": "2022-05-17T00:12:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846GJhx",
          "commit": {
            "abbreviatedOid": "4ebc70c"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-17T00:12:29Z",
          "updatedAt": "2022-05-17T00:12:30Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "```suggestion\r\n10. (m~_j1, ..., m~_jU) =  hash_to_scalar(PRF(8*ceil(log2(r))), U)\r\n```\r\n```suggestion\r\n10. (m~_j1, ..., m~_jU) =  hash_to_scalar(PRF(8*ceil(log2(q))), U)\r\n```",
              "createdAt": "2022-05-17T00:12:29Z",
              "updatedAt": "2022-05-17T00:12:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846GJi6",
          "commit": {
            "abbreviatedOid": "4ebc70c"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-17T00:12:39Z",
          "updatedAt": "2022-05-17T00:12:40Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "```suggestion\r\n12. r3 = r1 ^ -1 mod r\r\n```\r\n```suggestion\r\n12. r3 = r1 ^ -1 mod q\r\n```",
              "createdAt": "2022-05-17T00:12:39Z",
              "updatedAt": "2022-05-17T00:12:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846GJi7",
          "commit": {
            "abbreviatedOid": "4ebc70c"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-17T00:12:39Z",
          "updatedAt": "2022-05-17T00:12:40Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "```suggestion\r\n12. r3 = r1 ^ -1 mod r\r\n```\r\n```suggestion\r\n12. r3 = r1 ^ -1 mod q\r\n```",
              "createdAt": "2022-05-17T00:12:39Z",
              "updatedAt": "2022-05-17T00:12:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846YAvJ",
          "commit": {
            "abbreviatedOid": "dbd8d4c"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-19T23:47:16Z",
          "updatedAt": "2022-05-19T23:47:16Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "I think we should update computing e and s too as #135 is un-likely to be merged in its current form",
              "createdAt": "2022-05-19T23:47:16Z",
              "updatedAt": "2022-05-19T23:47:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846eVzq",
          "commit": {
            "abbreviatedOid": "dbd8d4c"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-22T23:43:00Z",
          "updatedAt": "2022-05-22T23:43:00Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Yeap! Done!",
              "createdAt": "2022-05-22T23:43:00Z",
              "updatedAt": "2022-05-22T23:43:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846emMB",
          "commit": {
            "abbreviatedOid": "6bedd7f"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Nice simplification across the board",
          "createdAt": "2022-05-23T03:18:15Z",
          "updatedAt": "2022-05-23T03:18:15Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax846itb3",
          "commit": {
            "abbreviatedOid": "6bedd7f"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-23T18:10:35Z",
          "updatedAt": "2022-05-23T18:10:35Z",
          "comments": []
        }
      ]
    },
    {
      "number": 144,
      "id": "PR_kwDOF8lax844ES9B",
      "title": "Rework Introduction",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/144",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Changes scoped proofs to proof of possession and generalizes some of the language around the core schemes properties",
      "createdAt": "2022-05-18T23:47:51Z",
      "updatedAt": "2022-05-20T05:54:36Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "85a1036b5a0ac8dbec42655798d61274937d21d7",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/pop",
      "headRefOid": "537e987d42c1b086180adbbde13b79d9193e1721",
      "closedAt": "2022-05-20T05:54:33Z",
      "mergedAt": "2022-05-20T05:54:33Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "593bf560b5428af5938e0f26c3a609ffcdf19016"
      },
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Some minor comments. Also, should we maybe also add something for the always revealed messages?? Maybe something like:\r\n\r\n**Always Revealed Messages** Aside from messages that a prover can elect to either disclose or keep un-revealed when creating a proof, the signer can indicate messages that the prover will be forced to always reveal. Those messages can include protected headers, signature metadata and any other information that the prover should not be able to keep un-disclosed, for the security of the protocol using BBS+.\r\n",
          "createdAt": "2022-05-19T20:16:38Z",
          "updatedAt": "2022-05-19T20:22:59Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Multiple approvals, purely editorial, merging.",
          "createdAt": "2022-05-20T05:54:29Z",
          "updatedAt": "2022-05-20T05:54:29Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax846SIql",
          "commit": {
            "abbreviatedOid": "2a9dc61"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-19T01:59:02Z",
          "updatedAt": "2022-05-19T02:00:58Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Should we be using messages instead of payloads?",
              "createdAt": "2022-05-19T01:59:02Z",
              "updatedAt": "2022-05-19T02:00:58Z"
            },
            {
              "originalPosition": 16,
              "body": "*possession :)",
              "createdAt": "2022-05-19T02:00:31Z",
              "updatedAt": "2022-05-19T02:00:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846SKWl",
          "commit": {
            "abbreviatedOid": "2a9dc61"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-19T02:14:04Z",
          "updatedAt": "2022-05-19T02:14:04Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "```suggestion\r\n**Proof of Possession** - The proofs generated by the scheme prove to a verifier that the party who generated the proof (prover) was in possession of a signature without revealing it. Because the scheme also supports binding a presentation header to the generated proof it makes the scheme suitable as a proof of possession protocol. Note the presentation header can include arbitrary information such as a cryptographic nonce and or an audience/domain identifier to ensure the generated proof can only be used appropriately, including providing a way for a verifier to detect a replay attack.\r\n```",
              "createdAt": "2022-05-19T02:14:04Z",
              "updatedAt": "2022-05-19T02:14:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846SKY-",
          "commit": {
            "abbreviatedOid": "2a9dc61"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-19T02:14:23Z",
          "updatedAt": "2022-05-19T02:14:23Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Yeap sure good catch",
              "createdAt": "2022-05-19T02:14:23Z",
              "updatedAt": "2022-05-19T02:14:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846SKcV",
          "commit": {
            "abbreviatedOid": "2a9dc61"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-19T02:14:50Z",
          "updatedAt": "2022-05-19T02:14:50Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "```suggestion\r\n**Selective Disclosure** - The scheme allows a signer to sign multiple messages and produce a single output signature. An intermediary (prover) then possessing the messages and the signature can generate a proof whereby they can choose which messages to disclose.\r\n```",
              "createdAt": "2022-05-19T02:14:50Z",
              "updatedAt": "2022-05-19T02:14:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846XOUr",
          "commit": {
            "abbreviatedOid": "054043f"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-19T19:45:02Z",
          "updatedAt": "2022-05-19T20:13:31Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "```suggestion\r\n**Unlinkable Proof Presentations** - The proofs generated by the scheme are known as zero-knowledge, proofs-of-knowledge of the signature, meaning a verifying party in receipt of a proof is unable to determine which signature was used to generate the proof, removing a common source of correlation. In general each proof generated is indistinguishable from random even for two proofs generated from the same signature.\r\n```\r\nAlthough terminology it's not 100% consistent even in research i think that the proof-of-knowledge does not by itself guarantee un-likability. The above description may be more accurate.",
              "createdAt": "2022-05-19T19:45:02Z",
              "updatedAt": "2022-05-19T20:13:31Z"
            },
            {
              "originalPosition": 8,
              "body": "```suggestion\r\n**Selective Disclosure** - The scheme allows a signer (issuer) to sign multiple messages and produce a single -constant size- output signature. An intermediary (prover) then possessing the messages and the signature can generate a proof whereby they can choose which messages to disclose, while leaking no-information about the un-disclosed messages. The proof itself guarantees the integrity and authenticity of the disclosed messages (e.g., that they were originally signed by the issuer).\r\n```\r\nJust some thoughts.",
              "createdAt": "2022-05-19T19:45:11Z",
              "updatedAt": "2022-05-19T22:44:22Z"
            },
            {
              "originalPosition": 16,
              "body": "```suggestion\r\n**Proof of Possession** - The proofs generated by the scheme prove to a verifier that the party who generated the proof (prover) was in possession of a signature without revealing it. The scheme also supports binding a presentation header to the generated proof. The presentation header can include arbitrary information such as a cryptographic nonce, an audience/domain identifier to ensure the generated proof can only be used appropriately, including providing a way for a verifier to detect a replay attack, or any other information a protocol may require to be cryptographically tied to a proof.\r\n```\r\nSince the BBS+ proof is by definition a proof of possession protocol even without the presentation header the above could be a litle less confusing??",
              "createdAt": "2022-05-19T20:13:14Z",
              "updatedAt": "2022-05-19T20:13:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846Xk2j",
          "commit": {
            "abbreviatedOid": "054043f"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-19T21:00:20Z",
          "updatedAt": "2022-05-19T21:00:20Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Can we tweak the language from revealed -> disclosed?",
              "createdAt": "2022-05-19T21:00:20Z",
              "updatedAt": "2022-05-19T21:00:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846Xl1K",
          "commit": {
            "abbreviatedOid": "1edc30a"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-19T21:04:32Z",
          "updatedAt": "2022-05-19T21:04:32Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Agreed",
              "createdAt": "2022-05-19T21:04:32Z",
              "updatedAt": "2022-05-19T21:04:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846X5Fo",
          "commit": {
            "abbreviatedOid": "054043f"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-19T22:44:46Z",
          "updatedAt": "2022-05-19T22:44:46Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Yeap! Updated the suggestion",
              "createdAt": "2022-05-19T22:44:46Z",
              "updatedAt": "2022-05-19T22:44:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846X6W8",
          "commit": {
            "abbreviatedOid": "81b3242"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-19T22:53:57Z",
          "updatedAt": "2022-05-19T22:53:58Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "```suggestion\r\n**Selective Disclosure** - The scheme allows a signer (issuer) to sign multiple messages and produce a single -constant size- output signature. An intermediary (prover) then possessing the messages and the signature can generate a proof whereby they can choose which messages to disclose, while leaking no-information about the un-disclosed messages. The proof itself guarantees the integrity and authenticity of the disclosed messages (e.g. that they were originally signed by the issuer).\r\n```",
              "createdAt": "2022-05-19T22:53:57Z",
              "updatedAt": "2022-05-19T22:53:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846YDvt",
          "commit": {
            "abbreviatedOid": "537e987"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2022-05-20T00:15:00Z",
          "updatedAt": "2022-05-20T00:15:00Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax846YifD",
          "commit": {
            "abbreviatedOid": "537e987"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-20T04:44:02Z",
          "updatedAt": "2022-05-20T04:44:02Z",
          "comments": []
        }
      ]
    },
    {
      "number": 145,
      "id": "PR_kwDOF8lax844GxzD",
      "title": "Minor tweak to CreateGenerators",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/145",
      "state": "CLOSED",
      "author": "alessandroguggino",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I found the same issue as @christianpaquin in #139, and I hope this helps a little bit to make it clearer.",
      "createdAt": "2022-05-19T09:28:22Z",
      "updatedAt": "2022-06-27T09:07:25Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "85a1036b5a0ac8dbec42655798d61274937d21d7",
      "headRepository": "alessandroguggino/bbs-signature",
      "headRefName": "creategenerators",
      "headRefOid": "57a97b2091ca584d175424f9444bae730bbbcb13",
      "closedAt": "2022-06-21T08:21:49Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "`message_generator_seed` appears in more places in the spec, so it wouldn't be sufficient to only modify the `CreateGenerators` section. I'd rather keep this name, however, and replace the variable name in `h = xof(seed)`.",
          "createdAt": "2022-05-19T19:22:52Z",
          "updatedAt": "2022-05-19T19:22:52Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Thanks for the PR, I would rather clarify in the ciphersuite definition how H_d and H_s are computed by using this function alongside this change, I will file a seperate PR to do so",
          "createdAt": "2022-05-19T23:49:58Z",
          "updatedAt": "2022-05-19T23:49:58Z"
        },
        {
          "author": "alessandroguggino",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> `message_generator_seed` appears in more places in the spec, so it wouldn't be sufficient to only modify the `CreateGenerators` section. \r\n\r\nI think that `message_generator_seed` is a specific seed for message generators H, while `CreateGenerators` is a generic function used to get H_s and H_d too. That's why I changed the input as seed and added a line in the description.\r\n\r\n> I would rather clarify in the ciphersuite definition how H_d and H_s are computed\r\n\r\nYou are right, I should have added them in the list. If you are going to do it, is ok! Otherwise, I'm available.\r\n\r\nThanks!\r\n\r\n",
          "createdAt": "2022-05-20T08:09:34Z",
          "updatedAt": "2022-05-20T08:09:34Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Related to #161 ",
          "createdAt": "2022-06-01T07:43:24Z",
          "updatedAt": "2022-06-01T07:43:24Z"
        },
        {
          "author": "alessandroguggino",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think I can close this PR after the merge of a new `create_generators`",
          "createdAt": "2022-06-21T08:21:49Z",
          "updatedAt": "2022-06-21T08:21:49Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax846YGxS",
          "commit": {
            "abbreviatedOid": "a32e5f7"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-20T00:46:24Z",
          "updatedAt": "2022-05-20T00:46:24Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax846eLte",
          "commit": {
            "abbreviatedOid": "a32e5f7"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Minor nit. LGTM otherwise! Thanks!",
          "createdAt": "2022-05-22T15:53:19Z",
          "updatedAt": "2022-05-22T15:54:01Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "```suggestion\r\nIt is used to compute the set of message generators (`H_1`, `H_2`, etc.,), the signature blinding value generator (`H_s`), and the signature domain generator (`H_d`).\r\n```\r\nI think we don't use the generators as part of a list any more (for what i know of at least. In any place that we do is left over by older versions). I think this more is accurate in the current notation. Also, we ended up calling the \"domain separation tag\" just \"domain\" if I'm not mistaken.",
              "createdAt": "2022-05-22T15:53:19Z",
              "updatedAt": "2022-05-22T18:04:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846fTWv",
          "commit": {
            "abbreviatedOid": "a32e5f7"
          },
          "author": "alessandroguggino",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-23T07:51:25Z",
          "updatedAt": "2022-05-23T07:51:25Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Thank you! Then should we also edit the seed named `signature_dst_generator_seed` in the Ciphersuite section?",
              "createdAt": "2022-05-23T07:51:25Z",
              "updatedAt": "2022-05-23T07:51:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846iCLu",
          "commit": {
            "abbreviatedOid": "a32e5f7"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-23T15:46:02Z",
          "updatedAt": "2022-05-23T15:46:02Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "That's a good point! Made the update in #152. Thanks!",
              "createdAt": "2022-05-23T15:46:02Z",
              "updatedAt": "2022-05-23T15:46:02Z"
            }
          ]
        }
      ]
    },
    {
      "number": 147,
      "id": "PR_kwDOF8lax844JvbE",
      "title": "Update point serialization/de-serialization rules",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/147",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Fixes #146",
      "createdAt": "2022-05-19T22:26:02Z",
      "updatedAt": "2022-05-20T02:56:03Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "85a1036b5a0ac8dbec42655798d61274937d21d7",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/update-octet-to-point",
      "headRefOid": "1849b54bb40f675aeead658e289dcfe5949384a2",
      "closedAt": "2022-05-20T02:55:57Z",
      "mergedAt": "2022-05-20T02:55:56Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "60c88166c3e1ee9e7dda14f6b4fbb870c2e92f5e"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@christianpaquin ",
          "createdAt": "2022-05-19T22:26:19Z",
          "updatedAt": "2022-05-19T22:26:19Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think that the last step of `SkToPk` should also be updated to `point_to_octets_g2`. First step of `SignatureToOctets` should be `point_to_octets_g1`. Otherwise LGTM.",
          "createdAt": "2022-05-20T00:12:24Z",
          "updatedAt": "2022-05-20T00:12:24Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "> I think that the last step of SkToPk should also be updated to point_to_octets_g2. First step of SignatureToOctets should be point_to_octets_g1. Otherwise LGTM.\r\n\r\nGood catch, addressed",
          "createdAt": "2022-05-20T00:47:03Z",
          "updatedAt": "2022-05-20T00:47:03Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Multiple approvals, merging.",
          "createdAt": "2022-05-20T02:55:07Z",
          "updatedAt": "2022-05-20T02:55:07Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax846X2pX",
          "commit": {
            "abbreviatedOid": "3626777"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-19T22:26:55Z",
          "updatedAt": "2022-05-19T22:26:56Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "```suggestion\r\n: returns the point P for the respective subgroup corresponding to the canonical representation ostr, or INVALID if ostr is not a valid output of the respective point\\_to\\_octets_g* function.  This operation is also known as deserialization.\r\n```",
              "createdAt": "2022-05-19T22:26:55Z",
              "updatedAt": "2022-05-19T22:26:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846X3z5",
          "commit": {
            "abbreviatedOid": "af5fb3e"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-19T22:35:10Z",
          "updatedAt": "2022-05-19T22:35:32Z",
          "comments": [
            {
              "originalPosition": 81,
              "body": "```suggestion\r\n: follows the format documented in Appendix C section 1 of [@!I-D.irtf-cfrg-pairing-friendly-curves] for the G1 subgroup, using compression (i.e., setting C\\_bit = 1).\r\n```\r\nI think we are using compression in the spec to this point. We can always fall back if need be.",
              "createdAt": "2022-05-19T22:35:10Z",
              "updatedAt": "2022-05-19T22:35:32Z"
            },
            {
              "originalPosition": 84,
              "body": "```suggestion\r\n: follows the format documented in Appendix C section 1 of [@!I-D.irtf-cfrg-pairing-friendly-curves] for the G2 subgroup, using compression (i.e., setting C\\_bit = 1).\r\n```",
              "createdAt": "2022-05-19T22:35:28Z",
              "updatedAt": "2022-05-19T22:35:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846X-QD",
          "commit": {
            "abbreviatedOid": "820c31e"
          },
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-19T23:26:10Z",
          "updatedAt": "2022-05-19T23:26:10Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax846YP4N",
          "commit": {
            "abbreviatedOid": "1849b54"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-20T01:59:19Z",
          "updatedAt": "2022-05-20T01:59:19Z",
          "comments": []
        }
      ]
    },
    {
      "number": 149,
      "id": "PR_kwDOF8lax844Mcih",
      "title": "Fixed typo in KeyValidate; subgroup_check(A -> W)",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/149",
      "state": "MERGED",
      "author": "christianpaquin",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-05-20T14:22:46Z",
      "updatedAt": "2022-05-20T22:35:33Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "593bf560b5428af5938e0f26c3a609ffcdf19016",
      "headRepository": "christianpaquin/bbs-signature",
      "headRefName": "subgroup_check_typo",
      "headRefOid": "5803bd83035a462bef85562da1c5f3652e7b7ef6",
      "closedAt": "2022-05-20T22:35:33Z",
      "mergedAt": "2022-05-20T22:35:32Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "49b0b3aeeeeabcb41331f1af107182e13d60513c"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Minor editorial nit, merging",
          "createdAt": "2022-05-20T22:35:28Z",
          "updatedAt": "2022-05-20T22:35:28Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax846buSk",
          "commit": {
            "abbreviatedOid": "5803bd8"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-20T15:58:22Z",
          "updatedAt": "2022-05-20T15:58:22Z",
          "comments": []
        }
      ]
    },
    {
      "number": 151,
      "id": "PR_kwDOF8lax844PN0X",
      "title": "Alternative hash_to_scalar without an xof",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/151",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "First shot in a `hash_to_scalar_xmd` function to be used with regular hashes as an alternative to the one currently in the spec (that uses an xof). The proposed function essentially makes use of `expand_message_xmd` (not called directly, see below why), and will give a less efficient option for implementers not wishing to make use of shake256.\r\n\r\nComparison with `hash_to_field` and `expand_message_xmd`:\r\n1.\t**Memory efficiency**: `hash_to_field` will call `expand_message` once to output the total number of bytes needed for all the outputted elements. Since we may potentially need to create many scalars, this may not be the more efficient approach. For example, if one wants to create a proof with 1000 hidden messages, the output of `expand_message` will need to be at least 64 kb. In contrast, `hash_to_scalar_xmd` will only need to \u201chold\u201d 64 bytes at once. Note that the total number of hash invocations is the same in both cases, so the computational overhead will effectively be zero.\r\n2.\t**Efficiently checking if a scalar is 0**: Although there are discussions on not overengineering the spec, I feel here is the one place we may need to have the check. The reason is that many signed messages may result to the probability of returning a 0 been higher than what we anticipate (not really an issue for bls12-381 but may become an issue for \u201csmaller\u201d ECs).\r\n3.\tCalling `expand_message_xmd` directly instead of the xof would be wasteful (it would result to at least n-1 unnecessary hash computations for b_0)\r\n\r\nAnother option can be to use hkdf instead. The tradeoff here is double the hash computations vs spec simplicity + the wider availability of hkdf.\r\n",
      "createdAt": "2022-05-21T20:26:35Z",
      "updatedAt": "2022-06-24T03:16:53Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "5d8ec5a086046be0bce4c9d75defab2963a2a584",
      "headRepository": "BasileiosKal/bbs-signature",
      "headRefName": "hash_to_scalar_xmd",
      "headRefOid": "d51d9908bac8912105dc5dab297ef265c19fa5e5",
      "closedAt": "2022-06-24T03:16:53Z",
      "mergedAt": "2022-06-24T03:16:53Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "c7ffa999b125af00bd284dba6c1a953adb6dc149"
      },
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If the memory usage turns out to not be an issue the operation can be significantly simplified to something like,\r\n\r\n```\r\nresult = hash_to_scalar_xmd(msg, n)\r\n\r\nProcedure:\r\n\r\n1. msg_hash= hash(msg || I2OSP(0, 1) || I2OSP(n, 8))\r\n\r\n2. (scalar_1, ..., scalar_n) = hash_to_field(msg_hash, n)\r\n\r\n3. if 0 in (scalar_1, ..., scalar_n):\r\n\r\n4.     msg_hash = hash(msg_hash)\r\n\r\n5.     go back to step 2\r\n\r\n6. return (scalar_1, ..., scalar_n)\r\n```",
          "createdAt": "2022-05-21T20:32:42Z",
          "updatedAt": "2022-05-21T20:32:42Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Updated to use the `range(a, b)` notation introduced to #155.",
          "createdAt": "2022-06-01T19:21:45Z",
          "updatedAt": "2022-06-01T19:21:45Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> If the memory usage turns out to not be an issue the operation can be significantly simplified to something like,\r\n> \r\n> ```\r\n> result = hash_to_scalar_xmd(msg, n)\r\n> \r\n> Procedure:\r\n> \r\n> 1. msg_hash= hash(msg || I2OSP(0, 1) || I2OSP(n, 8))\r\n> \r\n> 2. (scalar_1, ..., scalar_n) = hash_to_field(msg_hash, n)\r\n> \r\n> 3. if 0 in (scalar_1, ..., scalar_n):\r\n> \r\n> 4.     msg_hash = hash(msg_hash)\r\n> \r\n> 5.     go back to step 2\r\n> \r\n> 6. return (scalar_1, ..., scalar_n)\r\n> ```\r\n\r\nLooking again, I think this may be the better option. There's no actual requirement for the hash_to_field implementation to output all of the bytes before generating the scalars, in fact the bls12-381 implementation does it iteratively: https://github.com/zkcrypto/bls12_381/blob/34dab74ae44cd77dfa867928dd2e6c8383d8dc9d/src/hash_to_curve/mod.rs#L50\r\n\r\nWe could even use the same method for both XOF and XMD modes and eliminate the separate versions, short-circuiting and restarting if a zero scalar is found (which is unlikely anyway) by using a slightly modified version of hash_to_field. (Edit) Here's what that might look like:\r\n\r\n```\r\nmsg_prime = msg || I2OSP(0, 1) || I2OSP(count, 8)\r\nlen_in_bytes = count * expand_length\r\nuniform_bytes = expand_message(msg_prime, hash_to_scalar_dst, len_in_bytes)\r\nfor i in range(1, count):\r\n  tv = uniform_bytes[expand_length*(i-1)..expand_length*i]\r\n  scalar_i = OS2IP(tv) mod r\r\n  if scalar_i == 0:\r\n  \treturn hash_to_scalar(uniform_bytes, count)\r\nreturn (scalar_1, ..., scalar_(count))\r\n```",
          "createdAt": "2022-06-17T01:14:51Z",
          "updatedAt": "2022-06-17T01:37:53Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think i prefer to directly use hash-to-field if we are to go the simpler round. If we assume an optimized implementation then this is much easier to be achieved if someone uses (an optimized) hash-to-field, rather than requiring from a bbs+ implementer to efficiently use an optimized expand-message. We can achieve the same effect of only one operation by just hashing the original message and trying again (as in my [original suggestion](https://github.com/decentralized-identity/bbs-signature/pull/151#issuecomment-1133764513)).\r\n\r\nBut let\u2019s discuss this more in the WG call :)",
          "createdAt": "2022-06-20T17:23:31Z",
          "updatedAt": "2022-06-20T17:24:44Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed on WG call, the current sentiment is to restructure the hash to scalar procedure to either use hash_to_field or expand_message to accomplish the same functionality but in a simpler manner. See above for the two proposals from @BasileiosKal and @andrewwhitehead respectively.",
          "createdAt": "2022-06-20T18:26:26Z",
          "updatedAt": "2022-06-20T18:26:26Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed on WG call, resolved to move to the hash_to_field based approach suggested by @BasileiosKal, however a slightly modified procedure to use a counter instead of hash if a zero scalar value is encountered. \r\n\r\nMore generally it was also discussed that we should open a tracking issue to determine whether we want to support rejection sampling in general across the spec for procedures that involve generating scalars. There is guidance in the hash to curve draft that advises against this style of check (e.g checking that a generated scalar value is zero) so we may revise to line up with that guidance because the probability is so low.",
          "createdAt": "2022-06-20T18:44:37Z",
          "updatedAt": "2022-06-20T18:44:37Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "After some more thought, a potentially annoying issue is that using `hash_to_field` will require defining 2 h2c ciphersuites, one for the xof and one for the xmd version of `expand_message`. The reason is that the h2c spec only defines suites where the `field` in `hash_to_field` is the base field of the EC itself and not the scalars mod r (that we need). This matters because we would then \"mod\" with the wrong prime (i.e.,  not r).\r\n\r\nAny thoughts here?? @andrewwhitehead, @tplooker?? If not, I may move with [Andrew\u2019s proposal](https://github.com/decentralized-identity/bbs-signature/pull/151#issuecomment-1158367638) to avoid this issue.",
          "createdAt": "2022-06-20T22:58:59Z",
          "updatedAt": "2022-06-20T22:58:59Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@BasileiosKal  The H2C spec does say this..\r\n\r\n> The hash_to_field function is also suitable for securely hashing to scalars.  For example, when hashing to the scalar field for an elliptic curve (sub)group with prime order r, it suffices to instantiate hash_to_field with target field GF(r).\r\n\r\nHowever, I'm not sure if we can guarantee that a particular H2C implementation has support for this operation.\r\n\r\nAlso this doesn't work if we want to support the reduced-memory iterative version: `return hash_to_scalar(uniform_bytes, count)`",
          "createdAt": "2022-06-20T23:23:24Z",
          "updatedAt": "2022-06-20T23:26:16Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "> After some more thought, a potentially annoying issue is that using hash_to_field will require defining 2 h2c ciphersuites, one for the xof and one for the xmd version of expand_message. The reason is that the h2c spec only defines suites where the field in hash_to_field is the base field of the EC itself and not the scalars mod r (that we need). This matters because we would then \"mod\" with the wrong prime (i.e., not r).\r\n\r\nOn the flip side would this not make the BBS signature ciphersuite definition simpler e.g just a single reference to h2c ciphersuite for all underlying operations?",
          "createdAt": "2022-06-21T00:22:43Z",
          "updatedAt": "2022-06-21T00:22:43Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> However, I'm not sure if we can guarantee that a particular H2C implementation has support for this operation.\r\n\r\nYea those are my worries as well. We can define the \"correct\" field for `hash-to-field` but there are some implementations that don't support Fr (like [blst](https://github.com/supranational/blst/blob/master/src/hash_to_field.c#L150). Other libs, like [nodle-bls12-381](https://github.com/paulmillr/noble-bls12-381/blob/main/index.ts#L286) and the[ rust crate](https://github.com/zkcrypto/bls12_381/blob/main/src/hash_to_curve/map_scalar.rs) do support this though).\r\n\r\n> On the flip side would this not make the BBS signature ciphersuite definition simpler e.g just a single reference to h2c ciphersuite for all underlying operations?\r\n\r\nThat\u2019s definitely true! However, as Andrew noted, an issue is that not all libraries have support for the operations we need. So we can create the suites, but we may raise the implementation barrier doing so.\r\n\r\nAnother issue is that we can't just define a different hash-to-field that mods r because we need the mod p to create the generators (i.e., for hash-to-curve). So this can be confusing to implementers (essentially we need two different versions of hash-to-field, one that mods p for create-generators and one that mods r for hash-to-scalar).",
          "createdAt": "2022-06-21T17:53:47Z",
          "updatedAt": "2022-06-21T18:05:36Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ok! i gave it a shot, based on @andrewwhitehead's [proposal](https://github.com/decentralized-identity/bbs-signature/pull/151#issuecomment-1158367638) of using  `expand-message`. As most libraries have a `mod r` functionality, this would create the lowest implementation barrier + keep the spec simpler. I added a note saying that hash-to-scalar essentially calls hash-to-field for Fr, so if implementers have this available, they can just use that. Also made some updates in the ciphersuites. Thoughts??",
          "createdAt": "2022-06-21T18:03:55Z",
          "updatedAt": "2022-06-21T20:21:10Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Multiple reviews and approvals, discussed on multiple wg calls, merging.",
          "createdAt": "2022-06-24T03:16:49Z",
          "updatedAt": "2022-06-24T03:16:49Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax846iw4b",
          "commit": {
            "abbreviatedOid": "bd89bd2"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-23T18:23:06Z",
          "updatedAt": "2022-05-23T18:23:07Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "```suggestion\r\n### Hashing to scalars\r\n```",
              "createdAt": "2022-05-23T18:23:07Z",
              "updatedAt": "2022-05-23T18:23:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846ixjv",
          "commit": {
            "abbreviatedOid": "bd89bd2"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-23T18:25:58Z",
          "updatedAt": "2022-05-23T18:25:58Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "```suggestion\r\n- r (REQUIRED), non-negative integer. The prime order of the G1 and G2 groups, defined by the ciphersuite.\r\n```",
              "createdAt": "2022-05-23T18:25:58Z",
              "updatedAt": "2022-05-23T18:25:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846uE53",
          "commit": {
            "abbreviatedOid": "d425bdb"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-25T16:40:29Z",
          "updatedAt": "2022-05-25T16:40:29Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "```suggestion\r\n2. `hash_to_scalar_xmd`, is less performant in comparison, requires a fixed length output function like SHA2 or SHA3.\r\n```",
              "createdAt": "2022-05-25T16:40:29Z",
              "updatedAt": "2022-05-25T16:40:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846zXEK",
          "commit": {
            "abbreviatedOid": "d425bdb"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-26T17:16:38Z",
          "updatedAt": "2022-05-26T17:16:39Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "Thanks! Updated!",
              "createdAt": "2022-05-26T17:16:38Z",
              "updatedAt": "2022-05-26T17:16:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8464NUO",
          "commit": {
            "abbreviatedOid": "0ae69de"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-27T17:24:02Z",
          "updatedAt": "2022-05-27T17:24:02Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "hash_to_scalar needs escaping, or maybe say something like \"two different operations for hashing inputs into scalar values\"",
              "createdAt": "2022-05-27T17:24:02Z",
              "updatedAt": "2022-05-27T17:24:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8464NpI",
          "commit": {
            "abbreviatedOid": "0ae69de"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-27T17:25:21Z",
          "updatedAt": "2022-05-27T17:25:22Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "I think SHAKE-256 and SHAKE-128 (with the hyphen) for consistency",
              "createdAt": "2022-05-27T17:25:22Z",
              "updatedAt": "2022-05-27T17:25:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8464Nz3",
          "commit": {
            "abbreviatedOid": "0ae69de"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-27T17:26:08Z",
          "updatedAt": "2022-05-27T17:26:08Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "*indicating",
              "createdAt": "2022-05-27T17:26:08Z",
              "updatedAt": "2022-05-27T17:26:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8464N7f",
          "commit": {
            "abbreviatedOid": "0ae69de"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-27T17:26:40Z",
          "updatedAt": "2022-05-27T17:26:40Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "It seems odd to list cipher suite parameters as required, aren't they all?",
              "createdAt": "2022-05-27T17:26:40Z",
              "updatedAt": "2022-05-27T17:26:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8464Onr",
          "commit": {
            "abbreviatedOid": "0ae69de"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-27T17:29:28Z",
          "updatedAt": "2022-05-27T17:29:29Z",
          "comments": [
            {
              "originalPosition": 71,
              "body": "I think it should return to step 5?",
              "createdAt": "2022-05-27T17:29:28Z",
              "updatedAt": "2022-05-27T17:29:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8464Qj6",
          "commit": {
            "abbreviatedOid": "0ae69de"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-27T17:31:08Z",
          "updatedAt": "2022-05-27T17:31:08Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "Maybe we should highlight that the real choice is between a modern extensible-output hash function and a more established fixed-output hash function like SHA-256.",
              "createdAt": "2022-05-27T17:31:08Z",
              "updatedAt": "2022-05-27T17:31:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8464Sqh",
          "commit": {
            "abbreviatedOid": "0ae69de"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-27T17:33:12Z",
          "updatedAt": "2022-05-27T17:33:12Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "I think `n` should be greater than 0",
              "createdAt": "2022-05-27T17:33:12Z",
              "updatedAt": "2022-05-27T17:33:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8464X2u",
          "commit": {
            "abbreviatedOid": "0ae69de"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-27T17:36:49Z",
          "updatedAt": "2022-05-27T17:36:49Z",
          "comments": [
            {
              "originalPosition": 91,
              "body": "For consistency maybe just say \"the output size of H measured in bytes, equal to b / 8\".\r\n\r\nShould we just define these during the procedure based on `b` and `s`?",
              "createdAt": "2022-05-27T17:36:49Z",
              "updatedAt": "2022-05-27T17:36:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8464YN0",
          "commit": {
            "abbreviatedOid": "0ae69de"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-27T17:38:19Z",
          "updatedAt": "2022-05-27T17:38:19Z",
          "comments": [
            {
              "originalPosition": 99,
              "body": "I think the DST length should be prepended for consistency",
              "createdAt": "2022-05-27T17:38:19Z",
              "updatedAt": "2022-05-27T17:38:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8464e-o",
          "commit": {
            "abbreviatedOid": "0ae69de"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-27T17:44:59Z",
          "updatedAt": "2022-05-27T17:45:00Z",
          "comments": [
            {
              "originalPosition": 144,
              "body": "Also applies to the xmd method. Maybe we can escape `e` and `s` here.",
              "createdAt": "2022-05-27T17:44:59Z",
              "updatedAt": "2022-05-27T17:45:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8467YK8",
          "commit": {
            "abbreviatedOid": "0ae69de"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-29T16:54:40Z",
          "updatedAt": "2022-05-29T16:54:41Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "Agreed, however there is the `key_info` parameter that is `OPTIONAL`.  IMO this is the reason that every other parameter is `REQUIRED`. Agreed though that this is not ideal, but it is \"necessary evil\" IMO.",
              "createdAt": "2022-05-29T16:54:40Z",
              "updatedAt": "2022-05-29T16:54:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8467YMO",
          "commit": {
            "abbreviatedOid": "0ae69de"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-29T16:55:31Z",
          "updatedAt": "2022-05-29T16:55:31Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "Updated! Thank you!",
              "createdAt": "2022-05-29T16:55:31Z",
              "updatedAt": "2022-05-29T16:55:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8467YP8",
          "commit": {
            "abbreviatedOid": "0ae69de"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-29T16:58:40Z",
          "updatedAt": "2022-05-29T16:58:40Z",
          "comments": [
            {
              "originalPosition": 99,
              "body": "It's true that this hurts consistency but there is a security reason for that. See [here](https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/issues/236) and [here](https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/pull/241) for context.\r\n\r\n### TL;TR\r\n prepending len(DST) here will mean that there are different `msg`, `dst`, `expand_length` combinations that give the same hash output. \r\n \r\n### Note \r\nAFAIK there are 2 solutions to the above.\r\n\r\n1. prepend the length of the message as well.\r\n2. append the length of the dst only.\r\n\r\nNeither are 100% consistent with the [Encoding of elements to be hashed](https://identity.foundation/bbs-signature/draft-bbs-signatures.html#name-encoding-of-elements-to-be-) section (for option 1 it may not be as \"obvious\", but after \"appending\" the lengths of some of the to-be-hashed elements one may thing that we would not need to append the length of the \"entire\" concatenated result as well).\r\n\r\nFor that reason, I prefer the current approach (option 2, i also update `hash_to_scalar_xof` to follow this). The \"elements to be hashed\" section will need updating IMO to something like \"concatenating elements\" or \"Inputs to hash_to_scalar encoding\".\r\n\r\nInterested to hear others thoughts here as well.",
              "createdAt": "2022-05-29T16:58:40Z",
              "updatedAt": "2022-05-29T16:58:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8467YQ3",
          "commit": {
            "abbreviatedOid": "0ae69de"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-29T16:59:30Z",
          "updatedAt": "2022-05-29T16:59:31Z",
          "comments": [
            {
              "originalPosition": 91,
              "body": "Agreed. Updated to use `b` and `s` instead. Thanks!",
              "createdAt": "2022-05-29T16:59:31Z",
              "updatedAt": "2022-05-29T16:59:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8467YSj",
          "commit": {
            "abbreviatedOid": "0ae69de"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-29T17:01:09Z",
          "updatedAt": "2022-05-29T17:01:09Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "Added some text to highlight this fact! Hopefully it is clear enough??",
              "createdAt": "2022-05-29T17:01:09Z",
              "updatedAt": "2022-05-29T17:01:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8467YT8",
          "commit": {
            "abbreviatedOid": "0ae69de"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-29T17:02:14Z",
          "updatedAt": "2022-05-29T17:02:15Z",
          "comments": [
            {
              "originalPosition": 144,
              "body": "Thank you! Updated the description for `expand_length`.",
              "createdAt": "2022-05-29T17:02:14Z",
              "updatedAt": "2022-05-29T17:02:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8467YXi",
          "commit": {
            "abbreviatedOid": "0ae69de"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-29T17:05:21Z",
          "updatedAt": "2022-05-29T17:05:22Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "Thank you! Updated",
              "createdAt": "2022-05-29T17:05:21Z",
              "updatedAt": "2022-05-29T17:05:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax847GXbv",
          "commit": {
            "abbreviatedOid": "0ae69de"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-01T07:41:37Z",
          "updatedAt": "2022-06-01T07:41:37Z",
          "comments": [
            {
              "originalPosition": 99,
              "body": "Im in favour of option 2 also",
              "createdAt": "2022-06-01T07:41:37Z",
              "updatedAt": "2022-06-01T07:41:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84746jr",
          "commit": {
            "abbreviatedOid": "1603a40"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-13T18:41:46Z",
          "updatedAt": "2022-06-13T18:41:46Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "```suggestion\r\n26. return proof_to_octets(proof)\r\n```",
              "createdAt": "2022-06-13T18:41:46Z",
              "updatedAt": "2022-06-13T18:41:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84746t8",
          "commit": {
            "abbreviatedOid": "1603a40"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-13T18:42:19Z",
          "updatedAt": "2022-06-13T18:42:20Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "Add back in the proof decoding rules",
              "createdAt": "2022-06-13T18:42:19Z",
              "updatedAt": "2022-06-13T18:42:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848dBlJ",
          "commit": {
            "abbreviatedOid": "3d7e10d"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-21T21:01:50Z",
          "updatedAt": "2022-06-21T21:01:50Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "This isn't used anymore",
              "createdAt": "2022-06-21T21:01:50Z",
              "updatedAt": "2022-06-21T21:01:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848dBrZ",
          "commit": {
            "abbreviatedOid": "3d7e10d"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-21T21:02:13Z",
          "updatedAt": "2022-06-21T21:02:13Z",
          "comments": [
            {
              "originalPosition": 60,
              "body": "Not _xof",
              "createdAt": "2022-06-21T21:02:13Z",
              "updatedAt": "2022-06-21T21:02:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848dFkm",
          "commit": {
            "abbreviatedOid": "3d7e10d"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-21T21:18:16Z",
          "updatedAt": "2022-06-21T21:18:17Z",
          "comments": [
            {
              "originalPosition": 151,
              "body": "Can we also resolve #168 in this PR by substituting this parameter in place of `8*ceil(log2(r))` for steps 8 and 9 of the procedure?",
              "createdAt": "2022-06-21T21:18:16Z",
              "updatedAt": "2022-06-21T21:18:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848dIZt",
          "commit": {
            "abbreviatedOid": "3d7e10d"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-21T21:31:07Z",
          "updatedAt": "2022-06-21T21:31:08Z",
          "comments": [
            {
              "originalPosition": 99,
              "body": "```suggestion\r\n6. for i in (1, ..., count):\r\n```",
              "createdAt": "2022-06-21T21:31:08Z",
              "updatedAt": "2022-06-21T21:31:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848dODn",
          "commit": {
            "abbreviatedOid": "3d7e10d"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-21T21:59:17Z",
          "updatedAt": "2022-06-21T21:59:18Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Good catch! Removed!",
              "createdAt": "2022-06-21T21:59:17Z",
              "updatedAt": "2022-06-21T21:59:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848dOHe",
          "commit": {
            "abbreviatedOid": "3d7e10d"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-21T21:59:37Z",
          "updatedAt": "2022-06-21T21:59:37Z",
          "comments": [
            {
              "originalPosition": 60,
              "body": "Thanks! Fixed!",
              "createdAt": "2022-06-21T21:59:37Z",
              "updatedAt": "2022-06-21T21:59:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848dOLE",
          "commit": {
            "abbreviatedOid": "3d7e10d"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-21T21:59:55Z",
          "updatedAt": "2022-06-21T21:59:55Z",
          "comments": [
            {
              "originalPosition": 99,
              "body": "Done!",
              "createdAt": "2022-06-21T21:59:55Z",
              "updatedAt": "2022-06-21T21:59:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848dOS6",
          "commit": {
            "abbreviatedOid": "3d7e10d"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-21T22:00:38Z",
          "updatedAt": "2022-06-21T22:00:38Z",
          "comments": [
            {
              "originalPosition": 151,
              "body": "Yea good idea! Done!",
              "createdAt": "2022-06-21T22:00:38Z",
              "updatedAt": "2022-06-21T22:00:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848dXah",
          "commit": {
            "abbreviatedOid": "f8dd02b"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-21T22:57:27Z",
          "updatedAt": "2022-06-21T22:57:27Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "I think this should be in the Parameters section",
              "createdAt": "2022-06-21T22:57:27Z",
              "updatedAt": "2022-06-21T22:57:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848dX6N",
          "commit": {
            "abbreviatedOid": "f8dd02b"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-21T23:01:07Z",
          "updatedAt": "2022-06-21T23:01:07Z",
          "comments": [
            {
              "originalPosition": 86,
              "body": "I'm not sure what DST value this is?",
              "createdAt": "2022-06-21T23:01:07Z",
              "updatedAt": "2022-06-21T23:01:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848dYWY",
          "commit": {
            "abbreviatedOid": "f8dd02b"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-21T23:04:18Z",
          "updatedAt": "2022-06-21T23:04:19Z",
          "comments": [
            {
              "originalPosition": 114,
              "body": "```suggestion\r\n7.     tv = uniform_bytes[(i-1)*expand_length..i*expand_length-1]\r\n```",
              "createdAt": "2022-06-21T23:04:18Z",
              "updatedAt": "2022-06-21T23:04:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848dYrQ",
          "commit": {
            "abbreviatedOid": "f8dd02b"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-21T23:06:46Z",
          "updatedAt": "2022-06-21T23:06:46Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "I was thinking this also what are definitions? I thought we only had inputs outputs and parameters?",
              "createdAt": "2022-06-21T23:06:46Z",
              "updatedAt": "2022-06-21T23:06:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848dZDH",
          "commit": {
            "abbreviatedOid": "f8dd02b"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-21T23:09:39Z",
          "updatedAt": "2022-06-21T23:09:40Z",
          "comments": [
            {
              "originalPosition": 135,
              "body": "I don't think `ceil(r+k)/8` is correct (it's huge). Maybe `ceil((ceil(log2(r)) + k) / 8)`",
              "createdAt": "2022-06-21T23:09:39Z",
              "updatedAt": "2022-06-21T23:10:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848dZ9f",
          "commit": {
            "abbreviatedOid": "f8dd02b"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-21T23:16:43Z",
          "updatedAt": "2022-06-21T23:16:43Z",
          "comments": [
            {
              "originalPosition": 98,
              "body": "I realized there's actually an issue with using expand_length here, as it conflicts with the recommended value for hash_to_field which is `ceil((ceil(log2(p)) + k) / 8)`. For BLS12-381 that is 48 bytes, but we have expand_length set to 64 bytes. That's not a problem here, but it does mean that a standard hash_to_field implementation can't be substituted.",
              "createdAt": "2022-06-21T23:16:43Z",
              "updatedAt": "2022-06-21T23:27:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848db2y",
          "commit": {
            "abbreviatedOid": "f8dd02b"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-21T23:32:04Z",
          "updatedAt": "2022-06-21T23:32:04Z",
          "comments": [
            {
              "originalPosition": 86,
              "body": "Ah, looks like it's the hash-to-curve ciphersuite identifier. There's a small issue that `hash_to_curve` is defined by the ciphersuite but `hash_to_curve_id` is referenced here and in `create_generators`",
              "createdAt": "2022-06-21T23:32:04Z",
              "updatedAt": "2022-06-21T23:32:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848hpc2",
          "commit": {
            "abbreviatedOid": "f8dd02b"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-22T15:47:47Z",
          "updatedAt": "2022-06-22T15:47:48Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "Fixed. Thanks!",
              "createdAt": "2022-06-22T15:47:48Z",
              "updatedAt": "2022-06-22T15:47:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848hpvB",
          "commit": {
            "abbreviatedOid": "f8dd02b"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-22T15:48:13Z",
          "updatedAt": "2022-06-22T15:48:14Z",
          "comments": [
            {
              "originalPosition": 86,
              "body": "Updated! Thank you! (named the ciphersuite parameter `hash_to_curve_suite` and used it in `create_generators` and `hash_to_scalar`)",
              "createdAt": "2022-06-22T15:48:14Z",
              "updatedAt": "2022-06-22T15:48:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848hp4p",
          "commit": {
            "abbreviatedOid": "f8dd02b"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-22T15:48:28Z",
          "updatedAt": "2022-06-22T15:48:29Z",
          "comments": [
            {
              "originalPosition": 114,
              "body": "Done!",
              "createdAt": "2022-06-22T15:48:28Z",
              "updatedAt": "2022-06-22T15:48:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848hqHF",
          "commit": {
            "abbreviatedOid": "f8dd02b"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-22T15:48:47Z",
          "updatedAt": "2022-06-22T15:48:47Z",
          "comments": [
            {
              "originalPosition": 135,
              "body": "Good catch! Yea it was wrong. Fixed.",
              "createdAt": "2022-06-22T15:48:47Z",
              "updatedAt": "2022-06-22T15:48:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848hwqo",
          "commit": {
            "abbreviatedOid": "f8dd02b"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-22T16:00:25Z",
          "updatedAt": "2022-06-22T16:00:25Z",
          "comments": [
            {
              "originalPosition": 98,
              "body": "Good point! Haven't thought about that. I updated `expand_length` to be 48 bytes. Don't see any reason for the 64 bytes value. It only makes sense if we are moding p, which we don\u2019t (64 was possibly copied from the bls signatures spec??).",
              "createdAt": "2022-06-22T16:00:25Z",
              "updatedAt": "2022-06-22T16:00:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848h5qI",
          "commit": {
            "abbreviatedOid": "f8dd02b"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-22T16:18:53Z",
          "updatedAt": "2022-06-22T16:18:53Z",
          "comments": [
            {
              "originalPosition": 98,
              "body": "Yes, 64 is the number of bytes when hashing to a G1 point (32 bytes are used for each component). If we want to allow the use of hash_to_field then I think we would need two different expand_length parameters, or we should just remove it from the ciphersuite and use definitions.",
              "createdAt": "2022-06-22T16:18:53Z",
              "updatedAt": "2022-06-22T16:18:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848iIMc",
          "commit": {
            "abbreviatedOid": "f8dd02b"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-22T16:51:04Z",
          "updatedAt": "2022-06-22T16:51:04Z",
          "comments": [
            {
              "originalPosition": 98,
              "body": "Don\u2019t see why we need 2 different `expand_length` parameters?? The `expand_length` defined by the ciphersuite will only be used for `hash_to_field` when creating scalars. When creating generators, one must use the `hash_to_field` defined by the H2C ciphersuite (which defines `L = 64 bytes`).\r\n\r\nI\u2019m fine with removing it and using definitions. I\u2019m not 100% clear about the reasoning though. Is it to be clearer to the developer and avoid mistakes (like using 48 bytes when creating generators??)",
              "createdAt": "2022-06-22T16:51:04Z",
              "updatedAt": "2022-06-22T16:51:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848iMaO",
          "commit": {
            "abbreviatedOid": "f8dd02b"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-22T17:04:11Z",
          "updatedAt": "2022-06-22T17:04:11Z",
          "comments": [
            {
              "originalPosition": 98,
              "body": "`create_generators` is using the `expand_length` parameter here though, as it uses `expand_message` directly.",
              "createdAt": "2022-06-22T17:04:11Z",
              "updatedAt": "2022-06-22T17:04:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848iM0L",
          "commit": {
            "abbreviatedOid": "f8dd02b"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-22T17:05:34Z",
          "updatedAt": "2022-06-22T17:05:35Z",
          "comments": [
            {
              "originalPosition": 98,
              "body": "Actually, while that is the case, it is just generating the next 'seed' from that value so that's probably okay. It does seem to confuse the purpose of the parameter a little, though.",
              "createdAt": "2022-06-22T17:05:35Z",
              "updatedAt": "2022-06-22T17:05:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848iTiU",
          "commit": {
            "abbreviatedOid": "f8dd02b"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-22T17:28:56Z",
          "updatedAt": "2022-06-22T17:28:56Z",
          "comments": [
            {
              "originalPosition": 98,
              "body": "(Sorry about the multiple messages.) I think we can probably move forward with this one and address the length parameter later unless there's additional feedback.",
              "createdAt": "2022-06-22T17:28:56Z",
              "updatedAt": "2022-06-22T17:28:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848kFS4",
          "commit": {
            "abbreviatedOid": "f8dd02b"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-22T23:18:26Z",
          "updatedAt": "2022-06-22T23:18:27Z",
          "comments": [
            {
              "originalPosition": 98,
              "body": "Thank you very much for the feedback :) This is clearly confusing so moving to definitions is the best option IMO.\r\n\r\nFor `ProofGen` I removed the update from here and re-introduce it in PR #183. For `create_generators` and `hash_to_scalar` I made the update here.",
              "createdAt": "2022-06-22T23:18:27Z",
              "updatedAt": "2022-06-22T23:18:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848pcoz",
          "commit": {
            "abbreviatedOid": "b86e1c4"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-23T18:52:57Z",
          "updatedAt": "2022-06-23T18:52:57Z",
          "comments": [
            {
              "originalPosition": 161,
              "body": "It's a bit confusing to combine these two parameters. I think either they should be separated, or (my preference would be) we just create the DST values by combining the value of `hash_to_curve_suite` with a prefix or suffix.",
              "createdAt": "2022-06-23T18:52:57Z",
              "updatedAt": "2022-06-23T18:52:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848qZDB",
          "commit": {
            "abbreviatedOid": "b86e1c4"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-23T22:12:36Z",
          "updatedAt": "2022-06-23T22:12:36Z",
          "comments": [
            {
              "originalPosition": 161,
              "body": "Done! (used 2nd option, i.e., using the `hash_to_curve_suite` value to create each dst). Thanks!",
              "createdAt": "2022-06-23T22:12:36Z",
              "updatedAt": "2022-06-23T22:12:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848qgev",
          "commit": {
            "abbreviatedOid": "fadf747"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-23T22:32:16Z",
          "updatedAt": "2022-06-23T22:32:16Z",
          "comments": [
            {
              "originalPosition": 182,
              "body": "I don't think this is used anymore",
              "createdAt": "2022-06-23T22:32:16Z",
              "updatedAt": "2022-06-23T22:32:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848qkK5",
          "commit": {
            "abbreviatedOid": "fadf747"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-23T22:56:52Z",
          "updatedAt": "2022-06-23T22:56:52Z",
          "comments": [
            {
              "originalPosition": 182,
              "body": "I'm really sorry about that! Fixed. Thanks!",
              "createdAt": "2022-06-23T22:56:52Z",
              "updatedAt": "2022-06-23T22:56:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848qly4",
          "commit": {
            "abbreviatedOid": "d51d990"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-06-23T23:09:56Z",
          "updatedAt": "2022-06-23T23:09:56Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax848rIRb",
          "commit": {
            "abbreviatedOid": "d51d990"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-06-24T03:16:06Z",
          "updatedAt": "2022-06-24T03:16:06Z",
          "comments": []
        }
      ]
    },
    {
      "number": 152,
      "id": "PR_kwDOF8lax844TcuZ",
      "title": "Editorial updates",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/152",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Various editorial changes:\r\n1.\tUpdated the ascii art to be less than 72 chars (we will need to do that in other places on the spec as well that are inside code blocks etc).\r\n2.\tChanged signature_dst_generator_seed -> sig_domain_generator_seed as noted by @alessandroguggino in PR #145 ([comment](https://github.com/decentralized-identity/bbs-signature/pull/145#discussion_r879127346)) \r\n3.\tFixed wrong reference to the SHA3 specification.\r\n4.\tRemoved the `hash_to_field` definition from the ciphersuite because it is not used by any operation at the moment. It is only mentioned as an alternative and for that I don\u2019t believe is needed in the ciphersuite. If the proposal from [here](https://github.com/decentralized-identity/bbs-signature/pull/151#issuecomment-1133764513) is adopted will re-add it.\r\n5.\tCategorizing the parameters defined on the ciphersuites (there are a lot of parameters and I personally have found my self re-reading the whole section more than once to find the one I was looking for. Maybe this makes things more clear and easy to read??)",
      "createdAt": "2022-05-23T15:42:52Z",
      "updatedAt": "2022-05-24T23:20:44Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "49b0b3aeeeeabcb41331f1af107182e13d60513c",
      "headRepository": "BasileiosKal/bbs-signature",
      "headRefName": "notation-update",
      "headRefOid": "d99c5051e88353396389d633f37cdc9179448302",
      "closedAt": "2022-05-24T23:20:44Z",
      "mergedAt": "2022-05-24T23:20:43Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "517868ceb34592c58e8b731c0e9d168d44821039"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Multiple approvals, discussed on WG call, merging",
          "createdAt": "2022-05-24T23:20:39Z",
          "updatedAt": "2022-05-24T23:20:39Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax846iwoL",
          "commit": {
            "abbreviatedOid": "d99c505"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "LGTM thanks!",
          "createdAt": "2022-05-23T18:21:57Z",
          "updatedAt": "2022-05-23T18:21:57Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax846nFbH",
          "commit": {
            "abbreviatedOid": "d99c505"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-24T14:22:05Z",
          "updatedAt": "2022-05-24T14:22:05Z",
          "comments": []
        }
      ]
    },
    {
      "number": 154,
      "id": "PR_kwDOF8lax844bgab",
      "title": "Re-organizing the sections",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/154",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Proposing the following structure for the document. The main change is that `Sign`, `Verify`, `ProofGen` and `ProofVerify` are moved to their own \"core operations\" section. This will allow us to more easily define \"higher level functions\" on top of the \"core operations\" if need be.\r\n\r\n```\r\n|--- Introduction\r\n|      |--- Terminology\r\n|      |--- Notation\r\n|      +--- Organization of this document\r\n|--- Conventions\r\n|--- Considerations\r\n|      |--- Subgroup Selection\r\n|      |--- Messages and Generators\r\n|      +--- Encoding of elements to be hashed\r\n|--- BBS Scheme Definition\r\n|      |--- Parameters\r\n|      |--- Key Generation\r\n|      |      |--- KeyGen\r\n|      |      |--- SkToPk\r\n|      |      +--- KeyValidate        \r\n|      +--- Core Operations\r\n|             |--- Sign\r\n|             |--- Verify\r\n|             |--- ProofGen\r\n|             +--- ProofVerify\r\n|--- Utility Functions\r\n|      |--- CreateGenerators\r\n|      |--- MapMessageToScalar\r\n|      |      +--- MapMessageToScalarAsHash\r\n|      +--- Hash to scalar\r\n|--- Serialization\r\n|      |--- OctetsToSignatures\r\n|      +--- SignatureToOctets\r\n|--- Security Considerations\r\n|--- Ciphersuites \r\n+--- Appendix\r\n```",
      "createdAt": "2022-05-25T09:10:25Z",
      "updatedAt": "2022-06-09T21:04:44Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "849e6d96b895615d460f92bf0b1d7efbb8f62519",
      "headRepository": "BasileiosKal/bbs-signature",
      "headRefName": "re-organizing-operations",
      "headRefOid": "7989c20991e33b0f4f1b9b970e0e271e441e9ee8",
      "closedAt": "2022-06-09T21:04:31Z",
      "mergedAt": "2022-06-09T21:04:31Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "69d54e61405064871f72e61f89e57a9e29635da9"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Suggested tweaks\r\n\r\n```\r\n|--- Introduction\r\n|      |--- Terminology\r\n|      |--- Notation\r\n|      +--- Organization of this document\r\n|--- Conventions\r\n|--- Considerations\r\n|      |--- Subgroup Selection\r\n|      |--- Messages and Generators\r\n|      +--- Encoding of elements to be hashed\r\n|--- Scheme Definition\r\n|      |--- Parameters\r\n|      |--- Key Generation Operations\r\n|      |      |--- KeyGen\r\n|      |      |--- SkToPk\r\n|      |      +--- KeyValidate        \r\n|      +--- Core Operations\r\n|             |--- Sign\r\n|             |--- Verify\r\n|             |--- ProofGen\r\n|             +--- ProofVerify\r\n|--- Utility Operations\r\n|      |--- CreateGenerators\r\n|      |--- MapMessageToScalar\r\n|      |      +--- MapMessageToScalarAsHash\r\n|      +--- Hash to scalar\r\n|      |--- OctetsToSignatures\r\n|      +--- SignatureToOctets\r\n|--- Security Considerations\r\n|--- Ciphersuite\r\n```",
          "createdAt": "2022-06-01T07:39:06Z",
          "updatedAt": "2022-06-01T07:39:06Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Suggested tweaks\r\n\r\nDone! Thanks!",
          "createdAt": "2022-06-02T11:59:50Z",
          "updatedAt": "2022-06-02T11:59:50Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@BasileiosKal with the merge of #155 can you rebase this PR as I think otherwise the section will end up in the wrong place, after that im happy to merge.",
          "createdAt": "2022-06-07T23:08:56Z",
          "updatedAt": "2022-06-07T23:08:56Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@BasileiosKal with the merge of #155 can you rebase this PR as I think otherwise the section will end up in the wrong place, after that im happy to merge.",
          "createdAt": "2022-06-07T23:08:56Z",
          "updatedAt": "2022-06-07T23:08:56Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> @BasileiosKal with the merge of https://github.com/decentralized-identity/bbs-signature/pull/155 can you rebase this PR as I think otherwise the section will end up in the wrong place, after that im happy to merge.\r\n\r\nDone rebase! \r\n\r\nSince we have 4 \"serialization\" operations maybe they are \"worth\" their own sub-section?? So the `Utility Operations` section now looks like:\r\n\r\n```\r\n|--- Utility Operations\r\n|      |--- CreateGenerators\r\n|      |--- MapMessageToScalar\r\n|      |      +--- MapMessageToScalarAsHash\r\n|      +--- Hash to scalar\r\n|      +---- Serialization\r\n|              |--- OctetsToSignatures\r\n|              |--- SignatureToOctets\r\n|              |--- OctetsToProof\r\n|              +--- ProofToOctets\r\n```\r\n\r\nI'm more than happy to fall back if people don't like this change.",
          "createdAt": "2022-06-08T19:43:28Z",
          "updatedAt": "2022-06-08T19:43:28Z"
        },
        {
          "author": "alessandroguggino",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Since we have 4 \"serialization\" operations maybe they are \"worth\" their own sub-section??\r\n\r\nYou're right! I agree",
          "createdAt": "2022-06-09T12:09:51Z",
          "updatedAt": "2022-06-09T12:09:59Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Multiple approvals, purely editorial, merging",
          "createdAt": "2022-06-09T21:04:44Z",
          "updatedAt": "2022-06-09T21:04:44Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax847QwQn",
          "commit": {
            "abbreviatedOid": "6fdf5eb"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-06-02T22:16:52Z",
          "updatedAt": "2022-06-02T22:16:52Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax847eS-e",
          "commit": {
            "abbreviatedOid": "6fdf5eb"
          },
          "author": "alessandroguggino",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-06-07T09:11:18Z",
          "updatedAt": "2022-06-07T09:11:18Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax847gvte",
          "commit": {
            "abbreviatedOid": "6fdf5eb"
          },
          "author": "alessandroguggino",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-07T16:09:57Z",
          "updatedAt": "2022-06-07T16:09:58Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "Remove the dot at the end.\r\n```suggestion\r\n## Encoding of elements to be hashed\r\n```",
              "createdAt": "2022-06-07T16:09:57Z",
              "updatedAt": "2022-06-07T16:09:58Z"
            }
          ]
        }
      ]
    },
    {
      "number": 155,
      "id": "PR_kwDOF8lax844cgoG",
      "title": "Proof serialization/de-serialization ",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/155",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #153\r\n\r\nIntroduces a `proof_to_octets` and a `octets_to_proof` operation",
      "createdAt": "2022-05-25T13:24:23Z",
      "updatedAt": "2022-06-07T23:05:47Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "517868ceb34592c58e8b731c0e9d168d44821039",
      "headRepository": "BasileiosKal/bbs-signature",
      "headRefName": "proof-serialization",
      "headRefOid": "452617e157314e88583e424c1aee22a1861c8ecf",
      "closedAt": "2022-06-07T23:05:47Z",
      "mergedAt": "2022-06-07T23:05:47Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "849e6d96b895615d460f92bf0b1d7efbb8f62519"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Multiple reviews and approvals, open 13 days, merging",
          "createdAt": "2022-06-07T23:05:42Z",
          "updatedAt": "2022-06-07T23:05:42Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax846uDie",
          "commit": {
            "abbreviatedOid": "bef291e"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-25T16:36:00Z",
          "updatedAt": "2022-05-25T16:36:01Z",
          "comments": [
            {
              "originalPosition": 137,
              "body": "```suggestion\r\n1. Three (3) valid compressed points of the G1 subgroup, different from the identity point of G1 (i.e., `A', Abar, D`, in ProofGen)\r\n```",
              "createdAt": "2022-05-25T16:36:00Z",
              "updatedAt": "2022-05-25T16:36:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846uDzQ",
          "commit": {
            "abbreviatedOid": "bef291e"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-25T16:36:50Z",
          "updatedAt": "2022-05-25T16:36:51Z",
          "comments": [
            {
              "originalPosition": 139,
              "body": "Little endian 32-bit? Can\u2019t remember if we have a description of serialized integers yet",
              "createdAt": "2022-05-25T16:36:50Z",
              "updatedAt": "2022-05-25T16:36:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846vQGE",
          "commit": {
            "abbreviatedOid": "bef291e"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-25T20:59:58Z",
          "updatedAt": "2022-05-25T20:59:59Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "```suggestion\r\nThis operation describes how to decode an octet string representing a proof, validate it and return the underlying components that make up the proof.\r\n```\r\n\r\nSuggestion to make this more consistent language with how we introduce each operation\r\n```suggestion\r\nThe `octets_to_proof` operations describes how to parse an octet string representation of a proof, validate it and return the underlying components.\r\n```",
              "createdAt": "2022-05-25T20:59:58Z",
              "updatedAt": "2022-05-25T20:59:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846vQGF",
          "commit": {
            "abbreviatedOid": "bef291e"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-25T20:59:58Z",
          "updatedAt": "2022-05-25T20:59:59Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "```suggestion\r\nThis operation describes how to decode an octet string representing a proof, validate it and return the underlying components that make up the proof.\r\n```\r\n\r\nSuggestion to make this more consistent language with how we introduce each operation\r\n```suggestion\r\nThe `octets_to_proof` operations describes how to parse an octet string representation of a proof, validate it and return the underlying components.\r\n```",
              "createdAt": "2022-05-25T20:59:58Z",
              "updatedAt": "2022-05-25T20:59:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846vQTb",
          "commit": {
            "abbreviatedOid": "bef291e"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-25T21:00:52Z",
          "updatedAt": "2022-05-25T21:00:52Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "```suggestion\r\n1. Three (3) valid points of the G1 subgroup, each of which must not equal the identity point.\r\n```",
              "createdAt": "2022-05-25T21:00:52Z",
              "updatedAt": "2022-05-25T21:00:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846vQTc",
          "commit": {
            "abbreviatedOid": "bef291e"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-25T21:00:52Z",
          "updatedAt": "2022-05-25T21:00:52Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "```suggestion\r\n1. Three (3) valid points of the G1 subgroup, each of which must not equal the identity point.\r\n```",
              "createdAt": "2022-05-25T21:00:52Z",
              "updatedAt": "2022-05-25T21:00:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846vQru",
          "commit": {
            "abbreviatedOid": "bef291e"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-25T21:02:19Z",
          "updatedAt": "2022-05-25T21:02:20Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "```suggestion\r\n3. A set of integers representing scalars in the range of 1 to r-1 inclusive, corresponding to the un-revealed from the proof message commitments.\r\n```\r\n\r\nAlso do we need to clarify the ordering expected here?\r\n```suggestion\r\n3. A number of integers representing scalars in the range of 1 to r-1 inclusive, corresponding to the un-revealed from the proof message commitments.\r\n```",
              "createdAt": "2022-05-25T21:02:19Z",
              "updatedAt": "2022-05-25T21:02:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846vQrv",
          "commit": {
            "abbreviatedOid": "bef291e"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-25T21:02:19Z",
          "updatedAt": "2022-05-25T21:02:20Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "```suggestion\r\n3. A set of integers representing scalars in the range of 1 to r-1 inclusive, corresponding to the un-revealed from the proof message commitments.\r\n```\r\n\r\nAlso do we need to clarify the ordering expected here?\r\n```suggestion\r\n3. A number of integers representing scalars in the range of 1 to r-1 inclusive, corresponding to the un-revealed from the proof message commitments.\r\n```",
              "createdAt": "2022-05-25T21:02:19Z",
              "updatedAt": "2022-05-25T21:02:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846vQzP",
          "commit": {
            "abbreviatedOid": "bef291e"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-25T21:02:50Z",
          "updatedAt": "2022-05-25T21:02:51Z",
          "comments": [
            {
              "originalPosition": 77,
              "body": "```suggestion\r\n- r (REQUIRED), non-negative integer. The prime order of the G1 and\r\n                G2 groups, defined by the ciphersuite.\r\n```",
              "createdAt": "2022-05-25T21:02:50Z",
              "updatedAt": "2022-05-25T21:03:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846vQzR",
          "commit": {
            "abbreviatedOid": "bef291e"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-25T21:02:50Z",
          "updatedAt": "2022-05-25T21:02:51Z",
          "comments": [
            {
              "originalPosition": 77,
              "body": "```suggestion\r\n- r (REQUIRED), non-negative integer. The prime order of the G1 and\r\n                G2 groups, defined by the ciphersuite.\r\n```\r\n```suggestion\r\n- r (REQUIRED), non-negative integer. The prime order of the G_1 and\r\n                G_2 groups, defined by the ciphersuite.\r\n```",
              "createdAt": "2022-05-25T21:02:50Z",
              "updatedAt": "2022-05-25T21:02:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846vR8x",
          "commit": {
            "abbreviatedOid": "bef291e"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-25T21:06:58Z",
          "updatedAt": "2022-05-25T21:06:58Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "Just a note we should probably go back through the spec and make this consistent if we want to adopt a pattern of defining parameters that are set by the cipher suite? Shall I create an issue?",
              "createdAt": "2022-05-25T21:06:58Z",
              "updatedAt": "2022-05-25T21:06:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846vR8y",
          "commit": {
            "abbreviatedOid": "bef291e"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-25T21:06:58Z",
          "updatedAt": "2022-05-25T21:06:58Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "Just a note we should probably go back through the spec and make this consistent if we want to adopt a pattern of defining parameters that are set by the cipher suite? Shall I create an issue?",
              "createdAt": "2022-05-25T21:06:58Z",
              "updatedAt": "2022-05-25T21:06:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846vVr9",
          "commit": {
            "abbreviatedOid": "bef291e"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-25T21:23:32Z",
          "updatedAt": "2022-05-25T21:23:32Z",
          "comments": [
            {
              "originalPosition": 98,
              "body": "Just checking this loop syntax is 0,1,2 wonder if we should do `(0,..,2)` and define the syntax in the terminology section?",
              "createdAt": "2022-05-25T21:23:32Z",
              "updatedAt": "2022-05-25T21:23:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846vVr-",
          "commit": {
            "abbreviatedOid": "bef291e"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-25T21:23:32Z",
          "updatedAt": "2022-05-25T21:23:32Z",
          "comments": [
            {
              "originalPosition": 98,
              "body": "Just checking this loop syntax is 0,1,2 wonder if we should do `(0,..,2)` and define the syntax in the terminology section?",
              "createdAt": "2022-05-25T21:23:32Z",
              "updatedAt": "2022-05-25T21:23:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846vV6-",
          "commit": {
            "abbreviatedOid": "bef291e"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-25T21:24:36Z",
          "updatedAt": "2022-05-25T21:24:37Z",
          "comments": [
            {
              "originalPosition": 126,
              "body": "Where is k defined?",
              "createdAt": "2022-05-25T21:24:37Z",
              "updatedAt": "2022-05-25T21:24:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846vV6_",
          "commit": {
            "abbreviatedOid": "bef291e"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-25T21:24:37Z",
          "updatedAt": "2022-05-25T21:24:37Z",
          "comments": [
            {
              "originalPosition": 126,
              "body": "Where is k defined?",
              "createdAt": "2022-05-25T21:24:37Z",
              "updatedAt": "2022-05-25T21:24:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846vWAy",
          "commit": {
            "abbreviatedOid": "bef291e"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-25T21:25:05Z",
          "updatedAt": "2022-05-25T21:25:06Z",
          "comments": [
            {
              "originalPosition": 163,
              "body": "```suggestion\r\n2. Let proof_octets be an empty octet string.\r\n```\r\n```suggestion\r\n2. Let proof_octets be the empty octet string.\r\n```",
              "createdAt": "2022-05-25T21:25:05Z",
              "updatedAt": "2022-05-25T21:25:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846vWAz",
          "commit": {
            "abbreviatedOid": "bef291e"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-25T21:25:05Z",
          "updatedAt": "2022-05-25T21:25:06Z",
          "comments": [
            {
              "originalPosition": 163,
              "body": "```suggestion\r\n2. Let proof_octets be an empty octet string.\r\n```\r\n```suggestion\r\n2. Let proof_octets be the empty octet string.\r\n```",
              "createdAt": "2022-05-25T21:25:05Z",
              "updatedAt": "2022-05-25T21:25:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846vWQv",
          "commit": {
            "abbreviatedOid": "bef291e"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-25T21:26:15Z",
          "updatedAt": "2022-05-25T21:26:15Z",
          "comments": [
            {
              "originalPosition": 146,
              "body": "Wonder if we actually need to supply the arguments destructed here like we do in signature to octets?",
              "createdAt": "2022-05-25T21:26:15Z",
              "updatedAt": "2022-05-25T21:26:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846vWQw",
          "commit": {
            "abbreviatedOid": "bef291e"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-25T21:26:15Z",
          "updatedAt": "2022-05-25T21:26:15Z",
          "comments": [
            {
              "originalPosition": 146,
              "body": "Wonder if we actually need to supply the arguments destructed here like we do in signature to octets?",
              "createdAt": "2022-05-25T21:26:15Z",
              "updatedAt": "2022-05-25T21:26:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846z0cj",
          "commit": {
            "abbreviatedOid": "bef291e"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-26T19:03:56Z",
          "updatedAt": "2022-05-26T19:03:56Z",
          "comments": [
            {
              "originalPosition": 139,
              "body": "Thank you! That's a good point! I don't think we discuss this on the document. Aren't there 256 bits necessary for scalars (for bls12-381)?? Also we use I2OSP/OS2IP which operates in big-endian order if I'm not mistaken, so we will need to add a note there if we decide to define integers to be little endian.",
              "createdAt": "2022-05-26T19:03:56Z",
              "updatedAt": "2022-05-26T20:11:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846z7KO",
          "commit": {
            "abbreviatedOid": "bef291e"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-26T19:30:16Z",
          "updatedAt": "2022-05-26T19:30:16Z",
          "comments": [
            {
              "originalPosition": 139,
              "body": "Opened issue #157 to discuss more about this. Thanks for raising!",
              "createdAt": "2022-05-26T19:30:16Z",
              "updatedAt": "2022-05-26T19:30:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8460N_P",
          "commit": {
            "abbreviatedOid": "bef291e"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-26T20:34:33Z",
          "updatedAt": "2022-05-26T20:34:34Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "Thanks! Updated!",
              "createdAt": "2022-05-26T20:34:34Z",
              "updatedAt": "2022-05-26T20:34:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8460Pct",
          "commit": {
            "abbreviatedOid": "bef291e"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-26T20:41:07Z",
          "updatedAt": "2022-05-26T20:41:08Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "> Also do we need to clarify the ordering expected here?\r\n\r\nThere is no way that i know, for the ordering to be checked here, so there may be no point in adding such description?? The expected \"ordering\" is kinda \"defined\" in step 4 in `ProofVerify` i.e., \r\n\r\n```\r\n4. (A', Abar, D, c, e^, r2^, r3^, s^, (m^_j1,...,m^_jU)) = proof\r\n```\r\nSince the functions are just utilities to be used internally and there are no inconsistencies that can arise when used with those core operations, an extra definition of the ordering may not be necessary??",
              "createdAt": "2022-05-26T20:41:07Z",
              "updatedAt": "2022-05-26T20:57:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8460Pfq",
          "commit": {
            "abbreviatedOid": "bef291e"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-26T20:41:21Z",
          "updatedAt": "2022-05-26T20:41:21Z",
          "comments": [
            {
              "originalPosition": 77,
              "body": "Thanks! Updated!",
              "createdAt": "2022-05-26T20:41:21Z",
              "updatedAt": "2022-05-26T20:41:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8460Qki",
          "commit": {
            "abbreviatedOid": "bef291e"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-26T20:45:40Z",
          "updatedAt": "2022-05-26T20:45:40Z",
          "comments": [
            {
              "originalPosition": 163,
              "body": "Thanks! Done!",
              "createdAt": "2022-05-26T20:45:40Z",
              "updatedAt": "2022-05-26T20:45:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8460S4Z",
          "commit": {
            "abbreviatedOid": "bef291e"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-26T20:55:49Z",
          "updatedAt": "2022-05-26T20:55:49Z",
          "comments": [
            {
              "originalPosition": 146,
              "body": "Since the input has no \"fixed\" length it may be more complicated to define it ''destructed\" (i.e., if we define it as `(A', Abar, D, c, e^, r2^, r3^, s^, (m^_1,...,m^_U))` we will need to define `U` which will be hard here or if we define it like `(A', Abar, D, c, e^, r2^, r3^, s^, msg_commitments`) we mix up structured and destructed forms which misses the point of consistency IMO.\r\n\r\nIn general, for consistency, I would prefer passing the signature in a structured way than passing the proof in a destructed one.",
              "createdAt": "2022-05-26T20:55:49Z",
              "updatedAt": "2022-05-26T22:16:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8460Tw1",
          "commit": {
            "abbreviatedOid": "bef291e"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-26T20:59:34Z",
          "updatedAt": "2022-05-26T20:59:35Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "Agreed! There is issue #125. We do need to focus more into closing it so the spec will be consistent.",
              "createdAt": "2022-05-26T20:59:34Z",
              "updatedAt": "2022-05-26T20:59:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8460hQJ",
          "commit": {
            "abbreviatedOid": "bef291e"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-26T22:12:53Z",
          "updatedAt": "2022-05-26T22:12:53Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "Done!",
              "createdAt": "2022-05-26T22:12:53Z",
              "updatedAt": "2022-05-26T22:12:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8460hQi",
          "commit": {
            "abbreviatedOid": "bef291e"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-26T22:12:56Z",
          "updatedAt": "2022-05-26T22:12:56Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "Thank you! Updated",
              "createdAt": "2022-05-26T22:12:56Z",
              "updatedAt": "2022-05-26T22:12:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8460hf0",
          "commit": {
            "abbreviatedOid": "bef291e"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-26T22:14:38Z",
          "updatedAt": "2022-05-26T22:14:39Z",
          "comments": [
            {
              "originalPosition": 98,
              "body": "Yeap! Good catch! Updated this line and added the `(a, ..., b)` syntax in the Notation section.",
              "createdAt": "2022-05-26T22:14:39Z",
              "updatedAt": "2022-05-26T22:14:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8460hiM",
          "commit": {
            "abbreviatedOid": "bef291e"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-26T22:14:54Z",
          "updatedAt": "2022-05-26T22:14:54Z",
          "comments": [
            {
              "originalPosition": 98,
              "body": "Yeap! Done!",
              "createdAt": "2022-05-26T22:14:54Z",
              "updatedAt": "2022-05-26T22:14:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8460hon",
          "commit": {
            "abbreviatedOid": "bef291e"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-26T22:15:34Z",
          "updatedAt": "2022-05-26T22:15:34Z",
          "comments": [
            {
              "originalPosition": 126,
              "body": "Apologies! This was a typo. It should be `j`. Updated.",
              "createdAt": "2022-05-26T22:15:34Z",
              "updatedAt": "2022-05-26T22:15:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846_D_x",
          "commit": {
            "abbreviatedOid": "caca3db"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-30T18:17:30Z",
          "updatedAt": "2022-05-30T18:17:31Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "```suggestion\r\n[a..b]\r\n```",
              "createdAt": "2022-05-30T18:17:30Z",
              "updatedAt": "2022-05-30T18:17:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax846_EHA",
          "commit": {
            "abbreviatedOid": "caca3db"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-30T18:18:29Z",
          "updatedAt": "2022-05-30T18:18:29Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "OR something like python `range(0,2)`",
              "createdAt": "2022-05-30T18:18:29Z",
              "updatedAt": "2022-05-30T18:18:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax847GVt3",
          "commit": {
            "abbreviatedOid": "bef291e"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-01T07:35:43Z",
          "updatedAt": "2022-06-01T07:35:43Z",
          "comments": [
            {
              "originalPosition": 146,
              "body": "Happy to move in that direction do we need to raise an issue to capture that?",
              "createdAt": "2022-06-01T07:35:43Z",
              "updatedAt": "2022-06-01T07:35:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax847KHzK",
          "commit": {
            "abbreviatedOid": "bef291e"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-01T18:29:54Z",
          "updatedAt": "2022-06-01T18:29:55Z",
          "comments": [
            {
              "originalPosition": 146,
              "body": "Thank you! Updated this PR to make the change for `octets_to_signature` and `signature_to_octets` (+ took the opportunity to make the operations < 72 chars). For other operations the update will most likely happen in #138. Opened #163 to keep track of this.",
              "createdAt": "2022-06-01T18:29:54Z",
              "updatedAt": "2022-06-01T18:30:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax847KH_p",
          "commit": {
            "abbreviatedOid": "caca3db"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-01T18:30:35Z",
          "updatedAt": "2022-06-01T18:30:35Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Thanks! Updated to `range(0, 2)` (we use [a..b] for array/octet_string slices)",
              "createdAt": "2022-06-01T18:30:35Z",
              "updatedAt": "2022-06-01T18:30:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax847Kd_-",
          "commit": {
            "abbreviatedOid": "e5ba570"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-01T19:49:58Z",
          "updatedAt": "2022-06-01T19:49:58Z",
          "comments": [
            {
              "originalPosition": 230,
              "body": "```suggestion\r\n16. if index != length(proof_octets), return INVALID\r\n```",
              "createdAt": "2022-06-01T19:49:58Z",
              "updatedAt": "2022-06-01T19:49:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax847Kek6",
          "commit": {
            "abbreviatedOid": "e5ba570"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-01T19:52:01Z",
          "updatedAt": "2022-06-01T19:52:01Z",
          "comments": [
            {
              "originalPosition": 232,
              "body": "```suggestion\r\n17. msg_commitments = ()\r\n```\r\n\r\nShould this be a set or array? if is a set I think it needs to be spread on step 19 e.g \r\n\r\n`19. return (A_0, A_1, A_2, s_0, s_1, s_2, s_3, s_4, ...msg_commitments)`",
              "createdAt": "2022-06-01T19:52:01Z",
              "updatedAt": "2022-06-01T19:52:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax847KfMN",
          "commit": {
            "abbreviatedOid": "e5ba570"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-01T19:54:13Z",
          "updatedAt": "2022-06-01T19:54:14Z",
          "comments": [
            {
              "originalPosition": 232,
              "body": "Otherwise from a data representation perspective serialized as JSON you could take the current syntax to mean\r\n\r\n```\r\nproof = {\r\n   A_0: ....,\r\n   .....\r\n   msg_commitments: {\r\n      s_5,\r\n      ...\r\n   }\r\n}\r\n```\r\n\r\nInstead of what I think is meant\r\n\r\n```\r\nproof = {\r\n   A_0: ....,\r\n   .....\r\n   s_5,\r\n   ...\r\n}\r\n```",
              "createdAt": "2022-06-01T19:54:14Z",
              "updatedAt": "2022-06-01T19:54:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax847KsqB",
          "commit": {
            "abbreviatedOid": "e5ba570"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-01T20:46:35Z",
          "updatedAt": "2022-06-01T20:46:36Z",
          "comments": [
            {
              "originalPosition": 232,
              "body": "I think that in the rest of the spec we use it as the first JSON example you listed. For example, in [proofGen](https://identity.foundation/bbs-signature/draft-bbs-signatures.html#name-proofgen), in step 25 we compute,\r\n```\r\n25. proof = (A', Abar, D, c, e^, r2^, r3^, s^, (m^_j1, ..., m^_jU))\r\n```\r\nAnd in [ProofVerify](https://identity.foundation/bbs-signature/draft-bbs-signatures.html#name-proofverify), at step 4, we (currently) parse the proof as,\r\n```\r\n4. (A', Abar, D, c, e^, r2^, r3^, s^, (m^_j1,...,m^_jU)) = proof\r\n```\r\nShow the options I see is\r\n1. We update this on those places as well (will be really easy to do in this PR)\r\n2. We keep using the same notation\r\n\r\nI'm fine with both. I don't think it make much difference from an implementations perspective. From an aesthetics perspective i may go with option 1, so there is some distinction between the different parts of the proof, but really not filling strong about it.",
              "createdAt": "2022-06-01T20:46:35Z",
              "updatedAt": "2022-06-01T20:46:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax847Qwgw",
          "commit": {
            "abbreviatedOid": "e5ba570"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-02T22:18:32Z",
          "updatedAt": "2022-06-02T22:18:33Z",
          "comments": [
            {
              "originalPosition": 232,
              "body": "Im actually fine with either so long as we are consistent, suffice to say if you think we are already being consistent w.r.t  option 1 then we can leave it as is.",
              "createdAt": "2022-06-02T22:18:32Z",
              "updatedAt": "2022-06-02T22:18:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax847Q3Zb",
          "commit": {
            "abbreviatedOid": "f7d1887"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-02T23:08:43Z",
          "updatedAt": "2022-06-02T23:08:43Z",
          "comments": [
            {
              "originalPosition": 232,
              "body": "There is a pending suggested change attached to this comment also which isn't entirely related to this conversation, once we have a resolution on that I'm happy to approve",
              "createdAt": "2022-06-02T23:08:43Z",
              "updatedAt": "2022-06-02T23:08:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax847VL62",
          "commit": {
            "abbreviatedOid": "e5ba570"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-03T19:39:06Z",
          "updatedAt": "2022-06-03T19:39:06Z",
          "comments": [
            {
              "originalPosition": 232,
              "body": "Yeap! Updated based on suggestion. Thanks!",
              "createdAt": "2022-06-03T19:39:06Z",
              "updatedAt": "2022-06-03T19:39:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax847cpuM",
          "commit": {
            "abbreviatedOid": "452617e"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-06-07T00:09:32Z",
          "updatedAt": "2022-06-07T00:09:32Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax847eVqK",
          "commit": {
            "abbreviatedOid": "452617e"
          },
          "author": "alessandroguggino",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-06-07T09:18:56Z",
          "updatedAt": "2022-06-07T09:18:56Z",
          "comments": []
        }
      ]
    },
    {
      "number": 156,
      "id": "PR_kwDOF8lax844idez",
      "title": "Typo and markdown escape for proper HTML rendering",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/156",
      "state": "MERGED",
      "author": "christianpaquin",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "- `SHKA-256` --> `SHAKE-256`\r\n- `hash_to_curve` --> `hash\\_to\\_curve`",
      "createdAt": "2022-05-26T18:27:46Z",
      "updatedAt": "2022-05-27T21:47:01Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "89de709a1235fe063d875ea0864e054d4f0e281f",
      "headRepository": "christianpaquin/bbs-signature",
      "headRefName": "fix-typos",
      "headRefOid": "ec46490922b07f5362ea3571551a1c8ca892159e",
      "closedAt": "2022-05-27T21:47:01Z",
      "mergedAt": "2022-05-27T21:47:01Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "83059a30911c5fa19caf12dd1507f6870cd4d561"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Minor editorial change, multiple approvals, merging",
          "createdAt": "2022-05-27T21:46:58Z",
          "updatedAt": "2022-05-27T21:46:58Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax846z7im",
          "commit": {
            "abbreviatedOid": "ec46490"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM! Thanks!",
          "createdAt": "2022-05-26T19:31:49Z",
          "updatedAt": "2022-05-26T19:31:49Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax8460oDT",
          "commit": {
            "abbreviatedOid": "ec46490"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-26T23:04:13Z",
          "updatedAt": "2022-05-26T23:04:13Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax8465iIr",
          "commit": {
            "abbreviatedOid": "ec46490"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-27T21:46:33Z",
          "updatedAt": "2022-05-27T21:46:33Z",
          "comments": []
        }
      ]
    },
    {
      "number": 158,
      "id": "PR_kwDOF8lax844jUQM",
      "title": "Appendices HTML formatting fix",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/158",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Currently, all the appendices are under one \"Appendix\" section in HTML. This PR solves this and separates each in its own Appendix.",
      "createdAt": "2022-05-26T22:36:05Z",
      "updatedAt": "2022-05-27T21:46:17Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "89de709a1235fe063d875ea0864e054d4f0e281f",
      "headRepository": "BasileiosKal/bbs-signature",
      "headRefName": "editorial-updates",
      "headRefOid": "09344c8e5b25c3c7ed7bb4a81ac6321d05c3d871",
      "closedAt": "2022-05-27T21:46:16Z",
      "mergedAt": "2022-05-27T21:46:16Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "7473dc3108966bed90aad21fc7fb9345542e0bba"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Minor editorial change, multiple approvals, merging",
          "createdAt": "2022-05-27T21:46:13Z",
          "updatedAt": "2022-05-27T21:46:13Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax8460oRO",
          "commit": {
            "abbreviatedOid": "09344c8"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-26T23:06:06Z",
          "updatedAt": "2022-05-26T23:06:06Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax8465iEJ",
          "commit": {
            "abbreviatedOid": "09344c8"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-27T21:45:55Z",
          "updatedAt": "2022-05-27T21:45:55Z",
          "comments": []
        }
      ]
    },
    {
      "number": 160,
      "id": "PR_kwDOF8lax844pNhT",
      "title": "fix typos",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/160",
      "state": "MERGED",
      "author": "dev0x1",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-05-29T19:12:57Z",
      "updatedAt": "2022-05-29T22:45:20Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "83059a30911c5fa19caf12dd1507f6870cd4d561",
      "headRepository": "dev0x1/bbs-signature",
      "headRefName": "gaurav/review",
      "headRefOid": "0cc034c85055c6c454b42ab7611cf9377f533c1b",
      "closedAt": "2022-05-29T22:45:20Z",
      "mergedAt": "2022-05-29T22:45:20Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "02ea4b981cc6288074c6beb968792d2e27d7003c"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Minor editorial fixes for typos, merging",
          "createdAt": "2022-05-29T22:44:43Z",
          "updatedAt": "2022-05-29T22:45:16Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax8467enM",
          "commit": {
            "abbreviatedOid": "0cc034c"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-29T22:44:28Z",
          "updatedAt": "2022-05-29T22:44:28Z",
          "comments": []
        }
      ]
    },
    {
      "number": 161,
      "id": "PR_kwDOF8lax844smIw",
      "title": "Generator definition within ciphersuite",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/161",
      "state": "CLOSED",
      "author": "andrewwhitehead",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR moves generator computation into a separate section, allowing for the use of separate computation methods and generator seed options. There are inconsistencies remaining with the test vectors, and the language and security considerations could likely use tidying up.",
      "createdAt": "2022-05-30T17:38:12Z",
      "updatedAt": "2022-06-16T21:44:52Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "02ea4b981cc6288074c6beb968792d2e27d7003c",
      "headRepository": "andrewwhitehead/bbs-signature",
      "headRefName": "suite-generators",
      "headRefOid": "ffe54514da9c9a47a387c78e85fbecba71fb88a6",
      "closedAt": "2022-06-16T21:44:52Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thinking more about it after the call, the only options i can see that would remove the generators from the input of the operations are,\r\n1. Suites will define a `createGenerators` operation (not necessarily the one that is currently on the document) and have each operation call `createGenerators` as part of their procedure, with a note that the output of this function can be cached.\r\n2. Each suite will only define \"global\" generators but make the \"generators\" parameter \"optional\". That way, people can define suites that don't specify the generators and use whatever they want.\r\n3. Define the suite as \"dynamic\" i.e., give the ability to the ciphersuite to \"know\" L and/or the issuers PK.\r\n\r\nPersonally i would go with Option 2. It serves most cases + it keeps the suites \"static\" and simple. Option 1 will add more steps to each operation, and as I said on the call, I'm not a huge fan of option 3 (i can definitely be convinced otherwise of-course).\r\n\r\n I'm very interested to hear others thoughts on this as well (c.c., @tplooker, @andrewwhitehead ^^).",
          "createdAt": "2022-05-30T20:40:14Z",
          "updatedAt": "2022-05-30T20:40:14Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think we need to hammer out the details on generator flexibility. To me it is seeming more like a misfeature that only complicates the API surface and the implementation.\r\n\r\nIn the original version we had generators that depended on the issuer's public key and the number of messages to be signed, but (to my knowledge) that was only avoiding malleability of those two factors, which is now accomplished by the domain message.\r\n\r\nBecause this keeps coming up as an issue, and there could conceivably be security considerations or benefits that come along with other creation methods (for example, one that didn't depend on hash-to-curve), I think we ought to leave this open ended in the style of the expand_message function in the hash-to-curve RFC: https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-11#section-5.4.4. Within the RFC there are two expand_message variants defined, and likely every implementation currently uses one or the other. However, each method defines an identifier which is added to the ciphersuite ID, and other arbitrarily-complex methods could be defined in separate RFCs.",
          "createdAt": "2022-05-30T22:29:53Z",
          "updatedAt": "2022-05-30T22:29:53Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agreed! Just to clarify, you are in favor of Option 1 in [my comment above](https://github.com/decentralized-identity/bbs-signature/pull/161#issuecomment-1141465183) then?? Is that accurate?? \r\n\r\nThis would mean that each ciphersuite has a `get_generators` parameter that can be any procedure (like [createGenerators](https://identity.foundation/bbs-signature/draft-bbs-signatures.html#name-creategenerators)) that deterministically returns a number of distinct, indistinguishable from uniformly random, points in G1. Then each operation will call `get_generators` to create the message generators with a note that the output of this function can be cached??\r\n\r\nIf I'm not missing something I'm not opposed to that direction. It's the only way i can see that would allow for what the previous version of the spec did (i.e., like `hash_to_curve(PK || i || L)`) without changing the scope of the ciphersuites. Although I'm not 100% convinced that this type of \"flexibility\" is actually whats needed. This syntax kinda assumes an operation that returns points and discourages (does not disallow) just \"picking\" random points.",
          "createdAt": "2022-05-31T19:12:27Z",
          "updatedAt": "2022-05-31T19:12:27Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\r\nIn any case, i think we all agree to remove the generators from the input of the operations, so i suggest moving in in this direction. After that, we can re-define how the generators are picked if need be. \r\n\r\n @andrewwhitehead i think it's easier to make the update in my [API_update](https://github.com/decentralized-identity/bbs-signature/pull/138) PR?? Is that ok or you prefer making the updates here??",
          "createdAt": "2022-05-31T19:15:28Z",
          "updatedAt": "2022-05-31T19:15:28Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, I think option 1 is my favorite at the moment. I should have an update to this PR in a bit, but I'm staying away from updating the operations to avoid conflicts.",
          "createdAt": "2022-05-31T22:14:10Z",
          "updatedAt": "2022-05-31T22:14:10Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax847JYzJ",
          "commit": {
            "abbreviatedOid": "ffe5451"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-01T17:03:47Z",
          "updatedAt": "2022-06-01T17:03:47Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "This needs adjustment - no underscores",
              "createdAt": "2022-06-01T17:03:47Z",
              "updatedAt": "2022-06-01T17:03:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax847LD2o",
          "commit": {
            "abbreviatedOid": "ffe5451"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "I really like the direction! Just some thoughts to maybe consider.",
          "createdAt": "2022-06-01T22:38:36Z",
          "updatedAt": "2022-06-01T22:47:17Z",
          "comments": [
            {
              "originalPosition": 180,
              "body": "I don't see why we would need to use a different hash function for the generators only?? Since `compute_generators_xof` is optional, it seems weird to me to make the ciphersuite to **have** to define the `generator_xof` parameter (or the other `compute_generators_xof`  specific parameters, like `hash_to_curve_g1`).",
              "createdAt": "2022-06-01T22:38:36Z",
              "updatedAt": "2022-06-01T22:47:17Z"
            },
            {
              "originalPosition": 69,
              "body": "Since we are making the update, should we maybe consider a different procedure as well?? Something like,\r\n```\r\nProcedure:\r\n\r\n1. L= maxMessageCount + 2\r\n2. h_0 = hash(seed || I2OSP(0, 2))\r\n3. h_1 = hash(h_0 || I2OSP(1, 2))\r\n4. for i in 1 to L:\r\n5.    generator_i = Identity_G1\r\n6.    while(generator_i == Identity_G1 or generator_i == P1)\r\n7.        candidate = hash_to_curve_g1(h_i, generator_dst)\r\n8.        h_i = hash(strxor(h_0, h_(i-1)) || I2OSP(i, 2))\r\n9.        if candidate not in generators: generator_i = candidate\r\n10. return generators\r\n```\r\nHere `hash` can be an xof also. What i like about this is that let's say you have cached 1000 generators and you need to sign 1001 messages. In the current procedure you need to compute the 1000 generators from the beginning.  In this approach though, You only need to save the last `h_i` computed, and immediately calculate the next generator. Some notes,\r\n\r\n- The input seed is not adversarially controlled so no need for more complicated procedures (because of the guarantees that this function gives, i.e., close to uniform output distribution)\r\n- Is less efficient, but i really don't think that time efficiency is what we should optimize for here. Also, cases like the above will hurt performance. \r\n- Is usable with whatever hash is defined by the ciphersuite, so no need for extra parameters (this is related with the discussion in #162 as well)\r\n\r\nThoughts?? c.c. @mikelodder7, @tplooker^^",
              "createdAt": "2022-06-01T22:38:58Z",
              "updatedAt": "2022-06-01T22:47:17Z"
            },
            {
              "originalPosition": 55,
              "body": "Just a though. It may be better to add the +2 when calling the function in the operations?? That way someone that is reading the procedures will not be confused why they got L+2 elements when they asked for L??",
              "createdAt": "2022-06-01T22:43:24Z",
              "updatedAt": "2022-06-01T22:47:17Z"
            },
            {
              "originalPosition": 45,
              "body": "```suggestion\r\n- maxMessageCount (REQUIRED), non-negative integer. The number of generators to be returned.\r\n```\r\n\r\nIf the operation is to be called inside each procedure, should this be something like the above?? Otherwise if this input is indeed the maximum number of messages that an issuer can (ever) sign, dosen't this dissallow what the previous version of the spec did (i.e., something like `g_i = hash_to_curve(PK || i || L)`) because in this case it will be weistfull to create maxMessageCount generators??",
              "createdAt": "2022-06-01T22:43:30Z",
              "updatedAt": "2022-06-01T22:47:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax847LHZ2",
          "commit": {
            "abbreviatedOid": "ffe5451"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-01T23:04:33Z",
          "updatedAt": "2022-06-01T23:04:34Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "Yes, that might be clearer",
              "createdAt": "2022-06-01T23:04:33Z",
              "updatedAt": "2022-06-01T23:04:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax847LJHk",
          "commit": {
            "abbreviatedOid": "ffe5451"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-01T23:15:46Z",
          "updatedAt": "2022-06-01T23:15:46Z",
          "comments": [
            {
              "originalPosition": 180,
              "body": "Yes, more likely it would just use the `hash` function. I'm not sure how best to specify the dependency between the hash used in `hash_to_curve_g1` and the other hash used in this method, and also require that it is an XOF. `hash_to_curve_g1`, `generator_seed` etc are meant to be parameters specific to the `compute_generators_xof` method and should probably be in their own section. I'm not sure yet if there is value in supporting `compute_generators` methods that don't necessarily depend on H2C, but maybe using a method that is agnostic of the hash type is good enough for now.",
              "createdAt": "2022-06-01T23:15:46Z",
              "updatedAt": "2022-06-01T23:15:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax847LJV9",
          "commit": {
            "abbreviatedOid": "ffe5451"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-01T23:17:32Z",
          "updatedAt": "2022-06-01T23:17:32Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "It's meant to be the maximum number of messages supported by this set of generators, but yes that could be clearer. Having a dependency on L in the seed seems like a liability to me.",
              "createdAt": "2022-06-01T23:17:32Z",
              "updatedAt": "2022-06-01T23:17:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax847NMWU",
          "commit": {
            "abbreviatedOid": "ffe5451"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-02T10:10:50Z",
          "updatedAt": "2022-06-02T10:10:51Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "I agree regarding the seed and L dependency. I would much rather say that the input is a ciphersuite-defined seed. So we don't have to worry a lot about adversarial inputs which can be a pain to deal with (even if we use an XOF only).\r\n\r\nIMO there are the following trade-offs in the different input choices to `compute_generators` :\r\n\r\n- If we use maxMessageCount, the generators can be a parameter and not created in the procedure of each operation. This makes it clearer that they should be cached.\r\n- On the cons side, it \"forces\" a hard upper limit to the number of messages that can be signed, without any \"technical\" reason. It also requires the users to define this number which may not be as \"straight forward\", since, the more messages they \"support\", the less efficient the operation will be and the more generators they will need to cache.\r\n- Calling `compute_generators(L)` inside each procedure is clearer IMO and doesn't require more \"work\" from the implementer to define parameters.\r\n- On the cons side, it may not be clear enough that the output of `compute_generators` should be cached and **NOT** be re-calculated each time.\r\n\r\nI would personally go with option 2 and call `compute_generators(L)` inside each operation, with a note that the output must be cached (if it's not, it is not a security issue, just an efficiency one, so i think it's fine).",
              "createdAt": "2022-06-02T10:10:51Z",
              "updatedAt": "2022-06-02T10:10:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax847NM4Z",
          "commit": {
            "abbreviatedOid": "ffe5451"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-02T10:12:54Z",
          "updatedAt": "2022-06-02T10:12:55Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "Thinking more about it, another option, based on expand_message from h2c, can be the following, \r\n```\r\n(generator_1, ..., generator_L) = compute_generators(seed, L)\r\n\r\nProcedure:\r\n\r\n1. seed = hash(seed)\r\n2. uniform_bytes = expand_message(seed, gen_seed_dst, points_octets_length * L)\r\n3. index = 0\r\n4. for i in 1 to L:\r\n5.        gen_seed = uniform_bytes[index..(index + octet_point_length - 1)]\r\n6.        generator_i = hash_to_curve_g1(gen_seed, gen_dst)\r\n7.        if generator_i is in generators or generator_i = Indetity_G1 or generator_i = P1:\r\n8.               seed = hash(seed)\r\n9.               go back to step 2\r\n10.      index += octet_point_length\r\n11. return generators\r\n```\r\nThis has more or less the same advantages and disadvantages with the above proposal. Note that we are not creating new dependencies here really. It also has the advantage that it accounts for adversarially controlled seeds (if we worry about that, which I'm not really). On the other hand, is less performant, but again i think we should optimize for usability and readability of the spec here than performance.\r\n\r\nMore importantly IMO, it's usable with the ciphersuite defined `hash` so no need for a `generator_xof` parameter.",
              "createdAt": "2022-06-02T10:12:55Z",
              "updatedAt": "2022-06-03T16:56:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax847NOj8",
          "commit": {
            "abbreviatedOid": "ffe5451"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-02T10:19:43Z",
          "updatedAt": "2022-06-02T10:19:44Z",
          "comments": [
            {
              "originalPosition": 180,
              "body": "That's a good point! I can't even imagine what those methods (not h2c based) would look like.\r\n\r\n> maybe using a method that is agnostic of the hash type is good enough for now.\r\n\r\nYeap! That's my thinking as well. That's why i took a shot in such a procedure [here](https://github.com/decentralized-identity/bbs-signature/pull/161#discussion_r887355556). Another option can be an hkdf based construction (we already have a \"optional dependency\" on hkdf for keyGen) or a expand_message based one (since 'compute_generators' depends on h2c either way) as i try to propose [here](https://github.com/decentralized-identity/bbs-signature/pull/161#discussion_r887793786). IMO we best use the same hash for everything. We could use a different hash for `hash_to_curve_g1` by just pointing to the defined h2c suite, but for creating the input seed we should use the bbs+ suite defined `hash`.\r\n\r\nAnother option can be to make the described `compute_generators` procedure a requirement, and define the `generators_xof` parameter to the ciphersuite as required. However, I'm really not a big fun of this approach.",
              "createdAt": "2022-06-02T10:19:43Z",
              "updatedAt": "2022-06-02T10:19:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax847PO0u",
          "commit": {
            "abbreviatedOid": "ffe5451"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-02T16:38:23Z",
          "updatedAt": "2022-06-02T16:38:23Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "My intention was that the operations would do something like `(H_s, H_d, H_1 ... H_L) = compute_generators(L)`.",
              "createdAt": "2022-06-02T16:38:23Z",
              "updatedAt": "2022-06-02T16:38:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax847PRgp",
          "commit": {
            "abbreviatedOid": "ffe5451"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-02T16:48:02Z",
          "updatedAt": "2022-06-02T16:48:02Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "I like the idea of using expand_message rather than defining something equivalent, but this method does make it harder to extend a cached list of generators.",
              "createdAt": "2022-06-02T16:48:02Z",
              "updatedAt": "2022-06-02T16:48:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax847SvVJ",
          "commit": {
            "abbreviatedOid": "ffe5451"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-03T11:05:22Z",
          "updatedAt": "2022-06-03T11:05:22Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "Good point. Using `expand_message_xmd` you could save `b_0, last_i, b_(last_i)` as state and start from where you left of (and it will be easy to describe in the spec IMO). Using `expand_message_xof` though will be harder. However the current xof based construction has the same issue. So if people want this ability they can always use `expand_message_xmd` with an xof??",
              "createdAt": "2022-06-03T11:05:22Z",
              "updatedAt": "2022-06-03T11:05:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax847Svxe",
          "commit": {
            "abbreviatedOid": "ffe5451"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-03T11:07:31Z",
          "updatedAt": "2022-06-03T11:07:31Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "+1. In this case i would suggest `maxMessageCount` -> `MessageCount` (or `message_count`). I think this will be clearer.",
              "createdAt": "2022-06-03T11:07:31Z",
              "updatedAt": "2022-06-03T11:07:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax847Sv0I",
          "commit": {
            "abbreviatedOid": "ffe5451"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-03T11:07:44Z",
          "updatedAt": "2022-06-03T11:07:45Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Note, in this case `L` should be inputted to `ProofVerify`. Not really an issue (i know a lot of implementations do this already), just a note so we will not forget to update the inputs.",
              "createdAt": "2022-06-03T11:07:44Z",
              "updatedAt": "2022-06-03T16:55:25Z"
            }
          ]
        }
      ]
    },
    {
      "number": 165,
      "id": "PR_kwDOF8lax845HQvu",
      "title": "Editorial updates",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/165",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Various editorial updates:\r\n1. PK and KeyValidate updates:\r\n    1. Changed `KeyValidate` to accept the de-serialized key (half the times `KeyValidate` was used the PK was (re) de-serialized  immediately after, which is inefficient).\r\n    2. Removed `KeyValidate` from `ProofGen` and `Sign` (we just hash the PK there).\r\n    3. Removed PK de-serialization from `Sign` (the result is not used).\r\n    4. Added PK de-serialization to `ProofVerify`.\r\n \r\n2. Changed notation from `m~_j1, \u2026, m~_jU` -> `m~_1, \u2026, m~_U` (I think it's clearer this way).\r\n\r\nSome updates noted by @dev0x1:\r\n1. Changed pairing equality check in `Verify` to match the one in `ProofVerify`.\r\n\r\n2. Fixed typo in `ProofVerify` (`H_s` -> `H_d` in step 8).\r\n\r\nI will update/re-base this as required if needed (it will probably have conflicts with some of the other open PRs).",
      "createdAt": "2022-06-04T14:34:16Z",
      "updatedAt": "2022-06-20T18:56:30Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "337f3b03caa246c0ed9265fae44b0ab78d94fa72",
      "headRepository": "BasileiosKal/bbs-signature",
      "headRefName": "editorial-updates",
      "headRefOid": "e0a67d6a46b23d5cbe1ba92384711e9740913e6b",
      "closedAt": "2022-06-20T18:56:30Z",
      "mergedAt": "2022-06-20T18:56:30Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "ec3780a935356478fdc3887036759ccee72c07fa"
      },
      "comments": [
        {
          "author": "dev0x1",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@BasileiosKal May be we can also update to use consistent ordering of **Abar** and **A'** in proof and input to `hash_to_scalar`, \r\nin `ProofGen`,\r\n`19. c = hash_to_scalar((PK || Abar || A' || D || C1 || C2 || ph), 1)`\r\n\r\n`25. proof = (A', Abar, D, c, e^, r2^, r3^, s^, (m^_j1, ..., m^_jU))`\r\n\r\nin `ProofVerify`,\r\n\r\n`4. (A', Abar, D, c, e^, r2^, r3^, s^, (m^_j1,...,m^_jU)) = proof`\r\n\r\n`10. cv = hash_to_scalar((PK || Abar || A' || D || C1 || C2 || ph), 1)`\r\n\r\n",
          "createdAt": "2022-06-06T09:47:05Z",
          "updatedAt": "2022-06-06T09:47:05Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "> @BasileiosKal May be we can also update to use consistent ordering of **Abar** and **A'** in proof and input to `hash_to_scalar`, in `ProofGen`, `19. c = hash_to_scalar((PK || Abar || A' || D || C1 || C2 || ph), 1)`\r\n> \r\n> `25. proof = (A', Abar, D, c, e^, r2^, r3^, s^, (m^_j1, ..., m^_jU))`\r\n> \r\n> in `ProofVerify`,\r\n> \r\n> `4. (A', Abar, D, c, e^, r2^, r3^, s^, (m^_j1,...,m^_jU)) = proof`\r\n> \r\n> `10. cv = hash_to_scalar((PK || Abar || A' || D || C1 || C2 || ph), 1)`\r\n\r\nI would probably raise this as a seperate issue rather than addressing in this PR",
          "createdAt": "2022-06-07T00:06:18Z",
          "updatedAt": "2022-06-07T00:06:18Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@BasileiosKal can you address conflicts?",
          "createdAt": "2022-06-07T23:07:25Z",
          "updatedAt": "2022-06-07T23:07:25Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Updated to remove conflicts + made ph in ProofVerify optional (thanks @dev0x1!!)",
          "createdAt": "2022-06-08T18:11:21Z",
          "updatedAt": "2022-06-08T18:11:21Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "After thinking more about it, IMO the best way to de-serialize the PK and check if it is valid is to introduce a `PubkeyToPoint` operation. The reasons are, \r\n\r\n1. If we de-serialize the PK in the procedure and pass the result in KeyValidate directly, we would potentially pass INVALID as input, which I really don\u2019t think it\u2019s wise (not technically wrong, but I\u2019m really afraid of implementation mistakes here).\r\n2. If we de-serialize the PK in KeyValidate, we would need to de-serialize the key twice. \r\n3. We want the two operations distinct so we can say that people can skip (or cache) the KeyValidate check.\r\n\r\nThe proposal goes around these issues. Thoughts??\r\n\r\n",
          "createdAt": "2022-06-08T19:04:51Z",
          "updatedAt": "2022-06-08T19:04:51Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Can you resolve conflicts with this PR?",
          "createdAt": "2022-06-09T21:05:27Z",
          "updatedAt": "2022-06-09T21:05:27Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed on the WG call resolved to make a few changes\r\n\r\n- rename pubkey_to_point to octets_to_pubkey\r\n- add identity check to octets_to_pubkey and then remove KeyValidate\r\n- add security consideration for sub group checks for the octet_to_point_g* functions",
          "createdAt": "2022-06-13T18:38:07Z",
          "updatedAt": "2022-06-13T18:38:07Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Discussed on the WG call resolved to make a few changes\r\n\r\nUpdated and ready for re-review!",
          "createdAt": "2022-06-20T11:56:52Z",
          "updatedAt": "2022-06-20T11:56:52Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax847Xmlt",
          "commit": {
            "abbreviatedOid": "96bd182"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-05T21:43:04Z",
          "updatedAt": "2022-06-05T21:43:04Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "I'd prefer we only hand the valid output of SkToPk as the input here",
              "createdAt": "2022-06-05T21:43:04Z",
              "updatedAt": "2022-06-05T21:43:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax847Xmmv",
          "commit": {
            "abbreviatedOid": "96bd182"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-05T21:44:13Z",
          "updatedAt": "2022-06-05T21:44:13Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "As per above I think we should consider drawing the boundary for this operation as `W` being the valid output from the SkToPk operation",
              "createdAt": "2022-06-05T21:44:13Z",
              "updatedAt": "2022-06-05T21:44:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax847bJtM",
          "commit": {
            "abbreviatedOid": "96bd182"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-06T17:56:19Z",
          "updatedAt": "2022-06-06T17:56:19Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "I'm not opposed to that. Just to clarify though, do you mean SkToPk not returning octetcs but W directly??",
              "createdAt": "2022-06-06T17:56:19Z",
              "updatedAt": "2022-06-06T17:56:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax847bJ0e",
          "commit": {
            "abbreviatedOid": "96bd182"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-06T17:56:42Z",
          "updatedAt": "2022-06-06T17:56:42Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "I would prefer that as well. That said it's a trade-off. The problem is that the output of `SkToPk` is an octet string, meaning we will need to de-serialize it in `KeyValidate`. Any time we call `KeyValidate` in a procedure though, we de-serialize the PK again. So we are doing two de-serializations wile we only need one.\r\n\r\nMaybe define `W` as a point in `G2` will be fine here??",
              "createdAt": "2022-06-06T17:56:42Z",
              "updatedAt": "2022-06-06T17:56:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax847coRs",
          "commit": {
            "abbreviatedOid": "96bd182"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-06T23:56:47Z",
          "updatedAt": "2022-06-06T23:56:48Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Apologies I meant to say `octets_to_point_g2` instead of `SkToPk` so we would handle that deserialization in the procedure that is going to call `KeyValidate`",
              "createdAt": "2022-06-06T23:56:48Z",
              "updatedAt": "2022-06-06T23:56:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax847n0wf",
          "commit": {
            "abbreviatedOid": "96bd182"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-08T19:06:37Z",
          "updatedAt": "2022-06-08T19:06:38Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Got it! That is indeed better. I updated towards that direction, introducing some more updates (see [here](https://github.com/decentralized-identity/bbs-signature/pull/165#issuecomment-1150289470)). Let me know of what you think of this new direction!",
              "createdAt": "2022-06-08T19:06:38Z",
              "updatedAt": "2022-06-08T19:06:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84741C6",
          "commit": {
            "abbreviatedOid": "2247a10"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-13T18:21:10Z",
          "updatedAt": "2022-06-13T18:21:10Z",
          "comments": [
            {
              "originalPosition": 249,
              "body": "```suggestion\r\n\r\nThis operation decodes an octet string representing a public key, validates it and return the corresponding point in G2.\r\n```",
              "createdAt": "2022-06-13T18:21:10Z",
              "updatedAt": "2022-06-13T18:21:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84741Rh",
          "commit": {
            "abbreviatedOid": "2247a10"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-06-13T18:22:00Z",
          "updatedAt": "2022-06-13T18:22:00Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax84745t4",
          "commit": {
            "abbreviatedOid": "2247a10"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "Dropping approval considering the changes we agreed on the WG call",
          "createdAt": "2022-06-13T18:38:35Z",
          "updatedAt": "2022-06-13T18:38:35Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax848W5CB",
          "commit": {
            "abbreviatedOid": "694d69e"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-20T18:09:13Z",
          "updatedAt": "2022-06-20T18:09:13Z",
          "comments": [
            {
              "originalPosition": 103,
              "body": "```suggestion\r\n10. return VALID\r\n```",
              "createdAt": "2022-06-20T18:09:13Z",
              "updatedAt": "2022-06-20T18:09:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848W5P8",
          "commit": {
            "abbreviatedOid": "694d69e"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-20T18:10:29Z",
          "updatedAt": "2022-06-20T18:10:30Z",
          "comments": [
            {
              "originalPosition": 283,
              "body": "```suggestion\r\n## Point de-serialization\r\n```",
              "createdAt": "2022-06-20T18:10:29Z",
              "updatedAt": "2022-06-20T18:10:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848W5Vh",
          "commit": {
            "abbreviatedOid": "5605266"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-06-20T18:11:02Z",
          "updatedAt": "2022-06-20T18:11:02Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax848W-Xh",
          "commit": {
            "abbreviatedOid": "5605266"
          },
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-06-20T18:42:01Z",
          "updatedAt": "2022-06-20T18:42:01Z",
          "comments": []
        }
      ]
    },
    {
      "number": 167,
      "id": "PR_kwDOF8lax845QSVW",
      "title": "Harmonized use of A_octets (vs a_octets)",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/167",
      "state": "MERGED",
      "author": "christianpaquin",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Capitalized the 'A' in `A_octets` everywhere.",
      "createdAt": "2022-06-07T15:42:42Z",
      "updatedAt": "2022-06-08T20:56:06Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "849e6d96b895615d460f92bf0b1d7efbb8f62519",
      "headRepository": "christianpaquin/bbs-signature",
      "headRefName": "harmonized-a_octets",
      "headRefOid": "a6a59d1cad3e6687882dd8132bb7fcb8432ba88c",
      "closedAt": "2022-06-08T20:56:06Z",
      "mergedAt": "2022-06-08T20:56:06Z",
      "mergedBy": "BasileiosKal",
      "mergeCommit": {
        "oid": "ef70c2d973f9944f18c0295e3028b814def82d1a"
      },
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Multiple approvals. Editorial update. Improves readability. Merging!",
          "createdAt": "2022-06-08T20:55:50Z",
          "updatedAt": "2022-06-08T20:55:50Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax847io2W",
          "commit": {
            "abbreviatedOid": "8d4a47c"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "LGTM just need to resolve conflicts",
          "createdAt": "2022-06-07T23:06:48Z",
          "updatedAt": "2022-06-07T23:06:48Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax847oJo-",
          "commit": {
            "abbreviatedOid": "a6a59d1"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "@christianpaquin I hope you don't mind but i took the liberty to resolve the conflicts. LGTM also. I'm happy to merge!",
          "createdAt": "2022-06-08T20:12:13Z",
          "updatedAt": "2022-06-08T20:12:13Z",
          "comments": []
        }
      ]
    },
    {
      "number": 169,
      "id": "PR_kwDOF8lax845fiQ9",
      "title": "Harmonization edits",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/169",
      "state": "MERGED",
      "author": "christianpaquin",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Harmonized 1) order of ph and header in ProofGen and ProofVerify arguments, and 2) use of \"indexes\".",
      "createdAt": "2022-06-10T21:23:34Z",
      "updatedAt": "2022-06-13T18:17:22Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "69d54e61405064871f72e61f89e57a9e29635da9",
      "headRepository": "christianpaquin/bbs-signature",
      "headRefName": "consistency-edits",
      "headRefOid": "25cb9b045bf52c06cf94dae81fb7c66c2e07e5b7",
      "closedAt": "2022-06-13T18:17:22Z",
      "mergedAt": "2022-06-13T18:17:22Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "c8a1055e766a4f1839fd5083aa6c7a9a865e3784"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Reviewed on WG call, multiple approvals, merging",
          "createdAt": "2022-06-13T18:17:15Z",
          "updatedAt": "2022-06-13T18:17:15Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax8474zgH",
          "commit": {
            "abbreviatedOid": "25cb9b0"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-06-13T18:15:21Z",
          "updatedAt": "2022-06-13T18:15:21Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax8474z7S",
          "commit": {
            "abbreviatedOid": "25cb9b0"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-06-13T18:16:57Z",
          "updatedAt": "2022-06-13T18:16:57Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax8474z7e",
          "commit": {
            "abbreviatedOid": "25cb9b0"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-06-13T18:16:57Z",
          "updatedAt": "2022-06-13T18:16:57Z",
          "comments": []
        }
      ]
    },
    {
      "number": 170,
      "id": "PR_kwDOF8lax845lTst",
      "title": "Add definition of U to ProofGen/ProofVerify",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/170",
      "state": "MERGED",
      "author": "christianpaquin",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Suggesting adding `U` to the definitions, since the value is used in the functions. \r\n\r\nAlso changed \"e.g.\" to \"i.e.\" as a clarification. ",
      "createdAt": "2022-06-13T19:02:44Z",
      "updatedAt": "2022-06-14T10:10:07Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "c8a1055e766a4f1839fd5083aa6c7a9a865e3784",
      "headRepository": "christianpaquin/bbs-signature",
      "headRefName": "add-U-def-to-proof-gen-and-verify",
      "headRefOid": "830a31df1e714374c53e0c037653ea5a93278607",
      "closedAt": "2022-06-14T10:10:07Z",
      "mergedAt": "2022-06-14T10:10:07Z",
      "mergedBy": "BasileiosKal",
      "mergeCommit": {
        "oid": "ca6dc83da752127a3d2cf61043c5781b7c433d53"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "LGTM thanks!",
          "createdAt": "2022-06-13T21:56:32Z",
          "updatedAt": "2022-06-13T21:56:32Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Multiple approvals. Merging.",
          "createdAt": "2022-06-14T10:09:56Z",
          "updatedAt": "2022-06-14T10:09:56Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax8475xjC",
          "commit": {
            "abbreviatedOid": "830a31d"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-06-13T21:56:20Z",
          "updatedAt": "2022-06-13T21:56:20Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax8478AxV",
          "commit": {
            "abbreviatedOid": "830a31d"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-06-14T10:03:57Z",
          "updatedAt": "2022-06-14T10:03:57Z",
          "comments": []
        }
      ]
    },
    {
      "number": 174,
      "id": "PR_kwDOF8lax845uCPV",
      "title": "Updated section refs to new v16 hash-to-curve spec",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/174",
      "state": "MERGED",
      "author": "christianpaquin",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "New v16 of the hash-to-curve spec removed section 5.1, so we need to adapt the section 5.x references in ours. See [v15 and v16 diff](https://www.ietf.org/rfcdiff?difftype=--hwdiff&url2=draft-irtf-cfrg-hash-to-curve-16.txt).\r\n\r\nI couldn't find the actual reference to the spec in the Normative References section, only generic `[@!I-D.irtf-cfrg-hash-to-curve]` refs; I assume the build system turns that to a ref to the latest version?",
      "createdAt": "2022-06-15T16:06:35Z",
      "updatedAt": "2022-06-15T23:51:52Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "ca6dc83da752127a3d2cf61043c5781b7c433d53",
      "headRepository": "christianpaquin/bbs-signature",
      "headRefName": "updated-refs-to-hash-to-curve-spec",
      "headRefOid": "14a916fa883e7699e6c92ebd0d377092776600db",
      "closedAt": "2022-06-15T23:51:52Z",
      "mergedAt": "2022-06-15T23:51:52Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "8c6930008f1482ccbdbd3cde7eea2f93ef4e920d"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Minor editorial tweak, merging",
          "createdAt": "2022-06-15T23:51:48Z",
          "updatedAt": "2022-06-15T23:51:48Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax848FivF",
          "commit": {
            "abbreviatedOid": "14a916f"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "LGTM thanks @christianpaquin and yes the reference resolution I believe auto resolves to the latest draft available for that name",
          "createdAt": "2022-06-15T20:25:52Z",
          "updatedAt": "2022-06-15T20:25:52Z",
          "comments": []
        }
      ]
    },
    {
      "number": 175,
      "id": "PR_kwDOF8lax845vD5U",
      "title": "Use Identity_G1 instead of 1 in ProofVerify",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/175",
      "state": "MERGED",
      "author": "christianpaquin",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Use Identity_G1 and Identity_GT instead of 1 in ProofVerify.\r\n\r\n",
      "createdAt": "2022-06-15T21:16:15Z",
      "updatedAt": "2022-06-16T23:14:01Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "8c6930008f1482ccbdbd3cde7eea2f93ef4e920d",
      "headRepository": "christianpaquin/bbs-signature",
      "headRefName": "use-id-element-in-proofverify",
      "headRefOid": "739202cdb54332dca56d47b9877355e52ef035d6",
      "closedAt": "2022-06-16T23:14:01Z",
      "mergedAt": "2022-06-16T23:14:01Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "337f3b03caa246c0ed9265fae44b0ab78d94fa72"
      },
      "comments": [
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "`Identity_GT` I suppose?",
          "createdAt": "2022-06-15T21:33:46Z",
          "updatedAt": "2022-06-15T21:33:46Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "> Identity_GT I suppose?\r\n\r\nYeah this would make more sense to me? could we add that to the terminology section @christianpaquin",
          "createdAt": "2022-06-15T23:17:26Z",
          "updatedAt": "2022-06-15T23:17:26Z"
        },
        {
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> > Identity_GT I suppose?\r\n> \r\n> Yeah this would make more sense to me? could we add that to the terminology section @christianpaquin\r\n\r\nDone",
          "createdAt": "2022-06-16T14:00:18Z",
          "updatedAt": "2022-06-16T14:00:18Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Multiple approvals, minor editorial change that provides an important clarification to the ProofVerify procedure, merging.",
          "createdAt": "2022-06-16T23:13:57Z",
          "updatedAt": "2022-06-16T23:13:57Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax848MNM5",
          "commit": {
            "abbreviatedOid": "739202c"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-06-16T23:08:14Z",
          "updatedAt": "2022-06-16T23:08:14Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax848MNjz",
          "commit": {
            "abbreviatedOid": "739202c"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-06-16T23:11:19Z",
          "updatedAt": "2022-06-16T23:11:19Z",
          "comments": []
        }
      ]
    },
    {
      "number": 177,
      "id": "PR_kwDOF8lax845ziih",
      "title": "Update generator creation procedure",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/177",
      "state": "MERGED",
      "author": "andrewwhitehead",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This removes several of the ciphersuite parameters in favor of a generator creation procedure which reuses the `expand_message` operation defined by hash-to-curve suite. Additional PRs would be needed to update the use of generators in the suite's operations, and to update the test vectors. I'm trying to avoid conflicts with open PRs.\r\n\r\nThe operation currently defines a `hash_output_bytes` value, but this would likely switch to `expand_length` used in #151.\r\n\r\nSupersedes #161 and the discussion on that PR.",
      "createdAt": "2022-06-16T21:44:40Z",
      "updatedAt": "2022-07-07T22:53:00Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "337f3b03caa246c0ed9265fae44b0ab78d94fa72",
      "headRepository": "andrewwhitehead/bbs-signature",
      "headRefName": "suite-generators-2",
      "headRefOid": "2f0064a6ca362d6a9b5cd7a791c0d76d4b9a19ce",
      "closedAt": "2022-06-20T21:41:04Z",
      "mergedAt": "2022-06-20T21:41:04Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "ccf48fa8e2e9eb022b3591687d5ca6e3bebac584"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed on WG call, multiple reviews and approvals, merging, thanks @andrewwhitehead!",
          "createdAt": "2022-06-20T21:40:59Z",
          "updatedAt": "2022-06-20T21:40:59Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax848L20S",
          "commit": {
            "abbreviatedOid": "7955cdd"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-16T21:56:02Z",
          "updatedAt": "2022-06-16T21:56:03Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "For an XOF hash, this is not much different from the previous procedure, it only adds a DST.",
              "createdAt": "2022-06-16T21:56:03Z",
              "updatedAt": "2022-06-16T21:56:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848L3Ii",
          "commit": {
            "abbreviatedOid": "7955cdd"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-16T21:57:49Z",
          "updatedAt": "2022-06-16T21:57:50Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "I don't see any need for the generator DST and seed DST to be ciphersuite parameters, although the actual values are up for debate (these are chosen to be similar to the KeyGen salt).",
              "createdAt": "2022-06-16T21:57:50Z",
              "updatedAt": "2022-06-16T21:57:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848L6NU",
          "commit": {
            "abbreviatedOid": "7955cdd"
          },
          "author": "alessandroguggino",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-16T22:17:05Z",
          "updatedAt": "2022-06-16T22:17:05Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "Why not use an `xof` instead of `expand_message` and then call `.read(...)` inside the for cycle?",
              "createdAt": "2022-06-16T22:17:05Z",
              "updatedAt": "2022-06-16T22:17:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848L6hk",
          "commit": {
            "abbreviatedOid": "7955cdd"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-16T22:19:13Z",
          "updatedAt": "2022-06-16T22:19:14Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "This procedure is meant to be easily implemented whether the hash-to-curve suite's hash function is extensible-output or not, without introducing an extra hash function.",
              "createdAt": "2022-06-16T22:19:13Z",
              "updatedAt": "2022-06-16T22:19:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848SjGg",
          "commit": {
            "abbreviatedOid": "7955cdd"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-19T09:08:35Z",
          "updatedAt": "2022-06-19T10:03:55Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "```suggestion\r\nThe `create_generators` operation defines how to create a set of generators that form a part of the public parameters used by the BBS Signature scheme to accomplish operations such as Sign, Verify, ProofGen and ProofVerify. It takes one input, the number of generator points to create, which is determined in part by the number of signed messages.\r\n```\r\nThe selectively revealed part may be confused to the number of messages that will be revealed by the proof. Maybe removing it will be clearer??",
              "createdAt": "2022-06-19T09:08:35Z",
              "updatedAt": "2022-06-19T10:03:56Z"
            },
            {
              "originalPosition": 53,
              "body": "```suggestion\r\n2. v = expand_message(generator_seed || I2OSP(0, 4), seed_dst, hash_output_bytes)\r\n```\r\nJust for consistency with line 728 and so we can guarantee that the inputs will be distinct??",
              "createdAt": "2022-06-19T09:12:59Z",
              "updatedAt": "2022-06-19T10:03:56Z"
            },
            {
              "originalPosition": 70,
              "body": "A potential issue here is that from the first generator, all other generators can be deterministically defined. On other words, `generator_2` is not indistinguishable from random if you know `generator_1`. \r\n\r\nI realize that this approach is meant to be more easily \"extendable\" so I'm fine with moving on with that and maybe updating it later if we need to. Since the seed is not adversarialy controlled this is most probably fine.\r\n\r\nThat said, some other options can be to,\r\n1. call `expand_message` once to get `count * hash_output_bytes` bytes and the get substrings of that as seeds. I do realize this is not as easily extendable, but it will be provably secure while keeping the number of parameters low.\r\n2. use a \"secret value\" like PRK in HKDF or b_0 in expand_message_xmd. So we can set `b_0 = hash(generator_seed)` and call `v = expand_message(b_0 || v || I2OSP(n, 4), seed_dst, hash_output_bytes)` etc..\r\n\r\nIn any case, i sugest moving with this now and work on a formal security analysis later. This will allow for some other progress to be done as well.",
              "createdAt": "2022-06-19T09:57:47Z",
              "updatedAt": "2022-06-19T10:03:56Z"
            },
            {
              "originalPosition": 41,
              "body": "We don't mod something here so i don't see the reason for this suggestion. This will be the seed that will go into hash_to_curve which can be whatever length we want wright?? Or are we going to use that value, just so we will not introduce an extra variable?? It still seems a little extensive though, why not use `ceil(log2(r)/8)` for example??",
              "createdAt": "2022-06-19T10:02:40Z",
              "updatedAt": "2022-06-19T10:03:56Z"
            },
            {
              "originalPosition": 19,
              "body": "Is `c` here `count`??",
              "createdAt": "2022-06-19T10:03:27Z",
              "updatedAt": "2022-06-19T10:03:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848Skfx",
          "commit": {
            "abbreviatedOid": "7955cdd"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-19T10:04:28Z",
          "updatedAt": "2022-06-19T10:04:28Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "That's true but since this procedure will be used to create ciphersuite specific operators i like not adding them to the things an implimenter will need to choose. Maybe adding them as operation definitions??",
              "createdAt": "2022-06-19T10:04:28Z",
              "updatedAt": "2022-06-19T10:04:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848Skf1",
          "commit": {
            "abbreviatedOid": "7955cdd"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-19T10:04:32Z",
          "updatedAt": "2022-06-19T10:04:32Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "There is a difference IMO and that is that we re-initialize the xof every time with a different seed. Personally, I\u2019m fine with the approach since it allows for the efficient \"expansion\" of cached generators.",
              "createdAt": "2022-06-19T10:04:32Z",
              "updatedAt": "2022-06-19T10:05:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848SlDn",
          "commit": {
            "abbreviatedOid": "7955cdd"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-19T10:28:06Z",
          "updatedAt": "2022-06-19T10:28:07Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "And actually, thinking more about it, does this method \"require\" expand_message?? Wouldn't just `hash` do, where if `hash` is an xof, we will specify the output length??",
              "createdAt": "2022-06-19T10:28:06Z",
              "updatedAt": "2022-06-19T10:28:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848SwrT",
          "commit": {
            "abbreviatedOid": "7955cdd"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-19T17:25:04Z",
          "updatedAt": "2022-06-19T17:25:04Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "Yes I wasn't clear there, it's only similar for the first generator.",
              "createdAt": "2022-06-19T17:25:04Z",
              "updatedAt": "2022-06-19T17:25:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848Swsh",
          "commit": {
            "abbreviatedOid": "7955cdd"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-19T17:26:09Z",
          "updatedAt": "2022-06-19T17:26:09Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Oops, I renamed that to `n`.",
              "createdAt": "2022-06-19T17:26:09Z",
              "updatedAt": "2022-06-19T17:26:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848SwuK",
          "commit": {
            "abbreviatedOid": "7955cdd"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-19T17:27:24Z",
          "updatedAt": "2022-06-19T17:27:24Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "> Maybe adding them as operation definitions??\r\n\r\nThey are added as definitions currently",
              "createdAt": "2022-06-19T17:27:24Z",
              "updatedAt": "2022-06-19T17:27:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848Swye",
          "commit": {
            "abbreviatedOid": "7955cdd"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-19T17:31:20Z",
          "updatedAt": "2022-06-19T17:31:21Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "`hash_output_bytes` would likely be replaced by `expand_length` in future, but that's in another PR. I didn't want to reference `xof_no_bytes` here.",
              "createdAt": "2022-06-19T17:31:20Z",
              "updatedAt": "2022-06-19T17:31:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848Sw3A",
          "commit": {
            "abbreviatedOid": "7955cdd"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-19T17:35:09Z",
          "updatedAt": "2022-06-19T17:35:09Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "> And actually, thinking more about it, does this method \"require\" expand_message?? Wouldn't just hash do, where if hash is an xof, we will specify the output length??\r\n\r\nIt could but that would limit `v` to the hash's output size for fixed output hashes. I prefer using `expand_message` here because it's a primitive that is guaranteed to be available and should be hard to misuse.",
              "createdAt": "2022-06-19T17:35:09Z",
              "updatedAt": "2022-06-19T17:35:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848Sw6D",
          "commit": {
            "abbreviatedOid": "7955cdd"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-19T17:37:44Z",
          "updatedAt": "2022-06-19T17:37:44Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "That could be a little harder to implement, because generator_seed doesn't have a bounded length, so the implementer might need to allocate a separate buffer to create the input for expand_message. If the inputs are not distinct, then the algorithm would loop to the next attempt because the generator was already output.",
              "createdAt": "2022-06-19T17:37:44Z",
              "updatedAt": "2022-06-19T17:54:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848Sw-R",
          "commit": {
            "abbreviatedOid": "7955cdd"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-19T17:41:12Z",
          "updatedAt": "2022-06-19T17:41:12Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "> generator_2 is not indistinguishable from random if you know generator_1\r\n\r\ngenerator_i does not determine the generator_(i+1) though, as the generator points are not used as inputs to create the next state. There are multiple `v` values which could produce each generator point, especially if we increase the size of `v`. And of course you would have to invert the hash somehow to predict the next value.\r\n\r\nAnother option would be to use `v[X..]` as the hash-to-curve input, so the first X bytes remain as 'private' for the generator state machine.",
              "createdAt": "2022-06-19T17:41:12Z",
              "updatedAt": "2022-06-19T17:50:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848Sx-e",
          "commit": {
            "abbreviatedOid": "7955cdd"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-19T18:31:32Z",
          "updatedAt": "2022-06-19T18:31:32Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "Here's what the last option might look like:\r\n\r\n```\r\nprivate_bytes = 16  # could be in definitions, probably does not need to be curve dependent\r\nhash_output_bytes = private_bytes + expand_length\r\nn = 1\r\nv = expand_message(generator_seed, seed_dst, hash_output_bytes)\r\nfor i in range(1, count):\r\n   generator_i = Identity_G1\r\n   while generator_i == Identity_G1 or generator_i == P1:\r\n       candidate = hash_to_curve_g1(v[private_bytes..hash_output_bytes], generator_dst)\r\n       if candidate not in generators[1..i-1]: generator_i = candidate\r\n       v = expand_message(v || I2OSP(n, 4), seed_dst, hash_output_bytes)\r\n       n = n + 1\r\nreturn generators\r\n```\r\n\r\nAnother option is to initialize v[..private_bytes] with zeroes when hashing the seed.",
              "createdAt": "2022-06-19T18:31:32Z",
              "updatedAt": "2022-06-19T18:31:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848S3iP",
          "commit": {
            "abbreviatedOid": "7955cdd"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-19T23:23:16Z",
          "updatedAt": "2022-06-19T23:23:16Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "> generator_i does not determine the generator_(i+1) though, as the generator points are not used as inputs to create the next state. There are multiple v values which could produce each generator point, especially if we increase the size of v. And of course you would have to invert the hash somehow to predict the next value.\r\n\r\nYea this is true in practice, however it may not be \"strong\" enough for a security proof. Proving \"statistical closeness to uniform\" is hard, since`P(generator_i | generator_(i-1), ..., generator_1) >> 1/i`. Also, I think we should treat the seed as a known, fixed value (like an IV) in this case, which does not help with the proof. Even if that was not the case though, it is true that multiple `v`'s can give the same point, but a simulator cannot find them, if we assume coalition resistance. As you noted though, we may be able to prove this for \"computationally close to uniform\".\r\n\r\nPersonally, I like the cut-off method. A prefix-free method could also work and is pretty close to the current direction of the PR. That said, I do suggest leaving any updates (if there are any required) after we do a formal analysis. I will try to write down a formal proof, and if there are any updates required as a result, we can make them in following PRs.\r\n",
              "createdAt": "2022-06-19T23:23:16Z",
              "updatedAt": "2022-06-19T23:23:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848S3j4",
          "commit": {
            "abbreviatedOid": "7955cdd"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-19T23:24:05Z",
          "updatedAt": "2022-06-19T23:24:06Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "Good point. Maybe then calculating a first `v` as `v = expand_message(generator_seed, seed_dst, hash_output_bytes)` and then again as `v = expand_message(v || I2OSP(0, 4), seed_dst, hash_output_bytes)` (this second `v` will be the \"seed\" for the first generator)?? I do realize this adds complexity, but it will make it easier to move to a cut-off or prefix-free like construction if we decide to do so.",
              "createdAt": "2022-06-19T23:24:05Z",
              "updatedAt": "2022-06-19T23:24:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848S3ml",
          "commit": {
            "abbreviatedOid": "7955cdd"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-19T23:25:19Z",
          "updatedAt": "2022-06-19T23:25:20Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "Ok. Thats a good point and i think that you are right in that expand_message will be just as available in practice.",
              "createdAt": "2022-06-19T23:25:19Z",
              "updatedAt": "2022-06-19T23:25:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848S3ny",
          "commit": {
            "abbreviatedOid": "7955cdd"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-19T23:25:57Z",
          "updatedAt": "2022-06-19T23:25:57Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "Oh, you right. My bad!",
              "createdAt": "2022-06-19T23:25:57Z",
              "updatedAt": "2022-06-19T23:25:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848XSXR",
          "commit": {
            "abbreviatedOid": "a499a62"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Just a minor comment. LGTM otherwise!!",
          "createdAt": "2022-06-20T20:48:53Z",
          "updatedAt": "2022-06-20T20:57:35Z",
          "comments": [
            {
              "originalPosition": 75,
              "body": "```suggestion\r\n9.        if candidate not in (generator_1, ..., generator_(i-1)):\r\n\r\n10.              generator_i = candidate\r\n\r\n11. return (generator_1, ..., generator_count)\r\n```\r\nJust a suggestion because we \"technically\" don\u2019t define the generators list",
              "createdAt": "2022-06-20T20:48:54Z",
              "updatedAt": "2022-06-20T21:08:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848XT7W",
          "commit": {
            "abbreviatedOid": "a499a62"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-20T21:00:48Z",
          "updatedAt": "2022-06-20T21:00:48Z",
          "comments": [
            {
              "originalPosition": 75,
              "body": "Thanks, maybe it should use `n` instead of `count` as the length parameter in line with hash-to-scalar?",
              "createdAt": "2022-06-20T21:00:48Z",
              "updatedAt": "2022-06-20T21:00:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848XU6N",
          "commit": {
            "abbreviatedOid": "a499a62"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-20T21:08:09Z",
          "updatedAt": "2022-06-20T21:08:09Z",
          "comments": [
            {
              "originalPosition": 75,
              "body": "Oh right, sorry! Yea I\u2019m fine with both honestly. I'm updating hash-to-scalar either way, so I can make that consistent with what we do here. I updated the suggestion to use `count` for now, just for ease, but I can go with either.",
              "createdAt": "2022-06-20T21:08:09Z",
              "updatedAt": "2022-06-20T21:08:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848XY95",
          "commit": {
            "abbreviatedOid": "2f0064a"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-06-20T21:40:06Z",
          "updatedAt": "2022-06-20T21:40:06Z",
          "comments": []
        }
      ]
    },
    {
      "number": 181,
      "id": "PR_kwDOF8lax845-rgh",
      "title": "Updates to intro",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/181",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Resolves #172 and makes a minor editorial tweak to intro section",
      "createdAt": "2022-06-20T23:40:51Z",
      "updatedAt": "2022-06-21T22:39:32Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "271897555aa6a941862a1c7c0314d85e43d69cb7",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/update-intro",
      "headRefOid": "f336811ae8276054ef50cb4924b2b6c9ca01f994",
      "closedAt": "2022-06-21T22:04:03Z",
      "mergedAt": "2022-06-21T22:04:03Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "5d8ec5a086046be0bce4c9d75defab2963a2a584"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Multiple approvals, editorial changes, merging",
          "createdAt": "2022-06-21T22:03:59Z",
          "updatedAt": "2022-06-21T22:03:59Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax848Y4rc",
          "commit": {
            "abbreviatedOid": "ec3fa9e"
          },
          "author": "alessandroguggino",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-21T08:15:20Z",
          "updatedAt": "2022-06-21T08:16:06Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "```suggestion\r\nThe name BBS is derived from the authors of the original academic work of Dan Boneh, Xavier Boyen, and Hovav Shacham, where the scheme was first described.\r\n```",
              "createdAt": "2022-06-21T08:15:20Z",
              "updatedAt": "2022-06-21T08:16:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848Y_N1",
          "commit": {
            "abbreviatedOid": "f336811"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Minor comment. LGTM otherwise!!",
          "createdAt": "2022-06-21T08:28:28Z",
          "updatedAt": "2022-06-21T08:43:25Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "```suggestion\r\n**Proof of Possession** - The proofs generated by the scheme prove to a verifier that the party who generated the proof (prover) was in possession of a signature without revealing it. The scheme also supports binding a presentation header to the generated proof. The presentation header can include arbitrary information such as a cryptographic nonce, an audience/domain identifier and/or time based validity information.\r\n```\r\nMaybe^?? Or remove the \"or\"??",
              "createdAt": "2022-06-21T08:28:28Z",
              "updatedAt": "2022-06-21T08:43:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848c-5d",
          "commit": {
            "abbreviatedOid": "ec3fa9e"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-21T20:51:36Z",
          "updatedAt": "2022-06-21T20:51:37Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "`/` often implies or so adding it would be and or or IMO?",
              "createdAt": "2022-06-21T20:51:36Z",
              "updatedAt": "2022-06-21T20:51:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848dGXG",
          "commit": {
            "abbreviatedOid": "f336811"
          },
          "author": "alessandroguggino",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-06-21T21:21:48Z",
          "updatedAt": "2022-06-21T21:21:48Z",
          "comments": []
        }
      ]
    },
    {
      "number": 182,
      "id": "PR_kwDOF8lax846DaZa",
      "title": "Order points in hash and update 1 to Identity_GT",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/182",
      "state": "MERGED",
      "author": "alessandroguggino",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #173 by @dev0x1.\r\nNow the challenge hashes `c` and `cv` in `ProofGen` and `ProofVerify` are computed as `hash_to_scalar((PK || A' || Abar || D || C1 || C2 || ph), 1)`, to keep the ordering of the proof.\r\n\r\nThe other minor fix is to follow the new notation introduced in #175  and use `Identity_GT` instead of `1` in `Verify`.",
      "createdAt": "2022-06-21T18:48:42Z",
      "updatedAt": "2022-06-21T22:45:06Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "271897555aa6a941862a1c7c0314d85e43d69cb7",
      "headRepository": "alessandroguggino/bbs-signature",
      "headRefName": "consistency-fixes",
      "headRefOid": "8114fc20fb81d8ca9c308fbec3be6eeb774a6137",
      "closedAt": "2022-06-21T20:59:19Z",
      "mergedAt": "2022-06-21T20:59:19Z",
      "mergedBy": "BasileiosKal",
      "mergeCommit": {
        "oid": "d9cf0acb995770963bca1fe262e5d3def484a3c7"
      },
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Multiple approvals, editorial update, merging! Thanks @alessandroguggino!!",
          "createdAt": "2022-06-21T20:59:06Z",
          "updatedAt": "2022-06-21T20:59:06Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax848dAL6",
          "commit": {
            "abbreviatedOid": "8114fc2"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM! Thanks!",
          "createdAt": "2022-06-21T20:56:22Z",
          "updatedAt": "2022-06-21T20:56:22Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax848dAaH",
          "commit": {
            "abbreviatedOid": "8114fc2"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-06-21T20:57:13Z",
          "updatedAt": "2022-06-21T20:57:13Z",
          "comments": []
        }
      ]
    },
    {
      "number": 183,
      "id": "PR_kwDOF8lax846LFnL",
      "title": "New API update",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/183",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Substitutes previous PR #138 on API update since it had more conflicts than text at this point.\r\n\r\n### Updates:\r\nThis PR introduces the following main changes:\r\n\r\n1. Removes the generators from the input of the operations. Now the generators are computed as part of the operation procedure, using `create_generators` and a ciphersuite defined seed.\r\n2. Makes all arguments \u201cstructured\u201d (this is to be more explicit when for example we need a specific subarray of an inputted array in the correct order, i.e., revealed messages from messages using the indexes etc.). This closes #163.\r\n3. Introduces an additional section for the core operations called `Precomputations`. The reason is that, as the result of the above updates, a lot of steps are needed to de-structure the inputs or get sub-arrays of the inputted arrays etc. I find that those steps \u201cfill\u201d the main procedure, making it harder to read (especially ProofGen/ ProofVerify). So, I moved them to the \u201cPrecomputation\u201d section to try and make things more readable. \r\n\r\n### Pros and Cons:\r\n**Pros**:\r\n-\tWe are as explicit as it gets when it comes to the ordering of things etc.\r\n-\tThe operations api is much nicer IMO (no more generators there!! Thanks @andrewwhitehead!!)\r\n\r\n**Cons**:\r\n-\tA lot more steps. Been explicit requires describing every step of how we get certain elements.\r\n\r\n### Note:\r\nRegarding the `Precomputations` section if the WG finds it to be more confusing than helpful I\u2019m fine with removing it. Personally, I like it, but it was an \u201cexperiment\u201d to see how it looks.\r\n\r\nAlso addresses #159, #117, #113, #168, #139",
      "createdAt": "2022-06-22T22:35:00Z",
      "updatedAt": "2022-06-25T00:30:56Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "c7ffa999b125af00bd284dba6c1a953adb6dc149",
      "headRepository": "BasileiosKal/bbs-signature",
      "headRefName": "api_update_new",
      "headRefOid": "486aa5344f75737f04e7481eef61e0b3f0f265a6",
      "closedAt": "2022-06-25T00:30:56Z",
      "mergedAt": "2022-06-25T00:30:55Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "5dda637a99669328d770f7fb783007426305b65e"
      },
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Also made the `revealed` -> `disclosed` update here. Closes #178.",
          "createdAt": "2022-06-23T09:24:50Z",
          "updatedAt": "2022-06-23T09:24:50Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@alessandroguggino\r\n> I would specify why R and U are called that.\r\n\r\nDone! Thank you!\r\n\r\n> Also, why not add in the precomputations the MapMessageToScalarAsHash operation?\r\n\r\nThe `MapMessageToScalarAsHash` is an optional operation acting as a suggestion for applications that want to hash the messages before signing them. If we added as a precomputation would be like enforcing it. However, I think we want the flexibility so we can combine bbs+ with range proofs etc.",
          "createdAt": "2022-06-23T16:34:21Z",
          "updatedAt": "2022-06-23T16:34:21Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Multiple reviews and approvals, merging, thanks @BasileiosKal!",
          "createdAt": "2022-06-25T00:30:51Z",
          "updatedAt": "2022-06-25T00:30:51Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax848m02T",
          "commit": {
            "abbreviatedOid": "fdf3998"
          },
          "author": "alessandroguggino",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Great!\r\n\r\nI would specify why `R` and `U` are called that.\r\nMaybe something like:\r\n\r\n```\r\n- R, is the non-negative integer representing the number of disclosed\r\n     (revealed) messages, i.e., R = length(disclosedIndexes).\r\n     If no messages are disclosed, the value of R MUST evaluate to zero (0).\r\n- U, is the non-negative integer representing the number of hidden\r\n     (undisclosed) messages, i.e., U = L - R.\r\n```\r\n\r\nAlso, why not add in the precomputations the `MapMessageToScalarAsHash` operation?",
          "createdAt": "2022-06-23T11:02:54Z",
          "updatedAt": "2022-06-23T11:03:53Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax848nYRf",
          "commit": {
            "abbreviatedOid": "fdf3998"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-23T12:53:59Z",
          "updatedAt": "2022-06-23T12:53:59Z",
          "comments": [
            {
              "originalPosition": 67,
              "body": "is this really optional?",
              "createdAt": "2022-06-23T12:53:59Z",
              "updatedAt": "2022-06-23T12:53:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848nZOf",
          "commit": {
            "abbreviatedOid": "fdf3998"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-23T12:56:34Z",
          "updatedAt": "2022-06-23T12:56:34Z",
          "comments": [
            {
              "originalPosition": 126,
              "body": "excellent",
              "createdAt": "2022-06-23T12:56:34Z",
              "updatedAt": "2022-06-23T12:56:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848nZ4O",
          "commit": {
            "abbreviatedOid": "fdf3998"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-23T12:58:25Z",
          "updatedAt": "2022-06-23T12:58:26Z",
          "comments": [
            {
              "originalPosition": 226,
              "body": "if order matters should this be optional?",
              "createdAt": "2022-06-23T12:58:26Z",
              "updatedAt": "2022-06-23T12:58:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848naQx",
          "commit": {
            "abbreviatedOid": "fdf3998"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-06-23T12:59:29Z",
          "updatedAt": "2022-06-23T12:59:29Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax848ouHc",
          "commit": {
            "abbreviatedOid": "fdf3998"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-23T16:18:30Z",
          "updatedAt": "2022-06-23T16:18:30Z",
          "comments": [
            {
              "originalPosition": 67,
              "body": "\"Technically\" yes. It is optional because someone could only sign the header (with always disclosed information) and not the messages (which you can selectively disclose from) and vice versa.\r\n\r\nIf they sign neither the result will be a signature on just the signers PK, which \"technically\" is valid (but most likely useless). To support the other 2 use cases though we left both as optional.",
              "createdAt": "2022-06-23T16:18:30Z",
              "updatedAt": "2022-06-23T16:18:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848ouOl",
          "commit": {
            "abbreviatedOid": "fdf3998"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-23T16:18:50Z",
          "updatedAt": "2022-06-23T16:18:50Z",
          "comments": [
            {
              "originalPosition": 126,
              "body": "Thank you!! \ud83d\ude04",
              "createdAt": "2022-06-23T16:18:50Z",
              "updatedAt": "2022-06-23T16:18:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848oyXz",
          "commit": {
            "abbreviatedOid": "fdf3998"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-23T16:30:00Z",
          "updatedAt": "2022-06-23T16:30:01Z",
          "comments": [
            {
              "originalPosition": 226,
              "body": "Thank you very much for your feedback!! This can be confusing, but I think having it as REQUIRED will be like \"forcing\" the prover to disclose messages. So, I don't see a better alternative using the current syntax. I\u2019ve added an `if not supplied it defaults to the empty array \"()\"` to try and make it clearer. \r\n\r\nIn general, what I want to enforce is that if not supplied, no revealed messages can be supplied either. However, if it is supplied, it must be ordered.",
              "createdAt": "2022-06-23T16:30:00Z",
              "updatedAt": "2022-06-23T16:30:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848qZRo",
          "commit": {
            "abbreviatedOid": "6bd55f3"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-23T22:12:42Z",
          "updatedAt": "2022-06-23T22:12:42Z",
          "comments": [
            {
              "originalPosition": 226,
              "body": "It seems to me like messages should come before disclosedIndexes in the argument list if only because of the optionality... if there are no signed messages then there are definitely no disclosedIndexes, but the same can't be said for the reverse.",
              "createdAt": "2022-06-23T22:12:42Z",
              "updatedAt": "2022-06-23T22:12:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848qegc",
          "commit": {
            "abbreviatedOid": "6bd55f3"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-23T22:19:58Z",
          "updatedAt": "2022-06-23T22:19:58Z",
          "comments": [
            {
              "originalPosition": 292,
              "body": "It's less clear now that the hash input encoding rules apply here. I think we need to define a helper function like `encode_for_hash` and explain the encoding rules there. That could be a separate update, though.",
              "createdAt": "2022-06-23T22:19:58Z",
              "updatedAt": "2022-06-23T22:19:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848qesl",
          "commit": {
            "abbreviatedOid": "6bd55f3"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-23T22:21:13Z",
          "updatedAt": "2022-06-23T22:21:13Z",
          "comments": [
            {
              "originalPosition": 289,
              "body": "```suggestion\r\n4. gen_octets = (H_s || H_d || H_1 || ... || H_L)\r\n```",
              "createdAt": "2022-06-23T22:21:13Z",
              "updatedAt": "2022-06-23T22:21:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848qeuh",
          "commit": {
            "abbreviatedOid": "6bd55f3"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-23T22:21:24Z",
          "updatedAt": "2022-06-23T22:21:25Z",
          "comments": [
            {
              "originalPosition": 301,
              "body": "```suggestion\r\n8. (m~_j1, ..., m~_jU) = hash_to_scalar(PRF(prf_len), U)\r\n```",
              "createdAt": "2022-06-23T22:21:24Z",
              "updatedAt": "2022-06-23T22:21:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848qe9Q",
          "commit": {
            "abbreviatedOid": "6bd55f3"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-23T22:22:56Z",
          "updatedAt": "2022-06-23T22:22:57Z",
          "comments": [
            {
              "originalPosition": 430,
              "body": "```suggestion\r\n6. H_i1, ..., H_iR = MsgGenerators[i1], ..., MsgGenerators[iR]\r\n```",
              "createdAt": "2022-06-23T22:22:56Z",
              "updatedAt": "2022-06-23T22:22:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848qfRE",
          "commit": {
            "abbreviatedOid": "6bd55f3"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-23T22:25:00Z",
          "updatedAt": "2022-06-23T22:25:00Z",
          "comments": [
            {
              "originalPosition": 226,
              "body": "Yeah I agree with this ^",
              "createdAt": "2022-06-23T22:25:00Z",
              "updatedAt": "2022-06-23T22:25:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848qfYa",
          "commit": {
            "abbreviatedOid": "6bd55f3"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-23T22:25:49Z",
          "updatedAt": "2022-06-23T22:25:50Z",
          "comments": [
            {
              "originalPosition": 184,
              "body": "```suggestion\r\n6. gen_octets = (H_s || H_d || H_1 || ... || H_L)\r\n```",
              "createdAt": "2022-06-23T22:25:49Z",
              "updatedAt": "2022-06-23T22:25:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848qfja",
          "commit": {
            "abbreviatedOid": "6bd55f3"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-23T22:26:34Z",
          "updatedAt": "2022-06-23T22:26:35Z",
          "comments": [
            {
              "originalPosition": 90,
              "body": "Just a note I think we should provide an explanation some where as to why we are adding another concept to the definition of an operation. I assume this is because the result of such could be cached or handled in an alternative manner?",
              "createdAt": "2022-06-23T22:26:35Z",
              "updatedAt": "2022-06-23T22:26:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848qlLC",
          "commit": {
            "abbreviatedOid": "6bd55f3"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-23T23:04:44Z",
          "updatedAt": "2022-06-23T23:04:44Z",
          "comments": [
            {
              "originalPosition": 292,
              "body": "That's true. I would prefer taking this up in another PR as well though. Opened #185 to keep track of this. Thanks for raising.",
              "createdAt": "2022-06-23T23:04:44Z",
              "updatedAt": "2022-06-23T23:04:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848qsb1",
          "commit": {
            "abbreviatedOid": "fdf3998"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-23T23:45:47Z",
          "updatedAt": "2022-06-23T23:45:47Z",
          "comments": [
            {
              "originalPosition": 226,
              "body": "Done!",
              "createdAt": "2022-06-23T23:45:47Z",
              "updatedAt": "2022-06-23T23:45:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848qs6Q",
          "commit": {
            "abbreviatedOid": "6bd55f3"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-23T23:50:11Z",
          "updatedAt": "2022-06-23T23:50:12Z",
          "comments": [
            {
              "originalPosition": 90,
              "body": "The real reason is for readability. In practice it's a \"setting up\" process where we can get all necessary elements for the \"core procedure\". So essentially yes, staff that can be cached and that \"cannot\" return INVALID.\r\n\r\nAdded a small paragraph in the start of the Core operations section. We can always update that as well.",
              "createdAt": "2022-06-23T23:50:11Z",
              "updatedAt": "2022-06-23T23:50:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848u7gN",
          "commit": {
            "abbreviatedOid": "486aa53"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-06-24T20:16:40Z",
          "updatedAt": "2022-06-24T20:16:40Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax848wFgl",
          "commit": {
            "abbreviatedOid": "486aa53"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-06-25T00:30:32Z",
          "updatedAt": "2022-06-25T00:30:32Z",
          "comments": []
        }
      ]
    },
    {
      "number": 184,
      "id": "PR_kwDOF8lax846Rham",
      "title": "Clarified scalar operations",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/184",
      "state": "MERGED",
      "author": "christianpaquin",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Added explicit mod r and moved the scalar multiplications before additions to avoid op-priority confusions.",
      "createdAt": "2022-06-23T21:55:27Z",
      "updatedAt": "2022-06-24T03:13:49Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "5d8ec5a086046be0bce4c9d75defab2963a2a584",
      "headRepository": "christianpaquin/bbs-signature",
      "headRefName": "add-explicit-modR",
      "headRefOid": "cd29702ca6898745bdd4837fb1322a5b9ed2a4dc",
      "closedAt": "2022-06-24T03:13:48Z",
      "mergedAt": "2022-06-24T03:13:48Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "13cd0e373132e0bc7748c04608b195c157ed2284"
      },
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "LGTM. \r\n\r\nJust a note. maybe we are encouraging people to do the x*y + z operations and then mod r?? which I don't think is a good idea in practice (it should be ((x * y mod r) + z) mod r ??). \r\n\r\nAnother option would be to define that all operations between scalars happen in the multiplicative group mod r?? That would be the more \"mathematically correct\" description, although I\u2019m uncertain if it would be the clearer one. \r\n\r\nI'm definitely overthinking this though. I think we should move with merging this \ud83d\ude04",
          "createdAt": "2022-06-23T22:45:21Z",
          "updatedAt": "2022-06-23T23:09:03Z"
        },
        {
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\r\n> Just a note. maybe we are encouraging people to do the x*y + z operations and then mod r?? which I don't think is a good idea in practice (it should be ((x * y mod r) + z) mod r ??).\r\n\r\nIt's true, but it also becomes cumbersome. Your suggestion for a note somewhere that all calculations in that field is mod r. I simply wanted to avoid someone leaving a larger scalar and then trying to multiply that to the elliptic curve point; result would be validate but would be very inefficient. A simple mod r at the end indicates it's ok to apply the modulo at the end of the equation (confirming my interpretation of the spec).",
          "createdAt": "2022-06-24T01:14:35Z",
          "updatedAt": "2022-06-24T01:14:35Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Multiple reviews and approvals, merging.",
          "createdAt": "2022-06-24T03:13:42Z",
          "updatedAt": "2022-06-24T03:13:42Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax848qO0F",
          "commit": {
            "abbreviatedOid": "cd29702"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-06-23T22:02:04Z",
          "updatedAt": "2022-06-23T22:02:04Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax848qfx4",
          "commit": {
            "abbreviatedOid": "cd29702"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-06-23T22:27:16Z",
          "updatedAt": "2022-06-23T22:27:16Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax848rIBJ",
          "commit": {
            "abbreviatedOid": "cd29702"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-06-24T03:13:28Z",
          "updatedAt": "2022-06-24T03:13:28Z",
          "comments": []
        }
      ]
    },
    {
      "number": 186,
      "id": "PR_kwDOF8lax846VfP6",
      "title": "Update KeyGen procedure to use hash_to_scalar",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/186",
      "state": "MERGED",
      "author": "andrewwhitehead",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Since we don't use HKDF anywhere else and aren't trying to be compatible with the BLS signatures spec (different salt).\r\n\r\nIt's a bit odd using camel case for the input parameters and snake case for the parameter, but I'm trying to be consistent with the rest of the spec.\r\n\r\nLikewise, I'm not sure if we prefer len() or length(), and either way we might need to define that.",
      "createdAt": "2022-06-24T20:46:21Z",
      "updatedAt": "2023-06-19T18:44:47Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "f6c3ae60e966da5101e15d3895aba972fc12e478",
      "headRepository": "andrewwhitehead/bbs-signature",
      "headRefName": "upd/keygen",
      "headRefOid": "969a3fb980e3f2c812fff2a9dc9d32e066dad2df",
      "closedAt": "2023-06-19T18:44:46Z",
      "mergedAt": "2023-06-19T18:44:46Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "c7eb8b4ccc29f453d2d3f68e472704092947ec3f"
      },
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Although i agree with removing the dependency to hkdf I'm worried that we are changing the security assumptions.\r\n\r\nIt's true that the H2C spec claims `expand_message` to be intistinquishable from a RO, however 1. there is no formal published work proving that (the claim is based in comparisons with [[CDMP05]](https://link.springer.com/content/pdf/10.1007/11535218_26.pdf)), 2. we didn't required that up until now. We only required `expand_message` to have basic \"hash\" properties i.e., \"un-revershability\" and \"coalition resistance\". So using it for `KeyGen` does raise the amount of assumptions we have to make.\r\n\r\n### Note:\r\nThis is probably completely fine. We can always add this to the list of things we need to revisit and do a formal analysis on ;P. So I'm happy to move with this.",
          "createdAt": "2022-06-25T17:28:00Z",
          "updatedAt": "2022-06-25T17:28:00Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "For reference, the VOPRF draft also uses hash-to-scalar for key generation: https://cfrg.github.io/draft-irtf-cfrg-voprf/draft-irtf-cfrg-voprf.html#name-key-generation-and-context-",
          "createdAt": "2022-10-17T18:43:46Z",
          "updatedAt": "2022-10-17T18:43:46Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed on WG call today, @andrewwhitehead is going to update with latest changes from VOPRF once #230 is merged.",
          "createdAt": "2022-12-12T22:04:58Z",
          "updatedAt": "2022-12-12T22:04:58Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on WG of 14th of Feb. Will discuss after PR #243 is resolved.",
          "createdAt": "2023-02-13T19:19:17Z",
          "updatedAt": "2023-02-13T19:19:17Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on WG call on 6th of Mar. Will update the test vectors and try to incorporate the update for draft 02.",
          "createdAt": "2023-03-06T19:24:43Z",
          "updatedAt": "2023-03-06T19:24:43Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on WG call 13th of Mar, will update to include the ciphersuite id to the default dst. Will review after.",
          "createdAt": "2023-03-13T19:19:13Z",
          "updatedAt": "2023-03-13T19:19:13Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed briefly on the 10th April call, @andrewwhitehead believes all pending updates to the schemes definition have been done and we will discuss again next week as a wider group about approval and merging.",
          "createdAt": "2023-04-10T18:27:32Z",
          "updatedAt": "2023-04-10T18:27:32Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed on WG call 19th of June, multiple approvals, merging.",
          "createdAt": "2023-06-19T18:44:43Z",
          "updatedAt": "2023-06-19T18:44:43Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax848wVA1",
          "commit": {
            "abbreviatedOid": "71b06f9"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-25T12:00:58Z",
          "updatedAt": "2022-06-25T17:27:47Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "```suggestion\r\nThe KeyGen defined in this document is RECOMMENDED but not required. Implementers can elect to use a different procedure, as long as the result is an indistinguishable from uniformly random scalar in the range from 1 to r-1. An example of an HKDF based alternative is the KeyGen operation, defined in Section 2.3 of  [@I-D.irtf-cfrg-bls-signature] (with an appropriate, BBS specific, salt value, like \"BBS_SIG_KEYGEN_SALT_\")\r\n```\r\nI would also add something like the above note, saying that this procedure is a recommendation and point to bls sigs at least as an alternative.",
              "createdAt": "2022-06-25T12:00:58Z",
              "updatedAt": "2022-06-25T17:27:47Z"
            },
            {
              "originalPosition": 41,
              "body": "```suggestion\r\n- key_salt, a random ASCII string. If not supplied it defaults to the ASCII string \"BBS-SIG-KEYGEN-SALT-\".\r\n```\r\nWhy not name it a salt?? Also the random salt requirement in [Krawczyk2010](https://link.springer.com/content/pdf/10.1007/978-3-642-14623-7_34.pdf) is not only about HKDF, but for all (generic) KDFs,\r\n\r\nThe suggestion about requiting the salt to be random is most likely overkill, so no need to use it.",
              "createdAt": "2022-06-25T12:05:58Z",
              "updatedAt": "2022-06-25T17:27:47Z"
            },
            {
              "originalPosition": 56,
              "body": "Is this removed to not have to define a `hash` in the ciphersuite?? Can we use `expand_message` instead??",
              "createdAt": "2022-06-25T12:06:18Z",
              "updatedAt": "2022-06-25T17:27:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8481JRq",
          "commit": {
            "abbreviatedOid": "71b06f9"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-27T17:46:49Z",
          "updatedAt": "2022-06-27T17:46:49Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "This follows the pattern in MapMessageToScalarAsHash where the parameter is described as a DST, but I'm not opposed to calling it a salt.",
              "createdAt": "2022-06-27T17:46:49Z",
              "updatedAt": "2022-06-27T17:46:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8481LRa",
          "commit": {
            "abbreviatedOid": "71b06f9"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-27T17:53:39Z",
          "updatedAt": "2022-06-27T17:53:40Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "There is a similar comment after the method but it could be updated.",
              "createdAt": "2022-06-27T17:53:40Z",
              "updatedAt": "2022-06-27T17:53:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85LeFuX",
          "commit": {
            "abbreviatedOid": "1faf6dd"
          },
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-01-23T19:10:53Z",
          "updatedAt": "2023-01-23T19:10:53Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85Lj4Bb",
          "commit": {
            "abbreviatedOid": "2559927"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-24T15:13:03Z",
          "updatedAt": "2023-01-24T17:44:22Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "```suggestion\r\nFor security, key\\_material MUST be random and infeasible to guess, e.g. generated by a trusted source of randomness and with enough entropy. See [@!RFC4086] for suggestions on generating randomness.\r\n```",
              "createdAt": "2023-01-24T15:13:04Z",
              "updatedAt": "2023-01-24T17:44:22Z"
            },
            {
              "originalPosition": 62,
              "body": "Just a note: `hash_to_scalar` currently guarantees that `SK != 0`. IMO of course it would be better to update `hash_to_scalar` than this operation.",
              "createdAt": "2023-01-24T17:17:16Z",
              "updatedAt": "2023-02-06T14:45:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85MJ1TK",
          "commit": {
            "abbreviatedOid": "2559927"
          },
          "author": "Wind4Greg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-01-31T16:53:10Z",
          "updatedAt": "2023-01-31T16:53:10Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85MnNyL",
          "commit": {
            "abbreviatedOid": "2559927"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-06T14:48:48Z",
          "updatedAt": "2023-02-06T14:48:53Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "```suggestion\r\n8.      SK = hash_to_scalar(derive_input || I2OSP(counter, 1), 1, key_dst)\r\n9.      if SK is INVALID, return INVALID\r\n10.     counter = counter + 1\r\n11. return SK\r\n```\r\n\r\nAfter merging #240 `hash_to_scalar` is updated and it may return INVALID. We should check here for it.",
              "createdAt": "2023-02-06T14:48:48Z",
              "updatedAt": "2023-02-06T14:48:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85RoRqW",
          "commit": {
            "abbreviatedOid": "bb20d18"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-03T17:48:17Z",
          "updatedAt": "2023-04-17T17:26:12Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "```suggestion\r\nKeyGen takes an optional input, key\\_info. This parameter MAY be used to derive distinct keys from the same key material.\r\n```\r\nJust a technicality, but it may be hard to guarantee that the keys will be independent?? distinct may be a better word here?",
              "createdAt": "2023-04-03T17:48:17Z",
              "updatedAt": "2023-04-17T17:26:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85X8vwq",
          "commit": {
            "abbreviatedOid": "bb20d18"
          },
          "author": "Wind4Greg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-06-12T18:18:43Z",
          "updatedAt": "2023-06-12T18:18:43Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85YmjQf",
          "commit": {
            "abbreviatedOid": "969a3fb"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-06-19T15:46:47Z",
          "updatedAt": "2023-06-19T15:46:47Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85YnWP0",
          "commit": {
            "abbreviatedOid": "969a3fb"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-06-19T18:44:15Z",
          "updatedAt": "2023-06-19T18:44:15Z",
          "comments": []
        }
      ]
    },
    {
      "number": 187,
      "id": "PR_kwDOF8lax846Vjz6",
      "title": "Editorial updates",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/187",
      "state": "MERGED",
      "author": "andrewwhitehead",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "- fix references to `p` as the subgroup order\r\n- define `r` for BLS12-381-G1\r\n- remove BLS12-381-G2 suite definition\r\n",
      "createdAt": "2022-06-24T21:11:06Z",
      "updatedAt": "2022-07-07T22:50:13Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "c7ffa999b125af00bd284dba6c1a953adb6dc149",
      "headRepository": "andrewwhitehead/bbs-signature",
      "headRefName": "fix/edits",
      "headRefOid": "9f953c06e99df5c9f3ecc7e1d8d2ff9ec9cf535a",
      "closedAt": "2022-06-27T19:43:56Z",
      "mergedAt": "2022-06-27T19:43:55Z",
      "mergedBy": "BasileiosKal",
      "mergeCommit": {
        "oid": "98458efdde54309549b235f59daec52b8c22572e"
      },
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Multiple approvals, Discussed in the WG call. Merging",
          "createdAt": "2022-06-27T19:43:43Z",
          "updatedAt": "2022-06-27T19:43:43Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax848whz3",
          "commit": {
            "abbreviatedOid": "9f953c0"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-06-25T21:43:30Z",
          "updatedAt": "2022-06-25T21:43:30Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax848wjkY",
          "commit": {
            "abbreviatedOid": "9f953c0"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-26T00:16:10Z",
          "updatedAt": "2022-06-26T00:16:21Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "Should we move this to the (bbs) ciphersuite maybe?? The [H2C suites](https://www.ietf.org/archive/id/draft-irtf-cfrg-hash-to-curve-16.html#name-defining-a-new-hash-to-curv) don't have an `r` parameter.",
              "createdAt": "2022-06-26T00:16:10Z",
              "updatedAt": "2022-06-26T00:16:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8481Rlp",
          "commit": {
            "abbreviatedOid": "9f953c0"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-06-27T18:16:09Z",
          "updatedAt": "2022-06-27T18:16:09Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax8481RtI",
          "commit": {
            "abbreviatedOid": "9f953c0"
          },
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-06-27T18:16:35Z",
          "updatedAt": "2022-06-27T18:16:35Z",
          "comments": []
        }
      ]
    },
    {
      "number": 188,
      "id": "PR_kwDOF8lax846X9Fr",
      "title": "Add the revealed messages to the challenge",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/188",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #74\r\n\r\nReplaces #128. See the discussion there for more context.\r\n\r\nAdds the revealed indexes, the number of revealed messages and the revealed messages themselves to the Fiat\u2013Shamir challenge hash.",
      "createdAt": "2022-06-26T17:41:48Z",
      "updatedAt": "2022-06-27T19:45:11Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "5dda637a99669328d770f7fb783007426305b65e",
      "headRepository": "BasileiosKal/bbs-signature",
      "headRefName": "challenge_hash_update",
      "headRefOid": "e05c31ca5a05a2ba3f44035477596371eec34f13",
      "closedAt": "2022-06-27T19:45:11Z",
      "mergedAt": "2022-06-27T19:45:11Z",
      "mergedBy": "BasileiosKal",
      "mergeCommit": {
        "oid": "7e09c0e6cc6027d870a009f0894f0518fe892111"
      },
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Multiple approvals. Discussed in the WG call. Merging",
          "createdAt": "2022-06-27T19:43:21Z",
          "updatedAt": "2022-06-27T19:43:21Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax848w8yE",
          "commit": {
            "abbreviatedOid": "e05c31c"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-06-26T18:25:40Z",
          "updatedAt": "2022-06-26T18:25:40Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax8481fQa",
          "commit": {
            "abbreviatedOid": "e05c31c"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-06-27T19:04:24Z",
          "updatedAt": "2022-06-27T19:04:24Z",
          "comments": []
        }
      ]
    },
    {
      "number": 189,
      "id": "PR_kwDOF8lax846YADW",
      "title": "Add acknowledgements section",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/189",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This PR re-orders the editors list based on the latest [contributions statistics](https://github.com/decentralized-identity/bbs-signature/graphs/contributors) which needs to be done prior to submission as an internet draft for the CFRG meeting.\r\n\r\nAlso added an acknowledgements section, feel free to comment and add others that I may have missed.\r\n\r\nCloses #180 and closes #52 ",
      "createdAt": "2022-06-26T18:52:42Z",
      "updatedAt": "2022-06-27T20:42:01Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "5dda637a99669328d770f7fb783007426305b65e",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/acknowledgements-section",
      "headRefOid": "c54fdb47226720ce9ee1a83e088446bfb451c9ef",
      "closedAt": "2022-06-27T20:41:56Z",
      "mergedAt": "2022-06-27T20:41:56Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "a7f1eecf20de286eee46551bf8023e3c9f473a84"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Multiple approvals, purely editorial, merging.",
          "createdAt": "2022-06-27T20:41:44Z",
          "updatedAt": "2022-06-27T20:41:44Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax848w91q",
          "commit": {
            "abbreviatedOid": "07203e5"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-26T19:12:26Z",
          "updatedAt": "2022-06-26T19:42:30Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "```suggestion\r\n<reference anchor=\"BBS04\" target=\"https://link.springer.com/chapter/10.1007/978-3-540-28628-8_3\">\r\n```\r\nBecause of my other comment (citing using the authors initials).",
              "createdAt": "2022-06-26T19:13:05Z",
              "updatedAt": "2022-06-26T19:45:23Z"
            },
            {
              "originalPosition": 86,
              "body": "```suggestion\r\n\r\n<reference anchor=\"ASM06\" target=\"https://link.springer.com/chapter/10.1007/11832072_8\">\r\n <front>\r\n   <title>Constant-Size Dynamic k-TAA</title>\r\n   <author initials=\"M. H.\" surname=\"Au\" fullname=\"Man Ho Au\">\r\n    </author>\r\n    <author initials=\"W.\" surname=\"Susilo\" fullname=\"Willy Susilo\">\r\n    </author>\r\n    <author initials=\"Y.\" surname=\"Mu\" fullname=\"Yi Mu\">\r\n    </author>\r\n    <date year=\"2006\"/>\r\n </front>\r\n <seriesInfo name=\"In\" value=\"International Conference on Security and Cryptography for Networks\"/>\r\n <seriesInfo name=\"pages\" value=\"111-125\"/>\r\n <seriesInfo name=\"Springer,\" value=\"Berlin, Heidelberg\"/>\r\n</reference>\r\n```\r\nI think this should maybe be mentioned too. There is also the [[CL04]](https://link.springer.com/content/pdf/10.1007/978-3-540-28628-8_4.pdf) paper that came before, but it was the above that proved security and \"popularized\" BBS+ (this is the one that is referenced by [[CDL16]](https://eprint.iacr.org/2016/663.pdf) for example).",
              "createdAt": "2022-06-26T19:35:27Z",
              "updatedAt": "2022-06-26T19:42:30Z"
            },
            {
              "originalPosition": 59,
              "body": "```suggestion\r\nThe authors would like to acknowledge the significant amount of academic work that preceeded the development of this document. In particular the original work of [@BBS04] which was subsequently developed in [@ASM06] and in [@CDL16]. This last academic work is the one mostly used by this document.\r\n```\r\nAs far as i know of, It's more customary to cite using the authors initials with the year of publishing (at least in this format).\r\n\r\nAlso added one more paper.",
              "createdAt": "2022-06-26T19:38:15Z",
              "updatedAt": "2022-06-26T19:42:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax848xBiS",
          "commit": {
            "abbreviatedOid": "c54fdb4"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-06-26T22:23:20Z",
          "updatedAt": "2022-06-26T22:23:20Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax848x7_3",
          "commit": {
            "abbreviatedOid": "c54fdb4"
          },
          "author": "alessandroguggino",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thanks! ",
          "createdAt": "2022-06-27T07:25:46Z",
          "updatedAt": "2022-06-27T07:25:46Z",
          "comments": []
        }
      ]
    },
    {
      "number": 190,
      "id": "PR_kwDOF8lax846YJZJ",
      "title": "encode for hash operation",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/190",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #185 using @andrewwhitehead's proposal (introducing an encode_for_hash operation).\r\n\r\nOpened as a draft because of the timetable + the fact that it is not a small pr. Will mark it as ready to review if the other open PRs are merged.\r\n\r\n### NOTES:\r\n1. The `encode_for_hash` function can also substitute the `signature_to_octets` and `proof_to_octets` operations (the results will be the same). I left that for another PR if we decide to go that way (I\u2019m not convinced that it would be the best option myself).\r\n2. Removed the distinction with DSTs. We are explicitly appending their length everywhere in the spec.\r\n3. this pr also closes #74 like pr #188. However, I realize this requires more time and reviews so better to move with #188 first (I will resolve the conflicts).",
      "createdAt": "2022-06-26T22:44:51Z",
      "updatedAt": "2022-07-04T18:16:00Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "8d9b9a01fb770975f32c363166259b36904fb68e",
      "headRepository": "BasileiosKal/bbs-signature",
      "headRefName": "encode_for_hash",
      "headRefOid": "d2c93a47c1b33e898cc7533fe9a15e7b53cc4660",
      "closedAt": "2022-07-04T18:15:59Z",
      "mergedAt": "2022-07-04T18:15:59Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "894456f0f24da41abcab823f1d2e1bbe7da8c505"
      },
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed in the WG call. Will split the challenge hash input to multiple lines (instead of calling encode_for_hash twice)",
          "createdAt": "2022-06-27T18:54:14Z",
          "updatedAt": "2022-06-27T19:05:45Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ready for review c.c. @andrewwhitehead, @tplooker ^",
          "createdAt": "2022-06-27T22:28:06Z",
          "updatedAt": "2022-06-27T22:28:06Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "After @tplooker's suggestion, I made the procedure \"informative\" (made it a recommendation) and added the \"normative\" definition to the notation section (maybe we will need to do that for `hash_to_scalar` and `create_generators` as well).\r\n\r\n@andrewwhitehead really sorry to requesting your review again. Any thoughts on that??^",
          "createdAt": "2022-06-28T23:37:45Z",
          "updatedAt": "2022-06-28T23:37:45Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't think it can be only a recommended implementation, as any changes would impact compatibility and the security of the scheme. If variations were supported then I think they would need to be added to the suite identifier.",
          "createdAt": "2022-06-28T23:52:09Z",
          "updatedAt": "2022-06-28T23:52:09Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I don't think it can be only a recommended implementation, as any changes would impact compatibility and the security of the scheme. If variations were supported then I think they would need to be added to the suite identifier.\r\n\r\n@andrewwhitehead that is true. The tradeoff IMO is that if the `encode_for_hash` is \"normative\" we may need to define it more formally. However this will be hard to do in the spec (for example is the line `if el is an octet string representing a public key` formal enough??). I'm afraid that if we make it a requirement with this type of syntax we may face the same negative feedback that the [ZCach encoding](https://www.ietf.org/archive/id/draft-irtf-cfrg-pairing-friendly-curves-10.html#name-zcash-serialization-format-) in the [PFC spec](https://www.ietf.org/archive/id/draft-irtf-cfrg-pairing-friendly-curves-10.html) faced by the CFRG.\r\n\r\nDon't have a perfect solution for now. Should we leave it as normative and revisit this later (i.e., not close #185)?? Thoughts @tplooker??^",
          "createdAt": "2022-06-29T15:18:34Z",
          "updatedAt": "2022-06-29T15:18:34Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Also, IMO we can define the properties that every `encode_for_hash` function should have. Bijection is one for sure and we can also require prefix-free encoding to be safe. However do we really want to add the `encode_for_hash` function to the suite id??",
          "createdAt": "2022-06-29T15:18:50Z",
          "updatedAt": "2022-06-29T15:18:50Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Apologies I should have been more specific, I think the behaviour of encode_for_hash needs to be normative to promote interoperable implementations as @andrewwhitehead points out. I was more wondering whether we position the procedural definition here as informative because I can imagine there being multiple ways to implement it in practise. I guess that argument could also be applied more broadly to other operations in the scheme too so perhaps its not worth the complication?",
          "createdAt": "2022-06-29T20:40:26Z",
          "updatedAt": "2022-06-29T20:40:26Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Updated. As far as if the procedure is \"formal enough\" to be normative, I'm not 100% convinced my self but I may be overthinking this. \r\n\r\nIt's true that most likely people will not use a straight line implementation of this procedure, however i do mention that this is just an explanation of the described behavior, and also most likely, to @tplooker's point, people will not use straight line implementations for most things in the spec IMO.\r\n\r\n",
          "createdAt": "2022-06-30T00:31:48Z",
          "updatedAt": "2022-06-30T00:31:48Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Multiple approvals, discussed on 4th of July WG call, merging",
          "createdAt": "2022-07-04T18:15:55Z",
          "updatedAt": "2022-07-04T18:15:55Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax8481cwU",
          "commit": {
            "abbreviatedOid": "b3dfcd3"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-27T18:55:08Z",
          "updatedAt": "2022-06-27T18:55:08Z",
          "comments": [
            {
              "originalPosition": 139,
              "body": "```suggestion\r\n8. if dom_for_hash is INVALID, return INVALID\r\n```",
              "createdAt": "2022-06-27T18:55:08Z",
              "updatedAt": "2022-06-27T18:55:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8481dCm",
          "commit": {
            "abbreviatedOid": "b3dfcd3"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-27T18:56:14Z",
          "updatedAt": "2022-06-27T18:56:15Z",
          "comments": [
            {
              "originalPosition": 240,
              "body": "```suggestion\r\n8. if dom_for_hash is INVALID, return INVALID\r\n```",
              "createdAt": "2022-06-27T18:56:14Z",
              "updatedAt": "2022-06-27T18:56:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8481dMH",
          "commit": {
            "abbreviatedOid": "b3dfcd3"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-27T18:56:48Z",
          "updatedAt": "2022-06-27T18:56:49Z",
          "comments": [
            {
              "originalPosition": 163,
              "body": "```suggestion\r\n6. if dom_for_hash is INVALID, return INVALID\r\n```",
              "createdAt": "2022-06-27T18:56:48Z",
              "updatedAt": "2022-06-27T18:56:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8487MlT",
          "commit": {
            "abbreviatedOid": "0bbb3a0"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-28T17:33:29Z",
          "updatedAt": "2022-06-28T17:33:29Z",
          "comments": [
            {
              "originalPosition": 109,
              "body": "```suggestion\r\n5. e_s_for_hash = encode_for_hash((SK, domain, msg_1, ..., msg_L))\r\n```",
              "createdAt": "2022-06-28T17:33:29Z",
              "updatedAt": "2022-06-28T17:33:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8487M6C",
          "commit": {
            "abbreviatedOid": "0bbb3a0"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-06-28T17:34:39Z",
          "updatedAt": "2022-06-28T17:34:39Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax8487bQr",
          "commit": {
            "abbreviatedOid": "0bbb3a0"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-28T18:23:49Z",
          "updatedAt": "2022-06-28T18:23:50Z",
          "comments": [
            {
              "originalPosition": 109,
              "body": "Good catch! Thanks!",
              "createdAt": "2022-06-28T18:23:49Z",
              "updatedAt": "2022-06-28T18:23:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8487kVm",
          "commit": {
            "abbreviatedOid": "b97757f"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-06-28T18:56:55Z",
          "updatedAt": "2022-06-28T18:56:55Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax8487733",
          "commit": {
            "abbreviatedOid": "b97757f"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-28T20:11:12Z",
          "updatedAt": "2022-06-28T20:11:13Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Should we shift this as an operation under section 5 (https://identity.foundation/bbs-signature/draft-bbs-signatures.html#name-utility-operations)?",
              "createdAt": "2022-06-28T20:11:12Z",
              "updatedAt": "2022-06-28T20:11:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84881xH",
          "commit": {
            "abbreviatedOid": "b97757f"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-28T23:33:48Z",
          "updatedAt": "2022-06-28T23:33:48Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Done!\r\n\r\nProbably best since we are referencing `hash_to_scalar` also!",
              "createdAt": "2022-06-28T23:33:48Z",
              "updatedAt": "2022-06-28T23:33:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax849Q36k",
          "commit": {
            "abbreviatedOid": "c19e9ba"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-04T18:11:58Z",
          "updatedAt": "2022-07-04T18:11:59Z",
          "comments": [
            {
              "originalPosition": 271,
              "body": "```suggestion\r\nThe above is further described in the following procedure.\r\n```",
              "createdAt": "2022-07-04T18:11:58Z",
              "updatedAt": "2022-07-04T18:11:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax849Q38Q",
          "commit": {
            "abbreviatedOid": "c19e9ba"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-07-04T18:12:10Z",
          "updatedAt": "2022-07-04T18:12:10Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax849Q4DQ",
          "commit": {
            "abbreviatedOid": "c19e9ba"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-04T18:13:17Z",
          "updatedAt": "2022-07-04T18:13:18Z",
          "comments": [
            {
              "originalPosition": 257,
              "body": "```suggestion\r\n### EncodeForHash\r\n```",
              "createdAt": "2022-07-04T18:13:18Z",
              "updatedAt": "2022-07-04T18:13:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax849Q4SR",
          "commit": {
            "abbreviatedOid": "d2c93a4"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-07-04T18:15:30Z",
          "updatedAt": "2022-07-04T18:15:30Z",
          "comments": []
        }
      ]
    },
    {
      "number": 191,
      "id": "PR_kwDOF8lax846ZyqZ",
      "title": "Minor update to terminology",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/191",
      "state": "MERGED",
      "author": "alessandroguggino",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fix to stay consistent with the definitions of `R` and `U` in `ProofGen` (and `ProofVerify`)",
      "createdAt": "2022-06-27T09:57:23Z",
      "updatedAt": "2022-06-27T20:16:00Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "7e09c0e6cc6027d870a009f0894f0518fe892111",
      "headRepository": "alessandroguggino/bbs-signature",
      "headRefName": "update-terminology",
      "headRefOid": "5ce7780bc51ee835c820908534200643d929b13b",
      "closedAt": "2022-06-27T19:54:53Z",
      "mergedAt": "2022-06-27T19:54:53Z",
      "mergedBy": "BasileiosKal",
      "mergeCommit": {
        "oid": "3db28455680a30d2a6aa2bb748106cdc449e6e1e"
      },
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed in the WG call. Multiple approvals. Merging! Thanks @alessandroguggino!",
          "createdAt": "2022-06-27T19:54:46Z",
          "updatedAt": "2022-06-27T19:54:46Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax8481OuA",
          "commit": {
            "abbreviatedOid": "3ebe3ec"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-06-27T18:05:44Z",
          "updatedAt": "2022-06-27T18:05:44Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax8481Pgs",
          "commit": {
            "abbreviatedOid": "3ebe3ec"
          },
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-06-27T18:08:38Z",
          "updatedAt": "2022-06-27T18:08:38Z",
          "comments": []
        }
      ]
    },
    {
      "number": 192,
      "id": "PR_kwDOF8lax846bs6y",
      "title": "Consistency updates",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/192",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Changes for consistency:\r\n1. `len()` -> `length()`.\r\n2. Consistent array de-structuring.\r\n3. Make code blocks < 72 chars.\r\n4. Update `create_generators`. Same result, removed the `while` and added a `go back to step 4` for consistency (we where referencing `generator_0` without defining it at the first step where `i = 1`).",
      "createdAt": "2022-06-27T17:28:47Z",
      "updatedAt": "2022-06-28T20:04:39Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "3db28455680a30d2a6aa2bb748106cdc449e6e1e",
      "headRepository": "BasileiosKal/bbs-signature",
      "headRefName": "consistency-update",
      "headRefOid": "5dcc5f3ab5c88bd19f3bdbd118b65d4043d6d520",
      "closedAt": "2022-06-28T20:04:38Z",
      "mergedAt": "2022-06-28T20:04:38Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "4818d31bd6d459d018bb3e36c9247561feb61ad4"
      },
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on the WG call. The issue of the naming convention for SK and PKs came up (neither the SK not the PK is a point to be capitalized). Will address to another PR to avoid conflicts with #186.",
          "createdAt": "2022-06-27T19:41:14Z",
          "updatedAt": "2022-06-27T19:41:14Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Multiple approvals, purely editorial, merging",
          "createdAt": "2022-06-28T20:04:34Z",
          "updatedAt": "2022-06-28T20:04:34Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax8482MaF",
          "commit": {
            "abbreviatedOid": "37ba905"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-27T22:09:37Z",
          "updatedAt": "2022-06-27T22:09:38Z",
          "comments": [
            {
              "originalPosition": 213,
              "body": "```suggestion\r\nLet the prover be in possession of a BBS signature `(A, e, s)` with `A = B * (1/(e + SK))` where `SK` the signer's secret key and,\r\n```",
              "createdAt": "2022-06-27T22:09:38Z",
              "updatedAt": "2022-06-27T22:09:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8482MmA",
          "commit": {
            "abbreviatedOid": "37ba905"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-27T22:10:40Z",
          "updatedAt": "2022-06-27T22:10:40Z",
          "comments": [
            {
              "originalPosition": 215,
              "body": "Maybe we can update this formula to use H_s and H_d? Or are we leaving the domain out of this section?",
              "createdAt": "2022-06-27T22:10:40Z",
              "updatedAt": "2022-06-27T22:10:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8487LE5",
          "commit": {
            "abbreviatedOid": "37ba905"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-28T17:28:15Z",
          "updatedAt": "2022-06-28T17:28:16Z",
          "comments": [
            {
              "originalPosition": 215,
              "body": "Yea! Good catch. Updated to use `H_s, H_d` add added `domain` (not explaining what it is, using it like `e, s` etc).",
              "createdAt": "2022-06-28T17:28:15Z",
              "updatedAt": "2022-06-28T17:28:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8487LPN",
          "commit": {
            "abbreviatedOid": "0758d31"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-28T17:28:49Z",
          "updatedAt": "2022-06-28T17:28:49Z",
          "comments": [
            {
              "originalPosition": 273,
              "body": "```suggestion\r\nNote that the verifier will know the elements in the left side of the above equations (i.e., `C1` and `C2`) but not in the right side (i.e., `s'`, `r3` and the undisclosed messages: `msg_j1, ..., msg_jU`). However, using the `nizk`, the prover can convince the verifier that they (the prover) know the elements that satisfy those equations, without disclosing them. Then, if both EQ1 and EQ2 hold, and `e(A', PK) = e(Abar, P2)`, an extractor can return a valid BBS signature from the signer's `SK`, on the disclosed messages. The proof returned is `(A', Abar, D, nizk)`. To validate the proof, a verifier checks that `e(A', PK) = e(Abar, P2)` and verifies the `nizk`. Validating the proof, will guarantee the authenticity and integrity of the disclosed messages, as well as ownership of the undisclosed messages and of the signature.\r\n```",
              "createdAt": "2022-06-28T17:28:49Z",
              "updatedAt": "2022-06-28T17:28:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8487LYE",
          "commit": {
            "abbreviatedOid": "0758d31"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-28T17:29:19Z",
          "updatedAt": "2022-06-28T17:29:19Z",
          "comments": [
            {
              "originalPosition": 273,
              "body": "Last tiny suggestion",
              "createdAt": "2022-06-28T17:29:19Z",
              "updatedAt": "2022-06-28T17:29:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax8487M2B",
          "commit": {
            "abbreviatedOid": "0758d31"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-06-28T17:34:26Z",
          "updatedAt": "2022-06-28T17:34:26Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax8487bxa",
          "commit": {
            "abbreviatedOid": "0758d31"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-28T18:25:46Z",
          "updatedAt": "2022-06-28T18:25:46Z",
          "comments": [
            {
              "originalPosition": 273,
              "body": "Thank you!!",
              "createdAt": "2022-06-28T18:25:46Z",
              "updatedAt": "2022-06-28T18:25:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84875A_",
          "commit": {
            "abbreviatedOid": "5dcc5f3"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-06-28T20:04:07Z",
          "updatedAt": "2022-06-28T20:04:07Z",
          "comments": []
        }
      ]
    },
    {
      "number": 193,
      "id": "PR_kwDOF8lax846jTAA",
      "title": "Fix and add links",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/193",
      "state": "MERGED",
      "author": "alessandroguggino",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Very little contribution but I hope it is helpful.\r\n- Fixed existing links (removing typos, whitespaces, capitalizing first letter, ...)\r\n- Added missing links to operations\r\n- Removed an old paragraph about BlindSign",
      "createdAt": "2022-06-29T09:23:31Z",
      "updatedAt": "2022-06-30T10:17:35Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "4818d31bd6d459d018bb3e36c9247561feb61ad4",
      "headRepository": "alessandroguggino/bbs-signature",
      "headRefName": "fix-links",
      "headRefOid": "9ea88ba87c78e6a3c17cd1a6fd2bc601bdfa482c",
      "closedAt": "2022-06-29T20:55:02Z",
      "mergedAt": "2022-06-29T20:55:02Z",
      "mergedBy": "BasileiosKal",
      "mergeCommit": {
        "oid": "8d9b9a01fb770975f32c363166259b36904fb68e"
      },
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Multiple approvals! Editorial update! Merging.",
          "createdAt": "2022-06-29T20:54:57Z",
          "updatedAt": "2022-06-29T20:54:57Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax849BtMb",
          "commit": {
            "abbreviatedOid": "9ea88ba"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "LGTM thanks!",
          "createdAt": "2022-06-29T19:03:04Z",
          "updatedAt": "2022-06-29T19:03:04Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax849CP8K",
          "commit": {
            "abbreviatedOid": "9ea88ba"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Looks Good! Thanks @alessandroguggino!",
          "createdAt": "2022-06-29T20:54:37Z",
          "updatedAt": "2022-06-29T20:54:37Z",
          "comments": []
        }
      ]
    },
    {
      "number": 195,
      "id": "PR_kwDOF8lax846z9fR",
      "title": "editorial updates",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/195",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Updates:\r\n\r\n- Removes the new line after every procedure step (couldn\u2019t find another cfrg draft that does that).\r\n- Removes the `hash` and `xof` from the parameters section.\r\n- Defines the inputted messages as a list of scalars than a list of octet-strings.\r\n\r\nOpening this to discuss on the next call. However, it is blocked by #186 and #190. Those should be merged first. Will rebase this after that.\r\n",
      "createdAt": "2022-07-04T17:20:10Z",
      "updatedAt": "2022-07-04T21:59:52Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "894456f0f24da41abcab823f1d2e1bbe7da8c505",
      "headRepository": "BasileiosKal/bbs-signature",
      "headRefName": "editorial-update",
      "headRefOid": "3dee1eff327d071003c117ec7c30f020c9315341",
      "closedAt": "2022-07-04T21:59:51Z",
      "mergedAt": "2022-07-04T21:59:51Z",
      "mergedBy": "BasileiosKal",
      "mergeCommit": {
        "oid": "c2f24c812e16078cff5c72186201d87cca5f2267"
      },
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Multiple approvals. Discussed in the WG call. Merging. Thanks everyone!",
          "createdAt": "2022-07-04T21:59:47Z",
          "updatedAt": "2022-07-04T21:59:47Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax849Q42I",
          "commit": {
            "abbreviatedOid": "7d52a26"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-07-04T18:20:51Z",
          "updatedAt": "2022-07-04T18:20:51Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax849RLJ_",
          "commit": {
            "abbreviatedOid": "3dee1ef"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-07-04T21:57:16Z",
          "updatedAt": "2022-07-04T21:57:16Z",
          "comments": []
        }
      ]
    },
    {
      "number": 197,
      "id": "PR_kwDOF8lax8464EPN",
      "title": "Only run GH-pages update on push to main branch",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/197",
      "state": "MERGED",
      "author": "andrewwhitehead",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes GHA errors on cloned repositories (assuming you don't touch the main branch)",
      "createdAt": "2022-07-05T19:35:01Z",
      "updatedAt": "2022-07-06T18:09:06Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "c2f24c812e16078cff5c72186201d87cca5f2267",
      "headRepository": "andrewwhitehead/bbs-signature",
      "headRefName": "fix/gha-local",
      "headRefOid": "3baab9ec5b02249a2250b754b345c7506cab8dae",
      "closedAt": "2022-07-06T18:09:06Z",
      "mergedAt": "2022-07-06T18:09:06Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "75a22987676395fb48eb74c929756cd4cbdb8fad"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Thanks @andrewwhitehead ",
          "createdAt": "2022-07-06T18:09:01Z",
          "updatedAt": "2022-07-06T18:09:01Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax849WRh7",
          "commit": {
            "abbreviatedOid": "3baab9e"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2022-07-05T21:49:09Z",
          "updatedAt": "2022-07-05T21:49:09Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax849bFzZ",
          "commit": {
            "abbreviatedOid": "3baab9e"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-07-06T18:08:50Z",
          "updatedAt": "2022-07-06T18:08:50Z",
          "comments": []
        }
      ]
    },
    {
      "number": 198,
      "id": "PR_kwDOF8lax8469ody",
      "title": "Update my contact info",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/198",
      "state": "MERGED",
      "author": "andrewwhitehead",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Also fixes a few unescaped underscores",
      "createdAt": "2022-07-06T19:55:11Z",
      "updatedAt": "2022-07-06T20:20:40Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "75a22987676395fb48eb74c929756cd4cbdb8fad",
      "headRepository": "andrewwhitehead/bbs-signature",
      "headRefName": "upd/andrew",
      "headRefOid": "d736c4aaef80ebc7873e5f7f9af41286e4c24c15",
      "closedAt": "2022-07-06T20:20:40Z",
      "mergedAt": "2022-07-06T20:20:40Z",
      "mergedBy": "BasileiosKal",
      "mergeCommit": {
        "oid": "f57d378547113c6f698fafd664c09a9ebe48673b"
      },
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Multiple approvals! Merging!",
          "createdAt": "2022-07-06T20:20:35Z",
          "updatedAt": "2022-07-06T20:20:35Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax849bmiz",
          "commit": {
            "abbreviatedOid": "d736c4a"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-07-06T20:14:50Z",
          "updatedAt": "2022-07-06T20:14:50Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax849bn2X",
          "commit": {
            "abbreviatedOid": "d736c4a"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-07-06T20:20:14Z",
          "updatedAt": "2022-07-06T20:20:14Z",
          "comments": []
        }
      ]
    },
    {
      "number": 199,
      "id": "PR_kwDOF8lax84697sg",
      "title": "consistency updates",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/199",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Updates discussed in the last (on 2022-07-04) WG call:\r\n\r\n1. `H_s`, `H_d` -> `Q_1`, `Q_2`\r\n2. `messageIndexes`, `disclosedMessages` -> `message_indexes`, `disclosed_messages`\r\n3. `Ciphersuite__ID` -> `ciphersuite_id`\r\n4. Added `length` definition\r\n5. Removed the `H_s` and `H_d` definitions\r\n\r\nSome of the updates that i didn't make:\r\n1. Didn\u2019t change `MsgGenerators` to `msg_generators` (it looks better this way to me, but this is the only reason. Happy to make the update if people prefer it)\r\n2. Didn\u2019t update `P1` to `Q_1`. I\u2019m worried about the security of that change in some scenarios, and I think we should think a little more about it. Will open an issue to discuss more and explain my worries.",
      "createdAt": "2022-07-06T20:33:15Z",
      "updatedAt": "2022-07-06T21:06:39Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "f57d378547113c6f698fafd664c09a9ebe48673b",
      "headRepository": "BasileiosKal/bbs-signature",
      "headRefName": "consistency-updates",
      "headRefOid": "d9c7465159c29e54103b7b840e4373c72de3435b",
      "closedAt": "2022-07-06T21:06:39Z",
      "mergedAt": "2022-07-06T21:06:38Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "4f2a9fa6e0a165f84c4225603e8f8252a9f8c306"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Multiple approvals, proposal discussed on WG call, merging.",
          "createdAt": "2022-07-06T21:06:33Z",
          "updatedAt": "2022-07-06T21:06:33Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax849bvmS",
          "commit": {
            "abbreviatedOid": "d9c7465"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-07-06T20:45:26Z",
          "updatedAt": "2022-07-06T20:45:26Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax849b0np",
          "commit": {
            "abbreviatedOid": "d9c7465"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-07-06T21:06:09Z",
          "updatedAt": "2022-07-06T21:06:09Z",
          "comments": []
        }
      ]
    },
    {
      "number": 200,
      "id": "PR_kwDOF8lax846-C2Z",
      "title": "Updating my name in the spec",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/200",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-07-06T20:49:26Z",
      "updatedAt": "2022-07-06T21:01:44Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "f57d378547113c6f698fafd664c09a9ebe48673b",
      "headRepository": "BasileiosKal/bbs-signature",
      "headRefName": "name-update",
      "headRefOid": "002e27265586b7e44ad1e4d41d261fc0cb1c63a4",
      "closedAt": "2022-07-06T21:01:44Z",
      "mergedAt": "2022-07-06T21:01:44Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "085436d75423debea72aad31f9c71d7ed511e600"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax849bw25",
          "commit": {
            "abbreviatedOid": "002e272"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-07-06T20:50:32Z",
          "updatedAt": "2022-07-06T20:50:32Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax849bzl-",
          "commit": {
            "abbreviatedOid": "002e272"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-07-06T21:01:39Z",
          "updatedAt": "2022-07-06T21:01:39Z",
          "comments": []
        }
      ]
    },
    {
      "number": 201,
      "id": "PR_kwDOF8lax847E5fH",
      "title": "Editorial updates before submission",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/201",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Minor updates prior to IETF submission for 114 meeting.\r\n\r\n- Remove usage of the word derive when referring to proofs, instead using generate\r\n- Minor language and gramma tweaks\r\n- Moved considerations under scheme definition instead of it being its own section\r\n- Added basic description for selective disclosure use case for identity credentials\r\n- Added document history section",
      "createdAt": "2022-07-08T03:26:47Z",
      "updatedAt": "2022-09-13T23:25:14Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "4f2a9fa6e0a165f84c4225603e8f8252a9f8c306",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/edits",
      "headRefOid": "b497ec9f4807b724d1a36a57e3c8439071031ba2",
      "closedAt": "2022-07-08T23:10:21Z",
      "mergedAt": "2022-07-08T23:10:21Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "c90bb232e0aa73ee1b3a5e35ba1c8d798eeec48a"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Multiple approvals, merging",
          "createdAt": "2022-07-08T23:10:16Z",
          "updatedAt": "2022-07-08T23:10:16Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax849jZpQ",
          "commit": {
            "abbreviatedOid": "24dc9b3"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM!",
          "createdAt": "2022-07-08T10:00:30Z",
          "updatedAt": "2022-07-08T10:05:50Z",
          "comments": [
            {
              "originalPosition": 142,
              "body": "```suggestion\r\nBBS Signatures ofter an alternative model that solves the same problems that proof of cryptographic key possession schemes do for bearer based schemes, but in a way that doesn't introduce new up-front protocol complexity. In the context of a protocol like OAuth2.0 the access token issued by the authorization server would feature a BBS Signature, however instead of the client providing this access token as issued, in their request to a resource server, they generate a unique proof from the original access token and include that in the request instead. Because the access token is not shared in a request to a resource server, attacks such as MITM are mitigated. A resource server also obtains the ability to detect a replay attack by ensuring the proof presented is unique.\r\n```\r\n\r\nNitpicking but wouldn't the holder/prover be an RP only in the context of OIDC?? In the context of OAuth2.0 wouldn't \"client\" be more appropriate??",
              "createdAt": "2022-07-08T10:00:30Z",
              "updatedAt": "2022-07-08T10:05:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax849kqxB",
          "commit": {
            "abbreviatedOid": "24dc9b3"
          },
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-07-08T14:49:44Z",
          "updatedAt": "2022-07-08T14:49:44Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax849mDvF",
          "commit": {
            "abbreviatedOid": "24dc9b3"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-07-08T21:12:06Z",
          "updatedAt": "2022-07-08T21:12:06Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax849mQjb",
          "commit": {
            "abbreviatedOid": "24dc9b3"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-08T23:09:52Z",
          "updatedAt": "2022-07-08T23:09:52Z",
          "comments": [
            {
              "originalPosition": 142,
              "body": "yes good catch",
              "createdAt": "2022-07-08T23:09:52Z",
              "updatedAt": "2022-07-08T23:09:52Z"
            }
          ]
        }
      ]
    },
    {
      "number": 202,
      "id": "PR_kwDOF8lax847H_hK",
      "title": "length definition fix",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/202",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Small fix in the definition of length (length is used for both arrays and octet strings).",
      "createdAt": "2022-07-08T18:50:51Z",
      "updatedAt": "2022-07-08T23:11:28Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "4f2a9fa6e0a165f84c4225603e8f8252a9f8c306",
      "headRepository": "BasileiosKal/bbs-signature",
      "headRefName": "notation-fix",
      "headRefOid": "fb2eed0294aeb8726a14b8e1d8f96d94f8965aec",
      "closedAt": "2022-07-08T23:11:10Z",
      "mergedAt": "2022-07-08T23:11:10Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "b7c17f075a481d15ff29e54c868f2d98407058cf"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Minor clarification, merging",
          "createdAt": "2022-07-08T23:11:28Z",
          "updatedAt": "2022-07-08T23:11:28Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax849mQpi",
          "commit": {
            "abbreviatedOid": "fb2eed0"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-07-08T23:11:01Z",
          "updatedAt": "2022-07-08T23:11:01Z",
          "comments": []
        }
      ]
    },
    {
      "number": 203,
      "id": "PR_kwDOF8lax847JOv0",
      "title": "Fix old H0 references",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/203",
      "state": "MERGED",
      "author": "andrewwhitehead",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-07-09T17:27:44Z",
      "updatedAt": "2022-07-09T23:21:14Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "95a35b05a5f59960c62fb46cf07be99fa3ba19aa",
      "headRepository": "andrewwhitehead/bbs-signature",
      "headRefName": "fix/h0",
      "headRefOid": "0ae42b888cd7b6091ed48413b6fc94d9e1101bfe",
      "closedAt": "2022-07-09T23:21:14Z",
      "mergedAt": "2022-07-09T23:21:14Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "20a01df627432de5acd0b6ef3cdc585164d497de"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Minor change, fixes typo, merging",
          "createdAt": "2022-07-09T23:21:10Z",
          "updatedAt": "2022-07-09T23:21:10Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax849mx6M",
          "commit": {
            "abbreviatedOid": "0ae42b8"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-07-09T23:20:52Z",
          "updatedAt": "2022-07-09T23:20:52Z",
          "comments": []
        }
      ]
    },
    {
      "number": 205,
      "id": "PR_kwDOF8lax849WUDY",
      "title": "Removed generator_seed from create_generators calls",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/205",
      "state": "MERGED",
      "author": "christianpaquin",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Removed the `generator_seed` parameter from the `create_generators` calls, as it is already defined as a ciphersuite value within that function.",
      "createdAt": "2022-08-17T20:07:56Z",
      "updatedAt": "2022-08-18T10:36:59Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "57d6ae95c501167ed319a124f5f376e6f04f925a",
      "headRepository": "christianpaquin/bbs-signature",
      "headRefName": "create-generators-params",
      "headRefOid": "371b5036fc51d13a6e1fdbecf43d7a186b436338",
      "closedAt": "2022-08-18T10:36:59Z",
      "mergedAt": "2022-08-18T10:36:59Z",
      "mergedBy": "BasileiosKal",
      "mergeCommit": {
        "oid": "4e7cff0f246eeedc9b8736fde11b0ae73588e199"
      },
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Multiple approvals! Editorial update. Merging! Thanks @christianpaquin!!",
          "createdAt": "2022-08-18T10:36:52Z",
          "updatedAt": "2022-08-18T10:36:52Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax85AKw05",
          "commit": {
            "abbreviatedOid": "371b503"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-08-18T00:39:40Z",
          "updatedAt": "2022-08-18T00:39:40Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85AM35I",
          "commit": {
            "abbreviatedOid": "371b503"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-08-18T10:35:37Z",
          "updatedAt": "2022-08-18T10:35:37Z",
          "comments": []
        }
      ]
    },
    {
      "number": 208,
      "id": "PR_kwDOF8lax849auXi",
      "title": "Update signature related fixtures",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/208",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This PR updates the fixtures to align to the current spec, including adding in those that feature a header value.",
      "createdAt": "2022-08-18T20:01:57Z",
      "updatedAt": "2022-09-12T18:10:20Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "4e7cff0f246eeedc9b8736fde11b0ae73588e199",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/update-signature-fixtures",
      "headRefOid": "d65255be7528e38669b73b836003baadaff2718a",
      "closedAt": "2022-09-12T18:10:15Z",
      "mergedAt": "2022-09-12T18:10:15Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "cd221a28441de49b8369b376d23174f6c0173e5c"
      },
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on the WG call of the 22nd of August! Will need to check the generator points on the spec for correctness and consistency with the new fixtures.",
          "createdAt": "2022-08-22T19:22:42Z",
          "updatedAt": "2022-08-22T19:22:42Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Merging with the recent merge of #214, still further work required on refining these fixtures.",
          "createdAt": "2022-09-12T18:10:09Z",
          "updatedAt": "2022-09-12T18:10:09Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax85AUMZm",
          "commit": {
            "abbreviatedOid": "d65255b"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM!",
          "createdAt": "2022-08-19T15:52:29Z",
          "updatedAt": "2022-08-19T15:52:29Z",
          "comments": []
        }
      ]
    },
    {
      "number": 209,
      "id": "PR_kwDOF8lax849a6pE",
      "title": "Adds missing + in ProofVerify's T computation",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/209",
      "state": "MERGED",
      "author": "christianpaquin",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-08-18T20:52:41Z",
      "updatedAt": "2022-08-19T15:54:59Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "4e7cff0f246eeedc9b8736fde11b0ae73588e199",
      "headRepository": "christianpaquin/bbs-signature",
      "headRefName": "ProofVerify_T_typo",
      "headRefOid": "b28262e6ceebdd1375532e0cf8a177d9e0e716c7",
      "closedAt": "2022-08-19T15:54:59Z",
      "mergedAt": "2022-08-19T15:54:59Z",
      "mergedBy": "BasileiosKal",
      "mergeCommit": {
        "oid": "0523774c6f573dedb65f4e248fc24d7600aa9988"
      },
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Multiple approvals! Editorial update. Merging. Thanks!!",
          "createdAt": "2022-08-19T15:54:55Z",
          "updatedAt": "2022-08-19T15:54:55Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax85AQcwu",
          "commit": {
            "abbreviatedOid": "b28262e"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-08-18T21:54:26Z",
          "updatedAt": "2022-08-18T21:54:26Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85AUM7J",
          "commit": {
            "abbreviatedOid": "b28262e"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-08-19T15:54:07Z",
          "updatedAt": "2022-08-19T15:54:07Z",
          "comments": []
        }
      ]
    },
    {
      "number": 210,
      "id": "PR_kwDOF8lax849bF-n",
      "title": "Update proof fixtures",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/210",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Depended on #208 being merged ahead",
      "createdAt": "2022-08-18T21:54:02Z",
      "updatedAt": "2023-02-23T21:14:59Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "4e7cff0f246eeedc9b8736fde11b0ae73588e199",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/update-proof-fixtures",
      "headRefOid": "d80c57fef0178dbb84a82607802e89528c5ed5e1",
      "closedAt": "2022-10-11T07:10:55Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Question about the values used to generate these test vectors: do all the signatures and proofs use the generators in `fixtures/generators.json`, and if so, are the two first entries `Q1` and `Q2` and the remaining ones `H1` ... `H8` ? ",
          "createdAt": "2022-08-25T04:26:16Z",
          "updatedAt": "2022-08-25T04:26:16Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "DIscussed on WG call 20th Sept, will add a note to capture the fixtures are non-deterministic in nature.",
          "createdAt": "2022-09-19T18:23:12Z",
          "updatedAt": "2022-09-19T18:23:12Z"
        },
        {
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It would be great to also add the fixtures for the sha256 ciphersuite",
          "createdAt": "2022-09-19T18:46:48Z",
          "updatedAt": "2022-09-19T18:46:48Z"
        },
        {
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> It would be great to also add the fixtures for the sha256 ciphersuite\r\n\r\nAny ETA for this, @tplooker, @BasileiosKal? Anxious to plug these in my implementation :)",
          "createdAt": "2022-09-26T16:51:43Z",
          "updatedAt": "2022-09-26T16:51:43Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hey @christianpaquin! Sorry for the long delay. Had to take some time off. Iv now opened #221 with the updated fixtures. \r\n\r\nNote that the signature fixtures do also take into account #216. It's a simple update were the ciphersuite id is not appended with its length when hashing.",
          "createdAt": "2022-10-08T23:56:07Z",
          "updatedAt": "2022-10-08T23:56:07Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Closing in favour of #221 ",
          "createdAt": "2022-10-11T07:10:55Z",
          "updatedAt": "2022-10-11T07:10:55Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax85AUlim",
          "commit": {
            "abbreviatedOid": "d80c57f"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-08-19T17:23:17Z",
          "updatedAt": "2022-08-19T17:23:56Z",
          "comments": [
            {
              "originalPosition": 122,
              "body": "Maybe it's naive, but could this be confusing until we have the ability to test with a deterministic proofGen??",
              "createdAt": "2022-08-19T17:23:17Z",
              "updatedAt": "2022-08-19T17:23:56Z"
            }
          ]
        }
      ]
    },
    {
      "number": 211,
      "id": "PR_kwDOF8lax849eKRr",
      "title": "Add DST as input to hash_to_scalar",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/211",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #194\r\n\r\nI also updated the definition of the `ciphersuite_id` to be a ASCII string, instead of an octet string. This makes it easier to concatenate it with other strings to create DSTs which will then become octet strings using `utf8()`.\r\n\r\nLastly, I'm passing the inputted message in `MapMessageToScalarAsHash` directly to `hash_to_scalar` because I don't see a reason to append it with each length anymore, since we are using `expand_message`",
      "createdAt": "2022-08-19T15:48:58Z",
      "updatedAt": "2022-08-31T02:25:37Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "4e7cff0f246eeedc9b8736fde11b0ae73588e199",
      "headRepository": "BasileiosKal/bbs-signature",
      "headRefName": "hash-to-scalar",
      "headRefOid": "d8537755b2d698cf6224a32f31be07a44fefd68c",
      "closedAt": "2022-08-31T02:25:37Z",
      "mergedAt": "2022-08-31T02:25:37Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "1dbf27eab59c6fff1993940457d114cc22e15116"
      },
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on the WG call of the 22nd of August. Will need to make the DST formats consistent across operations. Will use octet-strings for the DSTs and have them default to `utf8(default_dst)`.",
          "createdAt": "2022-08-22T18:17:27Z",
          "updatedAt": "2022-08-22T19:18:52Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed on WG call 29th August, awaiting updates and re-review.",
          "createdAt": "2022-08-29T18:37:09Z",
          "updatedAt": "2022-08-29T18:37:09Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Multiple approvals, discussed on WG call, merging",
          "createdAt": "2022-08-31T02:25:32Z",
          "updatedAt": "2022-08-31T02:25:32Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax85A6rID",
          "commit": {
            "abbreviatedOid": "abe2415"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-08-29T17:44:33Z",
          "updatedAt": "2022-08-29T17:44:33Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "I don't think the DST needs to be defined as 'ASCII encoded' here, as technically any octet string is accepted.",
              "createdAt": "2022-08-29T17:44:33Z",
              "updatedAt": "2022-08-29T17:44:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85A7lbg",
          "commit": {
            "abbreviatedOid": "abe2415"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-08-29T21:12:08Z",
          "updatedAt": "2022-08-29T21:12:08Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Done. Thanks!",
              "createdAt": "2022-08-29T21:12:08Z",
              "updatedAt": "2022-08-29T21:12:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85A711p",
          "commit": {
            "abbreviatedOid": "d853775"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-08-29T22:37:44Z",
          "updatedAt": "2022-08-29T22:37:44Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85BCrva",
          "commit": {
            "abbreviatedOid": "d853775"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-08-31T02:25:13Z",
          "updatedAt": "2022-08-31T02:25:13Z",
          "comments": []
        }
      ]
    },
    {
      "number": 213,
      "id": "PR_kwDOF8lax849eePO",
      "title": "Add sha256 ciphersuite",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/213",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Adding a sha256 based suite alongside the existing shake256 based one.",
      "createdAt": "2022-08-19T17:19:05Z",
      "updatedAt": "2022-08-29T18:33:06Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "0523774c6f573dedb65f4e248fc24d7600aa9988",
      "headRepository": "BasileiosKal/bbs-signature",
      "headRefName": "sha256_suite",
      "headRefOid": "c3cefcb34d551033502ad359e3210a7c90eba6a7",
      "closedAt": "2022-08-29T18:33:06Z",
      "mergedAt": "2022-08-29T18:33:06Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "9276b6f8c175672bdf52fd628308174e9be53695"
      },
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on the WG call on the 22nd of August. Will update based on Andrew's review!",
          "createdAt": "2022-08-22T18:20:02Z",
          "updatedAt": "2022-08-22T19:17:55Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed on WG call 30th August, multiple approvals, merging.",
          "createdAt": "2022-08-29T18:32:59Z",
          "updatedAt": "2022-08-29T18:32:59Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax85AbiKS",
          "commit": {
            "abbreviatedOid": "1399d83"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-08-22T18:20:52Z",
          "updatedAt": "2022-08-22T18:20:52Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "```suggestion\r\nNote that these two ciphersuites differ only in the hash function (SHAKE-256 vs SHA-256) and in the hash-to-curve suites used. The hash-to-curve suites differ in the `expand_message` variant and underlying hash function. More concretely, the [BLS12-381-SHAKE-256](#bls12-381-shake-256) ciphersuite makes use of `expand_message_xof` with SHAKE-256, while [BLS12-381-SHA-256](#bls12-381-sha-256) makes use of `expand_message_xmd` with SHA-256. Curve parameters are common between the two ciphersuites.\r\n```",
              "createdAt": "2022-08-22T18:20:52Z",
              "updatedAt": "2022-08-22T18:20:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85A6pfC",
          "commit": {
            "abbreviatedOid": "c3cefcb"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-08-29T17:40:27Z",
          "updatedAt": "2022-08-29T17:40:27Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85A645l",
          "commit": {
            "abbreviatedOid": "c3cefcb"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-08-29T18:30:03Z",
          "updatedAt": "2022-08-29T18:30:03Z",
          "comments": []
        }
      ]
    },
    {
      "number": 214,
      "id": "PR_kwDOF8lax84-ycM5",
      "title": "Generator fixtures update",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/214",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Updated generator fixtures. Also disabled the fixture-population workflow until the tooling is up to date with the spec.",
      "createdAt": "2022-09-12T14:15:03Z",
      "updatedAt": "2022-09-12T18:07:39Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "1dbf27eab59c6fff1993940457d114cc22e15116",
      "headRepository": "BasileiosKal/bbs-signature",
      "headRefName": "gens-fixtures",
      "headRefOid": "34913f0b7b077fc227c3d0ba1ea6fcb47667bdea",
      "closedAt": "2022-09-12T18:07:39Z",
      "mergedAt": "2022-09-12T18:07:39Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "5a47464430bb4522edb01926c892e7c2f6bde80d"
      },
      "comments": [
        {
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Are these for the shake ciphersuite, and if so, will there be sha256 values soon? ",
          "createdAt": "2022-09-12T16:44:40Z",
          "updatedAt": "2022-09-12T16:49:49Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yea those are just for the shake suite (just updating the existing ones). Will hopefully include ones for the Sha256 suite soon enough.",
          "createdAt": "2022-09-12T17:17:48Z",
          "updatedAt": "2022-09-12T17:17:48Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Merging as it affects other fixture related PR's",
          "createdAt": "2022-09-12T18:07:34Z",
          "updatedAt": "2022-09-12T18:07:34Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax85B1vGS",
          "commit": {
            "abbreviatedOid": "34913f0"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-09-12T18:03:58Z",
          "updatedAt": "2022-09-12T18:03:58Z",
          "comments": []
        }
      ]
    },
    {
      "number": 215,
      "id": "PR_kwDOF8lax84-zLXJ",
      "title": "Add suite specific fixed g1 base point",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/215",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Updated tooling to calculate the G1 base point for each ciphersuite. \r\n\r\n- To avoid conflicts with #214 I don't write them in the fixtures file (the points are hardcoded in the suites). Will update after that PR is resolved.\r\n- The message generator fixtures creation still needs updating to the latest spec.",
      "createdAt": "2022-09-12T16:41:24Z",
      "updatedAt": "2022-09-26T20:20:13Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "1dbf27eab59c6fff1993940457d114cc22e15116",
      "headRepository": "BasileiosKal/bbs-signature",
      "headRefName": "g1-base-point",
      "headRefOid": "eb8e53d16a2390b38d7a207af94e1eb4ed4d06c6",
      "closedAt": "2022-09-26T20:20:12Z",
      "mergedAt": "2022-09-26T20:20:12Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "3e69a8b16fd7788993e9d3a8849f311ade47fc5e"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Multiple reviews and approvals, merging",
          "createdAt": "2022-09-26T20:20:06Z",
          "updatedAt": "2022-09-26T20:20:06Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax85B1YPg",
          "commit": {
            "abbreviatedOid": "eb8e53d"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-09-12T17:06:04Z",
          "updatedAt": "2022-09-12T17:06:04Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85B5q8_",
          "commit": {
            "abbreviatedOid": "eb8e53d"
          },
          "author": "jovfer",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-13T11:45:33Z",
          "updatedAt": "2022-09-13T11:45:33Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "@BasileiosKal @OR13  most likely a dumb question(s) from me, as I'm not an expert in BBS:\r\n1) Is it OK to have a collision for some generator_i == P1?\r\n2) Or is it guaranteed that hash_to_curve_g1(...) <> P1? (why?)\r\n\r\nmay be it's worth a note here.",
              "createdAt": "2022-09-13T11:45:33Z",
              "updatedAt": "2022-09-13T11:47:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85B8LUX",
          "commit": {
            "abbreviatedOid": "eb8e53d"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-13T18:43:55Z",
          "updatedAt": "2022-09-13T18:43:55Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "cc @mikelodder7 @tplooker ",
              "createdAt": "2022-09-13T18:43:55Z",
              "updatedAt": "2022-09-13T18:43:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85B8RhA",
          "commit": {
            "abbreviatedOid": "eb8e53d"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-13T19:05:48Z",
          "updatedAt": "2022-09-13T19:05:49Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "That\u2019s actually a great question\ud83d\ude04\r\n\r\n## TL;TR\r\nIt's not OK to have a collision, but the probability of having a collision with P1 is practically 0.\r\n\r\n## In detail\r\nThat probability is ~2^-128. This comes from the collision resistance of hash_to_curve_g1 (which comes from the collision resistance of the underlying hash function+the security level of the curve). This guarantees that unless you create more than 2^128 generators, generator_i will be different from P1 (note that they are created from different inputs to `hash_to_curve_g1`). Also, even if a collision could be found, the attacker would have to influence the seed that is used to create all the generators to take advantage of it (they shouldn't be able to, in a correct implementation).\r\n\r\nIf that security level is deemed not enough in the future, there are alternative curves and hash functions that can be used, with higher security levels.\r\n\r\nWe have checks like that throughout the document, but we are currently debating if we should keep all of them. The tradeoff is that they guard against events that could compromise security, however, the probability of those events is practically 0. Also, we are worried that the more complicated draft could lead to implementation bugs like infinite loops (since we keep trying in a loop until we get a valid result).\r\n\r\nThe reason I removed P1 specifically here from that check was practical. We can't check for a coalition with P1 in the body of the same operation used to create P1.\r\n\r\nA note is a good idea. We do have an [issue](https://github.com/decentralized-identity/bbs-signature/issues/206) open, to debate on what the best way to describe those requirements would be. No matter the case though, we will soon add text that describes all those considerations in detail.",
              "createdAt": "2022-09-13T19:05:48Z",
              "updatedAt": "2022-09-13T19:25:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85B8RzY",
          "commit": {
            "abbreviatedOid": "eb8e53d"
          },
          "author": "mikelodder7",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-13T19:06:51Z",
          "updatedAt": "2022-09-13T19:06:52Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Agreed. The likelihood of a collision is so low it\u2019s not worth checking. Just a note about it is good enough",
              "createdAt": "2022-09-13T19:06:51Z",
              "updatedAt": "2022-09-13T19:06:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85B--lQ",
          "commit": {
            "abbreviatedOid": "eb8e53d"
          },
          "author": "jovfer",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-14T08:30:00Z",
          "updatedAt": "2022-09-14T08:30:00Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Thanks for the details, that makes perfect sense. My understanding was similar, but the next things is actually the source for my confusion: \r\nWhat about of the collusion for `generator_i` and `generator_j`? isn't it the same to `P1` vs `generator_i` ?\r\n\r\nShould we remove the whole check in this line? (seems like just one of the cases to be debated mentioned in your comment)",
              "createdAt": "2022-09-14T08:30:00Z",
              "updatedAt": "2022-09-14T08:36:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85CA2RX",
          "commit": {
            "abbreviatedOid": "eb8e53d"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-14T13:45:57Z",
          "updatedAt": "2022-09-14T13:45:57Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Collisions between `generator_i` and `generator_j` are a bit different. Because we are essentially checking for (any) duplicates (rather than equality with a fixed value, i.e., `generator_i = P1`), we must also consider the [birthday paradox](https://en.wikipedia.org/wiki/Birthday_problem) when calculating the probability of that event.\r\n \r\nThat said, it probably won\u2019t matter enough in practice, and the probability will still be close to ~2^-128. So most likely we will remove that check too. It\u2019s a bit more complicated case though so we want to be 100% sure first.",
              "createdAt": "2022-09-14T13:45:57Z",
              "updatedAt": "2022-09-14T13:45:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85CGZ8d",
          "commit": {
            "abbreviatedOid": "eb8e53d"
          },
          "author": "jovfer",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-15T10:56:14Z",
          "updatedAt": "2022-09-15T10:56:15Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "ah yes, I've missed the effect of the birthday paradox in the first place at all. Not sure how much actual effect it will have for avg number of msgs per credential for such small probability per single collision, but agree: let's keep the rest of the check for now.\r\nThanks for the explanation.",
              "createdAt": "2022-09-15T10:56:14Z",
              "updatedAt": "2022-09-15T10:59:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85CUiWi",
          "commit": {
            "abbreviatedOid": "eb8e53d"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-09-19T18:15:43Z",
          "updatedAt": "2022-09-19T18:15:43Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85CzszV",
          "commit": {
            "abbreviatedOid": "eb8e53d"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-09-26T20:19:14Z",
          "updatedAt": "2022-09-26T20:19:14Z",
          "comments": []
        }
      ]
    },
    {
      "number": 216,
      "id": "PR_kwDOF8lax84_hTR8",
      "title": "Update encoding rules",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/216",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #207\r\n\r\nDSTs are defined as octet strings everywhere. Default DSTs are turned into octet strings using `utf8`. Also, the `ciphersuite_id` is excluded from the \u201cmust be prepended with its length\u201d rule when hashing (no reason for it).",
      "createdAt": "2022-09-23T19:49:00Z",
      "updatedAt": "2022-10-11T21:21:15Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "7e587fa1f7489f470b6d6d2fd3413a961fba8ef9",
      "headRepository": "BasileiosKal/bbs-signature",
      "headRefName": "encoding_updates",
      "headRefOid": "aee2934719c75eacfb85622ebe898fcd539217af",
      "closedAt": "2022-10-11T21:21:15Z",
      "mergedAt": "2022-10-11T21:21:15Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "5fc8cb899fd5de307e74ddf866565da920367b91"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "With the CFRG draft adoption the draft name has changed again, please rebase this PR to target the new draft name `draft-irtf-cfrg-bbs-signatures`",
          "createdAt": "2022-10-06T20:31:48Z",
          "updatedAt": "2022-10-06T20:31:48Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Multiple approvals, open over two weeks, merging",
          "createdAt": "2022-10-11T21:21:11Z",
          "updatedAt": "2022-10-11T21:21:11Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax85CzGeS",
          "commit": {
            "abbreviatedOid": "c71ffc1"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-26T18:06:41Z",
          "updatedAt": "2022-09-26T18:06:41Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "`el` is utf8 but utf8 is applied again",
              "createdAt": "2022-09-26T18:06:41Z",
              "updatedAt": "2022-09-26T18:06:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85CzGod",
          "commit": {
            "abbreviatedOid": "c71ffc1"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-26T18:07:11Z",
          "updatedAt": "2022-09-26T18:07:11Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "Is this used? Why not just pass it as a G2 point?",
              "createdAt": "2022-09-26T18:07:11Z",
              "updatedAt": "2022-09-26T18:07:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85CzGud",
          "commit": {
            "abbreviatedOid": "c71ffc1"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-26T18:07:30Z",
          "updatedAt": "2022-09-26T18:07:31Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "```suggestion\r\n            utf8(ciphersuite_id || \"SIG_GENERATOR_SEED_\"), where\r\n```",
              "createdAt": "2022-09-26T18:07:30Z",
              "updatedAt": "2022-09-26T18:07:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85DkadL",
          "commit": {
            "abbreviatedOid": "c71ffc1"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-06T20:46:46Z",
          "updatedAt": "2022-10-06T20:46:46Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "Thinks! Fixed.",
              "createdAt": "2022-10-06T20:46:46Z",
              "updatedAt": "2022-10-06T20:46:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85Dkag_",
          "commit": {
            "abbreviatedOid": "c71ffc1"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-06T20:47:01Z",
          "updatedAt": "2022-10-06T20:47:02Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "Thanks! Fixed.",
              "createdAt": "2022-10-06T20:47:01Z",
              "updatedAt": "2022-10-06T20:47:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85Dkc_B",
          "commit": {
            "abbreviatedOid": "c71ffc1"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-06T20:56:48Z",
          "updatedAt": "2022-10-06T20:56:48Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "We definitely could, but i like having the PK as an octet string. It's more intuitive for a developer IMO. Also updating this would be a bigger change (will need to update the `octets_to_pubkey` to something like `validate_pubkey` which I'm not sure how it would look like. Opened #219 to keep track of this.",
              "createdAt": "2022-10-06T20:56:48Z",
              "updatedAt": "2022-10-06T20:56:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85Dw1QB",
          "commit": {
            "abbreviatedOid": "aee2934"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-11T07:07:09Z",
          "updatedAt": "2022-10-11T07:07:09Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85D1wqi",
          "commit": {
            "abbreviatedOid": "aee2934"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-11T21:16:39Z",
          "updatedAt": "2022-10-11T21:16:39Z",
          "comments": []
        }
      ]
    },
    {
      "number": 220,
      "id": "PR_kwDOF8lax85AZPon",
      "title": "Tooling: update msg generators calculation",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/220",
      "state": "MERGED",
      "author": "jovfer",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Align msg generator tooling to the spec:\r\n* fix DST for h2c\r\n* replace hash by expand",
      "createdAt": "2022-10-07T13:26:24Z",
      "updatedAt": "2022-11-22T06:40:29Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "5fc8cb899fd5de307e74ddf866565da920367b91",
      "headRepository": "jovfer/bbs-signature",
      "headRefName": "sm/fix_tooling_msg_gen",
      "headRefOid": "d3b38509c0518335cd75794ddd334fb84b589a22",
      "closedAt": "2022-10-17T18:39:37Z",
      "mergedAt": "2022-10-17T18:39:37Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "4f60782d1479ce24a1df93f3e2140407d39eb2cc"
      },
      "comments": [
        {
          "author": "jovfer",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@BasileiosKal thanks for review :) applied your suggestions ",
          "createdAt": "2022-10-14T06:44:05Z",
          "updatedAt": "2022-10-14T06:44:05Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed on WG call 17th of October, multiple approvals, merging thanks @jovfer!",
          "createdAt": "2022-10-17T18:39:33Z",
          "updatedAt": "2022-10-17T18:39:33Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax85DnzQ4",
          "commit": {
            "abbreviatedOid": "54e5cd5"
          },
          "author": "jovfer",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-07T13:39:13Z",
          "updatedAt": "2022-10-07T13:39:14Z",
          "comments": [
            {
              "originalPosition": 3,
              "body": "Is it intentional divergency from the spec? The `msg` / `buffer` to be hashed in the next line is output of expand_msg according to the spec and it's just direct output of shake256 in this impl.\r\n\r\n`make_g1_base_point` seems to be aligned to the spec",
              "createdAt": "2022-10-07T13:39:13Z",
              "updatedAt": "2022-10-07T13:41:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85DqwMD",
          "commit": {
            "abbreviatedOid": "54e5cd5"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-08T23:15:42Z",
          "updatedAt": "2022-10-08T23:15:42Z",
          "comments": [
            {
              "originalPosition": 3,
              "body": "Its a create_generators procedure from a previous version of the spec and should be updated. Thanks for pointing it out!",
              "createdAt": "2022-10-08T23:15:42Z",
              "updatedAt": "2022-10-08T23:15:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85Drtan",
          "commit": {
            "abbreviatedOid": "54e5cd5"
          },
          "author": "jovfer",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-10T06:41:03Z",
          "updatedAt": "2022-10-10T06:41:04Z",
          "comments": [
            {
              "originalPosition": 3,
              "body": "done, please review",
              "createdAt": "2022-10-10T06:41:03Z",
              "updatedAt": "2022-10-10T06:48:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85D-pTf",
          "commit": {
            "abbreviatedOid": "6fa2fcb"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Great! Thanks for working on this! Just a couple of comments. LGTM otherwise!",
          "createdAt": "2022-10-13T10:10:44Z",
          "updatedAt": "2022-10-13T10:41:27Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "```suggestion\r\n    let seed = seed.unwrap_or(default_seed);\r\n```\r\nThis is just regarding the TODO ;P In the spec there is the option of supplying an issuer specific seed and not the default one. There is some discussion around this and it may change in the future, but currently this is here to allow for this (note that the `signer_specific_generators` will pass the Issuer's pk as the seed).",
              "createdAt": "2022-10-13T10:10:44Z",
              "updatedAt": "2022-10-13T10:41:27Z"
            },
            {
              "originalPosition": 33,
              "body": "```suggestion\r\n        let candidate = G1Projective::hash::<<X as BbsCiphersuite>::Expander>(&v, &X::generator_dst());\r\n```\r\nThis is essentially the hash_to_cuurve_g1 call in the procedure. Hash to curve should use whatever expand_message operation the ciphersuite defines (its actually the other way around. The ciphersuite defines a hash-to-curve suite which in turn defines the expand_message used, but you get the point \ud83d\ude04).",
              "createdAt": "2022-10-13T10:20:52Z",
              "updatedAt": "2022-10-13T10:41:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85EECzX",
          "commit": {
            "abbreviatedOid": "6fa2fcb"
          },
          "author": "jovfer",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-14T06:58:03Z",
          "updatedAt": "2022-10-14T06:58:04Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "oops, fixed one hard-coded thing (DST) but missed the main one \ud83d\ude04",
              "createdAt": "2022-10-14T06:58:03Z",
              "updatedAt": "2022-10-14T06:58:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85ENyvJ",
          "commit": {
            "abbreviatedOid": "d3b3850"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM! Thanks!",
          "createdAt": "2022-10-17T16:21:43Z",
          "updatedAt": "2022-10-17T16:21:43Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85EOdVY",
          "commit": {
            "abbreviatedOid": "d3b3850"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-17T18:38:53Z",
          "updatedAt": "2022-10-17T18:38:53Z",
          "comments": []
        }
      ]
    },
    {
      "number": 221,
      "id": "PR_kwDOF8lax85AcLi4",
      "title": "Fixtures and tooling update",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/221",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR:\r\n- Updates existing fixtures and adds SHA256 suite ones. Proof fixture files are included but not added to the spec to avoid further conflicts with #210.\r\n- Updates the fixtures tooling to read and write the fixtures on the document.\r\n- Closes #217. Updates the message-generators tooling to return the correct file format.\r\n\r\n## Notes \r\n\r\n1. This PR depends on #216 (in all the fixtures i am not prepending the length of the ciphersuite's ID encoding when hashing).\r\n2. The message-generators tooling is \"deactivated\" on the workflow since it is not up to date with the spec. The generator files are not the ones returned by that tool and should be the correct ones.",
      "createdAt": "2022-10-08T23:12:23Z",
      "updatedAt": "2022-10-24T02:08:17Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "7e587fa1f7489f470b6d6d2fd3413a961fba8ef9",
      "headRepository": "BasileiosKal/bbs-signature",
      "headRefName": "fixtures-update",
      "headRefOid": "ea75530ca9b234fded70cd79ad58bcaa871aa64c",
      "closedAt": "2022-10-23T20:01:23Z",
      "mergedAt": "2022-10-23T20:01:23Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "091930a1e4b288c79a71f07e8d3ea198a8af2539"
      },
      "comments": [
        {
          "author": "tmarkovski",
          "authorAssociation": "MEMBER",
          "body": "Would it be possible to include fixtures for some of the other utility operations, specifically `scalars = hash_to_scalar(msg_octets, count)`. This operation is harder to validate as it's always a dependent part inside existing operations. A simple fixture for hashing an octet string into 1 and 2 scalars would go a long way.",
          "createdAt": "2022-10-12T11:42:03Z",
          "updatedAt": "2022-10-12T11:42:03Z"
        },
        {
          "author": "tmarkovski",
          "authorAssociation": "MEMBER",
          "body": "Some of the DST or SEED values contain `RO_` in them, while some use `R0_`, letter `O` vs number `0`. Is this intentional?",
          "createdAt": "2022-10-13T00:36:48Z",
          "updatedAt": "2022-10-13T00:36:48Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "R.e., the `R0_` in the DST's it's a typo. Thanks for identifying it, would never had picked it up \ud83d\ude05 The correct form is `RO_` (not with the zero). The fixtures use the correct DST (with `RO_`)\r\n\r\nR.e., the `make_generators` procedure, the current one is not up to date with the latest spec. PR #220 updates it. This PR has \"deactivated\" that tooling for the workflow, i.e., the generators fixtures are not yet created from that tool. Will reactivate it after #220 is merged.",
          "createdAt": "2022-10-13T09:55:39Z",
          "updatedAt": "2022-10-13T09:55:39Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Added `hash-to-scalar` and `MapMessageToScalarAsHash` test vectors. @tmarkovski hope those will be useful! ",
          "createdAt": "2022-10-17T16:17:16Z",
          "updatedAt": "2022-10-17T16:17:16Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@tmarkovski, @christianpaquin I just pushed some new test vectors, after fixing a typo i made in one of the dst's. Sorry about that. It should be consistent now. Please use the updated ones in your testings!",
          "createdAt": "2022-10-18T15:05:44Z",
          "updatedAt": "2022-10-18T15:05:44Z"
        },
        {
          "author": "tmarkovski",
          "authorAssociation": "MEMBER",
          "body": "Happy to report that all test vectors are passing at present! Thanks for updating the test vectors and looking into the my issue.\r\n\r\n<details>\r\n  <summary>Test Results</summary>\r\n\r\n```\r\n\r\nrunning 62 tests\r\ntest encoding::test::to_octet_string_test ... ok\r\ntest hashing::test::test_encode ... ok\r\ntest encoding::test::encode_for_hash_test_vector ... ok\r\ntest hashing::test::hash_to_curve_1_scalar_output_sha ... ok\r\ntest hashing::test::hash_to_curve_1_scalar_output_shake ... ok\r\ntest hashing::test::hash_to_curve_10_scalar_output_shake ... ok\r\ntest hashing::test::map_message_to_scalar_test ... ok\r\ntest key::test::get_random_key ... ok\r\ntest key::test::gen_key_from_ikm ... ok\r\ntest key::test::sk_to_pk_test ... ok\r\ntest proof::test::proof_suite_1::case_bls12_381_sha_256_proof_proof007_json ... ok\r\ntest generators::test::generators_test::case_bls12_381_sha_256_generators_json_bls12381sha256 ... ok\r\ntest generators::test::generators_test::case_bls12_381_shake_256_generators_json_bls12381shake256 ... ok\r\ntest proof::test::proof_suite_1::case_bls12_381_sha_256_proof_proof008_json ... ok\r\ntest proof::test::proof_suite_1::case_bls12_381_sha_256_proof_proof009_json ... ok\r\ntest proof::test::proof_suite_1::case_bls12_381_sha_256_proof_proof012_json ... ok\r\ntest proof::test::proof_suite_1::case_bls12_381_sha_256_proof_proof001_json ... ok\r\ntest proof::test::proof_suite_1::case_bls12_381_sha_256_proof_proof006_json ... ok\r\ntest proof::test::proof_suite_2::case_bls12_381_shake_256_proof_proof001_json ... ok\r\ntest proof::test::proof_suite_1::case_bls12_381_sha_256_proof_proof004_json ... ok\r\ntest proof::test::proof_suite_1::case_bls12_381_sha_256_proof_proof005_json ... ok\r\ntest proof::test::proof_suite_1::case_bls12_381_sha_256_proof_proof002_json ... ok\r\ntest proof::test::proof_suite_1::case_bls12_381_sha_256_proof_proof011_json ... ok\r\ntest proof::test::proof_suite_1::case_bls12_381_sha_256_proof_proof013_json ... ok\r\ntest proof::test::proof_suite_1::case_bls12_381_sha_256_proof_proof010_json ... ok\r\ntest proof::test::proof_suite_1::case_bls12_381_sha_256_proof_proof003_json ... ok\r\ntest proof::test::proof_suite_2::case_bls12_381_shake_256_proof_proof007_json ... ok\r\ntest proof::test::proof_suite_2::case_bls12_381_shake_256_proof_proof008_json ... ok\r\ntest proof::test::proof_suite_2::case_bls12_381_shake_256_proof_proof009_json ... ok\r\ntest proof::test::proof_suite_2::case_bls12_381_shake_256_proof_proof012_json ... ok\r\ntest signature::test::signature_from_octets_fails_incorrect_size ... ok\r\ntest signature::test::signature_from_octets_succeeds ... ok\r\ntest proof::test::test_proof_from_bytes ... ok\r\ntest signature::test::signature_from_octets_succeeds_slice ... ok\r\ntest proof::test::proof_suite_2::case_bls12_381_shake_256_proof_proof006_json ... ok\r\ntest proof::test::proof_suite_2::case_bls12_381_shake_256_proof_proof004_json ... ok\r\ntest proof::test::proof_suite_2::case_bls12_381_shake_256_proof_proof003_json ... ok\r\ntest proof::test::proof_suite_2::case_bls12_381_shake_256_proof_proof002_json ... ok\r\ntest proof::test::proof_suite_2::case_bls12_381_shake_256_proof_proof005_json ... ok\r\ntest signature::test::signature_suite_1::case_bls12_381_sha_256_signature_signature001_json ... ok\r\ntest signature::test::signature_suite_1::case_bls12_381_sha_256_signature_signature002_json ... ok\r\ntest proof::test::proof_suite_2::case_bls12_381_shake_256_proof_proof010_json ... ok\r\ntest proof::test::proof_suite_2::case_bls12_381_shake_256_proof_proof013_json ... ok\r\ntest proof::test::proof_suite_2::case_bls12_381_shake_256_proof_proof011_json ... ok\r\ntest signature::test::signature_suite_1::case_bls12_381_sha_256_signature_signature003_json ... ok\r\ntest signature::test::signature_suite_1::case_bls12_381_sha_256_signature_signature005_json ... ok\r\ntest signature::test::signature_suite_2::case_bls12_381_shake_256_signature_signature001_json ... ok\r\ntest signature::test::signature_suite_2::case_bls12_381_shake_256_signature_signature002_json ... ok\r\ntest signature::test::signature_suite_1::case_bls12_381_sha_256_signature_signature004_json ... ok\r\ntest signature::test::signature_suite_1::case_bls12_381_sha_256_signature_signature006_json ... ok\r\ntest signature::test::signature_suite_1::case_bls12_381_sha_256_signature_signature007_json ... ok\r\ntest signature::test::signature_to_octets_succeeds ... ok\r\ntest signature::test::signature_suite_2::case_bls12_381_shake_256_signature_signature003_json ... ok\r\ntest signature::test::signature_suite_1::case_bls12_381_sha_256_signature_signature008_json ... ok\r\ntest signature::test::signature_suite_1::case_bls12_381_sha_256_signature_signature009_json ... ok\r\ntest signature::test::signature_suite_2::case_bls12_381_shake_256_signature_signature005_json ... ok\r\ntest signature::test::signature_suite_2::case_bls12_381_shake_256_signature_signature004_json ... ok\r\ntest signature::test::signature_suite_2::case_bls12_381_shake_256_signature_signature006_json ... ok\r\ntest signature::test::signature_suite_2::case_bls12_381_shake_256_signature_signature008_json ... ok\r\ntest signature::test::signature_suite_2::case_bls12_381_shake_256_signature_signature007_json ... ok\r\ntest signature::test::signature_suite_2::case_bls12_381_shake_256_signature_signature009_json ... ok\r\ntest test::bbs_demo ... ok\r\n\r\ntest result: ok. 62 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.92s\r\n\r\n\r\nrunning 5 tests\r\ntest src/lib.rs - Bbs::message (line 56) ... ok\r\ntest src/lib.rs - Bbs::message_with (line 89) ... ok\r\ntest src/lib.rs - Bbs::message (line 65) ... ok\r\ntest src/lib.rs - Bbs::sign (line 115) ... ok\r\ntest src/lib.rs - Bbs::verify (line 143) ... ok\r\n\r\ntest result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.46s\r\n\r\n```\r\n\r\n</details>\r\n\r\nMy thoughts and findings:\r\n- Most negative tests are hard to validate for the reason they specify. Once my positive tests worked, I only assumed the negative tests are working as well, since they were all failing before.\r\n- Tests without header and presentation header might be useful as well\r\n- I stumbled on the use of hex and treating messages as encoded scalars, but this has already been addressed I think. Might be useful to add variable length message inputs.\r\n- Why does the `Sign` algorithm accept SK and PK as input, but doesn't validate if the PK is correct. `SkToPk` is fairly inexpensive operation, it seems that only SK is needed. Is there a security concern similar to what affected ECDSA?\r\n",
          "createdAt": "2022-10-19T00:19:12Z",
          "updatedAt": "2022-10-19T00:33:35Z"
        },
        {
          "author": "jovfer",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@tmarkovski are the implementation and tests (referred in your message above) public? If so, could you please share a link?",
          "createdAt": "2022-10-20T06:45:26Z",
          "updatedAt": "2022-10-20T06:45:45Z"
        },
        {
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It would be good to add a signing test over 0 messages, and a proof test disclosing no messages, to provide test cases for edge conditions (to validate the handling of empty argument arrays). ",
          "createdAt": "2022-10-21T16:30:16Z",
          "updatedAt": "2022-10-21T16:30:16Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "> @tmarkovski are the implementation and tests (referred in your message above) public? If so, could you please share a link?\r\n\r\nI believe it is this @jovfer? https://github.com/trinsic-id/bbs/tree/main",
          "createdAt": "2022-10-21T21:47:39Z",
          "updatedAt": "2022-10-21T21:47:39Z"
        },
        {
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "FYI @BasileiosKal, my [implementation](https://github.com/microsoft/bbs-node-reference) now validates these test vectors; simply sync with main and `npm test`. ",
          "createdAt": "2022-10-23T03:52:41Z",
          "updatedAt": "2022-10-23T03:52:41Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "I've attempted to capture all the comments from this PR in #225 and #7. Because we have three implementations verifying these fixtures I'd like to merge at this point and publish a new draft revision ahead of the IETF meeting.",
          "createdAt": "2022-10-23T20:00:11Z",
          "updatedAt": "2022-10-23T20:00:11Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Multiple approvals, reviewed on last WG call, residual gaps captured in issues, merging",
          "createdAt": "2022-10-23T20:00:53Z",
          "updatedAt": "2022-10-23T20:00:53Z"
        },
        {
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Great. I updated my lib to fetch fixtures from the main branch.",
          "createdAt": "2022-10-24T02:08:17Z",
          "updatedAt": "2022-10-24T02:08:17Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax85D5jv0",
          "commit": {
            "abbreviatedOid": "8248ff5"
          },
          "author": "tmarkovski",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-12T14:04:14Z",
          "updatedAt": "2022-10-12T14:04:15Z",
          "comments": [
            {
              "originalPosition": 2,
              "body": "Is this item a scalar value? If so, is it in big endian? I can only deserialize it to a scalar if I treat it as little endian.",
              "createdAt": "2022-10-12T14:04:15Z",
              "updatedAt": "2022-10-12T14:04:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85D53al",
          "commit": {
            "abbreviatedOid": "8248ff5"
          },
          "author": "tmarkovski",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-12T14:49:27Z",
          "updatedAt": "2022-10-12T14:49:27Z",
          "comments": [
            {
              "originalPosition": 2,
              "body": "Are these messages treated as scalars that can be direct inputs in the `sign` operation or they need to be mapped using `MapMessageToScalarAsHash`? If they are scalars, I have issues deserializing some of these as scalar values. I may be doing something wrong, but would love some clarification how we use these values.",
              "createdAt": "2022-10-12T14:49:27Z",
              "updatedAt": "2022-10-12T15:05:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85D6dj4",
          "commit": {
            "abbreviatedOid": "8248ff5"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-12T16:25:22Z",
          "updatedAt": "2022-10-12T16:25:23Z",
          "comments": [
            {
              "originalPosition": 2,
              "body": "They need to be mapped using `MapMessageToScalarAsHash` prior to passing them in Sign etc. Thanks for pointing out this oversight! Will add the scalar values as well as some `hash_to_sclar` fixtures soon.",
              "createdAt": "2022-10-12T16:25:22Z",
              "updatedAt": "2022-10-12T16:25:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85D62VD",
          "commit": {
            "abbreviatedOid": "8248ff5"
          },
          "author": "tmarkovski",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-12T17:47:57Z",
          "updatedAt": "2022-10-12T17:47:58Z",
          "comments": [
            {
              "originalPosition": 2,
              "body": "Much appreciated",
              "createdAt": "2022-10-12T17:47:57Z",
              "updatedAt": "2022-10-12T17:47:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85D8Mmc",
          "commit": {
            "abbreviatedOid": "8248ff5"
          },
          "author": "tmarkovski",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "Calls in `main.rs` in `make_generators` to `G1Projective::hash::<ExpandMsgXof<Shake256>>` should be replaced with `G1Projective::hash::<X::Expander>`. Sorry, I can't make a suggestion, as it's not part of the diff changes.",
          "createdAt": "2022-10-13T00:01:27Z",
          "updatedAt": "2022-10-13T00:01:27Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85EPDhV",
          "commit": {
            "abbreviatedOid": "af809d4"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-17T20:52:54Z",
          "updatedAt": "2022-10-17T20:52:54Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85EPi7j",
          "commit": {
            "abbreviatedOid": "af809d4"
          },
          "author": "tmarkovski",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-17T23:46:52Z",
          "updatedAt": "2022-10-17T23:46:52Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85EQtnm",
          "commit": {
            "abbreviatedOid": "af809d4"
          },
          "author": "jovfer",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-18T07:26:13Z",
          "updatedAt": "2022-10-18T07:26:14Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Do we need more updates in the tool?",
              "createdAt": "2022-10-18T07:26:14Z",
              "updatedAt": "2022-10-18T07:26:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85ETsck",
          "commit": {
            "abbreviatedOid": "af809d4"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-18T15:02:07Z",
          "updatedAt": "2022-10-18T15:02:07Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "No no the tool is fine! I just opened this PR before you updating the tool. Will remove after.",
              "createdAt": "2022-10-18T15:02:07Z",
              "updatedAt": "2022-10-18T15:02:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85EWMOv",
          "commit": {
            "abbreviatedOid": "a32d617"
          },
          "author": "tmarkovski",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-19T00:26:04Z",
          "updatedAt": "2022-10-19T00:26:04Z",
          "comments": [
            {
              "originalPosition": 89,
              "body": "```suggestion\r\n    let extra = 1u32.to_be_bytes().to_vec();\r\n```\r\n\r\nThis will fail on 32-bit systems because `usize` is variable length. Using any other fixed length integer is a better approach, though I doubt anyone will ever run into this issue \ud83d\ude00",
              "createdAt": "2022-10-19T00:26:04Z",
              "updatedAt": "2022-10-19T00:31:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85EX1gI",
          "commit": {
            "abbreviatedOid": "a32d617"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-19T08:34:30Z",
          "updatedAt": "2022-10-19T08:34:31Z",
          "comments": [
            {
              "originalPosition": 89,
              "body": "Good point! Fixed",
              "createdAt": "2022-10-19T08:34:30Z",
              "updatedAt": "2022-10-19T08:34:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85EontE",
          "commit": {
            "abbreviatedOid": "ea75530"
          },
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-21T20:11:52Z",
          "updatedAt": "2022-10-21T20:11:53Z",
          "comments": [
            {
              "originalPosition": 2,
              "body": "How are these messages encoded, @BasileiosKal? Are these scalars (in hex), or octet strings that need to be encoded with MapMessageToScalar? When I try to parse these directly, I get an error because these are bigger than the order `r`. ",
              "createdAt": "2022-10-21T20:11:52Z",
              "updatedAt": "2022-10-21T20:11:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85Eo6XR",
          "commit": {
            "abbreviatedOid": "ea75530"
          },
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-21T21:33:57Z",
          "updatedAt": "2022-10-21T21:33:57Z",
          "comments": [
            {
              "originalPosition": 2,
              "body": "Looking at @tmarkovski's implementation, seems like you indeed need to first map the messages to scalar. This is a bit confusing because the spec's Sign and Verify function's `messages` param, matching the name in the fixture files, is of type scalar.",
              "createdAt": "2022-10-21T21:33:57Z",
              "updatedAt": "2022-10-21T21:33:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85Eo8Mh",
          "commit": {
            "abbreviatedOid": "ea75530"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-21T21:45:44Z",
          "updatedAt": "2022-10-21T21:45:44Z",
          "comments": [
            {
              "originalPosition": 2,
              "body": "@christianpaquin agreed I think clarifying text here about the form of messages in these test vectors is important. Also think the additional test case you suggest is a good one, there are few possible ones we could add.",
              "createdAt": "2022-10-21T21:45:44Z",
              "updatedAt": "2022-10-21T21:45:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85EpcsI",
          "commit": {
            "abbreviatedOid": "ea75530"
          },
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-22T01:26:47Z",
          "updatedAt": "2022-10-22T01:26:47Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "All the revealed messages are numbered using a 0-based counter in the tests. My implementation uses a 1-based one, matching the sub-indices in the spec. This makes my code fails when validating the proofs due to a different `cv_for_hash` value (disclosed indices are hashed in). We should call out the expected behavior explicitly. My personal vote: use a one-based counter.  ",
              "createdAt": "2022-10-22T01:26:47Z",
              "updatedAt": "2022-10-22T03:58:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85Er6ce",
          "commit": {
            "abbreviatedOid": "ea75530"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-23T19:55:22Z",
          "updatedAt": "2022-10-23T19:55:22Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Good point have captured notes of this in #225 and #7 ",
              "createdAt": "2022-10-23T19:55:22Z",
              "updatedAt": "2022-10-23T19:55:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85Er6nB",
          "commit": {
            "abbreviatedOid": "ea75530"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-23T19:55:39Z",
          "updatedAt": "2022-10-23T19:55:39Z",
          "comments": [
            {
              "originalPosition": 2,
              "body": "Have captured a note to follow up on this in #7 ",
              "createdAt": "2022-10-23T19:55:39Z",
              "updatedAt": "2022-10-23T19:55:39Z"
            }
          ]
        }
      ]
    },
    {
      "number": 222,
      "id": "PR_kwDOF8lax85A2GrU",
      "title": "Replace 0 (zero) with O in suite id",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/222",
      "state": "MERGED",
      "author": "tmarkovski",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "I'm assuming the 0 was not intended to be there. Can easily cause headaches when copy/pasting from the spec page",
      "createdAt": "2022-10-14T21:35:25Z",
      "updatedAt": "2022-10-18T13:03:19Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "5fc8cb899fd5de307e74ddf866565da920367b91",
      "headRepository": "tmarkovski/bbs-signature",
      "headRefName": "typos",
      "headRefOid": "66ec884dbfd03fc8fa2fb5cf0253f61421cdb75a",
      "closedAt": "2022-10-17T18:25:40Z",
      "mergedAt": "2022-10-17T18:25:39Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "acaaf7ab1dc42c6c90241439bc822fa406f6cfa5"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed on WG call 17th of October, multiple approvals, merging",
          "createdAt": "2022-10-17T18:25:35Z",
          "updatedAt": "2022-10-17T18:25:35Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax85EIdWk",
          "commit": {
            "abbreviatedOid": "66ec884"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-14T22:14:41Z",
          "updatedAt": "2022-10-14T22:14:41Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85ENx9n",
          "commit": {
            "abbreviatedOid": "66ec884"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-17T16:19:24Z",
          "updatedAt": "2022-10-17T16:19:24Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85EOZXp",
          "commit": {
            "abbreviatedOid": "66ec884"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-17T18:24:57Z",
          "updatedAt": "2022-10-17T18:24:57Z",
          "comments": []
        }
      ]
    },
    {
      "number": 226,
      "id": "PR_kwDOF8lax85BRmWt",
      "title": "[224] Update D def to simplify calc.",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/226",
      "state": "CLOSED",
      "author": "jovfer",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fix #224 ",
      "createdAt": "2022-10-21T10:27:55Z",
      "updatedAt": "2022-12-12T22:02:43Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "4f60782d1479ce24a1df93f3e2140407d39eb2cc",
      "headRepository": "jovfer/bbs-signature",
      "headRefName": "sm/feat_d_def_update",
      "headRefOid": "ea16b995c346adb71b6f53219c93710f00af8c68",
      "closedAt": "2022-12-12T22:02:43Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Thanks @jovfer, considering that this is a breaking change to the proof representation and it only provides a minor improvement around proof computation we will keep this PR open until we consider other breaking changes that it could be adopted with.",
          "createdAt": "2022-11-21T19:15:33Z",
          "updatedAt": "2022-11-21T19:15:33Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed on the 12th of December WG call, given the improvement in readability for this proposal is minor and the performance difference is likely to be negligible we are not going to proceed with this change for now, closing the PR on that basis, please re-open if you have any further questions.",
          "createdAt": "2022-12-12T22:02:43Z",
          "updatedAt": "2022-12-12T22:02:43Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 228,
      "id": "PR_kwDOF8lax85D7YTl",
      "title": "Messages number upper limit solution",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/228",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closing Issue #212\r\n\r\nImplementation + benches of the 3 proposals: [https://github.com/BasileiosKal/bbs-issue-212](https://github.com/BasileiosKal/bbs-issue-212)\r\n\r\nA benchmark report is attached. See also comment [here](https://github.com/decentralized-identity/bbs-signature/issues/212#issuecomment-1328329157) for some of the bench results.\r\n\r\nThis PR proposes option A from the issue (Pros: faster, simpler. Cons: Multiple PRF calls) + adds a consideration to address the cons.\r\n\r\n[benchmarks.zip](https://github.com/decentralized-identity/bbs-signature/files/10117955/benchmarks.zip)\r\n",
      "createdAt": "2022-11-29T23:06:32Z",
      "updatedAt": "2022-12-12T19:14:01Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "46bad6e64b9730eea2e1db55c22c74f3dbab6f28",
      "headRepository": "BasileiosKal/bbs-signature",
      "headRefName": "messages_number_issue",
      "headRefOid": "197e6a73423092c35e6a22e805642f3b83ed6075",
      "closedAt": "2022-12-12T19:14:00Z",
      "mergedAt": "2022-12-12T19:14:00Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "df9e8fb5d26f4830dbaf2aed111e6c684cbb965b"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed on WG call 12th of December, multiple approvals, merging.",
          "createdAt": "2022-12-12T19:13:53Z",
          "updatedAt": "2022-12-12T19:13:53Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax85HdqYp",
          "commit": {
            "abbreviatedOid": "d05bac6"
          },
          "author": "jovfer",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-11-30T09:20:31Z",
          "updatedAt": "2022-11-30T09:20:32Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "just a minor feedback from non-expert reader of the doc :)\r\nThe name confuses me while I was reading the diff changes first time. It may look like a breaking change as in some other places `expand_len` parameter affects final hash or expand output results which is suppose to be deterministic. It's not a case here as it is used as input for PRF, so this is backward-compatible change, but the name may be confusing a bit.",
              "createdAt": "2022-11-30T09:20:32Z",
              "updatedAt": "2022-11-30T09:21:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85Hhyxl",
          "commit": {
            "abbreviatedOid": "d05bac6"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-11-30T21:32:27Z",
          "updatedAt": "2022-11-30T21:32:27Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Thanks for the feedback :D I did spend some time on that. The reason i decided to keep the `expand_len` term is because, as you noticed `hash_to_scalar` also uses it (with the name making much more sense there), and it seemed weird to have 2 different names for the same value.\r\n\r\nI agree that this can be confusing though. However i don't think calling it `prf_out_len` is a better approach. Maybe `expand_scalar_len` or similar?? (open to suggestions, I'm really bad with names my self ;P)!",
              "createdAt": "2022-11-30T21:32:27Z",
              "updatedAt": "2022-11-30T21:32:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85H1qXf",
          "commit": {
            "abbreviatedOid": "d05bac6"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-12-05T20:41:47Z",
          "updatedAt": "2022-12-05T20:41:47Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "```suggestion\r\nThe operation calculates multiple random scalars using a PRF (see [Parameters](#parameters)). The required length of the PRF output is defined as `expand_len`. Each value returned by the PRF is reduced modulo the group order `r`. To avoid biased results when creating the random scalars, the output of the PRF MUST be at least `(ceil(log2(r))+k` bytes long, where `k` is the targeted security level, specified by the ciphersuite (see Section 5 in [@!I-D.irtf-cfrg-hash-to-curve] for more details). ProofGen defines `expand_len = ceil((ceil(log2(r))+k)/8)`. For both the [BLS12-381-SHAKE-256](#bls12-381-shake-256) and [BLS12-381-SHA-256](#bls12-381-sha-256) ciphersuites, `log2(r) = 255`, `k = 128` and `expand_len = 48`. See [Section 5.10](#randomness-requirements) for further security considerations and requirements around the generated randomness.\r\n```",
              "createdAt": "2022-12-05T20:41:47Z",
              "updatedAt": "2022-12-05T20:41:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85H1uIb",
          "commit": {
            "abbreviatedOid": "d05bac6"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2022-12-05T20:54:59Z",
          "updatedAt": "2022-12-05T20:54:59Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85H10nI",
          "commit": {
            "abbreviatedOid": "d05bac6"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-12-05T21:15:33Z",
          "updatedAt": "2022-12-05T21:15:33Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Thanks! Done!",
              "createdAt": "2022-12-05T21:15:33Z",
              "updatedAt": "2022-12-05T21:15:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85H2sjX",
          "commit": {
            "abbreviatedOid": "197e6a7"
          },
          "author": "tmarkovski",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-12-06T00:16:19Z",
          "updatedAt": "2022-12-06T00:16:19Z",
          "comments": []
        }
      ]
    },
    {
      "number": 230,
      "id": "PR_kwDOF8lax85FOZpJ",
      "title": "Encode for hash update",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/230",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #225\r\n\r\n1. Updated `encode_for_hash` per @andrewwhitehead's proposal from [here](https://github.com/decentralized-identity/bbs-signature/issues/225#issuecomment-1328315289) (including renaming the operation to serialize and definING `SignatureToOctets` and `ProofToOctets` based on `serialize`).\r\n2. Added 2 new operations, `get_domain` and `get_challenge`. Their purpose is to simplify the core operations, since with the revision on encode_for_hash they would have become more complex (note [proofGen](https://identity.foundation/bbs-signature/draft-irtf-cfrg-bbs-signatures.html#name-proofgen) will be 32 steps instead of 24 without those 2 operations).\r\n\r\n**NOTE**: I would like to introduce a breaking change and put the PK at the end of the serialized array in `get_domain` (step 7), to be consistent with the \u201coctet strings go at the end rule\u201d. Not worth it now, but maybe will bundle it together with some other breaking changes at some point.\r\n\r\nNot sure if the result is simpler overall but is more rigorous and much better defined IMO.\r\n",
      "createdAt": "2022-12-12T18:22:39Z",
      "updatedAt": "2023-01-10T06:58:52Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "df9e8fb5d26f4830dbaf2aed111e6c684cbb965b",
      "headRepository": "BasileiosKal/bbs-signature",
      "headRefName": "encode-for-hash-revision",
      "headRefOid": "0b5b9c259cc3e76ef72e8acfc95ea5c23ee5a4a2",
      "closedAt": "2023-01-10T06:58:51Z",
      "mergedAt": "2023-01-10T06:58:51Z",
      "mergedBy": "BasileiosKal",
      "mergeCommit": {
        "oid": "250bc32c523c2a2675ceae69e1d6395a9ac18165"
      },
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on the WG call 9th of January. Multiple approvals. Merging. Thank you everyone!",
          "createdAt": "2023-01-10T06:58:42Z",
          "updatedAt": "2023-01-10T06:58:42Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax85IX2Vd",
          "commit": {
            "abbreviatedOid": "a47e0ff"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-12-12T19:29:14Z",
          "updatedAt": "2022-12-12T19:29:15Z",
          "comments": [
            {
              "originalPosition": 464,
              "body": "Shouldn't we include the number of messages prior to the message points? I suppose that is a breaking change at this point. This is just to know that the proof hasn't been accidentally truncated.\r\n\r\n`(A', Abar, D, c, e^, r2^, r3^, s^, *U*, (m^_1, ..., m^_U))`",
              "createdAt": "2022-12-12T19:29:14Z",
              "updatedAt": "2022-12-13T18:22:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85IffOV",
          "commit": {
            "abbreviatedOid": "7862182"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-12-13T18:26:20Z",
          "updatedAt": "2022-12-13T18:26:21Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "```\r\n- ASCII strings will be transformed into octet strings using UTF-8 encoding.\r\n```\r\n\r\nThis reads a little strangely as there is no transformation involved, ASCII strings are UTF-8 strings (are octet strings).",
              "createdAt": "2022-12-13T18:26:20Z",
              "updatedAt": "2022-12-13T18:30:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85IfkLb",
          "commit": {
            "abbreviatedOid": "7862182"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-12-13T18:38:24Z",
          "updatedAt": "2022-12-13T18:38:25Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "```suggestion\r\nVariable-length octet strings will be prepended with an integer value representing the number of bytes in the string. This length is encoded to octets using `I2OSP` with an output length of 8 bytes. For example, the octet string `0x14d` is encoded as `0x0000000000000002014d`. If the length of the octet string exceeds `2^64 - 1`, the octet string must be rejected. ASCII strings are also encoded using this process by first converting to an octet string.\r\n```",
              "createdAt": "2022-12-13T18:38:24Z",
              "updatedAt": "2022-12-13T18:38:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85IflW_",
          "commit": {
            "abbreviatedOid": "7862182"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-12-13T18:40:30Z",
          "updatedAt": "2022-12-13T18:40:30Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "```suggestion\r\nConstant-length octet strings, including domain separation tags and the ciphersuite ID, will be encoded directly without prefixing with the length.\r\n```",
              "createdAt": "2022-12-13T18:40:30Z",
              "updatedAt": "2022-12-13T18:40:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85IfmQu",
          "commit": {
            "abbreviatedOid": "7862182"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-12-13T18:42:08Z",
          "updatedAt": "2022-12-13T18:42:09Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "I think we should just be explicit about what the defaults are for each variable at the point of use",
              "createdAt": "2022-12-13T18:42:08Z",
              "updatedAt": "2022-12-13T18:42:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85IfoNW",
          "commit": {
            "abbreviatedOid": "7862182"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-12-13T18:48:27Z",
          "updatedAt": "2022-12-13T18:48:28Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "```suggestion\r\nWhen serializing one or more values to produce an octet string, each element will be encoded using a specific operation determined by its type. More concretely,\r\n```",
              "createdAt": "2022-12-13T18:48:27Z",
              "updatedAt": "2022-12-13T18:48:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85IfpDC",
          "commit": {
            "abbreviatedOid": "7862182"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-12-13T18:51:11Z",
          "updatedAt": "2022-12-13T18:51:11Z",
          "comments": [
            {
              "originalPosition": 272,
              "body": "Calls to this method have PK as the first argument.",
              "createdAt": "2022-12-13T18:51:11Z",
              "updatedAt": "2022-12-13T18:51:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85IfpW2",
          "commit": {
            "abbreviatedOid": "7862182"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-12-13T18:52:11Z",
          "updatedAt": "2022-12-13T18:52:11Z",
          "comments": [
            {
              "originalPosition": 272,
              "body": "Maybe `encode_domain` (and `encode_challenge`) would be more descriptive?",
              "createdAt": "2022-12-13T18:52:11Z",
              "updatedAt": "2022-12-13T18:52:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85Ifphv",
          "commit": {
            "abbreviatedOid": "7862182"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-12-13T18:52:45Z",
          "updatedAt": "2022-12-13T18:52:45Z",
          "comments": [
            {
              "originalPosition": 272,
              "body": "Or `derive_`, `calculate_`, `hash_`, etc...",
              "createdAt": "2022-12-13T18:52:45Z",
              "updatedAt": "2022-12-13T18:52:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85IfyF4",
          "commit": {
            "abbreviatedOid": "7862182"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-12-13T19:21:02Z",
          "updatedAt": "2022-12-13T19:21:02Z",
          "comments": [
            {
              "originalPosition": 267,
              "body": "```suggestion\r\nThis operation calculates the domain value, a scalar representing the distillation of all essential contextual information for a signature. The same domain value must be calculated by all parties (the signer, the prover, and the verifier) for both the signature and proofs to be validated.\r\n\r\nThe input to the domain value includes an octet string called the header, chosen by the signer and meant to encode any information that is required to be revealed by the prover (such as an expiration date, or an identifier for the target audience). This is in contrast to the signed message values, which may be withheld during a proof.\r\n\r\nWhen a signature is calculated, the domain value is combined with a specific generator point (`Q_2`, see [Sign](#sign)) to protect the integrity of the public parameters and the header.\r\n```\r\n",
              "createdAt": "2022-12-13T19:21:02Z",
              "updatedAt": "2022-12-13T19:21:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85Ifzge",
          "commit": {
            "abbreviatedOid": "7862182"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-12-13T19:25:50Z",
          "updatedAt": "2022-12-13T19:25:51Z",
          "comments": [
            {
              "originalPosition": 304,
              "body": "```suggestion\r\n**Note**: If the header is not supplied in `get_domain`, it defaults to the empty octet string (\"\").\r\n```\r\n\r\nI think it's clear in the algorithm that the length is always included",
              "createdAt": "2022-12-13T19:25:50Z",
              "updatedAt": "2022-12-13T19:25:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85If0Hw",
          "commit": {
            "abbreviatedOid": "7862182"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-12-13T19:28:01Z",
          "updatedAt": "2022-12-13T19:28:02Z",
          "comments": [
            {
              "originalPosition": 297,
              "body": "Shouldn't `ciphersuite_id` be appended later and not passed to `serialize`?",
              "createdAt": "2022-12-13T19:28:01Z",
              "updatedAt": "2022-12-13T19:28:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85If0hV",
          "commit": {
            "abbreviatedOid": "7862182"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-12-13T19:29:27Z",
          "updatedAt": "2022-12-13T19:29:27Z",
          "comments": [
            {
              "originalPosition": 323,
              "body": "```suggestion\r\n- domain (REQUIRED), a scalar.\r\n```",
              "createdAt": "2022-12-13T19:29:27Z",
              "updatedAt": "2022-12-13T19:29:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85If1Gn",
          "commit": {
            "abbreviatedOid": "7862182"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-12-13T19:31:25Z",
          "updatedAt": "2022-12-13T19:31:25Z",
          "comments": [
            {
              "originalPosition": 297,
              "body": "Ah, I see there is a rule for ASCII strings.",
              "createdAt": "2022-12-13T19:31:25Z",
              "updatedAt": "2022-12-13T19:31:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85I38oK",
          "commit": {
            "abbreviatedOid": "a47e0ff"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-12-19T10:14:45Z",
          "updatedAt": "2022-12-19T10:14:45Z",
          "comments": [
            {
              "originalPosition": 464,
              "body": "Not a bad idea to add some redundancy in the proof value. Would also make the suggestion in #227 easier to implement.\r\n\r\nThat said, since `ProofVerify` is not a terribly inefficient operation, not sure how much will provide beyond some useful error information? Also, is truncating the proof something that will (somewhat) \"commonly\" happen (i assume not as much in the application layer)??\r\n\r\nIn any case it seems that it would be better addressed in a separate PR, so will open an issue to track the conversation and will resolve this comment if that is ok? Please feel free to un-resolve!",
              "createdAt": "2022-12-19T10:14:45Z",
              "updatedAt": "2022-12-19T10:14:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85I3-2f",
          "commit": {
            "abbreviatedOid": "7862182"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-12-19T10:21:14Z",
          "updatedAt": "2022-12-19T10:21:14Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "I do agree with this. The current rule followed is that ASCII string refers to text and ASCII code refers to bytes (e.g., utf8 is defined like `utf8(ascii_string)` currently).\r\n\r\nWe could make this clearer by updating `ASCII string` -> `Text` or `ASCII text` or `String`??\r\n\r\nSince this affects the whole doc, IMO its better to open a issue for tracking and address it in a separate PR?",
              "createdAt": "2022-12-19T10:21:14Z",
              "updatedAt": "2022-12-19T13:39:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85I4WeU",
          "commit": {
            "abbreviatedOid": "7862182"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-12-19T11:29:22Z",
          "updatedAt": "2022-12-19T11:29:23Z",
          "comments": [
            {
              "originalPosition": 304,
              "body": "That's true, though IMO it would be an easy mistake to make.\r\n\r\nits clear only if you notice the `If not supplied, it must default to the empty octet string (\"\")` part. If someone misses that and only notice the capitalized `(OPTIONAL)` could maybe make this mistake??",
              "createdAt": "2022-12-19T11:29:22Z",
              "updatedAt": "2022-12-19T11:29:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85I4Wfm",
          "commit": {
            "abbreviatedOid": "7862182"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-12-19T11:29:26Z",
          "updatedAt": "2022-12-19T11:29:26Z",
          "comments": [
            {
              "originalPosition": 304,
              "body": "maybe we could update the text to say `If not supplied, it must default to the empty octet string (\"\") **that has 0 length**` ",
              "createdAt": "2022-12-19T11:29:26Z",
              "updatedAt": "2022-12-19T11:29:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85I5Huj",
          "commit": {
            "abbreviatedOid": "7862182"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-12-19T13:55:16Z",
          "updatedAt": "2022-12-19T13:55:16Z",
          "comments": [
            {
              "originalPosition": 272,
              "body": "Done! (used `calculate_`).",
              "createdAt": "2022-12-19T13:55:16Z",
              "updatedAt": "2022-12-19T13:55:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85I5H_Q",
          "commit": {
            "abbreviatedOid": "7862182"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-12-19T13:55:40Z",
          "updatedAt": "2022-12-19T13:55:41Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "Agreed. Removed the paragraph on optional inputs. For constant length octet strings will revisit after #232 is resolved.",
              "createdAt": "2022-12-19T13:55:41Z",
              "updatedAt": "2022-12-19T13:55:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85I5NOh",
          "commit": {
            "abbreviatedOid": "a47e0ff"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-12-19T14:05:55Z",
          "updatedAt": "2022-12-19T14:05:55Z",
          "comments": [
            {
              "originalPosition": 464,
              "body": "opened #233 to track the issue!",
              "createdAt": "2022-12-19T14:05:55Z",
              "updatedAt": "2022-12-19T14:05:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85I5W1c",
          "commit": {
            "abbreviatedOid": "7862182"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-12-19T14:26:27Z",
          "updatedAt": "2022-12-19T14:26:27Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "Opened #234 to track this issue!",
              "createdAt": "2022-12-19T14:26:27Z",
              "updatedAt": "2022-12-19T14:26:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85I5Xho",
          "commit": {
            "abbreviatedOid": "7862182"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-12-19T14:28:11Z",
          "updatedAt": "2022-12-19T14:28:11Z",
          "comments": [
            {
              "originalPosition": 297,
              "body": "Yea. I was trying to follow the \"encode everything that are not already octet strings\" rule. I agree that this may not be optimal though. Opened #234 to discuss further.",
              "createdAt": "2022-12-19T14:28:11Z",
              "updatedAt": "2022-12-19T14:28:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85I7R0b",
          "commit": {
            "abbreviatedOid": "79eb6b4"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-12-19T20:33:51Z",
          "updatedAt": "2022-12-19T20:33:52Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "```suggestion\r\n: A non-interactive zero-knowledge proof from the Fiat-Shamir heuristic.\r\n```",
              "createdAt": "2022-12-19T20:33:52Z",
              "updatedAt": "2022-12-19T20:33:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85JNGbJ",
          "commit": {
            "abbreviatedOid": "0b5b9c2"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-12-22T19:33:49Z",
          "updatedAt": "2022-12-22T19:33:49Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85J-SDk",
          "commit": {
            "abbreviatedOid": "0b5b9c2"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-01-09T19:13:21Z",
          "updatedAt": "2023-01-09T19:13:21Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85J-YiS",
          "commit": {
            "abbreviatedOid": "0b5b9c2"
          },
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-01-09T19:34:52Z",
          "updatedAt": "2023-01-09T19:34:52Z",
          "comments": []
        }
      ]
    },
    {
      "number": 236,
      "id": "PR_kwDOF8lax85IJSTB",
      "title": "Use CSPRNGs instead of PRFs",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/236",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #229",
      "createdAt": "2023-01-19T16:45:33Z",
      "updatedAt": "2023-02-02T03:49:05Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "250bc32c523c2a2675ceae69e1d6395a9ac18165",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "vasilis/prf-to-rng",
      "headRefOid": "3b9558eac6b1a2f63e5c43a8aecf959380b74f8c",
      "closedAt": "2023-02-02T03:49:00Z",
      "mergedAt": "2023-02-02T03:49:00Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "447eee98e1409b40bc4f9479254475adf7c1440e"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Multiple reviews and approvals, merging.",
          "createdAt": "2023-02-02T03:48:56Z",
          "updatedAt": "2023-02-02T03:48:56Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax85LeGvw",
          "commit": {
            "abbreviatedOid": "292f6c6"
          },
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-01-23T19:14:17Z",
          "updatedAt": "2023-01-23T19:14:17Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85LeHUs",
          "commit": {
            "abbreviatedOid": "292f6c6"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-23T19:16:11Z",
          "updatedAt": "2023-01-23T19:16:11Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\n* get\\_random(n): returns a random octet string with a length of n bytes, sampled uniformly at random using a cryptographically secure pseudo-random number generator (CSPRNG) or a pseudo random function. See [@!RFC4086] for recommendations and requirements on the generation of random numbers.\r\n```",
              "createdAt": "2023-01-23T19:16:11Z",
              "updatedAt": "2023-01-23T19:16:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85Lh8HP",
          "commit": {
            "abbreviatedOid": "292f6c6"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-24T10:10:48Z",
          "updatedAt": "2023-01-24T10:10:49Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Thanks! Fixed!",
              "createdAt": "2023-01-24T10:10:48Z",
              "updatedAt": "2023-01-24T10:10:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85MJlEZ",
          "commit": {
            "abbreviatedOid": "3b9558e"
          },
          "author": "Wind4Greg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-01-31T16:25:48Z",
          "updatedAt": "2023-01-31T16:25:48Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85MTpPO",
          "commit": {
            "abbreviatedOid": "3b9558e"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-02T03:24:25Z",
          "updatedAt": "2023-02-02T03:24:25Z",
          "comments": []
        }
      ]
    },
    {
      "number": 237,
      "id": "PR_kwDOF8lax85IOnKO",
      "title": "Keygen tool and fixtures update",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/237",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "As noted from @Wind4Greg who i thank a lot, the keyPair fixtures did not validate using the keyGen operation described in the spec. The reason was a mistake i made in the implementation that was used to create those fixtures. \r\n\r\nThis PR:\r\n\r\n- Updates the KeyPair fixture (also adds the `IKM` and `key_info` inputs).\r\n- Updates all the fixtures to use the correct KeyPair.\r\n- Adds a reference tool that can be used to generate and save BBS KeyPairs.\r\n\r\nWill update after #186 is resolved. Thanks again @Wind4Greg! And sorry everyone for the inconvenience of having to update!",
      "createdAt": "2023-01-20T16:28:08Z",
      "updatedAt": "2023-02-02T04:02:28Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "250bc32c523c2a2675ceae69e1d6395a9ac18165",
      "headRepository": "BasileiosKal/bbs-signature",
      "headRefName": "keygen-fixtures",
      "headRefOid": "2c38f011e8d06d0bb9b74f8ae45022d83270f017",
      "closedAt": "2023-02-02T04:02:27Z",
      "mergedAt": "2023-02-02T04:02:27Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "6b7850ab86fad7ff8a04c7e3f166f3e719dc61b1"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Multiple reviews and approvals, merging as it is an important update to fixtures that is aligned to current spec text",
          "createdAt": "2023-02-02T04:02:20Z",
          "updatedAt": "2023-02-02T04:02:20Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax85Lf7CI",
          "commit": {
            "abbreviatedOid": "2c38f01"
          },
          "author": "Wind4Greg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Verified updated test vectors for key generation against draft procedures in JavaScript and Python.",
          "createdAt": "2023-01-24T00:58:34Z",
          "updatedAt": "2023-01-24T00:58:34Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85MT3in",
          "commit": {
            "abbreviatedOid": "2c38f01"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-02T04:00:57Z",
          "updatedAt": "2023-02-02T04:00:57Z",
          "comments": []
        }
      ]
    },
    {
      "number": 238,
      "id": "PR_kwDOF8lax85IPoX8",
      "title": "Removing L from ProofVerify input",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/238",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #227\r\n\r\nTaking a stab at the approach proposed by @rolfhaenni in #227. This PR:\r\n1.\tRemoves L from the inputs of ProofVerify and calculates it as L=R+U\r\n2.\tAdds a `Deserialization` group of steps in the core operations (also used for de-structuring).\r\n\r\nAlso removed the `Precomputation` steps in favor of the `Deserialization` ones (IMO what was a `Precomputation` step was a bit loosely defined).\r\n\r\nSince I removed the text saying that the `Precomputation` steps can be cached, I added some text detailing how the output of `create_generaotrs` can be cached + some requirements (although we may want to extent upon them in the future).\r\n\r\nWe could potentially also remove the`Definitions` from each operation, since those values are explicitly defined in the procedures.\r\n\r\nThanks again @rolfhaenni \ud83d\ude4c \r\n",
      "createdAt": "2023-01-20T20:51:05Z",
      "updatedAt": "2023-02-10T22:07:58Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "04bf8520f0f33afd13880474b4421621bc15978a",
      "headRepository": "BasileiosKal/bbs-signature",
      "headRefName": "api-update",
      "headRefOid": "12c8ab182ed4d36f38f8804e2229d88b0078e5d6",
      "closedAt": "2023-02-10T22:07:58Z",
      "mergedAt": "2023-02-10T22:07:58Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "610df58f5a7e6c52d91ae9a038298e2c17fbabd5"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Multiple approvals, open 3 weeks, discussed on WG calls, merging",
          "createdAt": "2023-02-10T22:07:53Z",
          "updatedAt": "2023-02-10T22:07:53Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax85LdtMs",
          "commit": {
            "abbreviatedOid": "9cc5f05"
          },
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-23T18:00:06Z",
          "updatedAt": "2023-01-23T18:00:07Z",
          "comments": [
            {
              "originalPosition": 224,
              "body": "Typo?",
              "createdAt": "2023-01-23T18:00:06Z",
              "updatedAt": "2023-01-23T18:00:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85MJjFP",
          "commit": {
            "abbreviatedOid": "9cc5f05"
          },
          "author": "Wind4Greg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-01-31T16:21:32Z",
          "updatedAt": "2023-01-31T16:21:32Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85MT6O3",
          "commit": {
            "abbreviatedOid": "9cc5f05"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-02T04:07:52Z",
          "updatedAt": "2023-02-02T04:07:53Z",
          "comments": [
            {
              "originalPosition": 224,
              "body": "```suggestion\r\nPreconditions:\r\n```",
              "createdAt": "2023-02-02T04:07:52Z",
              "updatedAt": "2023-02-02T04:07:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85MaJ1S",
          "commit": {
            "abbreviatedOid": "dfe0c4a"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-02T21:30:47Z",
          "updatedAt": "2023-02-02T21:30:48Z",
          "comments": [
            {
              "originalPosition": 272,
              "body": "```suggestion\r\n**NOTE**: If the generator points are retrieved from cache, the order in which they are retrieved MUST be the same as the order they were originally returned by the `create_generators` operation.\r\n```",
              "createdAt": "2023-02-02T21:30:47Z",
              "updatedAt": "2023-02-02T21:30:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85MaKG6",
          "commit": {
            "abbreviatedOid": "dfe0c4a"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-02T21:31:48Z",
          "updatedAt": "2023-02-02T21:31:49Z",
          "comments": [
            {
              "originalPosition": 276,
              "body": "```suggestion\r\nThe values `n` and `v` MAY also be cached in order to efficiently extend an existing list of cached generator points.\r\n```",
              "createdAt": "2023-02-02T21:31:48Z",
              "updatedAt": "2023-02-02T21:31:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85M5adi",
          "commit": {
            "abbreviatedOid": "12c8ab1"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-08T22:52:51Z",
          "updatedAt": "2023-02-08T22:52:51Z",
          "comments": []
        }
      ]
    },
    {
      "number": 239,
      "id": "PR_kwDOF8lax85IWOA7",
      "title": "Deterministic proof fixtures",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/239",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "closes #73, #7 \r\n\r\nDescribing a mocked seeded rng, using `expand_message`, which will be used to describe proof test vectors.",
      "createdAt": "2023-01-23T17:29:21Z",
      "updatedAt": "2023-02-24T04:26:13Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "610df58f5a7e6c52d91ae9a038298e2c17fbabd5",
      "headRepository": "BasileiosKal/bbs-signature",
      "headRefName": "proof-fixtures",
      "headRefOid": "d6fed80d1fe9ea459faa115a531eacc4c68a1748",
      "closedAt": "2023-02-24T04:26:12Z",
      "mergedAt": "2023-02-24T04:26:12Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "9ad26c68ce7660fd068f99f069a67e642c266055"
      },
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on WG call on the 14th of Feb. Will await verification of fixtures from implementations. ",
          "createdAt": "2023-02-13T19:18:30Z",
          "updatedAt": "2023-02-13T19:18:30Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Multiple approvals, discussed on multiple WG calls, fixtures submitted have now been verified by @Wind4Greg's implementation \ud83d\ude80 ",
          "createdAt": "2023-02-24T04:26:06Z",
          "updatedAt": "2023-02-24T04:26:06Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax85LeOa4",
          "commit": {
            "abbreviatedOid": "00d86b1"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-23T19:37:41Z",
          "updatedAt": "2023-01-23T19:37:42Z",
          "comments": [
            {
              "originalPosition": 128,
              "body": "```suggestion\r\nseeded_scalars = seeded_random_scalars(seed, count)\r\n```\r\n\r\nSeems a bit more consistent with the rest of the draft?",
              "createdAt": "2023-01-23T19:37:41Z",
              "updatedAt": "2023-01-23T19:37:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85MJZCe",
          "commit": {
            "abbreviatedOid": "00d86b1"
          },
          "author": "Wind4Greg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-01-31T16:00:42Z",
          "updatedAt": "2023-01-31T16:00:42Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85MRlE9",
          "commit": {
            "abbreviatedOid": "00d86b1"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-01T18:46:41Z",
          "updatedAt": "2023-02-01T18:46:41Z",
          "comments": [
            {
              "originalPosition": 128,
              "body": "Fixed. Thanks!",
              "createdAt": "2023-02-01T18:46:41Z",
              "updatedAt": "2023-02-01T18:46:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85MpQJr",
          "commit": {
            "abbreviatedOid": "956ef6c"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-06T19:32:52Z",
          "updatedAt": "2023-02-06T19:32:53Z",
          "comments": [
            {
              "originalPosition": 209,
              "body": "```suggestion\r\nFor the generation of the following fixtures the `mocked_calculate_random_scalars` defined in [Mocked Random Scalars](#mocked-random-scalars) is used, in place of the `calculate_random_scalars` operation, with the following seed value (hex encoding of `utf8(\"<first 30 digits of pi>\")`)\r\n```",
              "createdAt": "2023-02-06T19:32:53Z",
              "updatedAt": "2023-02-06T19:32:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85OOvhH",
          "commit": {
            "abbreviatedOid": "d6fed80"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-24T04:24:47Z",
          "updatedAt": "2023-02-24T04:24:47Z",
          "comments": []
        }
      ]
    },
    {
      "number": 240,
      "id": "PR_kwDOF8lax85IlT1q",
      "title": "Message encoding update",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/240",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #232\r\n\r\nAlso update `hash-to-scalar` to check if `expand_message` aborts.",
      "createdAt": "2023-01-26T11:16:36Z",
      "updatedAt": "2023-02-23T21:14:58Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "6b7850ab86fad7ff8a04c7e3f166f3e719dc61b1",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "vasilis/message-encoding-update",
      "headRefOid": "46fcb9a9d85f8bb5944e797258696bc941969ad5",
      "closedAt": "2023-02-06T14:35:30Z",
      "mergedAt": "2023-02-06T14:35:30Z",
      "mergedBy": "BasileiosKal",
      "mergeCommit": {
        "oid": "04bf8520f0f33afd13880474b4421621bc15978a"
      },
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Multiple approvals, discussed in WG call, merging. Thanks everyone!",
          "createdAt": "2023-02-06T14:35:24Z",
          "updatedAt": "2023-02-06T14:35:24Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax85Lw1qw",
          "commit": {
            "abbreviatedOid": "e5e8962"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-01-26T13:55:11Z",
          "updatedAt": "2023-01-26T13:55:11Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85MJTpF",
          "commit": {
            "abbreviatedOid": "e5e8962"
          },
          "author": "Wind4Greg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-01-31T15:49:41Z",
          "updatedAt": "2023-01-31T15:49:41Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85MJVuW",
          "commit": {
            "abbreviatedOid": "e5e8962"
          },
          "author": "Wind4Greg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-01-31T15:53:59Z",
          "updatedAt": "2023-01-31T15:53:59Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85MT438",
          "commit": {
            "abbreviatedOid": "e5e8962"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-02T04:04:23Z",
          "updatedAt": "2023-02-02T04:04:24Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "```suggestion\r\n6. if e or s is INVALID, return INVALID\r\n7. B = P1 + Q_1 * s + Q_2 * domain + H_1 * msg_1 + ... + H_L * msg_L\r\n8. A = B * (1 / (SK + e))\r\n9. return signature_to_octets(A, e, s)\r\n```",
              "createdAt": "2023-02-02T04:04:23Z",
              "updatedAt": "2023-02-02T04:04:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85Mau4N",
          "commit": {
            "abbreviatedOid": "b13e8be"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-02T23:47:32Z",
          "updatedAt": "2023-02-02T23:47:33Z",
          "comments": [
            {
              "originalPosition": 88,
              "body": "```suggestion\r\n11. if challenge is INVALID, return INVALID\r\n```",
              "createdAt": "2023-02-02T23:47:33Z",
              "updatedAt": "2023-02-02T23:47:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85MavPw",
          "commit": {
            "abbreviatedOid": "b13e8be"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-02T23:49:54Z",
          "updatedAt": "2023-02-02T23:49:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 241,
      "id": "PR_kwDOF8lax85JCGi8",
      "title": "Editorial updates",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/241",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #157, #76,  #234 \r\n\r\nBatching together multiple small editorial updates.\r\n\r\n- Adds some clarification on the endianness of octet strings (in the test vectors mainly).\r\n- Adds some text to clarify the mapping of messages to scalars.\r\n- Removes the utf8() operation and describes Ciphersuite_id and DSTs as octet strings directly.",
      "createdAt": "2023-02-01T18:15:37Z",
      "updatedAt": "2023-02-23T21:15:04Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "04bf8520f0f33afd13880474b4421621bc15978a",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "vasilis/editorial-updates",
      "headRefOid": "f3bef845075ca1a462039894251eaee3ad0ecf14",
      "closedAt": "2023-02-14T22:59:39Z",
      "mergedAt": "2023-02-14T22:59:39Z",
      "mergedBy": "BasileiosKal",
      "mergeCommit": {
        "oid": "6833700401948258ea49252053d45cd286850882"
      },
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on WG call on 14th of Feb. Will open issue on map-message-to-scalar flexibility and on ways to enforce the mapping procedure and address it to a different PR.",
          "createdAt": "2023-02-13T19:29:02Z",
          "updatedAt": "2023-02-13T19:29:02Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Multiple approvals. Discussed on WG call. Opened #245 to continue discussion on map message to scalar flexibility. Merging. Thanks everyone!",
          "createdAt": "2023-02-14T22:59:33Z",
          "updatedAt": "2023-02-14T22:59:33Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax85MTj7A",
          "commit": {
            "abbreviatedOid": "8ea20a3"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-02T02:53:45Z",
          "updatedAt": "2023-02-02T02:53:46Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\n: An operation that transforms a non-negative integer into an octet string, defined in Section 4 of [@!RFC8017]. Note, the output of this operation is in big-endian order.\r\n```",
              "createdAt": "2023-02-02T02:53:45Z",
              "updatedAt": "2023-02-02T02:53:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85MTkDZ",
          "commit": {
            "abbreviatedOid": "8ea20a3"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-02T02:54:20Z",
          "updatedAt": "2023-02-02T02:54:21Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "```suggestion\r\n: An operation that transforms a octet string into an non-negative integer, defined in Section 4 of [@!RFC8017]. Note, the input of this operation must be in big-endian order.\r\n```",
              "createdAt": "2023-02-02T02:54:20Z",
              "updatedAt": "2023-02-02T02:54:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85MpS7d",
          "commit": {
            "abbreviatedOid": "7484017"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-06T19:41:06Z",
          "updatedAt": "2023-02-06T19:42:04Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "```suggestion\r\n            ciphersuite_id || \"SIG_GENERATOR_SEED_\" where\r\n```",
              "createdAt": "2023-02-06T19:41:06Z",
              "updatedAt": "2023-02-06T19:42:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85M5Khw",
          "commit": {
            "abbreviatedOid": "c274231"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-08T21:51:10Z",
          "updatedAt": "2023-02-08T21:51:10Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "```suggestion\r\nEach of the core operations of the BBS signature scheme expect the inputted messages to be scalar values within a given range (specifically 1 and r-1, where r is the prime order of the G1 and G2 subgroups, defined by each ciphersuite, see [Notation](#notation)). There are multiple ways to transform a message from an octet string to a scalar value. This document defines the `MapMessageToScalarAsHash` operation, which hashes an octet string to a scalar (see [MapMessageToScalarAsHash](#mapmessagetoscalarashash)). An application can use a different `MapMessageToScalar` operation, but it MUST be clearly and unambiguously defined, for all parties involved. Before using the core operations, all messages MUST be mapped to their respective scalars using the same operation. The defined [MapMessageToScalarAsHash](#mapmessagetoscalarashash) is the RECOMMENDED way of mapping octet strings to scalar values.\r\n```",
              "createdAt": "2023-02-08T21:51:10Z",
              "updatedAt": "2023-02-08T21:51:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85M5K5X",
          "commit": {
            "abbreviatedOid": "c274231"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-08T21:52:32Z",
          "updatedAt": "2023-02-08T21:52:33Z",
          "comments": [
            {
              "originalPosition": 184,
              "body": "```suggestion\r\n- generator\\_seed: A global seed value of \"BBS\\_BLS12381G1\\_XOF:SHAKE-256\\_SSWU\\_RO\\_MESSAGE\\_GENERATOR\\_SEED\" (an ASCII string comprised of 59 bytes) which is used by the [create_generators](#generator-point-computation) operation to compute the required set of message generators.\r\n```",
              "createdAt": "2023-02-08T21:52:32Z",
              "updatedAt": "2023-02-08T21:53:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85M5K8a",
          "commit": {
            "abbreviatedOid": "c274231"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-08T21:52:43Z",
          "updatedAt": "2023-02-08T21:52:43Z",
          "comments": [
            {
              "originalPosition": 193,
              "body": "```suggestion\r\n- generator\\_seed: A global seed value of \"BBS\\_BLS12381G1\\_XMD:SHA-256\\_SSWU\\_RO\\_MESSAGE\\_GENERATOR\\_SEED\" (an ASCII string comprised of 57 bytes) which is used by the [create_generators](#generator-point-computation) operation to compute the required set of message generators.\r\n```",
              "createdAt": "2023-02-08T21:52:43Z",
              "updatedAt": "2023-02-08T21:53:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85M5bUk",
          "commit": {
            "abbreviatedOid": "c274231"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-08T22:56:42Z",
          "updatedAt": "2023-02-08T22:56:43Z",
          "comments": [
            {
              "originalPosition": 201,
              "body": "```suggestion\r\n**NOTE** All binary data below is represented as octet strings in big endian order, encoded in hexadecimal format.\r\n```",
              "createdAt": "2023-02-08T22:56:42Z",
              "updatedAt": "2023-02-08T22:56:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85NLsGd",
          "commit": {
            "abbreviatedOid": "cc102d5"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-13T03:52:17Z",
          "updatedAt": "2023-02-13T03:53:18Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "```suggestion\r\n            \"SIG_GENERATOR_SEED_\" is an ASCII string comprised of 19\r\n```",
              "createdAt": "2023-02-13T03:52:17Z",
              "updatedAt": "2023-02-13T03:53:18Z"
            },
            {
              "originalPosition": 73,
              "body": "```suggestion\r\n                 \"SIG_GENERATOR_DST_\" is an ASCII string comprised of\r\n```",
              "createdAt": "2023-02-13T03:52:29Z",
              "updatedAt": "2023-02-13T03:53:18Z"
            },
            {
              "originalPosition": 83,
              "body": "```suggestion\r\nThis operation takes an input message and maps it to a scalar value via a cryptographic hash function for the given curve. The operation takes also as an optional input a domain separation tag (dst). If a dst is not supplied, its value MUST default to the octet string returned from ciphersuite\\_id || \"MAP\\_MSG\\_TO\\_SCALAR\\_AS\\_HASH\\_\", where ciphersuite\\_id is the ASCII string representing the unique ID of the ciphersuite \"MAP\\_MSG\\_TO\\_SCALAR\\_AS\\_HASH\\_\" is an ASCII string comprised of 26 bytes.\r\n```",
              "createdAt": "2023-02-13T03:52:44Z",
              "updatedAt": "2023-02-13T03:53:18Z"
            },
            {
              "originalPosition": 103,
              "body": "```suggestion\r\nThe operation takes as input an octet string representing the message to hash (msg), the number of the scalars to return (count) as well as an optional domain separation tag (dst). If a dst is not supplied, its value MUST default to the octet string returned from ciphersuit\\_id || \"H2S\\_\", where ciphersuite\\_id is the octet string representing the unique ID of the ciphersuite and \"H2S_\" is an ASCII string comprised of 4 bytes.\r\n```",
              "createdAt": "2023-02-13T03:53:00Z",
              "updatedAt": "2023-02-13T03:53:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85NQ_zL",
          "commit": {
            "abbreviatedOid": "2dac862"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-13T19:24:56Z",
          "updatedAt": "2023-02-13T19:24:56Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85NRD57",
          "commit": {
            "abbreviatedOid": "2dac862"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-13T19:37:52Z",
          "updatedAt": "2023-02-13T19:37:52Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85NREbf",
          "commit": {
            "abbreviatedOid": "2dac862"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-13T19:39:39Z",
          "updatedAt": "2023-02-13T19:39:45Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "```suggestion\r\n```",
              "createdAt": "2023-02-13T19:39:39Z",
              "updatedAt": "2023-02-13T19:39:45Z"
            }
          ]
        }
      ]
    },
    {
      "number": 243,
      "id": "PR_kwDOF8lax85JYcyI",
      "title": "Reduce hash_to_scalar to a single output",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/243",
      "state": "MERGED",
      "author": "andrewwhitehead",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Resolves #242 \r\n\r\nRequires some updates to test vectors.",
      "createdAt": "2023-02-06T22:14:07Z",
      "updatedAt": "2023-02-22T19:37:30Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "610df58f5a7e6c52d91ae9a038298e2c17fbabd5",
      "headRepository": "andrewwhitehead/bbs-signature",
      "headRefName": "single-hash-to-scalar",
      "headRefOid": "ff8245ccee7a66f1179979a89197a4858ab53ce5",
      "closedAt": "2023-02-22T19:37:30Z",
      "mergedAt": "2023-02-22T19:37:30Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "5c17359cbcf29143805b4847aa6a4df9126315a1"
      },
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on WG call on the 14th of Feb. Will use expand_message to address comment and discuss again in the next WG call.",
          "createdAt": "2023-02-13T19:51:15Z",
          "updatedAt": "2023-02-13T19:51:15Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Some small nits. LGTM otherwise. It complicates `Sign` a bit more than i would like TBH, but given that we will probably remove `s` eventually, i think this is the better approach (removing `s` will significantly simplify `Sign` again).",
          "createdAt": "2023-02-15T02:59:59Z",
          "updatedAt": "2023-02-15T02:59:59Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Multiple reviews and approvals, discussed on prior WG calls, merging.",
          "createdAt": "2023-02-22T19:37:25Z",
          "updatedAt": "2023-02-22T19:37:25Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax85NLrJM",
          "commit": {
            "abbreviatedOid": "72dec3f"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-13T03:43:47Z",
          "updatedAt": "2023-02-13T03:43:53Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "In this, the inputs for `e` and `s` differ in one bit only. This will highly correlate the 2 values. Maybe we can do something like,\r\n\r\n```\r\n5.  e = hash_to_scalar(e_s_octs || I2OSP(0, 1))\r\n6.  if e is INVALID, return INVALID\r\n7.  s = hash_to_scalar(I2OSP(e) || I2OSP(1, 1))\r\n8.  if s is INVALID, return INVALID\r\n```\r\nThis has another small issue, namely that the 2 inputs do not have the same length, which will make it hard to guarantee that the Hamiltonian distance between them is infarct large.\r\n\r\nWe could argue that since the SK is unknown, in the RO model the 2 inputs will be at least 32 random bytes apart. However ideally we would do something like:\r\n```\r\n5.  v = hash_to_scalar(e_s_octs || I2OSP(0, 1))\r\n6.  if v is INVALID, return INVALID\r\n7.  e = hash_to_scalar(I2OSP(v) || I2OSP(1, 1))\r\n8.  if e is INVALID, return INVALID\r\n9.  s = hash_to_scalar(I2OSP(e) || I2OSP(2, 1))\r\n10. if s is INVALID, return INVALID\r\n```\r\nHere we don't require `hash_to_scalar` to be an RO, just the computational assumptions for the underlying hash will do. But at this point we rather complicate things IMO.",
              "createdAt": "2023-02-13T03:43:48Z",
              "updatedAt": "2023-02-13T03:43:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85NZmL8",
          "commit": {
            "abbreviatedOid": "15c74d7"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-14T23:04:10Z",
          "updatedAt": "2023-02-14T23:15:42Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "`expand_message` could abort as well. Should we add a check that `e_s_expand` is not INVALID (and maybe a note that if `expand_message` aborts we assume it returns INVALID??)",
              "createdAt": "2023-02-14T23:04:10Z",
              "updatedAt": "2023-02-14T23:15:42Z"
            },
            {
              "originalPosition": 36,
              "body": "```suggestion\r\n7.  e = hash_to_scalar(e_s_expand[0..(expand_len - 1)])\r\n9.  s = hash_to_scalar(e_s_expand[expand_len..(expand_len * 2 - 1)])\r\n8.  if e or s is INVALID, return INVALID\r\n```\r\nJust a very small suggestion for better readability??",
              "createdAt": "2023-02-14T23:15:26Z",
              "updatedAt": "2023-02-14T23:15:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85NZqhz",
          "commit": {
            "abbreviatedOid": "15c74d7"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-14T23:27:04Z",
          "updatedAt": "2023-02-14T23:27:04Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "I had thought we treated it as infallible, but apparently not, so updated now.",
              "createdAt": "2023-02-14T23:27:04Z",
              "updatedAt": "2023-02-14T23:27:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85NZ9BH",
          "commit": {
            "abbreviatedOid": "2719a24"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-15T00:57:44Z",
          "updatedAt": "2023-02-15T02:56:16Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "```suggestion\r\n**Note** When computing step 12 of the above procedure there is an extremely small probability (around `2^(-r)`) that the condition `(SK + e) = 0 mod r` will be met. How implementations evaluate the inverse of the scalar value `0` may vary, with some returning an error and others returning `0` as a result. If the returned value from the inverse operation `1/(SK + e)` does evaluate to `0` the value of `A` will equal `Identity_G1` thus an invalid signature. Implementations MAY elect to check `(SK + e) = 0 mod r` prior to step 9, and or `A != Identity_G1` after step 9 to prevent the production of invalid signatures.\r\n```",
              "createdAt": "2023-02-15T00:57:44Z",
              "updatedAt": "2023-02-15T02:56:16Z"
            },
            {
              "originalPosition": 33,
              "body": "```suggestion\r\n7.  if e_s_expand is INVALID, return INVALID\r\n```",
              "createdAt": "2023-02-15T00:57:49Z",
              "updatedAt": "2023-02-15T02:56:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85NamQq",
          "commit": {
            "abbreviatedOid": "ff8245c"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-15T05:24:55Z",
          "updatedAt": "2023-02-15T05:24:55Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85OFa2e",
          "commit": {
            "abbreviatedOid": "ff8245c"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-22T19:36:48Z",
          "updatedAt": "2023-02-22T19:36:48Z",
          "comments": []
        }
      ]
    },
    {
      "number": 247,
      "id": "PR_kwDOF8lax85Ki_mx",
      "title": "fix: remove l from call to calculate domain",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/247",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "As raised by @wind4greg, fixes a typo from previous iteration of `calculate_domain` that required L as an input.",
      "createdAt": "2023-02-22T19:45:03Z",
      "updatedAt": "2023-02-22T22:55:02Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "5c17359cbcf29143805b4847aa6a4df9126315a1",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/remove-l-domain-calc",
      "headRefOid": "5e2adccffd333d1a3f7e12e63885aa48b525f420",
      "closedAt": "2023-02-22T22:10:46Z",
      "mergedAt": "2023-02-22T22:10:46Z",
      "mergedBy": "BasileiosKal",
      "mergeCommit": {
        "oid": "84ff08e7a9ccdc0ab96f0ad9a9228d678a31f2cb"
      },
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Multiple approvals! Editorial update fixing a typo. Merging. Thank you everyone!",
          "createdAt": "2023-02-22T22:10:41Z",
          "updatedAt": "2023-02-22T22:10:41Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax85OFuv5",
          "commit": {
            "abbreviatedOid": "5e2adcc"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-22T20:19:19Z",
          "updatedAt": "2023-02-22T20:19:19Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85OGlpc",
          "commit": {
            "abbreviatedOid": "5e2adcc"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-22T22:09:49Z",
          "updatedAt": "2023-02-22T22:09:49Z",
          "comments": []
        }
      ]
    },
    {
      "number": 248,
      "id": "PR_kwDOF8lax85Kyj2d",
      "title": "Update fixtures for new h2s and sign",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/248",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Update fixtures to accommodate the updates in #243\r\n\r\nAlso change the number of bytes that will be \"hashed\" to `e` and `s` to 32 instead of 48 to avoid an extra, unnecessary hash.\r\n\r\n(note that those bytes will be \"extended\" to 48 pseudo random bytes inside `hash_to_scalar` either way).\r\n\r\nNot ideal still (we call `expand_message` twice while it could be once). This will be fixed if we decide to rm `s` so IMO the current procedure is fine for now.",
      "createdAt": "2023-02-27T03:20:30Z",
      "updatedAt": "2023-03-09T19:45:35Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "9ad26c68ce7660fd068f99f069a67e642c266055",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "vasilis/update-fixtures",
      "headRefOid": "22c58f1800b7befa03ec9a780dc87d847930cf96",
      "closedAt": "2023-03-09T18:22:13Z",
      "mergedAt": "2023-03-09T18:22:13Z",
      "mergedBy": "BasileiosKal",
      "mergeCommit": {
        "oid": "0af4400c2adff89504ebc5d63043610f7845f370"
      },
      "comments": [
        {
          "author": "tmarkovski",
          "authorAssociation": "MEMBER",
          "body": "I\u2019m having issues with the `calculate_domain` procedure in this PR.\r\nSpecifically, step `4.  dom_array = (Q_1, Q_2, L, H_1, ..., H_L)` lists the `L` argument coming after `Q_1` and `Q_2`, but this doesn't work against the fixtures. If I change that to `(L, Q_1, Q_2, H_1, ..., H_L)` such that `L` is at position 1, then the fixtures pass.\r\nI don't know which option is the correct one, but it seems the spec and the fixtures are out of agreement.",
          "createdAt": "2023-02-28T13:24:00Z",
          "updatedAt": "2023-02-28T13:47:09Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hey @tmarkovski! Thanks for catching this \ud83d\ude4c Updated the document to match the test vectors (i.e., use `dom_array = (L, Q_1, Q_2, H_1, ..., H_L)`). Not sure where the inconsistency was introduced but IMO it's this way.",
          "createdAt": "2023-03-06T07:57:14Z",
          "updatedAt": "2023-03-06T07:57:14Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on WG call on 6th of Mar. Test vectors are cross validated. Will close after reviews and @tmarkovski issue is resolved!",
          "createdAt": "2023-03-06T19:26:27Z",
          "updatedAt": "2023-03-06T19:26:27Z"
        },
        {
          "author": "Wind4Greg",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Reminder as mentioned on March 6th call all test vectors are validating against my implementation at https://github.com/Wind4Greg/grotto-bbs-signatures/tree/spec-update.",
          "createdAt": "2023-03-08T19:36:56Z",
          "updatedAt": "2023-03-08T19:36:56Z"
        },
        {
          "author": "tmarkovski",
          "authorAssociation": "MEMBER",
          "body": "Issue is resolved, test vectors pass and implementation matches the spec.",
          "createdAt": "2023-03-08T19:51:12Z",
          "updatedAt": "2023-03-08T19:51:12Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on WG call! Approved. Test vectors cross validated by multiple implementations! Merging. Thanks everyone!",
          "createdAt": "2023-03-09T18:22:06Z",
          "updatedAt": "2023-03-09T18:22:06Z"
        },
        {
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I started to update my implementation to match the updated spec. Hopefully I'll be close to done by our next meeting ",
          "createdAt": "2023-03-09T19:45:34Z",
          "updatedAt": "2023-03-09T19:45:34Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax85PeyPs",
          "commit": {
            "abbreviatedOid": "22c58f1"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-09T18:15:59Z",
          "updatedAt": "2023-03-09T18:15:59Z",
          "comments": []
        }
      ]
    },
    {
      "number": 250,
      "id": "PR_kwDOF8lax85LtU-l",
      "title": "chore: update changelog for v2",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/250",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Updates the changelog prior to publishing `draft-02`",
      "createdAt": "2023-03-09T19:04:44Z",
      "updatedAt": "2023-03-09T20:33:34Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "0af4400c2adff89504ebc5d63043610f7845f370",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/draft-02",
      "headRefOid": "efbc4d5f07f3f335c06775b3553b94b9881ebdfe",
      "closedAt": "2023-03-09T20:16:26Z",
      "mergedAt": "2023-03-09T20:16:26Z",
      "mergedBy": "BasileiosKal",
      "mergeCommit": {
        "oid": "747bdc334079b90d66fe0ec699d97f64d5b1ec6a"
      },
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Editorial update. Adding to changelog for draft 02. Merging!",
          "createdAt": "2023-03-09T20:16:20Z",
          "updatedAt": "2023-03-09T20:16:20Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax85PfLG6",
          "commit": {
            "abbreviatedOid": "f9009e9"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Some suggestions. LGTM otherwise!",
          "createdAt": "2023-03-09T19:09:14Z",
          "updatedAt": "2023-03-09T19:19:13Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "```suggestion\r\n* Shifted to multiple CSPRNG calls to calculate random elements, instead of expand_message\r\n* Updated hash_to_scalar to a single output\r\n\r\n```\r\nSome small additions.",
              "createdAt": "2023-03-09T19:09:14Z",
              "updatedAt": "2023-03-09T19:19:13Z"
            },
            {
              "originalPosition": 9,
              "body": "```suggestion\r\n* Shifted to using CSPRNG instead of PRF\r\n```",
              "createdAt": "2023-03-09T19:15:36Z",
              "updatedAt": "2023-03-09T19:19:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85PfwgX",
          "commit": {
            "abbreviatedOid": "efbc4d5"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-09T20:15:30Z",
          "updatedAt": "2023-03-09T20:15:30Z",
          "comments": []
        }
      ]
    },
    {
      "number": 251,
      "id": "PR_kwDOF8lax85Lyaii",
      "title": "Fixed type of serialize's octets_result",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/251",
      "state": "CLOSED",
      "author": "christianpaquin",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixed type of output value `octets_result`, and added the article \"an\" before some \"octet string\" for consistency.",
      "createdAt": "2023-03-10T17:48:26Z",
      "updatedAt": "2023-03-11T22:54:45Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "747bdc334079b90d66fe0ec699d97f64d5b1ec6a",
      "headRepository": "christianpaquin/bbs-signature",
      "headRefName": "editorial-spec-fixes",
      "headRefOid": "af7468108bd0a92e63e78326504959f6338b910b",
      "closedAt": "2023-03-11T22:54:45Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Thanks @christianpaquin I have addressed in this commit https://github.com/decentralized-identity/bbs-signature/commit/ef22de1afdb3cda4b7b8d16cef0fc072bd7bcdbc as the PR has conflicts and we need to submit draft-02 before the deadline.",
          "createdAt": "2023-03-11T22:54:45Z",
          "updatedAt": "2023-03-11T22:54:45Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax85PoNr0",
          "commit": {
            "abbreviatedOid": "af74681"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-11T22:41:12Z",
          "updatedAt": "2023-03-11T22:41:12Z",
          "comments": []
        }
      ]
    },
    {
      "number": 255,
      "id": "PR_kwDOF8lax85N2aL4",
      "title": "Added text on header, ph usage.",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/255",
      "state": "CLOSED",
      "author": "Wind4Greg",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Per the last meeting I added some small clarifying text on the `header` and `ph` fields.\r\n\r\nCheers\r\nGreg",
      "createdAt": "2023-04-07T17:55:07Z",
      "updatedAt": "2023-04-27T22:35:48Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "63db108bad3a40fb71e0d234b8922e8e4efcaac1",
      "headRepository": "Wind4Greg/bbs-signature",
      "headRefName": "header-caveat",
      "headRefOid": "a1355a853562a5729fe6b25acff8170186a5f772",
      "closedAt": "2023-04-27T22:35:48Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed on the WG call, decided that the best way to handle this caveat is to add a privacy consideration section to the spec that talks to this specific issue around header usage.",
          "createdAt": "2023-04-10T18:16:25Z",
          "updatedAt": "2023-04-10T18:16:25Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax85S8kD3",
          "commit": {
            "abbreviatedOid": "a1355a8"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Thanks Greg! The descriptions look great. Just a comment r.e., their placement in the document.",
          "createdAt": "2023-04-19T09:02:50Z",
          "updatedAt": "2023-04-19T09:05:39Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "IMO, those descriptions are not really suited for the input section of the operations, where we should try to keep things as simple as possible. I think there are 2 alternatives:\r\n1. Add the `header` and `presentation_header` terms in the [Terminology section](https://identity.foundation/bbs-signature/draft-irtf-cfrg-bbs-signatures.html#name-terminology), followed by the above description.\r\n2.  Add a new subsection of the [Considerations section](https://identity.foundation/bbs-signature/draft-irtf-cfrg-bbs-signatures.html#name-considerations), to describe their functionality in more detail.\r\n\r\n(I would go with option 2)\r\n\r\nThis is in addition to the privacy section around the header/ph use, mentioned [here](https://github.com/decentralized-identity/bbs-signature/pull/255#issuecomment-1502141929)\r\n",
              "createdAt": "2023-04-19T09:02:50Z",
              "updatedAt": "2023-04-19T09:05:39Z"
            },
            {
              "originalPosition": 16,
              "body": "Same as above^",
              "createdAt": "2023-04-19T09:03:05Z",
              "updatedAt": "2023-04-19T09:05:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85TBkLf",
          "commit": {
            "abbreviatedOid": "a1355a8"
          },
          "author": "Wind4Greg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-19T21:36:26Z",
          "updatedAt": "2023-04-19T21:36:26Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I like your options 2. Cheers Greg",
              "createdAt": "2023-04-19T21:36:26Z",
              "updatedAt": "2023-04-19T21:36:27Z"
            }
          ]
        }
      ]
    },
    {
      "number": 257,
      "id": "PR_kwDOF8lax85OCrSK",
      "title": "Revisiting BBS part 1: removed (old) Q1 and s sig value",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/257",
      "state": "MERGED",
      "author": "christianpaquin",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Removed `Q1`, `s`, and corresponding values, following the first proposed optimization in the EuroCrypt 2023 [Revisiting BBS paper](https://eprint.iacr.org/2023/275.pdf) (and then renamed `Q2` as `Q1`). Proof generation and verification modified by @andrewwhitehead to maintain compatibility with spec extensions; changes reviewed by the paper authors.\r\n\r\nNote: prototyped in [PR 18](https://github.com/microsoft/bbs-node-reference/pull/18) of the typescript library (tests failing due to old fixtures; run `npm run bbs` instead to test updated spec implementation).\r\n\r\nFixtures need to be updated.",
      "createdAt": "2023-04-11T16:03:58Z",
      "updatedAt": "2023-06-08T18:44:51Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "369cbc622c285fdb40cbb419bb2160abe08a3d97",
      "headRepository": "christianpaquin/bbs-signature",
      "headRefName": "revisiting-bbs",
      "headRefOid": "6f8435520cd3d319d38221e91de69e73f91dcfe1",
      "closedAt": "2023-06-08T18:21:12Z",
      "mergedAt": "2023-06-08T18:21:12Z",
      "mergedBy": "BasileiosKal",
      "mergeCommit": {
        "oid": "32b4700bdd9f082c57cbdb43b2d28af1a03d8ba8"
      },
      "comments": [
        {
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Note: not ready for review. I'm in discussion with the authors; I need to make some changes.",
          "createdAt": "2023-04-11T20:06:43Z",
          "updatedAt": "2023-04-11T20:06:43Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hey @christianpaquin thank you for your work on this! Just a couple of early notes/talk-points for the next WG call so i won't forget them \ud83d\ude05 \r\n\r\nCompletely removing `Q_1` and `r2` from `ProofGen` seems to make the resulting proof not zero-knowledge (at least not against the Signer).\r\n\r\nNote that the following holds given the updated values of `D`, `Abar` and `A'`, \r\n\r\n```\r\nAbar - D = A' * (-e)\r\n```\r\n\r\nIf someone knows `e` they can check the above equation and \"track\" the user (i.e., distinguish the proof value from a random element, i.e., break zero-knowledge).\r\n\r\n##\r\nAlso in Sign, we could just pass `e_octs` directly to hash_to_scalar (save the extra epand_message operation).",
          "createdAt": "2023-05-10T21:36:03Z",
          "updatedAt": "2023-05-10T21:36:03Z"
        },
        {
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Just a couple of early notes/talk-points for the next WG call\r\n\r\nYes, there are indeed some issues with my current PR; I'm hoping to have a revised one for our next call. Thanks for sharing your notes!\r\n",
          "createdAt": "2023-05-11T14:28:02Z",
          "updatedAt": "2023-05-11T14:28:02Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'll attach my version of the ProofGen/ProofVerify here for now. It's close to the paper's version, but requires a scalar inversion (slightly expensive), in line with the current proof. That allows equality proofs between unrevealed messages in different signatures. I believe the property `Abar - D = A' * (-e)` also cannot be checked when `e` is somehow known to the verifier.\r\n\r\n```\r\nproof = ProofGen(PK, signature, header, ph, messages, disclosed_indexes)\r\n\r\nInputs:\r\n\r\n- PK (REQUIRED), an octet string of the form outputted by the SkToPk\r\n                 operation.\r\n- signature (REQUIRED), an octet string of the form outputted by the\r\n                        Sign operation.\r\n- header (OPTIONAL), an octet string containing context and application\r\n                     specific information. If not supplied, it defaults\r\n                     to an empty string.\r\n- ph (OPTIONAL), an octet string containing the presentation header. If not\r\n                 supplied, it defaults to an empty string.\r\n- messages (OPTIONAL), a vector of scalars. If not supplied, it defaults\r\n                       to the empty array \"()\".\r\n- disclosed_indexes (OPTIONAL), vector of unsigned integers in ascending\r\n                                order. Indexes of disclosed messages. If\r\n                                not supplied, it defaults to the empty\r\n                                array \"()\".\r\n\r\nParameters:\r\n\r\n- P1, fixed point of G1, defined by the ciphersuite.\r\n\r\nDefinitions:\r\n\r\n- L, is the non-negative integer representing the number of messages.\r\n- R, is the non-negative integer representing the number of disclosed\r\n     (revealed) messages.\r\n- U, is the non-negative integer representing the number of undisclosed\r\n     messages, i.e., U = L - R.\r\n\r\nOutputs:\r\n\r\n- proof, an octet string; or INVALID.\r\n\r\nDeserialization:\r\n\r\n1.  signature_result = octets_to_signature(signature)\r\n2.  if signature_result is INVALID, return INVALID\r\n3.  (A, e) = signature_result\r\n4.  L = length(messages)\r\n5.  R = length(disclosed_indexes)\r\n6.  U = L - R\r\n7.  (i1, ..., iR) = disclosed_indexes\r\n8.  (j1, ..., jU) = range(1, L) \\ disclosed_indexes\r\n9.  (m_1, ..., m_L) = messages\r\n10. (m_i1, ..., m_iR) = (messages[i1], ..., messages[iR])\r\n11. (m_j1, ..., m_jU) = (messages[j1], ..., messages[jU])\r\n\r\nProcedure:\r\n\r\n1.  (Q_1, MsgGenerators) = create_generators(L+1)\r\n2.  (H_1, ..., H_L) = MsgGenerators\r\n3.  (H_j1, ..., H_jU) = (MsgGenerators[j1], ..., MsgGenerators[jU])\r\n4.  domain = calculate_domain(PK, Q_1, (H_1, ..., H_L), header)\r\n5.  if domain is INVALID, return INVALID\r\n6.  random_scalars = calculate_random_scalars(3+U)\r\n7.  (r1, r2, r3, m~_j1, ..., m~_jU) = random_scalars\r\n8.  B = P1 + Q_1 * domain + H_1 * m_1 + ... + H_L * m_L\r\n9.  Abar = A * r1\r\n10. Bbar = (B - A * e) * r1\r\n11. U = Bbar * r2 + Abar * r3 + H_j1 * m~_j1 + ... + H_jU * m~_jU\r\n12. c = calculate_challenge(Abar, Bbar, U, (i1, ..., iR),\r\n                            (m_i1, ..., m_iR), domain, ph)\r\n13. if c is INVALID, return INVALID\r\n14. r4 = r1^-1 (mod r)\r\n15. r2^ = r2 + r4 * c (mod r)\r\n16. r3^ = r3 + e * r4 * c (mod r)\r\n17. for j in (j1, ..., jU): m^_j = m~_j - m_j * c (mod r)\r\n18. proof = (Abar, Bbar, c, r2^, r3^, (m^_j1, ..., m^_jU))\r\n19. return proof_to_octets(proof)\r\n```\r\n\r\n```\r\nresult = ProofVerify(PK, proof, header, ph,\r\n                     disclosed_messages,\r\n                     disclosed_indexes)\r\n\r\nInputs:\r\n\r\n- PK (REQUIRED), an octet string of the form outputted by the SkToPk\r\n                 operation.\r\n- proof (REQUIRED), an octet string of the form outputted by the\r\n                    ProofGen operation.\r\n- header (OPTIONAL), an optional octet string containing context and\r\n                     application specific information. If not supplied,\r\n                     it defaults to an empty string.\r\n- ph (OPTIONAL), an octet string containing the presentation header. If not\r\n                 supplied, it defaults to an empty string.\r\n- disclosed_messages (OPTIONAL), a vector of scalars. If not supplied,\r\n                                 it defaults to the empty array \"()\".\r\n- disclosed_indexes (OPTIONAL), vector of unsigned integers in ascending\r\n                                order. Indexes of disclosed messages. If\r\n                                not supplied, it defaults to the empty\r\n                                array \"()\".\r\n\r\nParameters:\r\n\r\n- P1, fixed point of G1, defined by the ciphersuite.\r\n\r\nDefinitions:\r\n\r\n- R, is the non-negative integer representing the number of disclosed\r\n     (revealed) messages.\r\n- U, is the non-negative integer representing the number of undisclosed\r\n     messages.\r\n- L, is the non-negative integer representing the number of total,\r\n     messages i.e., L = U + R.\r\n\r\nOutputs:\r\n\r\n- result, either VALID or INVALID.\r\n\r\nDeserialization:\r\n\r\n1.  proof_result = octets_to_proof(proof)\r\n2.  if proof_result is INVALID, return INVALID\r\n3.  (Abar, Bbar, c, r2^, r3^, responses) = proof_result\r\n4.  W = octets_to_pubkey(PK)\r\n5.  if W is INVALID, return INVALID\r\n6.  U = length(responses)\r\n7.  R = length(disclosed_indexes)\r\n8.  L = R + U\r\n9.  (i1, ..., iR) = disclosed_indexes\r\n10. (j1, ..., jU) = range(1, L) \\ disclosed_indexes\r\n11. (m_i1, ..., m_iR) = disclosed_messages\r\n12. (m^_j1, ...., m^_jU) = responses\r\n\r\nPreconditions:\r\n\r\n1. for i in (i1, ..., iR), if i < 1 or i > L, return INVALID\r\n2. if length(disclosed_messages) != R, return INVALID\r\n\r\nProcedure:\r\n\r\n1.  (Q_1, MsgGenerators) = create_generators(L+1)\r\n2.  (H_1, ..., H_L) = MsgGenerators\r\n3.  (H_i1, ..., H_iR) = (MsgGenerators[i1], ..., MsgGenerators[iR])\r\n4.  (H_j1, ..., H_jU) = (MsgGenerators[j1], ..., MsgGenerators[jU])\r\n\r\n5.  domain = calculate_domain(PK, Q_1, (H_1, ..., H_L), header)\r\n6.  if domain is INVALID, return INVALID\r\n7.  D = P1 + Q_1 * domain + H_i1 * m_i1 + ... + H_iR * m_iR\r\n8.  U = Bbar * r2^ + Abar * r3^ + H_j1 * m^_j1 + ... + H_jU * m^_jU + D(-c)\r\n9.  cv = calculate_challenge(Abar, Bbar, U, (i1, ..., iR),\r\n                             (m_i1, ..., m_iR), domain, ph)\r\n10. if cv is INVALID, return INVALID\r\n11. if c != cv, return INVALID\r\n12. if e(Abar, W) * e(Bbar, -P2) != Identity_GT, return INVALID\r\n13. return VALID\r\n```\r\n\r\nEssentially the prover calculates:\r\n\r\n```\r\nUp = Bbar * r2 + Abar * r3 + H_j1 * m~_j1 + ... + H_jU * m~_jU\r\n```\r\n\r\nAnd the verifier checks:\r\n```\r\nGiven D = P1 + Q_1 * domain + H_i1 * m_i1 + ... + H_iR * m_iR\r\n      B = D + H_j1 * m_j1 + ... + H_jU * m_jU\r\nUv = Bbar * r2^ + Abar * r3^ + H_j1 * m^_j1 + ... + H_jU * m^_jU - Dc\r\n   = Bbar * (r2 + r4c) + Abar * (r3 + e*r4c) + H_j1 * (m~_j1 - m_j1*c) ... + H_jU * (m~_jU - m_jU*c) - Dc\r\n   = (Bbar * r2 + Abar * r3 + H_j1 * m~_j1 + ... + H_jU * m~_jU)\r\n     + Bbar * r4c + Abar * e*r4c - H_j1 * m_j1*c ... - H_jU * m_jU*c - Dc\r\n   = Up + (Bbar * r4c + Abar * e*r4c) - Bc\r\n   = Up + (B - A*e)c + (A*e)c - Bc\r\n   = Up\r\n```\r\n\r\nYou can think of this as a rearrangement of the verifier's equation in the paper:\r\n$U \\cdot \\bar{B}^c = C_J(\\vec{m})^s\\bar{A}^t\\prod_{i \\in I}{\\vec{h_1}[i]^{u_i}}$\r\n-> $U \\cdot C_J(\\vec{m})^c = \\bar{B}^s\\bar{A}^t\\prod_{i \\in I}{\\vec{h_1}[i]^{u_i}}$",
          "createdAt": "2023-05-11T19:46:16Z",
          "updatedAt": "2023-05-16T16:29:52Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Also r.e., the proof. It looks good to me and I think we can directly use it. The only suggestion I have is at step 10 of `ProofGen` instead of `Bbar = (B - A * e) * r1` to do `Bbar = B * r1 - Abar * e`.\r\n\r\nIts the same thing but implementations would more easily use Pippenger's algorithm for multi-exponentiation. \r\n\r\nc.c @andrewwhitehead",
          "createdAt": "2023-05-25T21:41:37Z",
          "updatedAt": "2023-05-25T21:41:37Z"
        },
        {
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks @BasileiosKal and @andrewwhitehead; I'll finally have time to address this next week (starting Tuesday since I'll be out for memorial day on Monday)",
          "createdAt": "2023-05-26T21:50:05Z",
          "updatedAt": "2023-05-26T21:50:05Z"
        },
        {
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@andrewwhitehead, @BasileiosKal, I integrated your new ProofGen/ProofVerify and review comments, respectively (except the `Bbar = B * r1 - Abar * e` suggestion, until Andrew comments, and  adding `L` to serialize, which we can indeed do in a separate PR).\r\n\r\n~PR still not ready for merge, I still need to update the serialization methods, and rename the generators (I'm still using Q2, while Andrew's functions use Q1)~ Just updated the PR to update other references (renamed Q2 --> Q1, updated challenge generation, and proof serialization)",
          "createdAt": "2023-05-29T16:03:54Z",
          "updatedAt": "2023-05-29T17:12:53Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Also r.e., the proof. It looks good to me and I think we can directly use it. The only suggestion I have is at step 10 of `ProofGen` instead of `Bbar = (B - A * e) * r1` to do `Bbar = B * r1 - Abar * e`.\r\n> \r\n> Its the same thing but implementations would more easily use Pippenger's algorithm for multi-exponentiation.\r\n\r\nThanks, I agree that's a good change. Not sure I'd recommend Pippenger specifically as it isn't constant-time. In my experiments the simplest and fastest option seemed to be using GLV multiplication with a naive sum of products (which could be parallelized).",
          "createdAt": "2023-05-29T17:15:04Z",
          "updatedAt": "2023-05-29T17:15:41Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Thanks, I agree that's a good change. Not sure I'd recommend Pippenger specifically as it isn't constant-time. In my experiments the simplest and fastest option seemed to be using GLV multiplication with a naive sum of products (which could be parallelized).\r\n\r\nThanks! Agreed! Either way, Pippenger would be overkill just to calculate `Bbar`, but its nice to have everything in uniform way either for Pippenger or GLV.",
          "createdAt": "2023-05-29T17:50:59Z",
          "updatedAt": "2023-05-29T17:50:59Z"
        },
        {
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\r\n\r\n\r\n> Discussed on the WG call on the 29th of May. Couple more suggestions discussed on the call! Thanks!\r\n\r\nMerged in. I also updated my implementation",
          "createdAt": "2023-05-29T23:39:03Z",
          "updatedAt": "2023-05-29T23:39:03Z"
        },
        {
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "body": "nit, but is the PR title accurate? seems like you removed Q2.\r\n\r\nnvm... I see https://github.com/decentralized-identity/bbs-signature/pull/257#issuecomment-1567308350",
          "createdAt": "2023-05-30T21:57:22Z",
          "updatedAt": "2023-05-30T21:59:01Z"
        },
        {
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> nit, but is the PR title accurate? seems like you removed Q2.\r\n> nvm... I see [#257 (comment)](https://github.com/decentralized-identity/bbs-signature/pull/257#issuecomment-1567308350)\r\n\r\nStill, a good point. I slightly clarified the title.",
          "createdAt": "2023-05-30T22:30:23Z",
          "updatedAt": "2023-05-30T22:30:23Z"
        },
        {
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\r\n> Suggesting to keep consistent notation for now (i.e., `msg_i` instead of `m_i` and `commitments` instead of `responses`). Probably better to update notation throughout the entire document in a separate PR?\r\n\r\nI merged your suggestions @BasileiosKal.",
          "createdAt": "2023-06-05T16:12:44Z",
          "updatedAt": "2023-06-05T16:12:44Z"
        },
        {
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> LGTM! Just a last suggestion for calculating `Bbar` which I think @andrewwhitehead seemed to [agree with](https://github.com/decentralized-identity/bbs-signature/pull/257#issuecomment-1567362121)?? (but please correct me Andrew \ud83d\ude4f).\r\n\r\nYes! I forgot about that change. Merged your suggested edit.",
          "createdAt": "2023-06-06T18:47:12Z",
          "updatedAt": "2023-06-06T18:55:16Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thank you @christianpaquin! Would like to wait @andrewwhitehead's review! After, it would be ready to merge IMO ",
          "createdAt": "2023-06-07T17:54:25Z",
          "updatedAt": "2023-06-07T17:54:25Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fantastic! I do agree with Andrew's above comment and opened #265 to keep track of it.\r\n\r\nSince we have multiple approvals I will merge this. Thank you everyone for your help and especially @christianpaquin and @andrewwhitehead for making this possible!",
          "createdAt": "2023-06-08T18:21:01Z",
          "updatedAt": "2023-06-08T18:21:01Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax85WB5k7",
          "commit": {
            "abbreviatedOid": "fd3ddd1"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Couple of suggestions for `Sign` (sorry for the multiple comments, it would not let me create 1 suggestion for the entire operation, because it would include deleted lines)",
          "createdAt": "2023-05-25T08:19:02Z",
          "updatedAt": "2023-05-25T08:23:20Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "```suggestion\r\n4. e = hash_to_scalar(serialize((SK, domain, msg_1, ..., msg_L)))\r\n5. if e is INVALID, return INVALID\r\n6. B = P1 + Q_2 * domain + H_1 * msg_1 + ... + H_L * msg_L\r\n7. A = B * (1 / (SK + e))\r\n```\r\n\r\nNot sure if a step checking that `serialize((SK, domain, msg_1, ..., msg_L))` is VALID is needed. If the inputted arguments of Sign are correct, all values passed to `serialize` are scalars that should not cause serialize to abort.\r\n\r\nProbably should add `L` in there, but this can be done in another PR. Even if we do though, `serialize` will fail only if `L > 2^64 - 1`, in which case `calculate_domain` would fail at step 2.",
              "createdAt": "2023-05-25T08:19:02Z",
              "updatedAt": "2023-05-25T08:23:20Z"
            },
            {
              "originalPosition": 37,
              "body": "```suggestion\r\n8. return signature_to_octets(A, e)\r\n```\r\nJust fixing the numbering based on my other comment",
              "createdAt": "2023-05-25T08:19:47Z",
              "updatedAt": "2023-05-25T08:23:20Z"
            },
            {
              "originalPosition": 17,
              "body": "```suggestion\r\n1. (Q_2, H_1, ..., H_L) = create_generators(L+1)\r\n2. domain = calculate_domain(PK, Q_2, (H_1, ..., H_L), header)\r\n3. if domain is INVALID, return INVALID\r\n```\r\nJust fixing the indentation based on my other comment",
              "createdAt": "2023-05-25T08:20:48Z",
              "updatedAt": "2023-05-25T08:23:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85WagjW",
          "commit": {
            "abbreviatedOid": "f1989ac"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Discussed on the WG call on the 29th of May. Couple more suggestions discussed on the call! Thanks!",
          "createdAt": "2023-05-29T18:49:16Z",
          "updatedAt": "2023-05-29T19:03:15Z",
          "comments": [
            {
              "originalPosition": 118,
              "body": "```suggestion\r\n14. r4 = - r1^-1 (mod r)\r\n```",
              "createdAt": "2023-05-29T18:49:16Z",
              "updatedAt": "2023-05-29T18:50:28Z"
            },
            {
              "originalPosition": 121,
              "body": "```suggestion\r\n17. for j in (j1, ..., jU): m^_j = m~_j + m_j * c (mod r)\r\n```",
              "createdAt": "2023-05-29T18:49:40Z",
              "updatedAt": "2023-05-29T18:50:28Z"
            },
            {
              "originalPosition": 172,
              "body": "```suggestion\r\n8.  C = Bbar * r2^ + Abar * r3^ + H_j1 * m^_j1 + ... + H_jU * m^_jU + D * c\r\n```",
              "createdAt": "2023-05-29T18:49:55Z",
              "updatedAt": "2023-05-29T18:50:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85WieAw",
          "commit": {
            "abbreviatedOid": "3840dda"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-30T21:54:12Z",
          "updatedAt": "2023-05-30T21:54:12Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85XMOKz",
          "commit": {
            "abbreviatedOid": "d71dae0"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Suggesting to keep consistent notation for now (i.e., `msg_i` instead of `m_i` and `commitments` instead of `responses`). Probably better to update notation throughout the entire document in a separate PR?",
          "createdAt": "2023-06-05T15:25:29Z",
          "updatedAt": "2023-06-05T15:52:47Z",
          "comments": [
            {
              "originalPosition": 111,
              "body": "```suggestion\r\n8.  B = P1 + Q_1 * domain + H_1 * msg_1 + ... + H_L * msg_L\r\n```",
              "createdAt": "2023-06-05T15:25:29Z",
              "updatedAt": "2023-06-05T15:52:47Z"
            },
            {
              "originalPosition": 116,
              "body": "```suggestion\r\n12. c = calculate_challenge(Abar, Bbar, C, (i1, ..., iR),\r\n                            (msg_i1, ..., msg_iR), domain, ph)\r\n```",
              "createdAt": "2023-06-05T15:25:58Z",
              "updatedAt": "2023-06-05T15:52:47Z"
            },
            {
              "originalPosition": 77,
              "body": "```suggestion\r\n9.  (msg_1, ..., msg_L) = messages\r\n10. (msg_i1, ..., msg_iR) = (messages[i1], ..., messages[iR])\r\n11. (msg_j1, ..., msg_jU) = (messages[j1], ..., messages[jU])\r\n```",
              "createdAt": "2023-06-05T15:26:10Z",
              "updatedAt": "2023-06-05T15:52:47Z"
            },
            {
              "originalPosition": 121,
              "body": "```suggestion\r\n17. for j in (j1, ..., jU): m^_j = m~_j + msg_j * c (mod r)\r\n```",
              "createdAt": "2023-06-05T15:26:32Z",
              "updatedAt": "2023-06-05T15:52:47Z"
            },
            {
              "originalPosition": 132,
              "body": "```suggestion\r\n3.  (Abar, Bbar, c, r2^, r3^, commitments) = proof_result\r\n```",
              "createdAt": "2023-06-05T15:32:52Z",
              "updatedAt": "2023-06-05T15:52:48Z"
            },
            {
              "originalPosition": 136,
              "body": "```suggestion\r\n6.  U = length(commitments)\r\n```",
              "createdAt": "2023-06-05T15:32:54Z",
              "updatedAt": "2023-06-05T15:52:48Z"
            },
            {
              "originalPosition": 144,
              "body": "```suggestion\r\n11. (msg_i1, ..., msg_iR) = disclosed_messages\r\n12. (m^_j1, ...., m^_jU) = commitments\r\n```",
              "createdAt": "2023-06-05T15:32:56Z",
              "updatedAt": "2023-06-05T15:52:48Z"
            },
            {
              "originalPosition": 171,
              "body": "```suggestion\r\n7.  D = P1 + Q_1 * domain + H_i1 * msg_i1 + ... + H_iR * msg_iR\r\n```",
              "createdAt": "2023-06-05T15:33:00Z",
              "updatedAt": "2023-06-05T15:52:48Z"
            },
            {
              "originalPosition": 174,
              "body": "```suggestion\r\n                             (msg_i1, ..., msg_iR), domain, ph)\r\n```",
              "createdAt": "2023-06-05T15:33:03Z",
              "updatedAt": "2023-06-05T15:52:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85XWNE2",
          "commit": {
            "abbreviatedOid": "68f756a"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM! Just a last suggestion for calculating `Bbar` which I think @andrewwhitehead seemed to [agree with](https://github.com/decentralized-identity/bbs-signature/pull/257#issuecomment-1567362121)?? (but please correct me Andrew \ud83d\ude4f).\r\n\r\nI'm fine with not including it also! Thanks!",
          "createdAt": "2023-06-06T15:05:44Z",
          "updatedAt": "2023-06-06T16:11:18Z",
          "comments": [
            {
              "originalPosition": 106,
              "body": "```suggestion\r\n10. Bbar = B * r1 - Abar * e\r\n```",
              "createdAt": "2023-06-06T15:05:44Z",
              "updatedAt": "2023-06-06T16:11:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85XhCg_",
          "commit": {
            "abbreviatedOid": "854e477"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-07T18:00:48Z",
          "updatedAt": "2023-06-07T18:00:49Z",
          "comments": [
            {
              "originalPosition": 182,
              "body": "```suggestion\r\n- Q_1 (REQUIRED), point of G1 (the first point returned from\r\n```",
              "createdAt": "2023-06-07T18:00:49Z",
              "updatedAt": "2023-06-07T18:00:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85XhCuo",
          "commit": {
            "abbreviatedOid": "854e477"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-07T18:01:26Z",
          "updatedAt": "2023-06-07T18:01:26Z",
          "comments": [
            {
              "originalPosition": 258,
              "body": "```suggestion\r\n           and e is a non-zero scalar mod r.\r\n```",
              "createdAt": "2023-06-07T18:01:26Z",
              "updatedAt": "2023-06-07T18:01:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85XhEbV",
          "commit": {
            "abbreviatedOid": "854e477"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-07T18:06:40Z",
          "updatedAt": "2023-06-07T18:06:40Z",
          "comments": [
            {
              "originalPosition": 352,
              "body": "Looks like the input count should be 11 now? But that might need changes to the test data.",
              "createdAt": "2023-06-07T18:06:40Z",
              "updatedAt": "2023-06-07T18:06:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85XhEsT",
          "commit": {
            "abbreviatedOid": "854e477"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-07T18:07:27Z",
          "updatedAt": "2023-06-07T18:07:27Z",
          "comments": [
            {
              "originalPosition": 397,
              "body": "This section will need more updates for consistency but I think that's a separate PR",
              "createdAt": "2023-06-07T18:07:27Z",
              "updatedAt": "2023-06-07T18:07:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85XhGtO",
          "commit": {
            "abbreviatedOid": "854e477"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "I added a couple comments but LGTM otherwise, thanks Christian! Removing 20+ lines is also nice.\r\n\r\nIn future I may want to suggest moving `c` to the end of the serialized proof so that it's easier to remove \u2013 in the case of multiple combined proofs it doesn't make sense to repeat it. I'm also tempted to reorder Abar before Bbar in the equation :)",
          "createdAt": "2023-06-07T18:13:31Z",
          "updatedAt": "2023-06-07T18:13:31Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85XhP2V",
          "commit": {
            "abbreviatedOid": "854e477"
          },
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-07T18:37:12Z",
          "updatedAt": "2023-06-07T18:37:12Z",
          "comments": [
            {
              "originalPosition": 352,
              "body": "Good point; pushed a fix. Test data will need an update anyway, but the text will already be correct.",
              "createdAt": "2023-06-07T18:37:12Z",
              "updatedAt": "2023-06-07T18:37:12Z"
            }
          ]
        }
      ]
    },
    {
      "number": 258,
      "id": "PR_kwDOF8lax85OGcE3",
      "title": "chore: add greg to acknowledgements",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/258",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Adding Greg to the acknowledgements due to his notable implementation feedback on the spec and contributions to the WG calls over the past several months.",
      "createdAt": "2023-04-12T06:31:11Z",
      "updatedAt": "2023-04-13T19:46:41Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "63db108bad3a40fb71e0d234b8922e8e4efcaac1",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/update-contributors",
      "headRefOid": "396b71a30c71512ef7d18c39b5a7a24438794b45",
      "closedAt": "2023-04-13T19:46:33Z",
      "mergedAt": "2023-04-13T19:46:33Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "d75a4108f0a45985d8b5371d8e965ec73221df90"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Multiple approvals, purely editorial, merging.",
          "createdAt": "2023-04-13T19:46:28Z",
          "updatedAt": "2023-04-13T19:46:28Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax85SYSsw",
          "commit": {
            "abbreviatedOid": "396b71a"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-04-12T20:51:09Z",
          "updatedAt": "2023-04-12T20:51:09Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85SZf7m",
          "commit": {
            "abbreviatedOid": "396b71a"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-04-13T01:35:25Z",
          "updatedAt": "2023-04-13T01:35:25Z",
          "comments": []
        }
      ]
    },
    {
      "number": 259,
      "id": "PR_kwDOF8lax85OGt4Z",
      "title": "chore: add plain english titles",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/259",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Adds plain english titles to key sections, fixes #244 ",
      "createdAt": "2023-04-12T07:28:50Z",
      "updatedAt": "2023-06-12T18:43:32Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "32b4700bdd9f082c57cbdb43b2d28af1a03d8ba8",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/plain-english-titles",
      "headRefOid": "c85bcb867dcae0080c4573070197ece6f1224356",
      "closedAt": "2023-06-12T18:43:28Z",
      "mergedAt": "2023-06-12T18:43:28Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "f6c3ae60e966da5101e15d3895aba972fc12e478"
      },
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on the WG call in the 17th of April. Mentioned that having the short term of the operation by the title (i.e., `Proof Generation (ProofGen)`) may not be consistent, since `Sign` for example, is the title and the function name.\r\n\r\nA couple more comments:\r\n1. We can get around the above by changing `Sign` to `Signature Generation (Sign)` and `Verify` to `Signature Verification (Verify)`. This will keep everything consistent!\r\n2. Should we change `MapMessageToScalar` to `Map Message to Scalar` and `MapMessageToScalarAsHash` to `Map Message to Scalar as Hash` also?? Same thing for the serialization functions.\r\n\r\nSo the TOC I propose is\r\n```\r\n3.1.  Parameters\r\n3.2.  Considerations\r\n  3.2.1.  Subgroup Selection\r\n  3.2.2.  Messages and generators\r\n  3.2.3.  Serializing to octet strings\r\n3.3.  Key Generation Operations\r\n  3.3.1.  Secret Key Generation (KeyGen)\r\n  3.3.2.  Public Key Calculation (SkToPk)\r\n3.4.  Core Operations\r\n  3.4.1.  Signature Generation (Sign)\r\n  3.4.2.  Signature Verification (Verify)\r\n  3.4.3.  Proof Generation (ProofGen)\r\n  3.4.4.  Proof Verification (ProofVerify)\r\n4. Utility Operations\r\n  4.1. Random scalars computation\r\n  4.2. Generator point computation\r\n  4.3. Message to Scalar\r\n    4.3.1. Message to Scalar as Hash\r\n  4.4. Hash to Scalar\r\n  4.5. Domain Calculation\r\n  4.6. Challenge Calculation\r\n  4.7. Serialization\r\n    4.7.1. Serialize\r\n    4.7.2. Signature to Octets\r\n    4.7.3. Octets to Signature\r\n    4.7.4. Proof to Octets\r\n    4.7.5. Octets to Proof\r\n    4.7.6. Octets to Public Key\r\n```",
          "createdAt": "2023-04-19T09:21:30Z",
          "updatedAt": "2023-04-19T09:21:30Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Updated PR with the bellow TOC changes (outside of using the clear text English version)\r\n\r\n```\r\nKeyGen -> Secret Key\r\nSkToPk -> Public Key\r\n\r\nSign -> Signature Generation (Sign)\r\nVerify -> Signature Verification (Verify)\r\nProofGen -> Proof Generation (ProofGen)\r\nProofVerify -> Proof Verification (ProofVerify)\r\n\r\nRandom scalars computation -> Random Scalars\r\nGenerator point computation -> Generators Calculation\r\nMapMessageToScalar -> Message to Scalar\r\nMapMessageToScalarAsHash -> Message to Scalar as Hash\r\n```",
          "createdAt": "2023-06-07T18:13:45Z",
          "updatedAt": "2023-06-07T18:13:45Z"
        },
        {
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes please to better names",
          "createdAt": "2023-06-08T02:16:31Z",
          "updatedAt": "2023-06-08T02:16:31Z"
        },
        {
          "author": "tmarkovski",
          "authorAssociation": "MEMBER",
          "body": "Everyone's favorite topic: naming.\r\n\r\n- Definitely more descriptive names is better. There is inconsistency though in the 3.4 naming. It feels like the short names from the long form want to be \"SignGen\", \"SignVerify\", because \"ProofGen\" and \"ProofVerify\", although \"SignGen\" and \"SignVerify\" sound very odd.\r\n- Does title case matter in the section titles? \"Subgroup Selection\" vs \"Messages and generators\"?\r\n\r\nJust nitpicking",
          "createdAt": "2023-06-08T12:55:43Z",
          "updatedAt": "2023-06-08T12:55:43Z"
        },
        {
          "author": "Wind4Greg",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Definitely an improvement. +1",
          "createdAt": "2023-06-08T17:08:13Z",
          "updatedAt": "2023-06-08T17:08:13Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thank you @tmarkovski!\r\n\r\n> There is inconsistency though in the 3.4 naming. It feels like the short names from the long form want to be \"SignGen\", \"SignVerify\", because \"ProofGen\" and \"ProofVerify\", although \"SignGen\" and \"SignVerify\" sound very odd.\r\n \r\nThat's a good point, but I would note that the short names are the names of the operations, not the short version of the titles. And yes, \"SignGen\" sounds very weird \ud83d\ude1d.\r\n\r\n> Does title case matter in the section titles? \"Subgroup Selection\" vs \"Messages and generators\"?\r\n\r\nYes it does. It should be consisted (i.e., everything should be upper case). Thank you for catching this! Fixed.",
          "createdAt": "2023-06-08T17:12:18Z",
          "updatedAt": "2023-06-08T17:12:18Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Multiple approvals, editorial improvement, merging.",
          "createdAt": "2023-06-12T18:43:25Z",
          "updatedAt": "2023-06-12T18:43:25Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax85XpF0M",
          "commit": {
            "abbreviatedOid": "320fef8"
          },
          "author": "brentzundel",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-06-08T16:44:50Z",
          "updatedAt": "2023-06-08T16:44:50Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85X8vaY",
          "commit": {
            "abbreviatedOid": "c85bcb8"
          },
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2023-06-12T18:17:47Z",
          "updatedAt": "2023-06-12T18:17:47Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85X8ve9",
          "commit": {
            "abbreviatedOid": "c85bcb8"
          },
          "author": "Wind4Greg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-06-12T18:18:01Z",
          "updatedAt": "2023-06-12T18:18:01Z",
          "comments": []
        }
      ]
    },
    {
      "number": 260,
      "id": "PR_kwDOF8lax85O6imP",
      "title": "fix: small typo",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/260",
      "state": "MERGED",
      "author": "tmarkovski",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-04-22T12:38:29Z",
      "updatedAt": "2023-04-23T15:00:52Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "d75a4108f0a45985d8b5371d8e965ec73221df90",
      "headRepository": "tmarkovski/bbs-signature",
      "headRefName": "tm/teh-typo",
      "headRefOid": "66ba663887ca0210b3a1392d07d2e65799591308",
      "closedAt": "2023-04-23T04:33:58Z",
      "mergedAt": "2023-04-23T04:33:58Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "67a93def3b5d077b26457333b75d50ec3222b5e0"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax85TQgUU",
          "commit": {
            "abbreviatedOid": "66ba663"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-04-23T04:33:53Z",
          "updatedAt": "2023-04-23T04:33:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 263,
      "id": "PR_kwDOF8lax85Q9Vy1",
      "title": "Typos fix",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/263",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #253 and #261\r\n\r\nVarious typo fixes.",
      "createdAt": "2023-05-21T16:04:59Z",
      "updatedAt": "2023-06-04T20:28:10Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "67a93def3b5d077b26457333b75d50ec3222b5e0",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "vasilis/typo-fixes",
      "headRefOid": "fd372379039653c283dc73359d5082987f102645",
      "closedAt": "2023-06-04T20:28:10Z",
      "mergedAt": "2023-06-04T20:28:10Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "369cbc622c285fdb40cbb419bb2160abe08a3d97"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Minor editorial improvements, multiple approvals, merging.",
          "createdAt": "2023-06-04T20:28:07Z",
          "updatedAt": "2023-06-04T20:28:07Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax85Waei6",
          "commit": {
            "abbreviatedOid": "fd37237"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-29T18:33:19Z",
          "updatedAt": "2023-05-29T18:33:19Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85XGpYX",
          "commit": {
            "abbreviatedOid": "fd37237"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-06-04T20:26:42Z",
          "updatedAt": "2023-06-04T20:26:42Z",
          "comments": []
        }
      ]
    },
    {
      "number": 264,
      "id": "PR_kwDOF8lax85RChtu",
      "title": "Create generators flexibility",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/264",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #206\r\n\r\nGoing with option 2 from the issue, allowing the definition of new `create_generators` and listing the relative requirements. \u03a4his will also benefit use cases like [Bound signatures](https://github.com/decentralized-identity/bbs-signature/issues/262).",
      "createdAt": "2023-05-22T17:16:21Z",
      "updatedAt": "2023-06-26T18:17:58Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "f6c3ae60e966da5101e15d3895aba972fc12e478",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "vasilis/generators-flexibility",
      "headRefOid": "ea81d680c1a4090b1175eebcfe63365d247f07da",
      "closedAt": "2023-06-26T18:17:53Z",
      "mergedAt": "2023-06-26T18:17:53Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "740e7d3cb9853c0ac7950bf81a25df55acfbdf1a"
      },
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on the WG call on the 29th of May, will re-consider the use of `extra_info` and add the PK as a parameter to the create_generators API.",
          "createdAt": "2023-05-29T18:24:35Z",
          "updatedAt": "2023-05-29T18:24:35Z"
        },
        {
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm not sure I understand the goal of parameterizing the generators creation. Isn't there a value for applications to pre-generate and reuse them across many issuers (which would not be possible of if they depend on an issuer PK).  Is the goal of the `header` to further scope the generators, so an issuer can have multiple distinct generators? Generators can be used to track users, so their uniformity has value. ",
          "createdAt": "2023-06-16T22:05:45Z",
          "updatedAt": "2023-06-16T22:05:45Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The ciphersuite does not have to take the PK and header into account when creating the generators, and the ones defined by the spec will not. It just seemed reasonable to pass those parameters in case the suite wants to define the generators differently (such as how the original implementation did, based on the issuer PK and number of messages). I don't think this increases correlation as the PK and header are known to all verifiers.",
          "createdAt": "2023-06-17T00:34:22Z",
          "updatedAt": "2023-06-17T00:34:22Z"
        },
        {
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I don't think this increases correlation as the PK and header are known to all verifiers.\r\n\r\nWhat header is this again? Is it a ciphersuite defined one, or a per-issuance one? I was just concerned that an issuer could pick a different header to create a \"tagged\" signature for a user.\r\n",
          "createdAt": "2023-06-19T16:56:54Z",
          "updatedAt": "2023-06-19T16:56:54Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It's the signature header, which is per issuance (and may be empty). It contributes to the domain hash.",
          "createdAt": "2023-06-19T17:06:46Z",
          "updatedAt": "2023-06-19T17:06:46Z"
        },
        {
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> It's the signature header, which is per issuance (and may be empty). It contributes to the domain hash.\r\n\r\nOk, so it doesn't add traceability risks then.",
          "createdAt": "2023-06-19T17:10:25Z",
          "updatedAt": "2023-06-19T17:10:25Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think a malicious issuer could use a unique header per signature to track the user. There are plans for adding privacy considerations to address this. The user (or anyone else) could check the header and decide if it is conformant to those considerations. \r\n\r\nIndented use-cases for the header (e.g., to include algorithm/protocol identifiers etc.,) make it hard to define it as part of the ciphersuite.",
          "createdAt": "2023-06-19T17:25:19Z",
          "updatedAt": "2023-06-19T17:25:19Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on the WG call on the 19th of June. Will remove the header parameter from the Inputs of `create_generators`.",
          "createdAt": "2023-06-19T19:03:12Z",
          "updatedAt": "2023-06-19T19:03:12Z"
        },
        {
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Discussed on the WG call on the 19th of June. Will remove the header parameter from the Inputs of `create_generators`.\r\n\r\nThe fixtures from PR #269 currently used the header, right? ",
          "createdAt": "2023-06-23T15:15:21Z",
          "updatedAt": "2023-06-23T15:15:21Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> The fixtures from PR https://github.com/decentralized-identity/bbs-signature/pull/269 currently used the header, right?\r\n\r\nI think the header should be ignored by the create generators procedure. It should be the same procedure, (i.e., `hash_to_generators` == the current `create_generators` from the main spec).\r\n\r\n[Similar to the PK](https://github.com/decentralized-identity/bbs-signature/pull/264/files#diff-af5e5e8fae3b8177ffbea885a6a9b1623c4fb790bc8eeaeef38d92706b30d0d1R1372), it was supplied in the core operations but ignored by the ciphersuite (I did removed the header entirely also)",
          "createdAt": "2023-06-23T19:15:00Z",
          "updatedAt": "2023-06-23T19:15:00Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed on WG call 26th of June, multiple approvals merging.",
          "createdAt": "2023-06-26T18:17:49Z",
          "updatedAt": "2023-06-26T18:17:49Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax85X8wuM",
          "commit": {
            "abbreviatedOid": "a05fbf9"
          },
          "author": "Wind4Greg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-06-12T18:20:48Z",
          "updatedAt": "2023-06-12T18:20:48Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85ZWCpD",
          "commit": {
            "abbreviatedOid": "212728f"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-26T16:31:41Z",
          "updatedAt": "2023-06-26T16:31:41Z",
          "comments": [
            {
              "originalPosition": 154,
              "body": "```suggestion\r\n- Must use proper domain separation for both the `create_generators` procedure, as well as all of the internally-called procedures.\r\n```",
              "createdAt": "2023-06-26T16:31:41Z",
              "updatedAt": "2023-06-26T16:31:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85ZWDEY",
          "commit": {
            "abbreviatedOid": "212728f"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-06-26T16:32:48Z",
          "updatedAt": "2023-06-26T16:32:48Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85ZWuEv",
          "commit": {
            "abbreviatedOid": "212728f"
          },
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2023-06-26T18:14:44Z",
          "updatedAt": "2023-06-26T18:14:44Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85ZWu6f",
          "commit": {
            "abbreviatedOid": "ea81d68"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-06-26T18:16:42Z",
          "updatedAt": "2023-06-26T18:16:42Z",
          "comments": []
        }
      ]
    },
    {
      "number": 266,
      "id": "PR_kwDOF8lax85Sw-vF",
      "title": "PK format and validation",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/266",
      "state": "CLOSED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Addressing point -**A**- from issue #246",
      "createdAt": "2023-06-12T12:02:06Z",
      "updatedAt": "2023-08-07T18:44:02Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "f6c3ae60e966da5101e15d3895aba972fc12e478",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "vasilis/pk-format",
      "headRefOid": "5a415f4d32991ad3345e58c4292904eb3238ee45",
      "closedAt": "2023-08-07T18:44:01Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This PR is conflicting with #268, by introducing further inconsistency on the inputs (points vs octet strings), while 268 tries to define all core operation inputs as octets.\r\n\r\nConverting to draft until #268 is resolved.",
          "createdAt": "2023-06-19T19:16:17Z",
          "updatedAt": "2023-06-19T19:16:17Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on the WG call of the 7th of Aug. Will close as no longer applicable.",
          "createdAt": "2023-08-07T18:19:50Z",
          "updatedAt": "2023-08-07T18:19:50Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax85Ye3Ob",
          "commit": {
            "abbreviatedOid": "5a415f4"
          },
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2023-06-16T22:10:29Z",
          "updatedAt": "2023-06-16T22:10:29Z",
          "comments": []
        }
      ]
    },
    {
      "number": 267,
      "id": "PR_kwDOF8lax85SyYYn",
      "title": "Error handling",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/267",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Implicitly handle errors form the utility sub-routines in the core operations + address point **B** from #246",
      "createdAt": "2023-06-12T15:30:09Z",
      "updatedAt": "2023-07-06T20:13:51Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "f363a216096b8414524c7dc03c3654ec61aa817d",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "vasilis/suites-format",
      "headRefOid": "7b5ba78b7de09949bd637a1bf86bacdaf9914524",
      "closedAt": "2023-07-06T20:13:51Z",
      "mergedAt": "2023-07-06T20:13:51Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "8e6106a98e8bdd87a77c673704f110726fd2cb77"
      },
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Updated the PR with the following\r\n\r\n- Introduced `ABORT` (like in h2c). An operation will `ABORT` if some of the Precoditions are not met. Any operation calling a function that ABORTed will also `ABORT`.\r\n- If `expand_message` ABORTs (which [it may](https://www.ietf.org/archive/id/draft-irtf-cfrg-hash-to-curve-16.html#name-expand_message_xmd)), `hash_to_scalar` will also ABORT, so no need for checking explicitly its result (or require `expand_len` to be defined in a way that will not cause `expand_message` to fail, which may not always be possible).\r\n- `return INVALID` is used for errors in the Deserialization/Procedure (like getting an invalid signature or deserializing a malformed proof). A subroutine's INVALID result is explicitly handled by the calling operation.\r\n- Updated `hash_to_scalar` and `create_generators` to NOT check for 0, duplicates etc.\r\n\r\nIMO this gives the more readable result.",
          "createdAt": "2023-06-14T12:08:30Z",
          "updatedAt": "2023-06-14T18:43:35Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "### Breaking Changes\r\n1. In `hash_to_scalar` removed the `counter`\r\n2. In `create_generators` step 3, changed `I2OSP(i, 4)` to `I2OSP(i, 8)`\r\n\r\n\r\n(\"1.\" is because I removed the checks for 0 and \"2.\"  is to align the max number of messages with the max number of generators)  ",
          "createdAt": "2023-06-20T11:06:41Z",
          "updatedAt": "2023-06-20T11:06:41Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Ready for merge, subject to resolving the conflicts.",
          "createdAt": "2023-06-26T18:47:08Z",
          "updatedAt": "2023-06-26T18:47:08Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax85YfCKe",
          "commit": {
            "abbreviatedOid": "af7e05d"
          },
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Improves readability",
          "createdAt": "2023-06-16T22:54:29Z",
          "updatedAt": "2023-06-16T22:54:29Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85YnS1f",
          "commit": {
            "abbreviatedOid": "d16bd79"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-19T18:28:35Z",
          "updatedAt": "2023-06-19T18:28:35Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\n: Error indicators. INVALID refers to an error encountered during the Deserialization or Procedure steps of an operation. An INVALID value can be returned by a subroutine and handled by the calling operation. ABORT indicates that one or more of the initial constraints defined by the operation are not met. In that case, the operation will stop execution. An operation calling a subroutine that aborted must also immediately abort.\r\n```",
              "createdAt": "2023-06-19T18:28:35Z",
              "updatedAt": "2023-06-19T18:28:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85YnTSR",
          "commit": {
            "abbreviatedOid": "d16bd79"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-19T18:30:39Z",
          "updatedAt": "2023-06-19T18:30:40Z",
          "comments": [
            {
              "originalPosition": 129,
              "body": "Seems like there's a change to the indentation here",
              "createdAt": "2023-06-19T18:30:39Z",
              "updatedAt": "2023-06-19T18:30:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85YnTXX",
          "commit": {
            "abbreviatedOid": "d16bd79"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-19T18:31:03Z",
          "updatedAt": "2023-06-19T18:31:03Z",
          "comments": [
            {
              "originalPosition": 173,
              "body": "Also here on the indentation",
              "createdAt": "2023-06-19T18:31:03Z",
              "updatedAt": "2023-06-19T18:31:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85YnTg5",
          "commit": {
            "abbreviatedOid": "d16bd79"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-19T18:31:48Z",
          "updatedAt": "2023-06-19T18:31:49Z",
          "comments": [
            {
              "originalPosition": 222,
              "body": "```suggestion\r\n- expand_len, defined by the ciphersuite.\r\n```",
              "createdAt": "2023-06-19T18:31:49Z",
              "updatedAt": "2023-06-19T18:31:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85YnUNS",
          "commit": {
            "abbreviatedOid": "d16bd79"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-19T18:35:37Z",
          "updatedAt": "2023-06-19T18:35:38Z",
          "comments": [
            {
              "originalPosition": 405,
              "body": "I believe this would be checked by `serialize`?",
              "createdAt": "2023-06-19T18:35:38Z",
              "updatedAt": "2023-06-19T18:35:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85Yrmna",
          "commit": {
            "abbreviatedOid": "d16bd79"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-20T10:29:26Z",
          "updatedAt": "2023-06-20T10:29:26Z",
          "comments": [
            {
              "originalPosition": 129,
              "body": "Fixed!",
              "createdAt": "2023-06-20T10:29:26Z",
              "updatedAt": "2023-06-20T10:29:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85Yrmpq",
          "commit": {
            "abbreviatedOid": "d16bd79"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-20T10:29:32Z",
          "updatedAt": "2023-06-20T10:29:32Z",
          "comments": [
            {
              "originalPosition": 173,
              "body": "Fixed!",
              "createdAt": "2023-06-20T10:29:32Z",
              "updatedAt": "2023-06-20T10:29:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85Yrmtc",
          "commit": {
            "abbreviatedOid": "d16bd79"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-20T10:29:41Z",
          "updatedAt": "2023-06-20T10:29:42Z",
          "comments": [
            {
              "originalPosition": 222,
              "body": "Fixed! Thanks!",
              "createdAt": "2023-06-20T10:29:42Z",
              "updatedAt": "2023-06-20T10:29:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85Yrx8i",
          "commit": {
            "abbreviatedOid": "d16bd79"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-20T10:58:15Z",
          "updatedAt": "2023-06-20T10:58:15Z",
          "comments": [
            {
              "originalPosition": 405,
              "body": "Yes. Iv added these checks here to ABORT instead of returning INVALID (which we would have to do if we were relying on `serialize` for the checks).\r\n\r\nThat way we don't have to check the result of `calculate_challenge` and `calculate_domain` in the core operations.",
              "createdAt": "2023-06-20T10:58:15Z",
              "updatedAt": "2023-06-20T10:58:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85ZV8yM",
          "commit": {
            "abbreviatedOid": "f466da9"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-06-26T16:17:57Z",
          "updatedAt": "2023-06-26T16:17:57Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85ZlkF7",
          "commit": {
            "abbreviatedOid": "7b5ba78"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-06-28T12:56:33Z",
          "updatedAt": "2023-06-28T12:56:33Z",
          "comments": []
        }
      ]
    },
    {
      "number": 268,
      "id": "PR_kwDOF8lax85TBWlc",
      "title": "Message to Scalar flexibility",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/268",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fix #245\r\n\r\nDefine input messages as octet strings and explicitly call `messages_to_scalars` in each operation.\r\n\r\nNote this makes #266 obsolete, since it enforces consistency on the input arguments (everything are octets now).\r\n\r\nBased on #267 to avoid the extra explicit checks (would be couple of steps)",
      "createdAt": "2023-06-14T18:06:10Z",
      "updatedAt": "2023-07-10T18:31:41Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "8e6106a98e8bdd87a77c673704f110726fd2cb77",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "vasilis/messages-format",
      "headRefOid": "8c71c2c7ccd52398680c9317acd4e694c1b1773b",
      "closedAt": "2023-07-10T18:31:41Z",
      "mergedAt": "2023-07-10T18:31:41Z",
      "mergedBy": "BasileiosKal",
      "mergeCommit": {
        "oid": "06338409b5c6dc24bf79426ab7b038de70ca591e"
      },
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on the WG call on the 19th of June, will define the Input of `messages_to_scalars` to be typed elements instead of octet strings.",
          "createdAt": "2023-06-19T19:02:21Z",
          "updatedAt": "2023-06-19T19:02:21Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Updated the PR as discussed om the WG call.\r\n\r\n### A message can now be a scalar or an octet string.\r\n\r\nDid not allow a message to be an integer. Reason is that if a `msg` is an int > r, then what would essentially get signed would be `msg' = msg mod r`, meaning that the signature would be valid for both `msg` and `msg'` (`< msg`), which seems wrong (especially taking into account range proofs).\r\n\r\nIf there is a need to sign an int > r, one could scale it down to make it a scalar. You could still use range proofs that way. \r\n\r\nDifferentiating between a scalar like a SK, and a date intended to be used in range proofs would only be possible on the basis of those messages indexes.\r\n\r\nAlso I don't think signed ints are needed either but I opened #270 to discuss this further.\r\n\r\nc.c @andrewwhitehead \ud83d\ude4f ",
          "createdAt": "2023-06-20T19:18:38Z",
          "updatedAt": "2023-06-20T19:18:38Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I put in some suggestions for using `MESSAGES_TO_SCALARS_ID`, but perhaps `OCTETS_TO_SCALARS_ID` would make more sense and avoid overuse of the term 'messages'?",
          "createdAt": "2023-06-26T16:16:06Z",
          "updatedAt": "2023-06-26T16:16:06Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Updated the operation. As discussed in the WG, added a `map_to_scalar` operation, that will map a `(msg, idx)` pair to a scalar.\r\n\r\n1. Turns out that if a msg is a scalar, simply returning it (while hashing the octet strings) is not secure. There is no way to know that what was signed is the octet string `msg` and not the `scalar = hash_to_scalar(msg)`.\r\n2. Did not use `octet_to_scalar` for the same reason.\r\n\r\ncc @andrewwhitehead i think the PR is ready for re-review!",
          "createdAt": "2023-07-02T16:28:06Z",
          "updatedAt": "2023-07-02T16:28:06Z"
        },
        {
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As mentioned in the discussion in today's WG call: U-Prove allows both direct encoding and hashing the attributes. This is useful, within _one_ ciphersuite, to allow encoding attributes of different types in one credential (e.g.: hash name, address, etc., but encode directly age and expiration to allow range proofs). See the `e` values in the Issuer params (section 2.3.1 of the [crypto spec](https://github.com/microsoft/uprove-node-reference/blob/main/doc/U-Prove%20Cryptographic%20Specification%20V1.1%20Revision%205.pdf)).",
          "createdAt": "2023-07-10T18:30:16Z",
          "updatedAt": "2023-07-10T18:30:30Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on the WG call on the 10th of July. Merging and will open an Issue to keep track of the conversation.",
          "createdAt": "2023-07-10T18:31:33Z",
          "updatedAt": "2023-07-10T18:31:33Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax85ZV4Zc",
          "commit": {
            "abbreviatedOid": "3c6cba6"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-26T16:07:29Z",
          "updatedAt": "2023-06-26T16:07:29Z",
          "comments": [
            {
              "originalPosition": 163,
              "body": "```suggestion\r\n- disclosed_messages (OPTIONAL), a vector of input_messages. If not\r\n```",
              "createdAt": "2023-06-26T16:07:29Z",
              "updatedAt": "2023-06-26T16:07:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85ZV5Mp",
          "commit": {
            "abbreviatedOid": "3c6cba6"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-26T16:09:16Z",
          "updatedAt": "2023-06-26T16:09:16Z",
          "comments": [
            {
              "originalPosition": 199,
              "body": "```suggestion\r\nEvery `messages_to_scalars` operation MUST define a unique `MESSAGES_TO_SCALARS_ID` value to be used by the ciphersuite. This value MUST only contain ASCII encoded characters with codes between 0x21 and 0x7e (inclusive) and MUST end with an underscore (ASCII code: 0x5f), other than the last character the string MUST not contain any other underscores (ASCII code: 0x5f).\r\n```\r\n\r\nI think it's better to spell it out.",
              "createdAt": "2023-06-26T16:09:16Z",
              "updatedAt": "2023-06-26T16:09:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85ZV5lC",
          "commit": {
            "abbreviatedOid": "3c6cba6"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-26T16:10:10Z",
          "updatedAt": "2023-06-26T16:10:10Z",
          "comments": [
            {
              "originalPosition": 234,
              "body": "Seems odd for us to use MSG here instead of MESSAGE",
              "createdAt": "2023-06-26T16:10:10Z",
              "updatedAt": "2023-06-26T16:10:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85ZV5pS",
          "commit": {
            "abbreviatedOid": "3c6cba6"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-26T16:10:19Z",
          "updatedAt": "2023-06-26T16:10:19Z",
          "comments": [
            {
              "originalPosition": 244,
              "body": "```suggestion\r\nThe `MESSAGES_TO_SCALARS_ID` of the `hash_messages_to_scalar` is defines as,\r\n```",
              "createdAt": "2023-06-26T16:10:19Z",
              "updatedAt": "2023-06-26T16:10:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85ZV5sy",
          "commit": {
            "abbreviatedOid": "3c6cba6"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-26T16:10:27Z",
          "updatedAt": "2023-06-26T16:10:27Z",
          "comments": [
            {
              "originalPosition": 247,
              "body": "```suggestion\r\nMESSAGES_TO_SCALARS_ID = \"HM2S_\"\r\n```",
              "createdAt": "2023-06-26T16:10:27Z",
              "updatedAt": "2023-06-26T16:10:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85ZV6rB",
          "commit": {
            "abbreviatedOid": "3c6cba6"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-26T16:12:48Z",
          "updatedAt": "2023-06-26T16:12:48Z",
          "comments": [
            {
              "originalPosition": 247,
              "body": "Having M2S in the identifier seems redundant to me. H2F might be better to refer to hash_to_field in the H2C spec.",
              "createdAt": "2023-06-26T16:12:48Z",
              "updatedAt": "2023-06-26T16:12:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85ZV63q",
          "commit": {
            "abbreviatedOid": "3c6cba6"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-26T16:13:17Z",
          "updatedAt": "2023-06-26T16:13:17Z",
          "comments": [
            {
              "originalPosition": 276,
              "body": "```suggestion\r\n  \"BBS_\" || H2C_SUITE_ID || MESSAGES_TO_SCALARS_ID || ADD_INFO\r\n```",
              "createdAt": "2023-06-26T16:13:17Z",
              "updatedAt": "2023-06-26T16:13:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85ZV69D",
          "commit": {
            "abbreviatedOid": "3c6cba6"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-26T16:13:30Z",
          "updatedAt": "2023-06-26T16:13:30Z",
          "comments": [
            {
              "originalPosition": 281,
              "body": "```suggestion\r\n  *  MESSAGES\\_TO\\_SCALARS\\_ID is the ID of the messages\\_to\\_scalars operation, as defined in (#messages-to-scalars).\r\n```",
              "createdAt": "2023-06-26T16:13:30Z",
              "updatedAt": "2023-06-26T16:13:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85ZWxF7",
          "commit": {
            "abbreviatedOid": "3c6cba6"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-26T18:22:58Z",
          "updatedAt": "2023-06-26T18:22:58Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "```suggestion\r\ninput\\_message\r\n: An input message to be signed by the signature scheme. An input\\_message can either be either an octet string or a scalar.\r\n```",
              "createdAt": "2023-06-26T18:22:58Z",
              "updatedAt": "2023-06-26T18:22:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85aM0Au",
          "commit": {
            "abbreviatedOid": "51544f3"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-04T19:07:57Z",
          "updatedAt": "2023-07-04T19:07:57Z",
          "comments": [
            {
              "originalPosition": 288,
              "body": "Within reasonable guarantees of collision avoidance?",
              "createdAt": "2023-07-04T19:07:57Z",
              "updatedAt": "2023-07-04T19:07:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85aM0OO",
          "commit": {
            "abbreviatedOid": "51544f3"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-04T19:09:29Z",
          "updatedAt": "2023-07-04T19:09:29Z",
          "comments": [
            {
              "originalPosition": 237,
              "body": "Hm, this seems to mean that any application which wants to pre-process the messages as mentioned above, must use a ciphersuite not defined by this document, with a different mapping function.",
              "createdAt": "2023-07-04T19:09:29Z",
              "updatedAt": "2023-07-04T19:09:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85aYX0Q",
          "commit": {
            "abbreviatedOid": "51544f3"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-06T11:30:32Z",
          "updatedAt": "2023-07-06T11:30:32Z",
          "comments": [
            {
              "originalPosition": 237,
              "body": "Yeap that was the indent. It seems that there is no way to define protocol-agnostic handling of scalar values (i.e., something like `if msg a scalar, return msg` does not work). \r\n\r\nRules need to be more strict and also consider the index of a message (for example the 1st message is expected to be a scalar, etc). So a ciphersuite defined protocol-specific mapping seems unavoidable.",
              "createdAt": "2023-07-06T11:30:32Z",
              "updatedAt": "2023-07-06T11:30:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85aaZG8",
          "commit": {
            "abbreviatedOid": "51544f3"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-06T16:01:02Z",
          "updatedAt": "2023-07-06T16:01:02Z",
          "comments": [
            {
              "originalPosition": 237,
              "body": "You can always also define the `map_to_scalar` operation to just accept scalars and be the identity, and then apply whatever pre processing you want??",
              "createdAt": "2023-07-06T16:01:02Z",
              "updatedAt": "2023-07-06T16:01:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85aakEd",
          "commit": {
            "abbreviatedOid": "51544f3"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-06T16:25:39Z",
          "updatedAt": "2023-07-06T16:25:40Z",
          "comments": [
            {
              "originalPosition": 288,
              "body": "Updated! Thanks!",
              "createdAt": "2023-07-06T16:25:39Z",
              "updatedAt": "2023-07-06T16:25:40Z"
            }
          ]
        }
      ]
    },
    {
      "number": 269,
      "id": "PR_kwDOF8lax85TIjrN",
      "title": "Fixtures update",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/269",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Updated fixtures based on the latest draft + changes from #186 and #264\r\n\r\nAlso fixes #252",
      "createdAt": "2023-06-15T20:55:08Z",
      "updatedAt": "2023-06-26T18:19:10Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "f6c3ae60e966da5101e15d3895aba972fc12e478",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "vasilis/fixtures-update",
      "headRefOid": "87613395f4ba9092270f4b74f1a0782552ce0854",
      "closedAt": "2023-06-26T18:19:06Z",
      "mergedAt": "2023-06-26T18:19:06Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "d4d4b9442dae7be93f1738840abd26ee955baee5"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Greg has verified these fixtures, multiple others are in the progress, merging in the meantime to help implementers with fetching a consistent version of the spec and fixtures from one document.",
          "createdAt": "2023-06-26T18:19:02Z",
          "updatedAt": "2023-06-26T18:19:02Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax85ZItfp",
          "commit": {
            "abbreviatedOid": "8761339"
          },
          "author": "Wind4Greg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Verified all test vectors against my JavaScript implementation that utilizes the noble/curves BLS12-381 library.",
          "createdAt": "2023-06-23T16:25:13Z",
          "updatedAt": "2023-06-23T16:25:13Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85ZWtVR",
          "commit": {
            "abbreviatedOid": "8761339"
          },
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "My implementation can validate these new vectors.",
          "createdAt": "2023-06-26T18:12:50Z",
          "updatedAt": "2023-06-26T18:12:50Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85ZWtbN",
          "commit": {
            "abbreviatedOid": "8761339"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-06-26T18:13:06Z",
          "updatedAt": "2023-06-26T18:13:06Z",
          "comments": []
        }
      ]
    },
    {
      "number": 271,
      "id": "PR_kwDOF8lax85UC3M2",
      "title": "Remove unused `epxand_dst` definition in Sign operation",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/271",
      "state": "MERGED",
      "author": "tmarkovski",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "`expand_dst` is no longer used in the Sign operation",
      "createdAt": "2023-06-27T14:32:16Z",
      "updatedAt": "2023-06-27T17:25:56Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "d4d4b9442dae7be93f1738840abd26ee955baee5",
      "headRepository": "tmarkovski/bbs-signature",
      "headRefName": "tm/remove-expand-dst",
      "headRefOid": "b0838bf08fa341221a6ad9622817c05da3162997",
      "closedAt": "2023-06-27T17:25:55Z",
      "mergedAt": "2023-06-27T17:25:55Z",
      "mergedBy": "BasileiosKal",
      "mergeCommit": {
        "oid": "f363a216096b8414524c7dc03c3654ec61aa817d"
      },
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Multiple approvals! Removing \"dead code\". Merging! Thank you @tmarkovski \ud83d\ude4f ",
          "createdAt": "2023-06-27T17:25:51Z",
          "updatedAt": "2023-06-27T17:25:51Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax85ZenO8",
          "commit": {
            "abbreviatedOid": "b0838bf"
          },
          "author": "brentzundel",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-06-27T15:16:41Z",
          "updatedAt": "2023-06-27T15:16:41Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85ZewvK",
          "commit": {
            "abbreviatedOid": "b0838bf"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-06-27T15:28:29Z",
          "updatedAt": "2023-06-27T15:28:29Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85ZfxVB",
          "commit": {
            "abbreviatedOid": "b0838bf"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-06-27T17:24:51Z",
          "updatedAt": "2023-06-27T17:24:51Z",
          "comments": []
        }
      ]
    },
    {
      "number": 272,
      "id": "PR_kwDOF8lax85UcsGD",
      "title": "fix: shake256 mockrng fixture",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/272",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-07-02T16:57:31Z",
      "updatedAt": "2023-07-06T20:00:43Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "f363a216096b8414524c7dc03c3654ec61aa817d",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "vasilis/mockrng-fixture",
      "headRefOid": "830d4658378700627308091a643faee4c38cc45d",
      "closedAt": "2023-07-06T20:00:43Z",
      "mergedAt": "2023-07-06T20:00:43Z",
      "mergedBy": "BasileiosKal",
      "mergeCommit": {
        "oid": "6dc0f35f15ce3de9c8c32d99cb1ee7d72cba6a22"
      },
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "New fixture got cross validated! merging! Thanks @christianpaquin",
          "createdAt": "2023-07-06T20:00:35Z",
          "updatedAt": "2023-07-06T20:00:35Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax85aA8KP",
          "commit": {
            "abbreviatedOid": "830d465"
          },
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "My implementation ([on PR21](https://github.com/microsoft/bbs-node-reference/pull/21)) validates these values.",
          "createdAt": "2023-07-03T01:52:58Z",
          "updatedAt": "2023-07-03T01:52:58Z",
          "comments": []
        }
      ]
    },
    {
      "number": 273,
      "id": "PR_kwDOF8lax85UddOl",
      "title": "Update test vectors",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/273",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Test vectors for #267 and #268.\r\n\r\n## Breaking changes from the PRs\r\n\r\n1. From #267\r\n\r\n    - `hash_to_scalar`:  removed `count`. There is no longer a loop and the input to `expand_message` is just `msg_octets` instead of `msg_prime = msg_octets || I2OSP(count, 8)`\r\n    - `creat_generators`: removed `n` (and the check at step 8) and went from `I2OSP(n, 4)` to `I2OSP(i, 8)` in the input to `expand_message` when calculating `v`.\r\n\r\n2. From #268\r\n\r\n    - `ciphersuite_id`: added `HM2S_` at the end (the `MAP_TO_SCALAR_ID` of the `map_to_scalar` operation).",
      "createdAt": "2023-07-02T22:10:13Z",
      "updatedAt": "2023-07-10T18:33:38Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "8e6106a98e8bdd87a77c673704f110726fd2cb77",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "vasilis/draft03-fixtures",
      "headRefOid": "768ec26d603867e7a6af3ec4aebfc7025795a1a2",
      "closedAt": "2023-07-10T18:33:38Z",
      "mergedAt": "2023-07-10T18:33:38Z",
      "mergedBy": "BasileiosKal",
      "mergeCommit": {
        "oid": "380b454986264bb26897d218ec2213fa2462f6de"
      },
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Note that the test vectors use variable length messages now (with one of the messages being empty). Addresses one of the comments in #223.",
          "createdAt": "2023-07-03T09:33:07Z",
          "updatedAt": "2023-07-03T09:33:07Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on the WG call of the 10th of July. Fixtures are cross validated. Mergin",
          "createdAt": "2023-07-10T18:33:34Z",
          "updatedAt": "2023-07-10T18:33:34Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 274,
      "id": "PR_kwDOF8lax85UhBTa",
      "title": "Add no header/ph fixtures",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/274",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Together with #273 will close #223.",
      "createdAt": "2023-07-03T11:30:52Z",
      "updatedAt": "2023-07-10T19:53:37Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "380b454986264bb26897d218ec2213fa2462f6de",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "vasilis/no-header-ph-fixtures",
      "headRefOid": "bcf59752d4c9826e06cabe563fd1c44a645af8b4",
      "closedAt": "2023-07-10T19:53:36Z",
      "mergedAt": "2023-07-10T19:53:36Z",
      "mergedBy": "BasileiosKal",
      "mergeCommit": {
        "oid": "e6d444e3874df2016d9c61d960d12bbef2045585"
      },
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on the WG call of the 10th of July. Will rebase and merge afterwards.",
          "createdAt": "2023-07-10T18:37:31Z",
          "updatedAt": "2023-07-10T18:37:31Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on the WG call on the 10th of July. Approved. Vectors are cross validated! Merging",
          "createdAt": "2023-07-10T19:53:29Z",
          "updatedAt": "2023-07-10T19:53:29Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax85awxAR",
          "commit": {
            "abbreviatedOid": "65baa33"
          },
          "author": "Wind4Greg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-07-10T18:55:54Z",
          "updatedAt": "2023-07-10T18:55:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 275,
      "id": "PR_kwDOF8lax85Uixja",
      "title": "Various editorial updates",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/275",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Main changes:\r\n- Renaming the base points of G1/G2\r\n- Removed the `Definitions` (we are explicitly defining everything in the operation)\r\n- Updated the ProofGen/ProofVerify explanatory section\r\n\r\n\\+ couple of terminology and operation description updates",
      "createdAt": "2023-07-03T16:37:17Z",
      "updatedAt": "2023-07-10T20:20:59Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "e6d444e3874df2016d9c61d960d12bbef2045585",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "vasilis/editorial-updates",
      "headRefOid": "afd617024884eb24356362837bcf04ae95c08319",
      "closedAt": "2023-07-10T20:20:59Z",
      "mergedAt": "2023-07-10T20:20:59Z",
      "mergedBy": "BasileiosKal",
      "mergeCommit": {
        "oid": "47a78fccf6116f7d0847da0ebf0ab6a280e294e8"
      },
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on the WG call on the 10 of July. Will wait for reviews before resolving",
          "createdAt": "2023-07-10T18:44:55Z",
          "updatedAt": "2023-07-10T18:44:55Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on the WG call of the 10th of July. Multiple approvals. Editorial updates. Merging",
          "createdAt": "2023-07-10T20:20:56Z",
          "updatedAt": "2023-07-10T20:20:56Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax85aM1Cu",
          "commit": {
            "abbreviatedOid": "23b5049"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-04T19:15:11Z",
          "updatedAt": "2023-07-04T19:15:11Z",
          "comments": [
            {
              "originalPosition": 155,
              "body": "Is this a line length issue? Also, switching the order of Abar and Bbar without switching r2 and r3 doesn't seem worth it to me :)",
              "createdAt": "2023-07-04T19:15:11Z",
              "updatedAt": "2023-07-04T19:15:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85aM1aU",
          "commit": {
            "abbreviatedOid": "23b5049"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-04T19:18:04Z",
          "updatedAt": "2023-07-04T19:18:04Z",
          "comments": [
            {
              "originalPosition": 259,
              "body": "Maybe 'knowledge' instead of 'ownership'?",
              "createdAt": "2023-07-04T19:18:04Z",
              "updatedAt": "2023-07-04T19:18:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85aYQV6",
          "commit": {
            "abbreviatedOid": "23b5049"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-06T11:10:37Z",
          "updatedAt": "2023-07-06T11:10:38Z",
          "comments": [
            {
              "originalPosition": 155,
              "body": "Oh boy another breaking change \ud83d\ude05. Switched r2 with r3 in #276 (with updated fixtures)",
              "createdAt": "2023-07-06T11:10:37Z",
              "updatedAt": "2023-07-06T11:10:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85aYQaw",
          "commit": {
            "abbreviatedOid": "23b5049"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-06T11:10:51Z",
          "updatedAt": "2023-07-06T11:10:51Z",
          "comments": [
            {
              "originalPosition": 155,
              "body": "> Is this a line length issue?\r\n\r\nYeap sadly",
              "createdAt": "2023-07-06T11:10:51Z",
              "updatedAt": "2023-07-06T11:10:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85aaWXT",
          "commit": {
            "abbreviatedOid": "23b5049"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-06T15:54:26Z",
          "updatedAt": "2023-07-06T15:54:26Z",
          "comments": [
            {
              "originalPosition": 259,
              "body": "Updated! Thanks!",
              "createdAt": "2023-07-06T15:54:26Z",
              "updatedAt": "2023-07-06T15:54:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85aiWB8",
          "commit": {
            "abbreviatedOid": "321bbf6"
          },
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-07T13:50:42Z",
          "updatedAt": "2023-07-07T13:55:20Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Why not BP1 and BP2, the `'` character might be hard to understand in the middle of the spec.",
              "createdAt": "2023-07-07T13:50:42Z",
              "updatedAt": "2023-07-07T13:55:20Z"
            },
            {
              "originalPosition": 127,
              "body": "Change `C` to `T` on line 12 since it's been renamed.",
              "createdAt": "2023-07-07T13:51:19Z",
              "updatedAt": "2023-07-07T13:55:51Z"
            },
            {
              "originalPosition": 29,
              "body": "We don't use BP (the G1 base point) in the spec, so we can get rid of it.",
              "createdAt": "2023-07-07T13:54:41Z",
              "updatedAt": "2023-07-07T13:56:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85ajmg0",
          "commit": {
            "abbreviatedOid": "321bbf6"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-07T16:37:57Z",
          "updatedAt": "2023-07-07T16:37:58Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "The indent was to use the notation from[ pairing-friendly curves](https://www.ietf.org/archive/id/draft-irtf-cfrg-pairing-friendly-curves-08.html#name-bls-curves-for-the-128-bit-) draft. But yea its hard to see. Changed to use `BP1` and `BP2`.",
              "createdAt": "2023-07-07T16:37:57Z",
              "updatedAt": "2023-07-07T16:37:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85ajmj9",
          "commit": {
            "abbreviatedOid": "321bbf6"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-07T16:38:07Z",
          "updatedAt": "2023-07-07T16:38:07Z",
          "comments": [
            {
              "originalPosition": 127,
              "body": "Fixed. Thanks!",
              "createdAt": "2023-07-07T16:38:07Z",
              "updatedAt": "2023-07-07T16:38:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85ajnAF",
          "commit": {
            "abbreviatedOid": "321bbf6"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-07T16:39:38Z",
          "updatedAt": "2023-07-07T16:39:38Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "`BP` (renamed to `BP1`) is used in the PR in the description of `P1` [in the ciphersuite](https://github.com/decentralized-identity/bbs-signature/pull/275/files#diff-af5e5e8fae3b8177ffbea885a6a9b1623c4fb790bc8eeaeef38d92706b30d0d1R1212) (i.e., that `P1 != BP1`). \r\n\r\nStill could most likely remove it, but better be on the safe side??",
              "createdAt": "2023-07-07T16:39:38Z",
              "updatedAt": "2023-07-07T16:40:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85aws2g",
          "commit": {
            "abbreviatedOid": "49f2fd5"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-10T18:43:05Z",
          "updatedAt": "2023-07-10T18:43:13Z",
          "comments": [
            {
              "originalPosition": 162,
              "body": "```suggestion\r\n```",
              "createdAt": "2023-07-10T18:43:06Z",
              "updatedAt": "2023-07-10T18:43:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85awtWG",
          "commit": {
            "abbreviatedOid": "9e8268d"
          },
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-07-10T18:44:26Z",
          "updatedAt": "2023-07-10T18:44:26Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85awwtc",
          "commit": {
            "abbreviatedOid": "9e8268d"
          },
          "author": "Wind4Greg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-07-10T18:55:00Z",
          "updatedAt": "2023-07-10T18:55:00Z",
          "comments": []
        }
      ]
    },
    {
      "number": 276,
      "id": "PR_kwDOF8lax85Uo9Yh",
      "title": "Put the challenge at the end",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/276",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fix #265\r\n\r\nMove the challenge value `c` at the end of the proof value. Specifically, the proof becomes\r\n\r\n```\r\nproof = (Abar, Bbar, r2^, r3^, (m^_j1, ..., m^_jU), c)\r\n```\r\n\r\nAlso change `Abar` with `Bbar` in ProofGen and `ProofVerify`",
      "createdAt": "2023-07-04T18:45:47Z",
      "updatedAt": "2023-07-10T18:52:24Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "vasilis/no-header-ph-fixtures",
      "baseRefOid": "8c9d497556a9928437d845e938b878199ead4d76",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "vasilis/challenge-index",
      "headRefOid": "2b7469f842aef123a63b9eccc8f281a4a808f7e9",
      "closedAt": "2023-07-10T18:52:24Z",
      "mergedAt": "2023-07-10T18:52:24Z",
      "mergedBy": "BasileiosKal",
      "mergeCommit": {
        "oid": "65baa33409c3d45013038b312450bc27982f3667"
      },
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "## Breaking Changes\r\n\r\n1. moved the challenge `c` value at the end of the proof value (requires an update to the proof serialization/de-serialization operations).\r\n2. In `ProofGen`. At step 11 during `C` calculation, switched `Abar` with `Bbar`. I.e., \r\n    ```\r\n    C = Bbar * r2 + Abar * r3 + ...  -->>  C = Abar * r2 + Bbar * r3 + ...\r\n    ```\r\n    Also in step 15 and 16 of `ProofGen`, the following changed (`e` \"moved\" from `r3^` to `r2^`)\r\n    ```\r\n    15. r2^ = r2 + r4 * c      -->>  r2^ = r2 + r4 * e * c\r\n    16. r3^ = r3 + r4 * e * c  -->>  r3^ = r3 + r4 * c\r\n    ```\r\n3. In `ProofVerify`, at step 8, again change `Abar` with `Bbar` during `C` calculation, i.e., \r\n    ```\r\n     C = Bbar * r2^ + Abar * r3^ + ...   -->>   C = Abar * r2^ + Bbar * r3^ + ...\r\n    ```",
          "createdAt": "2023-07-06T11:29:45Z",
          "updatedAt": "2023-07-06T11:29:45Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@andrewwhitehead, I'm really sorry, but there are some more changes to review \ud83d\ude4f",
          "createdAt": "2023-07-06T16:24:48Z",
          "updatedAt": "2023-07-06T16:24:48Z"
        },
        {
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "~Is this captured in any test vectors?~ Never mind, I see they are part of the PR itself.",
          "createdAt": "2023-07-06T21:16:48Z",
          "updatedAt": "2023-07-07T00:37:50Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hey Greg \ud83d\udc4b  The swapping is mainly for readability. Note that we just want to calculate `Abar * a_random_number + Bbar * another_random_number`. It is just a bit more sense to have `Abar * r2 + Bbar * r3` instead of `Bbar * r2 + Abar * r3`.\r\n\r\nThis does not go against the paper. It is just a naming convention. Another way to think of it, is instead of \"swapping\" `Abar` and `Bbar` we \"renaming\" `r2` to `r3`.\r\n\r\nThe reason it is a breaking change is that we have deterministic random number generation for testing.",
          "createdAt": "2023-07-07T19:06:52Z",
          "updatedAt": "2023-07-07T19:06:52Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on the WG call on the 10th of July. Test vectors are cross validated by multiple implementations. Merging.",
          "createdAt": "2023-07-10T18:52:18Z",
          "updatedAt": "2023-07-10T18:52:18Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax85aM1fn",
          "commit": {
            "abbreviatedOid": "d9f5e08"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-07-04T19:18:44Z",
          "updatedAt": "2023-07-04T19:18:44Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85adsAT",
          "commit": {
            "abbreviatedOid": "61fe83b"
          },
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Some minor editorial comments. Implemented the update in my library ([PR 23](https://github.com/microsoft/bbs-node-reference/pull/23)); test vectors pass.",
          "createdAt": "2023-07-07T03:58:39Z",
          "updatedAt": "2023-07-07T04:13:27Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Why have in inner parenthesis and have the `c` out of it?",
              "createdAt": "2023-07-07T03:58:40Z",
              "updatedAt": "2023-07-07T04:13:28Z"
            },
            {
              "originalPosition": 54,
              "body": "A bit confusing to have the `m^_j_i ` in parenthesis.",
              "createdAt": "2023-07-07T03:59:32Z",
              "updatedAt": "2023-07-07T04:13:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85ajRDu",
          "commit": {
            "abbreviatedOid": "61fe83b"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-07T15:45:41Z",
          "updatedAt": "2023-07-07T15:45:41Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Good catch! It was a typo. Fixed. Thanks!",
              "createdAt": "2023-07-07T15:45:41Z",
              "updatedAt": "2023-07-07T15:45:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85ajRMW",
          "commit": {
            "abbreviatedOid": "61fe83b"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-07T15:46:06Z",
          "updatedAt": "2023-07-07T15:46:06Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "Fixed. Thanks!",
              "createdAt": "2023-07-07T15:46:06Z",
              "updatedAt": "2023-07-07T15:46:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85ajySH",
          "commit": {
            "abbreviatedOid": "bde5cf3"
          },
          "author": "Wind4Greg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "I'm not sure why were are doing the swapping of Abar and Bbar. When I try to map this back to the [Revisiting BBS paper](https://eprint.iacr.org/2023/275.pdf) it seems like the way we currently have it is a close match and this change seems less like the paper. \r\n\r\nIs there another version of the paper with this changed? \r\n\r\nIs there a reason for this change?\r\n\r\nNote that we also don't seem to cite the \"Revisiting BBS\" paper in the update.",
          "createdAt": "2023-07-07T17:17:15Z",
          "updatedAt": "2023-07-07T17:17:15Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85amyOB",
          "commit": {
            "abbreviatedOid": "bde5cf3"
          },
          "author": "Wind4Greg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Implemented and confirmed all test vectors. Note the high level text description still has the parameters in the old order:\r\n\r\n```\r\nThe inputted proof value must consist of the following components, in that order:\r\n\r\n1. Two (2) valid points of the G1 subgroup, different from the identity point of G1 (i.e., `Abar, Bbar`, in ProofGen)\r\n2. Three (3) integers representing scalars in the range of 1 to r-1 inclusive (i.e., `c, r2^, r3^`, in ProofGen).\r\n3. A number of integers representing scalars in the range of 1 to r-1 inclusive, corresponding to the undisclosed from the proof messages (i.e., `m^_j1, ..., m^_jU`, in ProofGen, where U the number of undisclosed messages).\r\n```",
          "createdAt": "2023-07-07T22:41:35Z",
          "updatedAt": "2023-07-07T22:41:35Z",
          "comments": []
        }
      ]
    },
    {
      "number": 277,
      "id": "PR_kwDOF8lax85VGeK-",
      "title": "Update publish workflow",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/277",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fix (hopefully) the test vectors not appearing on the [published draft](https://www.ietf.org/archive/id/draft-irtf-cfrg-bbs-signatures-02.html) issue.",
      "createdAt": "2023-07-10T15:39:27Z",
      "updatedAt": "2023-07-10T20:25:32Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "380b454986264bb26897d218ec2213fa2462f6de",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "vasilis/publish-workflow",
      "headRefOid": "fc97579f78eeb60a9019161d81f5b006b4af0afe",
      "closedAt": "2023-07-10T20:25:31Z",
      "mergedAt": "2023-07-10T20:25:31Z",
      "mergedBy": "BasileiosKal",
      "mergeCommit": {
        "oid": "473df62c74ac0bf0b2a256c43b73e89a6399151d"
      },
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on the WG call on the 10th of July. Consensus on merging it. Merging",
          "createdAt": "2023-07-10T20:25:28Z",
          "updatedAt": "2023-07-10T20:25:28Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 281,
      "id": "PR_kwDOF8lax85XiUJh",
      "title": "feat: parameterize proof generation and verification",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/281",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Divide [ProofGen](https://identity.foundation/bbs-signature/draft-irtf-cfrg-bbs-signatures.html#name-proof-generation-proofgen) and [ProofVerify](https://identity.foundation/bbs-signature/draft-irtf-cfrg-bbs-signatures.html#name-proof-verification-proofver) to the `Initialization`, `Challenge Calculation` and `Finalization` phases. \r\n\r\nThis is done by introducing 3 operations; `ProofInit`, `ProofFinalize` and  `ProofVerifyInit`, that handle the computations that were previously part of ProofGen and ProofVerify.\r\n\r\nThis is to allow for extensions of BBS, like predicate proofs, combining 2 BBS proofs, combining BBS proofs with other Pedersen-style commitments and much more, without requiring them to re-define the entire operations from scratch.\r\n\r\n---\r\n\r\n**Advantages**: Not a breaking change.\r\n**Disadvantages**:  More operations/ larger document.",
      "createdAt": "2023-08-09T13:25:41Z",
      "updatedAt": "2023-09-26T07:33:01Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "1e5bbc7890d42696a40f298e1241fe698fe146a0",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "vasilis/proof-gen-procedure",
      "headRefOid": "71449060ec721335714f242e2c0087ec293bf768",
      "closedAt": "2023-09-26T07:33:01Z",
      "mergedAt": "2023-09-26T07:33:01Z",
      "mergedBy": "BasileiosKal",
      "mergeCommit": {
        "oid": "9b491a754cc6668234aed4d408b598cfa62eabcd"
      },
      "comments": [
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think this is a useful set of changes, and that is how implementations have been written previously in order to allow for proof combinations. The additional complexity, especially with separating out the core operations does me a little nervous about getting the draft adopted though.",
          "createdAt": "2023-08-21T16:55:56Z",
          "updatedAt": "2023-08-21T16:55:56Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on the WG call at 25th of Sep. Merging.",
          "createdAt": "2023-09-25T18:39:06Z",
          "updatedAt": "2023-09-25T18:39:06Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax85enp-b",
          "commit": {
            "abbreviatedOid": "3c10846"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-08-21T16:50:40Z",
          "updatedAt": "2023-08-21T16:50:40Z",
          "comments": [
            {
              "originalPosition": 310,
              "body": "```suggestion\r\nThis operation calculates the challenge scalar value, used during [ProofGen](#proof-generation-proofgen) and [ProofVerify](#proof-verification-proofverify), as part of the Fiat-Shamir heuristic, for making the proof protocol non-interactive (in a interactive setting, the challenge would be a random value supplied by the verifier).\r\n```",
              "createdAt": "2023-08-21T16:50:40Z",
              "updatedAt": "2023-08-21T16:50:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85enqCt",
          "commit": {
            "abbreviatedOid": "3c10846"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-08-21T16:50:52Z",
          "updatedAt": "2023-08-21T16:50:52Z",
          "comments": [
            {
              "originalPosition": 238,
              "body": "```suggestion\r\ninit_res = ProofVerifyInit(PK, proof, header, disclosed_messages,\r\n```",
              "createdAt": "2023-08-21T16:50:52Z",
              "updatedAt": "2023-08-21T16:50:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85enqGA",
          "commit": {
            "abbreviatedOid": "3c10846"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-08-21T16:51:00Z",
          "updatedAt": "2023-08-21T16:51:00Z",
          "comments": [
            {
              "originalPosition": 195,
              "body": "```suggestion\r\nproof = ProofFinalize(challenge, e_value, random_scalars, messages,\r\n```",
              "createdAt": "2023-08-21T16:51:00Z",
              "updatedAt": "2023-08-21T16:51:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85enqKQ",
          "commit": {
            "abbreviatedOid": "3c10846"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-08-21T16:51:10Z",
          "updatedAt": "2023-08-21T16:51:10Z",
          "comments": [
            {
              "originalPosition": 140,
              "body": "```suggestion\r\ninit_res = ProofInit(PK, signature, header, random_scalars, messages,\r\n```",
              "createdAt": "2023-08-21T16:51:10Z",
              "updatedAt": "2023-08-21T16:51:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85enqc-",
          "commit": {
            "abbreviatedOid": "3c10846"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-08-21T16:52:00Z",
          "updatedAt": "2023-08-21T16:52:00Z",
          "comments": [
            {
              "originalPosition": 297,
              "body": "Maybe we can rename MsgGenerators to msg_generators for consistency.",
              "createdAt": "2023-08-21T16:52:00Z",
              "updatedAt": "2023-08-21T16:52:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85enq_7",
          "commit": {
            "abbreviatedOid": "3c10846"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-08-21T16:53:31Z",
          "updatedAt": "2023-08-21T16:53:31Z",
          "comments": [
            {
              "originalPosition": 315,
              "body": "Maybe ProofChallengeCalculate for precision?",
              "createdAt": "2023-08-21T16:53:31Z",
              "updatedAt": "2023-08-21T16:53:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85fKfxe",
          "commit": {
            "abbreviatedOid": "3c10846"
          },
          "author": "Wind4Greg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Seems like a reasonable approach. Will we provide some intermediate test vectors to go with these operations? That will increase length too, but would aid developers.",
          "createdAt": "2023-08-25T23:00:55Z",
          "updatedAt": "2023-08-25T23:00:55Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85fS2mT",
          "commit": {
            "abbreviatedOid": "3c10846"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-08-28T17:55:44Z",
          "updatedAt": "2023-08-28T17:55:44Z",
          "comments": [
            {
              "originalPosition": 297,
              "body": "Not sure. I like the list of \"Points\" starting with a capital letter TBH. Not feeling strongly about it!",
              "createdAt": "2023-08-28T17:55:44Z",
              "updatedAt": "2023-08-28T17:55:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85fS2ry",
          "commit": {
            "abbreviatedOid": "3c10846"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-08-28T17:55:59Z",
          "updatedAt": "2023-08-28T17:55:59Z",
          "comments": [
            {
              "originalPosition": 315,
              "body": "Done. Thanks!",
              "createdAt": "2023-08-28T17:55:59Z",
              "updatedAt": "2023-08-28T17:55:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85h6t5X",
          "commit": {
            "abbreviatedOid": "9cddf9b"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-09-25T18:37:49Z",
          "updatedAt": "2023-09-25T18:38:08Z",
          "comments": [
            {
              "originalPosition": 177,
              "body": "```suggestion\r\n1. for i in undisclosed_indexes, i < 1 or i > L\r\n```",
              "createdAt": "2023-09-25T18:37:49Z",
              "updatedAt": "2023-09-25T18:38:08Z"
            }
          ]
        }
      ]
    },
    {
      "number": 282,
      "id": "PR_kwDOF8lax85YZ8rw",
      "title": "Separate core and interface operations",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/282",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #280\r\n\r\nAdds a commitment value to `Core` sign, to be used with Blind/Bound signatures.\r\n\r\nAlthough the `ciphersuite_id` changes this is not a breaking change. This PR defines an `api_id`, which has the same value with the old `ciphersuite_id` and is passed to the core operations, to be used for dsts, seeds etc..",
      "createdAt": "2023-08-21T16:20:30Z",
      "updatedAt": "2023-10-23T18:12:34Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "9b491a754cc6668234aed4d408b598cfa62eabcd",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "vasilis/api-core-separation",
      "headRefOid": "c913ceeff92a13b2d2420bcfb73ea6e7110f1508",
      "closedAt": "2023-10-23T18:12:34Z",
      "mergedAt": "2023-10-23T18:12:34Z",
      "mergedBy": "BasileiosKal",
      "mergeCommit": {
        "oid": "93adebc0908719e5ae2f29acc9e2ab054119d8e7"
      },
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on WG 23th of Oct. Multiple approvals. Merging.",
          "createdAt": "2023-10-23T18:12:26Z",
          "updatedAt": "2023-10-23T18:12:26Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax85fKfFh",
          "commit": {
            "abbreviatedOid": "eaa751a"
          },
          "author": "Wind4Greg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Very much like this approach. Once approved I will restructure my code's API along these lines.",
          "createdAt": "2023-08-25T22:54:15Z",
          "updatedAt": "2023-08-25T22:54:15Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85gmJ8_",
          "commit": {
            "abbreviatedOid": "81fe2ca"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-09-11T18:49:08Z",
          "updatedAt": "2023-09-11T18:49:09Z",
          "comments": [
            {
              "originalPosition": 821,
              "body": "```suggestion\r\nFor every set of messages and every message msg',\r\n```",
              "createdAt": "2023-09-11T18:49:09Z",
              "updatedAt": "2023-09-11T18:49:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85iTBYw",
          "commit": {
            "abbreviatedOid": "40271ff"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-09-28T15:29:01Z",
          "updatedAt": "2023-09-28T15:29:01Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "is there a better word here than inputted? are these messages named in the spec? can we include a ref here?",
              "createdAt": "2023-09-28T15:29:01Z",
              "updatedAt": "2023-09-28T15:29:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85iTCqf",
          "commit": {
            "abbreviatedOid": "40271ff"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-09-28T15:31:37Z",
          "updatedAt": "2023-09-28T15:31:37Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "This seems like its encouraging other specs to do something different... especially with integers.\r\n\r\nIt would be better to provide guidance to the other spec... \r\n\r\nIf you need to map data types other than octet strings, it is recommended that you ....\r\n\r\n1. describe your mapping in a document.\r\n2. provide test vectors, and cover edge cases, such as max and min datatypes, etc...",
              "createdAt": "2023-09-28T15:31:37Z",
              "updatedAt": "2023-09-28T15:31:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85iTD8T",
          "commit": {
            "abbreviatedOid": "40271ff"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-09-28T15:34:11Z",
          "updatedAt": "2023-09-28T15:34:11Z",
          "comments": [
            {
              "originalPosition": 258,
              "body": "This sentence seems important, it would be nice to cover the normative bit first, and then leave the background details to another sentence.",
              "createdAt": "2023-09-28T15:34:11Z",
              "updatedAt": "2023-09-28T15:34:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85iTFDr",
          "commit": {
            "abbreviatedOid": "40271ff"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-09-28T15:36:34Z",
          "updatedAt": "2023-09-28T15:36:34Z",
          "comments": [
            {
              "originalPosition": 409,
              "body": "Compare to CoreVerify..... `- generators (REQUIRED), vector of pseudo-random points in G1.`\r\n\r\nis this correct?",
              "createdAt": "2023-09-28T15:36:34Z",
              "updatedAt": "2023-09-28T15:36:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85iTFb0",
          "commit": {
            "abbreviatedOid": "40271ff"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-09-28T15:37:20Z",
          "updatedAt": "2023-09-28T15:37:20Z",
          "comments": [
            {
              "originalPosition": 631,
              "body": "same comment about points.",
              "createdAt": "2023-09-28T15:37:20Z",
              "updatedAt": "2023-09-28T15:37:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85iTF7w",
          "commit": {
            "abbreviatedOid": "40271ff"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-09-28T15:38:23Z",
          "updatedAt": "2023-09-28T15:38:23Z",
          "comments": [
            {
              "originalPosition": 747,
              "body": "```suggestion\r\nThe Interface operations MUST create the generators that are required by the core functions. To do so, they MUST use an operation that is conforming to the requirements listed in (#defining-new-generators). If a vector of messages is supplied (where each message can have different forms, for example octet strings, scalar values etc., depending on the application), the Interface operations MUST map the inputted messages to their scalar values, using an operation that is comforting to the requirements listed in (#define-a-new-map-to-scalar).\r\n```",
              "createdAt": "2023-09-28T15:38:23Z",
              "updatedAt": "2023-09-28T15:38:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85iTGPX",
          "commit": {
            "abbreviatedOid": "40271ff"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-09-28T15:39:03Z",
          "updatedAt": "2023-09-28T15:39:03Z",
          "comments": [
            {
              "originalPosition": 747,
              "body": "Feels like this sentence could be improved further.",
              "createdAt": "2023-09-28T15:39:03Z",
              "updatedAt": "2023-09-28T15:39:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85iTHsm",
          "commit": {
            "abbreviatedOid": "40271ff"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-09-28T15:42:00Z",
          "updatedAt": "2023-09-28T15:42:00Z",
          "comments": [
            {
              "originalPosition": 782,
              "body": "Feels like there should be more elaboration here, regarding safe extension.\r\n\r\nAlso not sure if there is a reference we can use to help send this signal home, perhaps ask the list for guidance on this.",
              "createdAt": "2023-09-28T15:42:00Z",
              "updatedAt": "2023-09-28T15:42:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85iTITy",
          "commit": {
            "abbreviatedOid": "40271ff"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-09-28T15:43:17Z",
          "updatedAt": "2023-09-28T15:43:17Z",
          "comments": [
            {
              "originalPosition": 903,
              "body": "```suggestion\r\nEvery operation that is used to return generator points for use with the core BBS operations ((#core-operations)), MUST return points that conform to the aforementioned rules. Such operation must also follow the rules outlined bellow,\r\n```",
              "createdAt": "2023-09-28T15:43:17Z",
              "updatedAt": "2023-09-28T15:43:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85iTI44",
          "commit": {
            "abbreviatedOid": "40271ff"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-09-28T15:44:30Z",
          "updatedAt": "2023-09-28T15:44:31Z",
          "comments": [
            {
              "originalPosition": 993,
              "body": "```suggestion\r\nAdditionally, the new operation MUST conform to the following requirements:\r\n```",
              "createdAt": "2023-09-28T15:44:31Z",
              "updatedAt": "2023-09-28T15:44:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85iTJ4w",
          "commit": {
            "abbreviatedOid": "40271ff"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Lots of nits, nothing critical.",
          "createdAt": "2023-09-28T15:46:36Z",
          "updatedAt": "2023-09-28T15:46:36Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85ibWp4",
          "commit": {
            "abbreviatedOid": "40271ff"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-09-29T19:00:49Z",
          "updatedAt": "2023-09-29T19:00:50Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "Addressed. Thank you!",
              "createdAt": "2023-09-29T19:00:49Z",
              "updatedAt": "2023-09-29T19:00:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85ibXGL",
          "commit": {
            "abbreviatedOid": "40271ff"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-09-29T19:01:50Z",
          "updatedAt": "2023-09-29T19:01:51Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "Updated (note also the addition of the `Mapping Messages to Scalars` security requirement). Thank you!",
              "createdAt": "2023-09-29T19:01:51Z",
              "updatedAt": "2023-09-29T19:01:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85ibXXX",
          "commit": {
            "abbreviatedOid": "40271ff"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-09-29T19:02:23Z",
          "updatedAt": "2023-09-29T19:02:23Z",
          "comments": [
            {
              "originalPosition": 409,
              "body": "Nope. Fixed.",
              "createdAt": "2023-09-29T19:02:23Z",
              "updatedAt": "2023-09-29T19:02:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85ibXZn",
          "commit": {
            "abbreviatedOid": "40271ff"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-09-29T19:02:27Z",
          "updatedAt": "2023-09-29T19:02:27Z",
          "comments": [
            {
              "originalPosition": 631,
              "body": "Fixed. Thanks!",
              "createdAt": "2023-09-29T19:02:27Z",
              "updatedAt": "2023-09-29T19:02:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85ibXeA",
          "commit": {
            "abbreviatedOid": "40271ff"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-09-29T19:02:36Z",
          "updatedAt": "2023-09-29T19:02:37Z",
          "comments": [
            {
              "originalPosition": 747,
              "body": "Updated. Thank you!",
              "createdAt": "2023-09-29T19:02:37Z",
              "updatedAt": "2023-09-29T19:02:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85ibXlU",
          "commit": {
            "abbreviatedOid": "40271ff"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-09-29T19:02:58Z",
          "updatedAt": "2023-09-29T19:02:58Z",
          "comments": [
            {
              "originalPosition": 782,
              "body": "Agreed. Made the sentence informational, expanded a bit and added some references. Will also ask the list for guidance.",
              "createdAt": "2023-09-29T19:02:58Z",
              "updatedAt": "2023-09-29T19:02:58Z"
            }
          ]
        }
      ]
    },
    {
      "number": 287,
      "id": "PR_kwDOF8lax85cGX1i",
      "title": "Update fixtures display, add traces",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/287",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Update fixture display to show it as `fixture_name = \"....fixture...\"`.\r\n\r\nAdded also a bit more detailed trace for the valid fixtures.",
      "createdAt": "2023-10-06T11:30:10Z",
      "updatedAt": "2023-10-23T18:29:56Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "9b491a754cc6668234aed4d408b598cfa62eabcd",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "vasilis/fixtures-trace",
      "headRefOid": "ba3c548492f78438dda1b76a89821e09230b91c3",
      "closedAt": "2023-10-23T18:16:54Z",
      "mergedAt": "2023-10-23T18:16:54Z",
      "mergedBy": "BasileiosKal",
      "mergeCommit": {
        "oid": "907eb46e050e81df935198d3e5651871a2974c70"
      },
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on the WG call on the 23rd of Oct. Editorial update. Merging",
          "createdAt": "2023-10-23T18:16:49Z",
          "updatedAt": "2023-10-23T18:16:49Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax85k7Gz4",
          "commit": {
            "abbreviatedOid": "ba3c548"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-23T18:16:17Z",
          "updatedAt": "2023-10-23T18:16:17Z",
          "comments": []
        }
      ]
    },
    {
      "number": 288,
      "id": "PR_kwDOF8lax85cz6Tm",
      "title": "Update Proof Gen",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/288",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Based on the WG discussions, update the BBS Proof based on [CDL16].\r\n\r\n(Uses  #287)",
      "createdAt": "2023-10-14T19:38:32Z",
      "updatedAt": "2023-12-05T15:22:18Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "b38e65a87445ba3c3c744561e6800a4bd3fb7522",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "vasilis/cdl-proof",
      "headRefOid": "475eb32e46e7d99aad8a40c11763d33a87ea17c4",
      "closedAt": "2023-12-05T15:22:17Z",
      "mergedAt": "2023-12-05T15:22:17Z",
      "mergedBy": "BasileiosKal",
      "mergeCommit": {
        "oid": "122456a833c7f20fe2b78fb6187fb7e6f21bb9c6"
      },
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@christianpaquin, @Wind4Greg ^these are breaking changes for the proof gen.\r\n\r\nHave included test vectors with additional traces to hopefully help with updating \ud83d\ude4f ",
          "createdAt": "2023-10-15T17:42:22Z",
          "updatedAt": "2023-10-15T17:42:22Z"
        },
        {
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> @christianpaquin, @Wind4Greg ^these are breaking changes for the proof gen.\r\n> \r\n> Have included test vectors with additional traces to hopefully help with updating \ud83d\ude4f\r\n\r\n@BasileiosKal, I updated my implementation ([here](https://github.com/microsoft/bbs-node-reference/pull/30)); test vectors pass.",
          "createdAt": "2023-11-08T16:03:16Z",
          "updatedAt": "2023-11-08T16:03:16Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Multiple approvals! Discussed on WG call at the 4th of December. Test Vectors cross validated. Merging.\r\n\r\nThank you everyone for your help!",
          "createdAt": "2023-12-05T15:22:12Z",
          "updatedAt": "2023-12-05T15:22:12Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax85mkEx1",
          "commit": {
            "abbreviatedOid": "9eb25ed"
          },
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-11-08T16:04:21Z",
          "updatedAt": "2023-11-08T16:06:14Z",
          "comments": [
            {
              "originalPosition": 173,
              "body": "Step number should be 6",
              "createdAt": "2023-11-08T16:04:21Z",
              "updatedAt": "2023-11-08T16:06:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85mk8Hy",
          "commit": {
            "abbreviatedOid": "9eb25ed"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-08T17:52:59Z",
          "updatedAt": "2023-11-08T17:52:59Z",
          "comments": [
            {
              "originalPosition": 173,
              "body": "Fixed. Thank you!",
              "createdAt": "2023-11-08T17:52:59Z",
              "updatedAt": "2023-11-08T17:53:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85nvHar",
          "commit": {
            "abbreviatedOid": "770ed0f"
          },
          "author": "Wind4Greg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "All test vectors confirmed against proof generation/verification update to specification via my independent JavaScript based implementation. Enhanced information (PNG scalars) in test vectors are a great help to implementers!",
          "createdAt": "2023-11-20T18:06:45Z",
          "updatedAt": "2023-11-20T18:06:45Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85pGEdt",
          "commit": {
            "abbreviatedOid": "475eb32"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-12-04T19:15:20Z",
          "updatedAt": "2023-12-04T19:15:20Z",
          "comments": []
        }
      ]
    },
    {
      "number": 289,
      "id": "PR_kwDOF8lax85dcSgx",
      "title": "Fix broken url to JWP",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/289",
      "state": "MERGED",
      "author": "lucagiorgino",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Update draft-irtf-cfrg-bbs-signatures.md",
      "createdAt": "2023-10-21T10:11:57Z",
      "updatedAt": "2023-10-23T09:01:48Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "9b491a754cc6668234aed4d408b598cfa62eabcd",
      "headRepository": "lucagiorgino/bbs-signature",
      "headRefName": "patch-1",
      "headRefOid": "ab8cd3aa5d4a41ac35c88fa7a9e3d03da5077459",
      "closedAt": "2023-10-23T08:17:20Z",
      "mergedAt": "2023-10-23T08:17:20Z",
      "mergedBy": "BasileiosKal",
      "mergeCommit": {
        "oid": "73c838c258a90d87c10b30d9d09a25dd3cb5417a"
      },
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Editorial update fixing a bug. Multiple approvals. Merging. Thanks!",
          "createdAt": "2023-10-23T08:17:15Z",
          "updatedAt": "2023-10-23T08:17:15Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax85k1pne",
          "commit": {
            "abbreviatedOid": "ab8cd3a"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-23T06:25:49Z",
          "updatedAt": "2023-10-23T06:25:49Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85k2Twv",
          "commit": {
            "abbreviatedOid": "ab8cd3a"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-23T08:16:26Z",
          "updatedAt": "2023-10-23T08:16:26Z",
          "comments": []
        }
      ]
    },
    {
      "number": 290,
      "id": "PR_kwDOF8lax85dg1WD",
      "title": "Clarify zero indexing of arrays",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/290",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Not a breaking change. Implementations used 0-indexing already,. even though was not clearly specified in the draft.",
      "createdAt": "2023-10-23T10:22:44Z",
      "updatedAt": "2023-11-27T16:25:26Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "76936111f906325bc0518a48744b5d4ea62a1086",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "vasilis/zero-indexing",
      "headRefOid": "d3ba5dd274cf42d5e45b09e46a55a3287a9ba058",
      "closedAt": "2023-11-27T16:25:26Z",
      "mergedAt": "2023-11-27T16:25:26Z",
      "mergedBy": "BasileiosKal",
      "mergeCommit": {
        "oid": "126c4a9700b31f05190886942ee12dc0cae9af02"
      },
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on the WG call on the 23rd of Oct. Will resolve conflicts and merge after approval.",
          "createdAt": "2023-10-23T18:35:36Z",
          "updatedAt": "2023-10-23T18:35:36Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on WG call at 20th of Nov. Multiple approvals! Merging",
          "createdAt": "2023-11-27T16:25:22Z",
          "updatedAt": "2023-11-27T16:25:22Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax85lWyfK",
          "commit": {
            "abbreviatedOid": "0bd4c9d"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-26T19:10:05Z",
          "updatedAt": "2023-10-26T19:10:05Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85mA7LQ",
          "commit": {
            "abbreviatedOid": "0bd4c9d"
          },
          "author": "dwaite",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2023-11-03T01:08:58Z",
          "updatedAt": "2023-11-03T01:10:06Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I would propose this note be moved down to the middle of the notation section (before mathematical terms), and be expanded with specific examples between the algorithmic and mathematical notations.\r\n\r\nProposed text:\r\n\r\n~~~\r\nNote that arrays in this document use the zero-based numbering common in\r\nmany programming languages, meaning that element indexing starts from 0.\r\nThis is distinct from naming used for explaining mathematical concepts,\r\nwhere natural (one-based) numbering might be used as part of the names\r\nfor clarity in that context.\r\n\r\nFor example,\r\n\r\n```\r\nX = [a_1, a_2, ..., a_n]\r\n```\r\n\r\nwould indicate\r\n\r\n```\r\nX[0] = a_1\r\nX[1] = a_2\r\n// ... and so on, up to\r\nX[n-1] = a_n\r\n```\r\n~~~",
              "createdAt": "2023-11-03T01:08:59Z",
              "updatedAt": "2023-11-03T01:10:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85mQ4Rk",
          "commit": {
            "abbreviatedOid": "0bd4c9d"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-06T16:50:36Z",
          "updatedAt": "2023-11-06T16:50:36Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Thanks for the suggestion \ud83d\ude4f \r\n\r\nFor now, added the suggested text to the `Considerations` section, to keep the notation text short.",
              "createdAt": "2023-11-06T16:50:36Z",
              "updatedAt": "2023-11-06T16:50:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85nvJ_y",
          "commit": {
            "abbreviatedOid": "d3ba5dd"
          },
          "author": "Wind4Greg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-11-20T18:11:49Z",
          "updatedAt": "2023-11-20T18:11:49Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85nvna5",
          "commit": {
            "abbreviatedOid": "d3ba5dd"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-11-20T19:14:12Z",
          "updatedAt": "2023-11-20T19:14:12Z",
          "comments": []
        }
      ]
    },
    {
      "number": 291,
      "id": "PR_kwDOF8lax85eDblJ",
      "title": "Add privacy considerations",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/291",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #256.",
      "createdAt": "2023-10-29T18:36:44Z",
      "updatedAt": "2023-12-05T15:47:04Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "b38e65a87445ba3c3c744561e6800a4bd3fb7522",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "vasilis/privacy-considerations",
      "headRefOid": "54a765cbcc07caf65ab34f3df620636b212ffc94",
      "closedAt": "2023-12-05T15:47:04Z",
      "mergedAt": "2023-12-05T15:47:04Z",
      "mergedBy": "BasileiosKal",
      "mergeCommit": {
        "oid": "2a6973750033de1e05010af490d37c4a328adc76"
      },
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on the WG 20th of Nov. Will update wording to use \"collusion\" instead of \"coalition\".",
          "createdAt": "2023-11-20T19:18:20Z",
          "updatedAt": "2023-11-20T19:18:20Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on the WG at the 4th of December. Multiple approvals. Editorial updates. Merging! Thank you!",
          "createdAt": "2023-12-05T15:47:00Z",
          "updatedAt": "2023-12-05T15:47:00Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax85lnTkG",
          "commit": {
            "abbreviatedOid": "1b5da3d"
          },
          "author": "dwaite",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-30T18:14:55Z",
          "updatedAt": "2023-10-30T18:23:17Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "```suggestion\r\nWhen a Prover presents a BBS proof to a Verifier, other than the messages they decide to disclose, there are two additional pieces of information that will be revealed. First, the total number of signed messages, which can be inferred from the size of the BBS proof and the length of the disclosed messages list. Second, the index the disclosed messages had in the list of signed messages (see (#proof-generation-proofgen)). This information, if unique to each Prover, could be employed to correlate multiple proof presentations together. As a result, the Issuer should not sign lists of messages with unique lengths or unique indexing. For this reason, it is RECOMMENDED that signed lists of messages are padded to a common length (using either random, or an unused by the application message, like 0 or 1). It is also RECOMMENDED that a constant ordering of messages will be preserved when possible. For example, if an application creates signatures for the messages `[<user_name>, <user_affiliation>, <user_country>]`, then those messages should always be signed in the same order, i.e., first message should always be the user's name (`<user_name>`), second message should always be the user's affiliation (`<user_affiliation>`) and the last message should always be the user's country of origins (`<user_country>`). Provers can employ consistency validation mechanisms, like the ones described in [@I-D.ietf-privacypass-key-consistency], to validate that those values are not used to correlate them.\r\n```",
              "createdAt": "2023-10-30T18:14:55Z",
              "updatedAt": "2023-10-30T18:23:17Z"
            },
            {
              "originalPosition": 12,
              "body": "user_county -> user_country",
              "createdAt": "2023-10-30T18:15:17Z",
              "updatedAt": "2023-10-30T18:23:17Z"
            },
            {
              "originalPosition": 6,
              "body": "Is the typical term in this context coalition or correlation?",
              "createdAt": "2023-10-30T18:17:56Z",
              "updatedAt": "2023-10-30T18:23:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85mQwuN",
          "commit": {
            "abbreviatedOid": "1b5da3d"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-06T16:38:37Z",
          "updatedAt": "2023-11-06T16:38:37Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Thanks! Fixed.",
              "createdAt": "2023-11-06T16:38:37Z",
              "updatedAt": "2023-11-06T16:38:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85mQxKy",
          "commit": {
            "abbreviatedOid": "1b5da3d"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-06T16:39:17Z",
          "updatedAt": "2023-11-06T16:39:17Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "AFAIK yes. Correlation generally refers to breaking the unlinkability property of the proofs (i.e., \"correlating\" multiple proofs presented by the same Prover together)\r\n\r\nCoalition refers to multiple parties (Verifiers and potentially the Issuer) working together to track the user's activity (the proofs they produce).",
              "createdAt": "2023-11-06T16:39:17Z",
              "updatedAt": "2023-11-06T16:39:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85nvJeO",
          "commit": {
            "abbreviatedOid": "ae8a3cd"
          },
          "author": "Wind4Greg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-11-20T18:10:19Z",
          "updatedAt": "2023-11-20T18:10:19Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85pGF89",
          "commit": {
            "abbreviatedOid": "54a765c"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-12-04T19:19:25Z",
          "updatedAt": "2023-12-04T19:19:25Z",
          "comments": []
        }
      ]
    },
    {
      "number": 293,
      "id": "PR_kwDOF8lax85etg1F",
      "title": "Fix Pedersen commitment reference",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/293",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-11-06T16:34:20Z",
      "updatedAt": "2023-11-20T19:19:02Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "76936111f906325bc0518a48744b5d4ea62a1086",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "vasilis/fix-reference",
      "headRefOid": "25024335acf100d864ff988dc3d6c1e38067a4a5",
      "closedAt": "2023-11-20T19:19:02Z",
      "mergedAt": "2023-11-20T19:19:02Z",
      "mergedBy": "BasileiosKal",
      "mergeCommit": {
        "oid": "5c52e059ce837d21c844acadf86e89188c538400"
      },
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Multiple approvals. Editorial update. Merging",
          "createdAt": "2023-11-20T19:18:55Z",
          "updatedAt": "2023-11-20T19:18:55Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax85mkG3Y",
          "commit": {
            "abbreviatedOid": "2502433"
          },
          "author": "christianpaquin",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-11-08T16:08:12Z",
          "updatedAt": "2023-11-08T16:08:12Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85nvIVK",
          "commit": {
            "abbreviatedOid": "2502433"
          },
          "author": "Wind4Greg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-11-20T18:07:55Z",
          "updatedAt": "2023-11-20T18:07:55Z",
          "comments": []
        }
      ]
    },
    {
      "number": 294,
      "id": "PR_kwDOF8lax85fBQCt",
      "title": "Update draft-irtf-cfrg-bbs-signatures.md",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/294",
      "state": "MERGED",
      "author": "alessandropino",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "## Possible typo\r\nIn section 3.6.3.  CoreProofGen I noticed that \"signature_result\" became \"signature_res\" and fixed that. Specifically\r\n\r\n```\r\n2. init_res = ProofInit(PK, signature_res, generators, random_scalars,\r\n                          header, messages, undisclosed_indexes, api_id)\r\n```\r\n\r\nIf it is not a typo and there is a reason for that, close this pull request.",
      "createdAt": "2023-11-09T10:40:34Z",
      "updatedAt": "2023-11-27T16:26:21Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "76936111f906325bc0518a48744b5d4ea62a1086",
      "headRepository": null,
      "headRefName": "main",
      "headRefOid": "d76bd48d237698a283099c3467c362a7194abb4a",
      "closedAt": "2023-11-27T16:26:20Z",
      "mergedAt": "2023-11-27T16:26:20Z",
      "mergedBy": "BasileiosKal",
      "mergeCommit": {
        "oid": "3f5e64f62eb75ef2f094b712a3b6d5042c11b8ba"
      },
      "comments": [
        {
          "author": "alessandropino",
          "authorAssociation": "CONTRIBUTOR",
          "body": "## Possible typo 2\r\nIn section 3.7.4. Challenge Calculation I also noticed that the previously defined c_arr became c_array in the next row\r\n```\r\n1. c_arr = (Abar, Bbar, C, R, i1, ..., iR, msg_i1, ..., msg_iR, domain)\r\n2. c_octs = serialize(c_array) || I2OSP(length(ph), 8) || ph\r\n```\r\nAgain if it is not a typo, close this pull request",
          "createdAt": "2023-11-09T11:22:54Z",
          "updatedAt": "2023-11-09T11:22:54Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Multiple approvals. Fixing typos. Merging. Thanks @alessandropino!",
          "createdAt": "2023-11-27T16:26:15Z",
          "updatedAt": "2023-11-27T16:26:15Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax85nvo_P",
          "commit": {
            "abbreviatedOid": "d76bd48"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-11-20T19:19:16Z",
          "updatedAt": "2023-11-20T19:19:16Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85nvpKp",
          "commit": {
            "abbreviatedOid": "d76bd48"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-11-20T19:19:48Z",
          "updatedAt": "2023-11-20T19:19:48Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85nvpOJ",
          "commit": {
            "abbreviatedOid": "d76bd48"
          },
          "author": "Wind4Greg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-11-20T19:19:59Z",
          "updatedAt": "2023-11-20T19:19:59Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85oIBpy",
          "commit": {
            "abbreviatedOid": "d76bd48"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-11-23T19:34:25Z",
          "updatedAt": "2023-11-23T19:34:25Z",
          "comments": []
        }
      ]
    },
    {
      "number": 296,
      "id": "PR_kwDOF8lax85gds9X",
      "title": "Update ciphersuites",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/296",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "- Removes the hash variable from the ciphersuites.\r\n- Fixes the ciphersuite IDs",
      "createdAt": "2023-11-27T17:23:32Z",
      "updatedAt": "2023-12-03T12:25:30Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "3f5e64f62eb75ef2f094b712a3b6d5042c11b8ba",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "vasilis/update-suites",
      "headRefOid": "46fbd496ec02cc559cef7ec559127ed758739306",
      "closedAt": "2023-12-03T12:25:30Z",
      "mergedAt": "2023-12-03T12:25:30Z",
      "mergedBy": "BasileiosKal",
      "mergeCommit": {
        "oid": "d65db142143c13f92f2c87a74cb1304faffbe9e5"
      },
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Multiple approvals. Editorial update. Merging. ",
          "createdAt": "2023-12-03T12:25:20Z",
          "updatedAt": "2023-12-03T12:25:20Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax85oYozn",
          "commit": {
            "abbreviatedOid": "46fbd49"
          },
          "author": "Wind4Greg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-11-27T20:23:25Z",
          "updatedAt": "2023-11-27T20:23:25Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85oYsA5",
          "commit": {
            "abbreviatedOid": "46fbd49"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-11-27T20:30:16Z",
          "updatedAt": "2023-11-27T20:30:16Z",
          "comments": []
        }
      ]
    },
    {
      "number": 297,
      "id": "PR_kwDOF8lax85gdxoV",
      "title": "Rm the optional commitment from CoreSign",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/297",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-11-27T17:37:04Z",
      "updatedAt": "2023-12-03T12:25:58Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "3f5e64f62eb75ef2f094b712a3b6d5042c11b8ba",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "vassilis/signature-commit",
      "headRefOid": "55170d3eaad37ed187cbd62cea806e4c3c1a5464",
      "closedAt": "2023-12-03T12:25:58Z",
      "mergedAt": "2023-12-03T12:25:58Z",
      "mergedBy": "BasileiosKal",
      "mergeCommit": {
        "oid": "b38e65a87445ba3c3c744561e6800a4bd3fb7522"
      },
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Multiple approvals. Editorial update. Merging.",
          "createdAt": "2023-12-03T12:25:54Z",
          "updatedAt": "2023-12-03T12:25:54Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax85oYpUo",
          "commit": {
            "abbreviatedOid": "55170d3"
          },
          "author": "Wind4Greg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-11-27T20:24:41Z",
          "updatedAt": "2023-11-27T20:24:41Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85oYrtn",
          "commit": {
            "abbreviatedOid": "55170d3"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-11-27T20:29:29Z",
          "updatedAt": "2023-11-27T20:29:29Z",
          "comments": []
        }
      ]
    },
    {
      "number": 298,
      "id": "PR_kwDOF8lax85gkn1i",
      "title": "Various editorial updates",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/298",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Couple of editorial updates\r\n- Updated abstract and some security considerations\r\n- Added academic works overview\r\n- Added header and presentation header usage section\r\n- Added section on post-quantum security",
      "createdAt": "2023-11-28T15:58:29Z",
      "updatedAt": "2023-12-15T18:18:22Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "2a6973750033de1e05010af490d37c4a328adc76",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "vasilis/editorial-changes",
      "headRefOid": "3568e9a4b8877e33b03ffa8ee0a60aa4e578ad89",
      "closedAt": "2023-12-15T18:18:22Z",
      "mergedAt": "2023-12-15T18:18:22Z",
      "mergedBy": "BasileiosKal",
      "mergeCommit": {
        "oid": "6cfa6a8ba1c38ed735c300c70be4f22099d73ee9"
      },
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Multiple approvals. Addressed review comments. Discussed on the WG call at the 11th of Dec. Merging. Thank you all!",
          "createdAt": "2023-12-15T18:18:16Z",
          "updatedAt": "2023-12-15T18:18:16Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax85pGIlC",
          "commit": {
            "abbreviatedOid": "909fdb4"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-12-04T19:22:35Z",
          "updatedAt": "2023-12-04T19:22:35Z",
          "comments": [
            {
              "originalPosition": 168,
              "body": "you probably want to use terminology from PQUIP here.\r\n\r\nhttps://datatracker.ietf.org/wg/pquip/documents/\r\n\r\nhttps://datatracker.ietf.org/doc/draft-ietf-pquip-pqc-engineers/\r\n\r\nCRQCs, etc.",
              "createdAt": "2023-12-04T19:22:35Z",
              "updatedAt": "2023-12-04T19:24:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85pGNbL",
          "commit": {
            "abbreviatedOid": "909fdb4"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-12-04T19:28:57Z",
          "updatedAt": "2023-12-04T19:28:57Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85poVH3",
          "commit": {
            "abbreviatedOid": "909fdb4"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-12-08T11:44:11Z",
          "updatedAt": "2023-12-08T11:44:11Z",
          "comments": [
            {
              "originalPosition": 168,
              "body": "Than you for the suggestion! Updated.",
              "createdAt": "2023-12-08T11:44:11Z",
              "updatedAt": "2023-12-08T11:44:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85p23ZK",
          "commit": {
            "abbreviatedOid": "6c46269"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-12-11T19:13:40Z",
          "updatedAt": "2023-12-11T19:13:40Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85p4Z30",
          "commit": {
            "abbreviatedOid": "6c46269"
          },
          "author": "Wind4Greg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Tried to put in suggest some minor wording/English fixes. If they don't come through we can catch them during the \"nits\" phase.",
          "createdAt": "2023-12-12T00:29:01Z",
          "updatedAt": "2023-12-12T00:44:58Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "This document describes the BBS Signature scheme, a secure, multi-message digital signature protocol, supporting proving knowledge of a signature while selectively disclosing any subset of the signed messages. Concretely, the scheme allows for signing multiple messages whilst producing a single, constant size, digital signature. Additionally, the possessor of a BBS signatures is able to create zero-knowledge, proofs-of-knowledge of a signature, while selectively disclosing subsets of the signed messages. Being zero-knowledge, the BBS proofs do not reveal any information about the undisclosed messages or the signature it self, while at the same time, guarantying the authenticity and integrity of the disclosed messages.",
              "createdAt": "2023-12-12T00:29:01Z",
              "updatedAt": "2023-12-12T00:44:58Z"
            },
            {
              "originalPosition": 5,
              "body": "Was just trying to correct the word usage: \"Been\" ==> \"Being\".\r\n\r\n",
              "createdAt": "2023-12-12T00:29:57Z",
              "updatedAt": "2023-12-12T00:44:58Z"
            },
            {
              "originalPosition": 63,
              "body": "There are two special values defined by the BBS Scheme; the `header` and the `presentation_header`. The `header` value is chosen by the Signer and is bound to both a BBS signature and the BBS proofs generated using that signature. Specifically, the Prover is required to reveal the `header` to the proof Verifier, during every BBS proof presentation. As a result, the Signer SHOULD NOT include in the `header` any identifying information, that may have the potential of compromising the Prover's privacy. Suitable use cases taking advantage of the `header` value, are binding a BBS signature (and subsequent BBS proofs) to a specific application, deployment or domain, or binding the signature to specific sets of metadata etc..",
              "createdAt": "2023-12-12T00:33:33Z",
              "updatedAt": "2023-12-12T00:44:58Z"
            },
            {
              "originalPosition": 63,
              "body": "Change:\r\n\"the Signer SHOULD NOT include to the `header` any\" ==> \"the Signer SHOULD NOT include in the `header` any\"",
              "createdAt": "2023-12-12T00:34:26Z",
              "updatedAt": "2023-12-12T00:44:58Z"
            },
            {
              "originalPosition": 65,
              "body": "Similarly, the Prover can choose a `presentation_header` value to be bound to the BBS proof (in contrast to the `header` value that is chosen by the Signer and is bound to both BBS proof and signature). Verifying a BBS proof will guarantee the authenticity and integrity of the `presentation_header`. This makes it suitable for applications where the Prover may want to \"sign\" a message in addition to creating their BBS proof, in a way similar to how group signatures can work. Specifically, the Verifier will know that the message included in the `presentation_header` was \"signed\" by a member of the group, where group here being the Provers having received valid signatures from the specific Signer, but will not know from exactly which member of the group the message was signed. Another application of the `presentation_header` is to guarantee freshness of a BBS proof and to avoid replay attacks. An example of how this could be achieved, is by including a random value supplied by the Verifier to the `presentation_header` value.",
              "createdAt": "2023-12-12T00:37:37Z",
              "updatedAt": "2023-12-12T00:44:58Z"
            },
            {
              "originalPosition": 65,
              "body": "Just some small English fixes in the above.",
              "createdAt": "2023-12-12T00:38:05Z",
              "updatedAt": "2023-12-12T00:44:58Z"
            }
          ]
        }
      ]
    },
    {
      "number": 299,
      "id": "PR_kwDOF8lax85guEYb",
      "title": "Update point to octets notation",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/299",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The [point to octets we used](https://www.ietf.org/archive/id/draft-irtf-cfrg-pairing-friendly-curves-11.html#name-zcash-serialization-format-) returns points to the curve but not in G1 necessarily.\r\n\r\n- Updated notation from `point_to_octets_g1 -> point_to_octets_E1` etc..\r\n- Added `subgroup_check_G*` where necessary. ",
      "createdAt": "2023-11-29T22:22:45Z",
      "updatedAt": "2023-12-11T19:27:14Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "2a6973750033de1e05010af490d37c4a328adc76",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "vasilis/point-encode",
      "headRefOid": "6d7c53379eab24399db1ac9fcab5cc7f9c242eea",
      "closedAt": "2023-12-11T19:27:13Z",
      "mergedAt": "2023-12-11T19:27:13Z",
      "mergedBy": "BasileiosKal",
      "mergeCommit": {
        "oid": "7eeec18a17f30211604e43019ec62fa92df60cb8"
      },
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed WG call at the 11th of Dec. Multiple approvals. Merging. Thank you!",
          "createdAt": "2023-12-11T19:27:10Z",
          "updatedAt": "2023-12-11T19:27:10Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax85pGOUk",
          "commit": {
            "abbreviatedOid": "7df589d"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-12-04T19:29:57Z",
          "updatedAt": "2023-12-04T19:29:57Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85p219M",
          "commit": {
            "abbreviatedOid": "f8ecc02"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-12-11T19:09:40Z",
          "updatedAt": "2023-12-11T19:09:41Z",
          "comments": [
            {
              "originalPosition": 132,
              "body": "```suggestion\r\n- r, non-negative integer. The prime order of the G1 and G2 groups,\r\n```",
              "createdAt": "2023-12-11T19:09:40Z",
              "updatedAt": "2023-12-11T19:09:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85p22e1",
          "commit": {
            "abbreviatedOid": "f8ecc02"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-12-11T19:11:08Z",
          "updatedAt": "2023-12-11T19:11:08Z",
          "comments": []
        }
      ]
    },
    {
      "number": 300,
      "id": "PR_kwDOF8lax85guNBp",
      "title": "Specify correct key_dst for fixtures",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/300",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixtures do not use the default `key_dst` defined by [KeyGen](https://identity.foundation/bbs-signature/draft-irtf-cfrg-bbs-signatures.html#name-secret-key).",
      "createdAt": "2023-11-29T22:48:03Z",
      "updatedAt": "2023-12-11T19:29:35Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "3f5e64f62eb75ef2f094b712a3b6d5042c11b8ba",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "vasilis/fix-keygen-fixtures",
      "headRefOid": "3adb137e4dd95f34042a4560b94fc23745ad6e44",
      "closedAt": "2023-12-11T19:29:35Z",
      "mergedAt": "2023-12-11T19:29:35Z",
      "mergedBy": "BasileiosKal",
      "mergeCommit": {
        "oid": "c010a9b1b30cb1727c34cef3676d118dd1f9849e"
      },
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on the WG call on the 11th of Dec. Multiple approvals. Merging. Thank you!",
          "createdAt": "2023-12-11T19:29:32Z",
          "updatedAt": "2023-12-11T19:29:32Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax85osLfy",
          "commit": {
            "abbreviatedOid": "8a9a63f"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-11-29T23:51:52Z",
          "updatedAt": "2023-11-29T23:51:52Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85p2uBO",
          "commit": {
            "abbreviatedOid": "3adb137"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-12-11T18:52:03Z",
          "updatedAt": "2023-12-11T18:52:03Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85p28oL",
          "commit": {
            "abbreviatedOid": "3adb137"
          },
          "author": "Wind4Greg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-12-11T19:28:17Z",
          "updatedAt": "2023-12-11T19:28:17Z",
          "comments": []
        }
      ]
    },
    {
      "number": 301,
      "id": "PR_kwDOF8lax85g_wIE",
      "title": "More editorial updates",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/301",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Consistency corrections.",
      "createdAt": "2023-12-03T23:40:43Z",
      "updatedAt": "2023-12-18T19:17:56Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "6cfa6a8ba1c38ed735c300c70be4f22099d73ee9",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "vasilis/edits",
      "headRefOid": "7e91db81a67988d388f6c749341757d1cabfb58f",
      "closedAt": "2023-12-18T19:17:56Z",
      "mergedAt": "2023-12-18T19:17:56Z",
      "mergedBy": "BasileiosKal",
      "mergeCommit": {
        "oid": "3bd6abe382095a4a8317a8d5a71023c8e9183924"
      },
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on the WG call at the 18th of Dec. Multiple approvals. Merging.",
          "createdAt": "2023-12-18T19:17:53Z",
          "updatedAt": "2023-12-18T19:17:53Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax85pGO6I",
          "commit": {
            "abbreviatedOid": "a500f8b"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-12-04T19:31:05Z",
          "updatedAt": "2023-12-04T19:31:06Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Holder should also be capitalized here, no?",
              "createdAt": "2023-12-04T19:31:05Z",
              "updatedAt": "2023-12-04T19:31:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85pGPln",
          "commit": {
            "abbreviatedOid": "a500f8b"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-12-04T19:32:54Z",
          "updatedAt": "2023-12-04T19:32:54Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85p4eF8",
          "commit": {
            "abbreviatedOid": "aefaa3b"
          },
          "author": "Wind4Greg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-12-12T00:51:50Z",
          "updatedAt": "2023-12-12T00:51:50Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85qh_TQ",
          "commit": {
            "abbreviatedOid": "8ce7627"
          },
          "author": "Wind4Greg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-12-18T16:36:48Z",
          "updatedAt": "2023-12-18T16:36:48Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85qi-0z",
          "commit": {
            "abbreviatedOid": "8ce7627"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-12-18T19:16:23Z",
          "updatedAt": "2023-12-18T19:16:23Z",
          "comments": [
            {
              "originalPosition": 904,
              "body": "```suggestion\r\nwhich is exactly what [Verify](#signature-verification-verify) checks for `A = Abar * r1'`. So seting `A = Abar * r1'`, the values `A`, `e`, `B` will form a valid BBS signature. Note that the verifier doesn't know `r1'`, `e` or all the values to compute `B`. However, they know that the Prover knows them, and as we saw above, knowledge of those values means knowledge of a valid signature on (among others) the disclosed messages.\r\n```",
              "createdAt": "2023-12-18T19:16:23Z",
              "updatedAt": "2023-12-18T19:16:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85qi-9_",
          "commit": {
            "abbreviatedOid": "8ce7627"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-12-18T19:16:46Z",
          "updatedAt": "2023-12-18T19:16:46Z",
          "comments": []
        }
      ]
    },
    {
      "number": 302,
      "id": "PR_kwDOF8lax85hMu7G",
      "title": "Add Acknowledgement",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/302",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Acknowledge two people that significantly contributed to the document through reviews and discussions.",
      "createdAt": "2023-12-05T16:15:24Z",
      "updatedAt": "2023-12-11T19:37:13Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "2a6973750033de1e05010af490d37c4a328adc76",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "vasilis/add-acknowledgement",
      "headRefOid": "d36f18ddbb5eb6ce31ac86c64708ccb6ea1ac35f",
      "closedAt": "2023-12-11T19:37:13Z",
      "mergedAt": "2023-12-11T19:37:13Z",
      "mergedBy": "BasileiosKal",
      "mergeCommit": {
        "oid": "20c42d566583c3aed4b99b3386a4c19cfc42c3c4"
      },
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on the WG call at the 11th of Dec. Multiple approvals. Merging. Thank you!",
          "createdAt": "2023-12-11T19:37:08Z",
          "updatedAt": "2023-12-11T19:37:08Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax85pSeWz",
          "commit": {
            "abbreviatedOid": "d36f18d"
          },
          "author": "Wind4Greg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-12-06T01:30:53Z",
          "updatedAt": "2023-12-06T01:30:53Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85p2_zj",
          "commit": {
            "abbreviatedOid": "d36f18d"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-12-11T19:36:42Z",
          "updatedAt": "2023-12-11T19:36:42Z",
          "comments": []
        }
      ]
    },
    {
      "number": 303,
      "id": "PR_kwDOF8lax85hgxCP",
      "title": "Fix mockrng dst",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/303",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Set `dst = api_id || \"MOCK_RANDOM_SCALARS_DST_\"` from  `ciphersuite_id || \"MOCK_RANDOM_SCALARS_DST_\"`.",
      "createdAt": "2023-12-08T10:54:39Z",
      "updatedAt": "2023-12-11T11:05:35Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "2a6973750033de1e05010af490d37c4a328adc76",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "vasilis/mockrng-dst-fix",
      "headRefOid": "6a06e40ba68e60e1386a3dbeb575bad1ee9c9f97",
      "closedAt": "2023-12-11T11:05:35Z",
      "mergedAt": "2023-12-11T11:05:35Z",
      "mergedBy": "BasileiosKal",
      "mergeCommit": {
        "oid": "141951c5f3aab83a707998e19e1a9cab5ec0153b"
      },
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Multiple approvals, editorial change. Merging! Thank you all!",
          "createdAt": "2023-12-11T11:05:27Z",
          "updatedAt": "2023-12-11T11:05:27Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax85po6Rc",
          "commit": {
            "abbreviatedOid": "28e027b"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-12-08T13:22:49Z",
          "updatedAt": "2023-12-08T13:22:49Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85prCoB",
          "commit": {
            "abbreviatedOid": "28e027b"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-12-08T17:48:40Z",
          "updatedAt": "2023-12-08T17:48:41Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nThe following section details a basic set of test vectors that can be used to confirm an implementation's correctness.\r\n```",
              "createdAt": "2023-12-08T17:48:40Z",
              "updatedAt": "2023-12-08T17:48:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85prE58",
          "commit": {
            "abbreviatedOid": "28e027b"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-12-08T17:55:29Z",
          "updatedAt": "2023-12-08T17:55:29Z",
          "comments": [
            {
              "originalPosition": 142,
              "body": "```suggestion\r\nand the domain separation tag `DST = api_id || \"MOCK_RANDOM_SCALARS_DST_\"`, where `api_id` is the identifier of the BBS Interface defined in (#bbs-signatures-interface), i.e., `api_id = ciphersuite_id || H2G_HM2S_`, where `ciphersuite_id` is the unique identifier of the `BLS12-381-SHA-256` ciphersuite as defined in (#bls12-381-sha-256) and `\"MOCK_RANDOM_SCALARS_DST_\"` is an ASCII string composed of 24 bytes. More specifically,\r\n```",
              "createdAt": "2023-12-08T17:55:29Z",
              "updatedAt": "2023-12-08T17:55:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85prE-w",
          "commit": {
            "abbreviatedOid": "28e027b"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-12-08T17:55:44Z",
          "updatedAt": "2023-12-08T17:55:44Z",
          "comments": []
        }
      ]
    },
    {
      "number": 304,
      "id": "PR_kwDOF8lax85hquld",
      "title": "Update proofgen algorithm explanation",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/304",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Based on the new proof from #288",
      "createdAt": "2023-12-11T10:59:49Z",
      "updatedAt": "2023-12-21T20:17:16Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "3bd6abe382095a4a8317a8d5a71023c8e9183924",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "vasilis/appendix-d",
      "headRefOid": "d70140dac5a89a81ff297875d973a991064cbcd0",
      "closedAt": "2023-12-21T20:17:15Z",
      "mergedAt": "2023-12-21T20:17:15Z",
      "mergedBy": "BasileiosKal",
      "mergeCommit": {
        "oid": "f8135b06b8e8a8331f78232cc223b7e6d447f6a7"
      },
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on the WG call at the 18th of Dec. Conflicts need resolving.",
          "createdAt": "2023-12-18T19:21:53Z",
          "updatedAt": "2023-12-18T19:21:53Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Conflicts resolved. Multiple approvals. Discussed on the last WG call (18th of Dec, 2023). Merging. Thank you!",
          "createdAt": "2023-12-21T20:17:12Z",
          "updatedAt": "2023-12-21T20:17:12Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax85p2ulV",
          "commit": {
            "abbreviatedOid": "efe87a6"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-12-11T18:53:26Z",
          "updatedAt": "2023-12-11T18:53:27Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "```suggestion\r\nThe following section provides a high-level explanation of how the `CoreProofGen` and `CoreProofVerify` operations work, as presented in Appendix B of [@TZ23] and used by this document. The `CoreProofGen` procedure can be categorized as a generic non-interactive zero-knowledge proof-of-knowledge (`nizk`). A `nizk` works as follows; Assume the group points `J_0`, `J_1`, ..., `J_n` and the exponents `e_0`, `e_1`, ..., `e_n`. Assume also that all the group points are publicly known, while only the exponent `e_0` is known to the Verifier of the `nizk` and the exponents `e_1`, ..., `e_n` are known only by the Prover of the protocol. The `nizk` can be used to prove a relationship of the form,\r\n```",
              "createdAt": "2023-12-11T18:53:27Z",
              "updatedAt": "2023-12-11T18:53:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85p2xKC",
          "commit": {
            "abbreviatedOid": "efe87a6"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-12-11T18:57:12Z",
          "updatedAt": "2023-12-11T18:57:13Z",
          "comments": [
            {
              "originalPosition": 84,
              "body": "```suggestion\r\nNote that if the value `D` is constructed correctly (as in \\[3\\]), then `B = D * r2'`. Proving knowledge of \\[6\\] corresponds to proving knowledge of `r2'`, which means that the Prover does actually know the value `B = D * r2'`. If \\[6\\] holds, then that `B` value that the Prover knows will also have the \"correct form\" (as in \\[1\\]), including all (the disclosed and \"some\" undisclosed) messages.\r\n```",
              "createdAt": "2023-12-11T18:57:13Z",
              "updatedAt": "2023-12-11T18:57:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85qiE1y",
          "commit": {
            "abbreviatedOid": "03c5e16"
          },
          "author": "Wind4Greg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Nice write up!",
          "createdAt": "2023-12-18T16:49:50Z",
          "updatedAt": "2023-12-18T16:49:50Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85qi_4y",
          "commit": {
            "abbreviatedOid": "03c5e16"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-12-18T19:19:37Z",
          "updatedAt": "2023-12-18T19:19:37Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "```suggestion\r\n- Prove possession of a valid signature. As defined above, a signature `(A, e)`, on messages `msg_1, ..., msg_L` is valid if `A = B * 1/(e + SK)`, where `B` as in \\[1\\]. However, the Prover cannot reveal neither `A`, `e` nor `B` to the Verifier (signature is uniquely identifiable and `B` will reveal information about the signed messages, even the undisclosed ones). To get around this, the Prover needs to hide the signature `(A, e)` and the value of `B`, in a way that will allow proving knowledge of such elements with the aforementioned relationship (i.e., that `A = B * 1/(e + SK)`), without revealing their value. We do this by randomizing them. To do that, they take uniformly random `r1, r2` in `[1, r-1]`, and calculate,\r\n```",
              "createdAt": "2023-12-18T19:19:37Z",
              "updatedAt": "2023-12-18T19:19:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85qjAdo",
          "commit": {
            "abbreviatedOid": "03c5e16"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-12-18T19:21:26Z",
          "updatedAt": "2023-12-18T19:21:26Z",
          "comments": [
            {
              "originalPosition": 101,
              "body": "```suggestion\r\nTo sum up; in order to validate the proof, a Verifier checks that `e(Abar, PK) = e(Bbar, BP2)` and verifies the `nizk`. Validating the proof will guarantee the authenticity and integrity of the disclosed messages, as well as knowledge of the undisclosed messages and of the signature.\r\n```",
              "createdAt": "2023-12-18T19:21:26Z",
              "updatedAt": "2023-12-18T19:21:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85q5xT5",
          "commit": {
            "abbreviatedOid": "7a2a7a8"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-12-21T19:09:29Z",
          "updatedAt": "2023-12-21T19:09:29Z",
          "comments": []
        }
      ]
    },
    {
      "number": 305,
      "id": "PR_kwDOF8lax85h7QfK",
      "title": "Making Pairing Friendly Curves draft reference informative",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/305",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Redefine the relative functionality from [Pairing-Friendly Curves](https://datatracker.ietf.org/doc/draft-irtf-cfrg-pairing-friendly-curves/) in this draft.",
      "createdAt": "2023-12-13T18:24:01Z",
      "updatedAt": "2023-12-18T22:19:23Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "3bd6abe382095a4a8317a8d5a71023c8e9183924",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "vasilis/rm-pairing-friendly-curves-id",
      "headRefOid": "b398c96b3d53b6cbb9695bfa7bea8498e730b3ec",
      "closedAt": "2023-12-18T22:19:23Z",
      "mergedAt": "2023-12-18T22:19:23Z",
      "mergedBy": "BasileiosKal",
      "mergeCommit": {
        "oid": "cd87c8ddbe129e7f8ff45371485ea0d1d6ea80b1"
      },
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> even an informative reference to an expired ID will probably cause problems.\r\n\r\nThat's true, but it is not \"forbidden\" (see the [bls sigs](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-bls-signature-05) reference to the [h2c rfc](https://www.rfc-editor.org/rfc/rfc9380.html#I-D.irtf-cfrg-bls-signature)). Even a normative reference is not an issue for the crypto panel review phase (it will certainly be a problem in later stages though).",
          "createdAt": "2023-12-16T20:07:11Z",
          "updatedAt": "2023-12-16T20:07:11Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on the WG call at the 18th of Dec. Will resolve conflicts and merge after that.",
          "createdAt": "2023-12-18T19:25:22Z",
          "updatedAt": "2023-12-18T19:25:22Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Conflicts resolved. Multiple approvals. Merging. Thank you all!",
          "createdAt": "2023-12-18T22:19:15Z",
          "updatedAt": "2023-12-18T22:19:15Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax85qHWuu",
          "commit": {
            "abbreviatedOid": "ce1e38f"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "even an informative reference to an expired ID will probably cause problems.",
          "createdAt": "2023-12-13T19:09:01Z",
          "updatedAt": "2023-12-13T19:09:01Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85qiBSM",
          "commit": {
            "abbreviatedOid": "ce1e38f"
          },
          "author": "Wind4Greg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-12-18T16:41:28Z",
          "updatedAt": "2023-12-18T16:41:28Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85qi9RK",
          "commit": {
            "abbreviatedOid": "ce1e38f"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-12-18T19:11:35Z",
          "updatedAt": "2023-12-18T19:11:35Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85qjCil",
          "commit": {
            "abbreviatedOid": "ce1e38f"
          },
          "author": "selfissued",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-12-18T19:27:31Z",
          "updatedAt": "2023-12-18T19:27:31Z",
          "comments": []
        }
      ]
    },
    {
      "number": 306,
      "id": "PR_kwDOF8lax85iLOex",
      "title": "Reference h2c as an RFC",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/306",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-12-16T21:07:52Z",
      "updatedAt": "2023-12-18T22:24:09Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "3bd6abe382095a4a8317a8d5a71023c8e9183924",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "vasilis/h2c-rfc",
      "headRefOid": "0b78cae7582c4720880bd460256e21cfdddc9e62",
      "closedAt": "2023-12-18T22:24:09Z",
      "mergedAt": "2023-12-18T22:24:09Z",
      "mergedBy": "BasileiosKal",
      "mergeCommit": {
        "oid": "05411383bcf867af786f7b9b194b077aab36ccf3"
      },
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed on the WG call at the 18th of Dec. Will resolve the conflicts and merge.",
          "createdAt": "2023-12-18T19:26:30Z",
          "updatedAt": "2023-12-18T19:26:30Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Resolved conflicts. Multiple approvals. Merging. Thank you everybody!",
          "createdAt": "2023-12-18T22:24:02Z",
          "updatedAt": "2023-12-18T22:24:02Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax85qh_tf",
          "commit": {
            "abbreviatedOid": "55fc1ad"
          },
          "author": "Wind4Greg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-12-18T16:37:47Z",
          "updatedAt": "2023-12-18T16:37:47Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85qi9-I",
          "commit": {
            "abbreviatedOid": "55fc1ad"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-12-18T19:13:45Z",
          "updatedAt": "2023-12-18T19:13:45Z",
          "comments": []
        }
      ]
    },
    {
      "number": 307,
      "id": "PR_kwDOF8lax85iS7XI",
      "title": "IETF idnits",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/307",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-12-18T18:58:04Z",
      "updatedAt": "2023-12-21T20:48:19Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "f8135b06b8e8a8331f78232cc223b7e6d447f6a7",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "vasilis/datatracker-nits",
      "headRefOid": "3f644fd2a230dd6f50cfe947b7558ba60c5373a5",
      "closedAt": "2023-12-21T20:48:19Z",
      "mergedAt": "2023-12-21T20:48:19Z",
      "mergedBy": "BasileiosKal",
      "mergeCommit": {
        "oid": "47a37686d12001217d2014065d6ef3ed8c410e23"
      },
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Multiple approvals. Editorial update. Merging. Thank you!",
          "createdAt": "2023-12-21T20:48:13Z",
          "updatedAt": "2023-12-21T20:48:13Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax85qjM03",
          "commit": {
            "abbreviatedOid": "dc7ef45"
          },
          "author": "Wind4Greg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-12-18T19:59:11Z",
          "updatedAt": "2023-12-18T19:59:11Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85qj9vv",
          "commit": {
            "abbreviatedOid": "d5d9f92"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-12-18T22:30:24Z",
          "updatedAt": "2023-12-18T22:30:24Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "```suggestion\r\n  *  ADD\\_INFO is an optional octet string indicating any additional information used to uniquely qualify the ciphersuite. When present this value MUST only contain ASCII encoded characters with codes between 0x21 and 0x7e (inclusive) and MUST end with an underscore (ASCII code: 0x5f). The last character MUST be the only underscore.\r\n```",
              "createdAt": "2023-12-18T22:30:24Z",
              "updatedAt": "2023-12-18T22:30:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax85qxVW7",
          "commit": {
            "abbreviatedOid": "1228eb6"
          },
          "author": "dwaite",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-12-20T16:57:57Z",
          "updatedAt": "2023-12-20T16:57:57Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85q5xc1",
          "commit": {
            "abbreviatedOid": "1228eb6"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-12-21T19:09:59Z",
          "updatedAt": "2023-12-21T19:09:59Z",
          "comments": []
        }
      ]
    },
    {
      "number": 312,
      "id": "PR_kwDOF8lax85lZUVP",
      "title": "spelling fix",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/312",
      "state": "MERGED",
      "author": "kdenhartog",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-01-30T01:51:48Z",
      "updatedAt": "2024-02-01T03:25:49Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "64f45aa812d17f10833027db9b685cf10604064e",
      "headRepository": "kdenhartog/bbs-signature",
      "headRefName": "patch-1",
      "headRefOid": "e006d207da8d9eedb408c84624d0765a2a3f1aaf",
      "closedAt": "2024-01-31T19:22:55Z",
      "mergedAt": "2024-01-31T19:22:55Z",
      "mergedBy": "andrewwhitehead",
      "mergeCommit": {
        "oid": "6946837b55d93615d3176e57d8a2a660c9b893b1"
      },
      "comments": [
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks!",
          "createdAt": "2024-01-31T19:23:01Z",
          "updatedAt": "2024-01-31T19:23:01Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax85uRipe",
          "commit": {
            "abbreviatedOid": "e006d20"
          },
          "author": "OR13",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-01-30T01:52:29Z",
          "updatedAt": "2024-01-30T01:52:29Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85uSHTr",
          "commit": {
            "abbreviatedOid": "e006d20"
          },
          "author": "dwaite",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-01-30T05:13:45Z",
          "updatedAt": "2024-01-30T05:13:45Z",
          "comments": []
        }
      ]
    },
    {
      "number": 319,
      "id": "PR_kwDOF8lax85xSqNz",
      "title": "Bound memory improvements",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/319",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #313\r\n\r\n\\+ new test vectors",
      "createdAt": "2024-06-03T12:15:10Z",
      "updatedAt": "2024-06-25T08:30:55Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "6946837b55d93615d3176e57d8a2a660c9b893b1",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "vasilis/bounded-memory",
      "headRefOid": "bf1d94bec67ba9723fdda90be2ecb48f5982d60b",
      "closedAt": "2024-06-25T08:30:55Z",
      "mergedAt": "2024-06-25T08:30:55Z",
      "mergedBy": "BasileiosKal",
      "mergeCommit": {
        "oid": "cc0ee269ef673b2a3aa9471de4066f2e100d126d"
      },
      "comments": [
        {
          "author": "Wind4Greg",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Great! Can you brief us at today's meeting?",
          "createdAt": "2024-06-03T17:34:17Z",
          "updatedAt": "2024-06-03T17:34:17Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Multiple approvals. Merging! Thank you all!",
          "createdAt": "2024-06-25T08:30:49Z",
          "updatedAt": "2024-06-25T08:30:49Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax85817mH",
          "commit": {
            "abbreviatedOid": "dee425f"
          },
          "author": "Wind4Greg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-03T17:46:46Z",
          "updatedAt": "2024-06-03T17:46:46Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "1. c_arr = (R, i1, ..., iR, msg_i1, ..., msg_iR, domain,",
              "createdAt": "2024-06-03T17:46:46Z",
              "updatedAt": "2024-06-03T17:46:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax858179Z",
          "commit": {
            "abbreviatedOid": "dee425f"
          },
          "author": "Wind4Greg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "See small change in text for c_arr.",
          "createdAt": "2024-06-03T17:47:40Z",
          "updatedAt": "2024-06-03T17:47:40Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax859Bp1w",
          "commit": {
            "abbreviatedOid": "dee425f"
          },
          "author": "Wind4Greg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-04T23:38:54Z",
          "updatedAt": "2024-06-04T23:38:54Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "My mistake. Didn't understand the syntax.",
              "createdAt": "2024-06-04T23:38:54Z",
              "updatedAt": "2024-06-04T23:38:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax859mGAd",
          "commit": {
            "abbreviatedOid": "dee425f"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-10T08:55:38Z",
          "updatedAt": "2024-06-10T08:55:38Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Added an extended description of the inputs to the challenge digest calculation. Hopefully this should better explain the intended ordering of the index, message pair in `c_arr`.",
              "createdAt": "2024-06-10T08:55:38Z",
              "updatedAt": "2024-06-10T08:55:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax859rP3D",
          "commit": {
            "abbreviatedOid": "bf1d94b"
          },
          "author": "Wind4Greg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Nice clear, higher level description of the challenge computation.",
          "createdAt": "2024-06-10T18:23:06Z",
          "updatedAt": "2024-06-10T18:23:06Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85-kumd",
          "commit": {
            "abbreviatedOid": "bf1d94b"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-06-17T18:15:35Z",
          "updatedAt": "2024-06-17T18:15:35Z",
          "comments": []
        }
      ]
    },
    {
      "number": 320,
      "id": "PR_kwDOF8lax85zhB9B",
      "title": "Editorial updates for draft 06",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/320",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Also fixes #317",
      "createdAt": "2024-06-25T15:38:48Z",
      "updatedAt": "2024-06-26T08:10:28Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "cc0ee269ef673b2a3aa9471de4066f2e100d126d",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "vasilis/draft-06",
      "headRefOid": "51e0f7552d5efe2ce14b9e3a0ce9c804452e3c07",
      "closedAt": "2024-06-26T08:10:28Z",
      "mergedAt": "2024-06-26T08:10:28Z",
      "mergedBy": "BasileiosKal",
      "mergeCommit": {
        "oid": "9e326b5fdd173e4d399d961e8de2a7ef559dc4f4"
      },
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Multiple approvals! Merging. Thank you all \ud83d\ude4f ",
          "createdAt": "2024-06-26T08:10:25Z",
          "updatedAt": "2024-06-26T08:10:25Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax85_gEkg",
          "commit": {
            "abbreviatedOid": "51e0f75"
          },
          "author": "Wind4Greg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Looks good Vasilis!",
          "createdAt": "2024-06-25T15:52:15Z",
          "updatedAt": "2024-06-25T15:52:15Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax85_k9CD",
          "commit": {
            "abbreviatedOid": "51e0f75"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-06-26T03:49:46Z",
          "updatedAt": "2024-06-26T03:49:46Z",
          "comments": []
        }
      ]
    },
    {
      "number": 324,
      "id": "PR_kwDOF8lax8564EOA",
      "title": "Various editorial and inconsistency fixes",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/324",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "- Addressed two comments made by @mmaker\r\n    - Proof de-serialization error\r\n    - Order of inputs in `CoreSign` call\r\n- Fixed #322\r\n- Fixed #309\r\n- Fixed wrong inputs in `calculate_domain` call in `CoreSign` and `CoreVerify`",
      "createdAt": "2024-09-09T16:33:24Z",
      "updatedAt": "2024-09-19T19:35:16Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "26c3949161303bce575b6503b18b95634367f775",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "vasilis/various-fixes",
      "headRefOid": "d3fca5c0a8556ea2393ee72f21870a2ab778c3d1",
      "closedAt": "2024-09-19T19:35:15Z",
      "mergedAt": "2024-09-19T19:35:15Z",
      "mergedBy": "BasileiosKal",
      "mergeCommit": {
        "oid": "e345f4aceabd0939ead46e0e40d00ea4467727a0"
      },
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Editorial updates. Multiple approvals. Merging. Thank you all!!",
          "createdAt": "2024-09-19T19:35:11Z",
          "updatedAt": "2024-09-19T19:35:11Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax86IiXc7",
          "commit": {
            "abbreviatedOid": "d3fca5c"
          },
          "author": "Wind4Greg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-09-09T18:56:42Z",
          "updatedAt": "2024-09-12T10:13:49Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax86KE2Ur",
          "commit": {
            "abbreviatedOid": "d3fca5c"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-09-19T19:04:20Z",
          "updatedAt": "2024-09-19T19:04:20Z",
          "comments": []
        }
      ]
    },
    {
      "number": 325,
      "id": "PR_kwDOF8lax8565DVk",
      "title": "Update Github Actions versions",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/325",
      "state": "MERGED",
      "author": "andrewwhitehead",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-09-09T19:01:48Z",
      "updatedAt": "2024-09-12T10:11:40Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "d69a231f2509ce45ed7b6277f6d6e018db06c22b",
      "headRepository": "andrewwhitehead/bbs-signature",
      "headRefName": "fix/actions-versions",
      "headRefOid": "58053ea52fbef3f414bcfe5e2c86de8f984c7bd3",
      "closedAt": "2024-09-12T10:11:40Z",
      "mergedAt": "2024-09-12T10:11:40Z",
      "mergedBy": "BasileiosKal",
      "mergeCommit": {
        "oid": "26c3949161303bce575b6503b18b95634367f775"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax86JFK0A",
          "commit": {
            "abbreviatedOid": "58053ea"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM! Thanks Andrew \ud83d\ude4f ",
          "createdAt": "2024-09-12T10:11:33Z",
          "updatedAt": "2024-09-12T10:11:33Z",
          "comments": []
        }
      ]
    },
    {
      "number": 326,
      "id": "PR_kwDOF8lax857V1BQ",
      "title": "Editorial review",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/326",
      "state": "MERGED",
      "author": "Wind4Greg",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Some small edits for readability. Started from end of document.\r\n\r\n1. Should use `NIZK` for acronym rather than `nizk`\r\n2. Removed \"subject to change\" warning on additional test vectors.\r\n3. Clarified scalar multiplication in *Notation* section. Document is very consistent with always using P*x where P is group element and x is scalar, in that order. *Notation* section had this reversed.",
      "createdAt": "2024-09-12T18:32:15Z",
      "updatedAt": "2024-09-19T19:34:54Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "26c3949161303bce575b6503b18b95634367f775",
      "headRepository": "Wind4Greg/bbs-signature",
      "headRefName": "editorial-review",
      "headRefOid": "66a2cb60035ca8643bfa18fbaa2f69fe0eb4eb89",
      "closedAt": "2024-09-19T19:34:54Z",
      "mergedAt": "2024-09-19T19:34:54Z",
      "mergedBy": "BasileiosKal",
      "mergeCommit": {
        "oid": "9cc9d49d9356b4febbce6210a45371ffa3372969"
      },
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Editorial updates. Multiple approvals. Merging. Thank you all \ud83d\ude4f",
          "createdAt": "2024-09-19T19:34:50Z",
          "updatedAt": "2024-09-19T19:34:50Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax86Jh9RG",
          "commit": {
            "abbreviatedOid": "66a2cb6"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-09-16T18:09:36Z",
          "updatedAt": "2024-09-16T18:09:36Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax86KE2nw",
          "commit": {
            "abbreviatedOid": "66a2cb6"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-09-19T19:05:06Z",
          "updatedAt": "2024-09-19T19:05:06Z",
          "comments": []
        }
      ]
    },
    {
      "number": 330,
      "id": "PR_kwDOF8lax86FX8j2",
      "title": "Address Crypto Panel review comments",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/330",
      "state": "OPEN",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Editorial updates to address the CFRG Crypto Panel review: https://mailarchive.ietf.org/arch/msg/crypto-panel/Vk5O4h_U3-QcWrm22KWwRFmSl7E/",
      "createdAt": "2024-12-16T15:32:54Z",
      "updatedAt": "2024-12-18T00:49:19Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "4aad363595c847d066611f8a789ec5afeed8659d",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "vasilis/crypto-panel-review",
      "headRefOid": "9f1efa12fa1b378cf9661133b06f87f6a8869e85",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax86VcDAm",
          "commit": {
            "abbreviatedOid": "9f1efa1"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-16T19:40:23Z",
          "updatedAt": "2024-12-16T19:40:24Z",
          "comments": [
            {
              "originalPosition": 320,
              "body": "```suggestion\r\nOn the other hand, the misuse of a `presentation_header`, chosen by the Prover and only bound to a BBS proof, does not incur as many privacy risks as the `header` value. For example, since a new `presentation_header` can be chosen each time a BBS proof is generated, random values are a viable choice. Still, to not break the unlinkability property, care must be taken that the `presentation_header` does not identify a single or small group of Provers. Acceptable values include random octet strings (possibly received from the Verifier, prior to the generation of the BBS proof), or more generally, any message the Prover may want to protect its integrity when presenting a BBS proof (note that the `presentation_header` value, when used, can be considered as \"signed\" by the Prover). Unacceptable values include the Prover's phone number, their complete physical address, their date of their birth etc..\r\n```",
              "createdAt": "2024-12-16T19:40:23Z",
              "updatedAt": "2024-12-16T19:40:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax86VcFzm",
          "commit": {
            "abbreviatedOid": "9f1efa1"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-16T19:42:23Z",
          "updatedAt": "2024-12-16T19:42:23Z",
          "comments": [
            {
              "originalPosition": 329,
              "body": "```suggestion\r\nNote that all core operations as defined in (#core-operations) expect the Signer's public key as input. It is RECOMMENDED for all those operations, that they deserialize the public key first using the `octets_to_pubkey` procedure defined in (#octets-to-public-key), even if they only require the octet string representation of the public key. If the `octets_to_pubkey` procedure returns INVALID, the calling operation should also return INVALID and abort. This recommendation applies is the `CoreSign` ((#coresign)) and `CoreProofGen` ((#coreproofgen)) operations. An explicit invocation to the `octets_to_pubkey` operation is already defined and therefore required in the `CoreVerify` ((#coreverify)) and `CoreProofVerify` ((#coreproofverify)) operations. If the required checks for the validity of the Signer's public key are not performed, the results are unpredictable, leading to unexpected vulnerabilities (for example, the output of the pairing operation on input of an invalid elliptic curve point can be highly irregular and implementation-dependent, with some returning the identity point of the elliptic curve and others returning errors).\r\n```",
              "createdAt": "2024-12-16T19:42:23Z",
              "updatedAt": "2024-12-16T19:42:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax86VcIpx",
          "commit": {
            "abbreviatedOid": "9f1efa1"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-16T19:44:19Z",
          "updatedAt": "2024-12-16T19:44:19Z",
          "comments": [
            {
              "originalPosition": 366,
              "body": "```suggestion\r\nOn the other hand, data confidentiality cannot be broken, even by adversaries with unbounded computational resources and in possession of the Signer's secret key. This means that even by utilizing a CRQC, adversaries will not be able to compromise the data confidentiality property of BBS proofs. As a result, an adversary with access to such a quantum computer, will not be able to reveal neither the messages undisclosed by a BBS proof, nor the hidden signature value (which the Prover showcases possession of). This guarantees that the privacy and hiding properties of BBS proofs that are currently used, will not be compromised by future quantum-attacks (a property that is often referred to as everlasting privacy). Note that this only considers BBS proofs, not BBS signatures, which do not possess the same hiding properties as the BBS proofs.\r\n```",
              "createdAt": "2024-12-16T19:44:19Z",
              "updatedAt": "2024-12-16T19:44:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax86VcKCu",
          "commit": {
            "abbreviatedOid": "9f1efa1"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-16T19:45:12Z",
          "updatedAt": "2024-12-16T19:45:12Z",
          "comments": [
            {
              "originalPosition": 222,
              "body": "```suggestion\r\nThis operation computes a deterministic signature from a secret key (`SK`), a set of `generators` (points of G1) and optionally a `header` and a vector of `messages`. Note that signature generation is deterministic, in contrast to the academic literature, where signature generation, and more specifically the calculation of the `e` value (Procedure step 2 below), is randomized (i.e., the `e` value is drawn at random, instead of been deterministically calculated by hashing the Signer's secret key and the list of messages). This alteration not only protects the scheme (at least the signature generation part) from vulnerabilities related to bad entropy sources, it also makes testing of the `CoreSign` operation easier.\r\n```",
              "createdAt": "2024-12-16T19:45:12Z",
              "updatedAt": "2024-12-16T19:45:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax86VcO3J",
          "commit": {
            "abbreviatedOid": "9f1efa1"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-16T19:49:01Z",
          "updatedAt": "2024-12-16T19:49:02Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nThis document describes the BBS Signature scheme, a secure, multi-message digital signature protocol, supporting proving knowledge of a signature while selectively disclosing any subset of the signed messages. Concretely, the scheme allows for signing multiple messages whilst producing a single, constant size, digital signature. Additionally, the possessor of a BBS signatures is able to create zero-knowledge, proofs of knowledge of a signature, while selectively disclosing subsets of the signed messages. Being zero-knowledge, the BBS proofs do not reveal any information about the undisclosed messages or the signature it self, while at the same time, guaranteeing the authenticity and integrity of the disclosed messages.\r\n```",
              "createdAt": "2024-12-16T19:49:01Z",
              "updatedAt": "2024-12-16T19:49:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax86VcPwn",
          "commit": {
            "abbreviatedOid": "9f1efa1"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-16T19:49:41Z",
          "updatedAt": "2024-12-16T19:49:41Z",
          "comments": [
            {
              "originalPosition": 165,
              "body": "```suggestion\r\nThe `ProofGen` operation creates a BBS proof, which is a zero-knowledge, proof-of-knowledge of a BBS signature, while optionally disclosing any subset of the signed messages. Validating the proof (see `ProofVerify` defined in (#proof-verification-proofverify)) guarantees authenticity and integrity of the `header` and disclosed messages, as well as knowledge of a valid BBS signature.\r\n```",
              "createdAt": "2024-12-16T19:49:41Z",
              "updatedAt": "2024-12-16T19:49:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax86VcQvz",
          "commit": {
            "abbreviatedOid": "9f1efa1"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-16T19:50:23Z",
          "updatedAt": "2024-12-16T19:50:23Z",
          "comments": [
            {
              "originalPosition": 195,
              "body": "```suggestion\r\nThe `ProofVerify` operation validates a BBS proof, given the Signer's public key (`PK`), a `header` and `presentation_header` values, the disclosed messages and the indexes those messages had in the original vector of signed messages.\r\n```",
              "createdAt": "2024-12-16T19:50:23Z",
              "updatedAt": "2024-12-16T19:50:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax86VcS5r",
          "commit": {
            "abbreviatedOid": "9f1efa1"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-16T19:51:59Z",
          "updatedAt": "2024-12-16T19:52:00Z",
          "comments": [
            {
              "originalPosition": 317,
              "body": "```suggestion\r\nAs mentioned in Section (#header-and-presentation-header), the `header` value is chosen by the Signer and bound to a BBS Signature and proof. Consequently, it must be revealed to the Verifier, together with a BBS proof. If that `header` value is chosen to have high entropy (i.e., unique per credential, Prover or small group of Provers), it can be used as a correlation vector to trace and link together all BBS proofs made by a signature bound to that `header` value. This will result to significantly worst privacy guarantees, by allowing adversaries to trace and link together all generated proofs bound to that `header` value (for example, if a random `header` is used during each BBS signature generation, adversaries will be able to link and trace the BBS proofs generated from that signature). The Issuer MUST choose a low entropy `header` value and it MUST be the same for a large number of users (Provers). Acceptable values include an application identifier, a country identifier etc.. Unacceptable values include random values, high cardinality expiration dates, the Prover's email address etc..\r\n```",
              "createdAt": "2024-12-16T19:51:59Z",
              "updatedAt": "2024-12-16T19:52:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax86VcWSf",
          "commit": {
            "abbreviatedOid": "9f1efa1"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-16T19:55:43Z",
          "updatedAt": "2024-12-16T19:55:43Z",
          "comments": [
            {
              "originalPosition": 313,
              "body": "```suggestion\r\nThe following sections will describe possible privacy threats, resulting from such values and side channels, that could compromise the unlinkability property of the BBS proof. Note that, the following sections describe ways to minimize possible identifying information revealed during a BBS proof presentation, related to the BBS Signatures scheme. To minimize the privacy threats of an entire system, other protections may also need to be employed, for example, using an IP hiding proxy network like TOR ([@DMS04]).\r\n```",
              "createdAt": "2024-12-16T19:55:43Z",
              "updatedAt": "2024-12-16T19:55:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax86Voa8u",
          "commit": {
            "abbreviatedOid": "9f1efa1"
          },
          "author": "Wind4Greg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-17T23:33:37Z",
          "updatedAt": "2024-12-17T23:33:37Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "\"signature it self,\" should be \"signature itself,\"",
              "createdAt": "2024-12-17T23:33:37Z",
              "updatedAt": "2024-12-17T23:33:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax86VobfJ",
          "commit": {
            "abbreviatedOid": "9f1efa1"
          },
          "author": "Wind4Greg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-17T23:35:43Z",
          "updatedAt": "2024-12-17T23:35:43Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "\"the value of BBS proof\" should be \"the value of a BBS proof\"",
              "createdAt": "2024-12-17T23:35:43Z",
              "updatedAt": "2024-12-17T23:35:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax86Vod1O",
          "commit": {
            "abbreviatedOid": "9f1efa1"
          },
          "author": "Wind4Greg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-17T23:43:34Z",
          "updatedAt": "2024-12-17T23:43:35Z",
          "comments": [
            {
              "originalPosition": 105,
              "body": "\"their interaction with a prover Verifier,\" should be \"their interaction with a Verifier,\" right?",
              "createdAt": "2024-12-17T23:43:35Z",
              "updatedAt": "2024-12-17T23:43:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax86VoeQA",
          "commit": {
            "abbreviatedOid": "9f1efa1"
          },
          "author": "Wind4Greg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-17T23:45:13Z",
          "updatedAt": "2024-12-17T23:45:14Z",
          "comments": [
            {
              "originalPosition": 115,
              "body": "\"inputted message is an octet\" should be \"input message is an octet\"",
              "createdAt": "2024-12-17T23:45:13Z",
              "updatedAt": "2024-12-17T23:45:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax86VofsX",
          "commit": {
            "abbreviatedOid": "9f1efa1"
          },
          "author": "Wind4Greg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-17T23:48:27Z",
          "updatedAt": "2024-12-17T23:48:27Z",
          "comments": [
            {
              "originalPosition": 165,
              "body": "ProofGen also uses the `presentation_header` and ProofVerify uses that and `header` and disclosed messages...",
              "createdAt": "2024-12-17T23:48:27Z",
              "updatedAt": "2024-12-17T23:48:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax86VosKX",
          "commit": {
            "abbreviatedOid": "9f1efa1"
          },
          "author": "Wind4Greg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-18T00:29:17Z",
          "updatedAt": "2024-12-18T00:29:17Z",
          "comments": [
            {
              "originalPosition": 275,
              "body": "\"The inputted `presentation_header` (`ph`) values.\" should be \"The input `presentation_header` (`ph`) values.\"",
              "createdAt": "2024-12-18T00:29:17Z",
              "updatedAt": "2024-12-18T00:29:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax86VotDz",
          "commit": {
            "abbreviatedOid": "9f1efa1"
          },
          "author": "Wind4Greg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-18T00:32:46Z",
          "updatedAt": "2024-12-18T00:32:46Z",
          "comments": [
            {
              "originalPosition": 311,
              "body": "\"gurantees consearn only the proof\" should be \"guarantees concern only the proof\"\r\n\" and ofcourse\" should be \"  and of course\"",
              "createdAt": "2024-12-18T00:32:46Z",
              "updatedAt": "2024-12-18T00:32:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax86Vot9E",
          "commit": {
            "abbreviatedOid": "9f1efa1"
          },
          "author": "Wind4Greg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-18T00:33:52Z",
          "updatedAt": "2024-12-18T00:33:52Z",
          "comments": [
            {
              "originalPosition": 313,
              "body": "\"side chanells,\" should be \"side channels,\"",
              "createdAt": "2024-12-18T00:33:52Z",
              "updatedAt": "2024-12-18T00:33:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax86Vou3P",
          "commit": {
            "abbreviatedOid": "9f1efa1"
          },
          "author": "Wind4Greg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-18T00:36:43Z",
          "updatedAt": "2024-12-18T00:36:44Z",
          "comments": [
            {
              "originalPosition": 317,
              "body": "\"corelation vector\" should be \"correlation vector\"\r\n\"gurantees, by allowing\" should be \"guarantees, by allowing\"\r\n\"Anacceptable values\" should be \"Unacceptable values\"",
              "createdAt": "2024-12-18T00:36:44Z",
              "updatedAt": "2024-12-18T00:36:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax86VowHU",
          "commit": {
            "abbreviatedOid": "9f1efa1"
          },
          "author": "Wind4Greg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-18T00:40:29Z",
          "updatedAt": "2024-12-18T00:40:29Z",
          "comments": [
            {
              "originalPosition": 320,
              "body": "\"the missuss of a\" should be \"the misuse of a\"\r\n\"viable choise.\" should be \"viable choice.\"\r\n\"Anacceptable values\" should be \"Unacceptable values\"",
              "createdAt": "2024-12-18T00:40:29Z",
              "updatedAt": "2024-12-18T00:40:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax86VoxKA",
          "commit": {
            "abbreviatedOid": "9f1efa1"
          },
          "author": "Wind4Greg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-18T00:44:27Z",
          "updatedAt": "2024-12-18T00:44:27Z",
          "comments": [
            {
              "originalPosition": 329,
              "body": "\"recommendation applies is the\" should be \"recommendation applies to the\"\r\n\"be highly iregural\" should be \"be highly irregular\"\r\n\"and implementation dependant,\" should be \"and implementation dependent,\"\r\n\"and others returnong errors)\" should be \"and others returning errors)\"",
              "createdAt": "2024-12-18T00:44:27Z",
              "updatedAt": "2024-12-18T00:44:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax86VoyB3",
          "commit": {
            "abbreviatedOid": "9f1efa1"
          },
          "author": "Wind4Greg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-18T00:48:09Z",
          "updatedAt": "2024-12-18T00:48:09Z",
          "comments": [
            {
              "originalPosition": 366,
              "body": "\"reveal neither the messages undisclosed by a BBS proof, nor the hidden signature value\" should be \"reveal either the messages undisclosed by a BBS proof, or the hidden signature value\"",
              "createdAt": "2024-12-18T00:48:09Z",
              "updatedAt": "2024-12-18T00:48:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax86Voyls",
          "commit": {
            "abbreviatedOid": "9f1efa1"
          },
          "author": "Wind4Greg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Looks good Vasilis. See separate comments for nits.",
          "createdAt": "2024-12-18T00:49:19Z",
          "updatedAt": "2024-12-18T00:49:19Z",
          "comments": []
        }
      ]
    }
  ]
}