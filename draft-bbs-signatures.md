%%%
title = "The BBS Signature Scheme"
abbrev = "The BBS Signature Scheme"
ipr= "none"
area = "Internet"
workgroup = "none"
submissiontype = "IETF"
keyword = [""]

[seriesInfo]
name = "Individual-Draft"
value = "draft-bbs-signatures-latest"
status = "informational"

[[author]]
initials = "M."
surname = "Lodder"
fullname = "Mike Lodder"
#role = "editor"
organization = "CryptID"
  [author.address]
  email = "redmike7gmail.com"

[[author]]
initials = "T."
surname = "Looker"
fullname = "Tobias Looker"
#role = "editor"
organization = "MATTR"
  [author.address]
  email = "tobias.looker@mattr.global"

[[author]]
initials = "A."
surname = "Whitehead"
fullname = "Andrew Whitehead"
#role = "editor"
organization = ""
  [author.address]
  email = "cywolf@gmail.com"

[[author]]
initials = "V."
surname = "Kalos"
fullname = "Vasileios Kalos"
#role = "editor"
organization = "MATTR"
  [author.address]
  email = "vasilis.kalos@mattr.global"
%%%

.# Abstract

BBS is a digital signature scheme categorized as a form of short group signature that supports several unique properties. Notably, the scheme supports signing multiple messages whilst producing a single output digital signature. Through this capability, the possessor of a signature is able to derive proofs that selectively disclose subsets of the originally signed set of messages, whilst preserving the verifiable authenticity and integrity of the messages. Furthermore, these derived proofs are said to be zero-knowledge in nature as they do not reveal the underlying signature; instead, what they reveal is a proof of knowledge of the undisclosed signature.

{mainmatter}

# Introduction

A digital signature scheme is a fundamental cryptographic primitive that is used to provide data integrity and verifiable authenticity in various protocols. The core premise of digital signature technology is built upon asymmetric cryptography where-by the possessor of a private key is able to sign a message, where anyone in possession of the corresponding public key matching that of the private key is able to verify the signature.

However, traditional digital signature schemes require both the signature and the entire message to be disclosed during verification, constraining its usage in certain applications.

The BBS Signature scheme provides multiple unique properties when compared with conventional digital signature schemes, however three key ones are:

**Selective Disclosure** - The scheme allows a signer to sign multiple payloads while still produce a single output signature. An intermediary then possessing the payloads and the signature can generate a proof whereby they can choose which payloads to reveal.

**Unlinkable Proof Presentations** - The proofs generated by the scheme are known as a signature proof of knowledge meaning a verifying party in receipt of a proof is unable to determine which signature was used to generate the proof.

**Scoped Proofs** - The proofs generated by the scheme feature a presentation header where the proving party is able to include any information they would like to cryptographically tie to the proof. This can include a cryptographic nonce and or an audience/domain identifier to ensure the generated proof can only be used appropriately and provides a way for a verifying/relying party to detect a replay attack.

Refer to (#usecases) for an elaboration on where and when these properties are useful

Below is a basic diagram describing the main entities involved in using the scheme

!---
~~~ ascii-art
  (1) sign                                       (3) ProofGen                                        (5) ProofVerify
  +-----                                         +-----                                               +-----
  |    |                                         |    |                                               |    |
  |    |                                         |    |                                               |    |
  |   \ /                                        |   \ /                                              |   \ /
+----------+                                   +-----------+                                        +-----------+
|          |                                   |           |                                        |           |
|          |                                   |           |                                        |           |
|          |                                   |           |                                        |           |
|  Signer  |---(2)* Send signature + msgs----->|  Holder/  |---(4)* Send proof + revealed msgs----->| Verifier  |
|          |                                   |  Prover   |                                        |           |
|          |                                   |           |                                        |           |
|          |                                   |           |                                        |           |
+----------+                                   +-----------+                                        +-----------+
~~~
!---
Figure: Basic diagram capturing the main entities involved in using the scheme

**Note** The protocols implied by the items annotated by an asterisk are out of scope for this specification

## Terminology

The following terminology is used throughout this document:

SK
: The secret key for the signature scheme.

PK
: The public key for the signature scheme.

L
: The total number of signed messages.

R
: The set of message indices that are retained or hidden in a signature proof of knowledge.

D
: The set of message indices that are disclosed in a signature proof of knowledge.

msg
: An input message to be signed by the signature scheme.

generator
: A valid point on the selected sub-group of the curve being used that is used to commit a value.

H_s
: A generator for the blinding value in the signature. The value of H_s is defined by each ciphersuite and must always be supplied to the operations listing it as a parameter.

H_d
: A generator for the signature domain, which binds both signature and proof to a specific context. The value of H_d is defined by each ciphersuite and must always be supplied to the operations listing it as a parameter.

signature
: The digital signature output.

nonce
: A cryptographic nonce

presentation\_header (ph)
: A payload generated and bound to the context of a specific spk.

nizk
: A non-interactive zero-knowledge proof from fiat-shamir heuristic.

dst
: The domain separation tag.

I2OSP
: As defined by Section 4 of [@!RFC8017]

OS2IP
: As defined by Section 4 of [@!RFC8017].

## Notation

The following notation and primitives are used:

a || b
: Denotes the concatenation of octet strings a and b.

I \\ J
: For sets I and J, denotes the difference of the two sets i.e., all the elements of I that do not appear in J, in the same order as they were in I.

X\[a..b\]
: Denotes a slice of the array `X` containing all elements from and including the value at index `a` until and including the value at index `b`. Note when this syntax is applied to an octet string, each element in the array `X` is assumed to be a single byte.

Terms specific to pairing-friendly elliptic curves that are relevant to this document are restated below, originally defined in [@!I-D.irtf-cfrg-pairing-friendly-curves]

E1, E2
: elliptic curve groups defined over finite fields. This document assumes that E1 has a more compact representation than E2, i.e., because E1 is defined over a smaller field than E2.

G1, G2
: subgroups of E1 and E2 (respectively) having prime order p.

GT
: a subgroup, of prime order p, of the multiplicative group of a field extension.

e
: G1 x G2 -> GT: a non-degenerate bilinear map.

r
: The prime order of the G1 and G2 subgroups.

P1, P2
: points on G1 and G2 respectively. For a pairing-friendly curve, this document denotes operations in E1 and E2 in additive notation, i.e., P + Q denotes point addition and x \* P denotes scalar multiplication. Operations in GT are written in multiplicative notation, i.e., a \* b is field multiplication.

Identity\_G1, Identity\_G1
: The identity element for the G1 and G2 subgroups respectively.

hash\_to\_curve\_g1(ostr) -> P
: A cryptographic hash function that takes as an arbitrary octet string input and returns a point in G1 as defined in [@!I-D.irtf-cfrg-hash-to-curve].

point\_to\_octets(P) -> ostr
: returns the canonical representation of the point P as an octet string. This operation is also known as serialization.

octets\_to\_point(ostr) -> P
: returns the point P corresponding to the canonical representation ostr, or INVALID if ostr is not a valid output of point\_to\_octets.  This operation is also known as deserialization.

subgroup\_check(P) -> VALID or INVALID
: returns VALID when the point P is an element of the subgroup of order p, and INVALID otherwise. This function can always be implemented by checking that p \* P is equal to the identity element.  In some cases, faster checks may also exist, e.g., [@Bowe19].

## Organization of this document

This document is organized as follows:

* (#scheme-definition) defines the BBS signature scheme including any parameters required to define a concrete ciphersuite.

* (#security-considerations) defines security considerations associated to the signature scheme.

* (#ciphersuites) defines the format of a ciphersuite, alongside a concrete ciphersuite based on the BLS12-381 curve.

# Conventions

The keywords **MUST**, **MUST NOT**, **REQUIRED**, **SHALL**, **SHALL NOT**, **SHOULD**,
**SHOULD NOT**, **RECOMMENDED**, **MAY**, and **OPTIONAL**, when they appear in this
document, are to be interpreted as described in [@!RFC2119].

# Scheme Definition

This section defines the BBS signature scheme, including the parameters required to define a concrete ciphersuite.

## Parameters

The schemes operations defined in (#operations) depend the following parameters:

* A pairing-friendly elliptic curve, plus associated functionality given in Section 1.4.

* hash, a hash function that MUST be a secure cryptographic hash function. For security, hash MUST output at least `ceil(log2(r))` bits, where r is the order of the subgroups G1 and G2 defined by the pairing-friendly elliptic curve. See [encoding of elements to be hashed](#encoding-of-elements-to-be-hashed) for details on how the inputs to the function must be encoded.

* xof, a cryptographically secure extendable-output function like SHAKE128 or SHAKE256. xof outputs any desirable amount of bytes using the `.read(int)` method. See [Encoding of elements to be hashed](#encoding-of-elements-to-be-hashed) for details on how the inputs to the function must be encoded.

* PRF(n): a pseudo-random function similar to [@!RFC4868]. Returns n pseudo randomly generated bytes.

## Considerations

### Subgroup Selection

In definition of this signature scheme there are two possible variations based upon the sub-group selection, namely where public keys are defined in G2 and signatures in G1 OR the opposite where public keys are defined in G1 and signatures in G2. Some pairing cryptography based digital signature schemes such as [@I-D.irtf-cfrg-bls-signature] elect to allow for both variations, because they optimize for different things. However, in the case of this scheme, due to the operations involved in both signature and proof generation being computational in-efficient when performed in G2 and in the pursuit of simplicity, the scheme is limited to a construction where public keys are in G2 and signatures in G1.

### Messages and generators

Throughout the operations of this signature scheme, each message that is signed is paired with a specific generator (point in G1). Specifically, if a generator `H_1` is multiplied with `msg_1` during signing, then `H_1` MUST be multiplied with `msg_1` in all other operations as well (signature verification, proof generation and proof verification). For simplicity, each function will take as input the list of generators to be used with the messages. Those generators can be any distinct element from the generators list `H`. Applications for efficiency can elect to pass the indexes of those generators to the list `H` instead. Care must be taken for the correct generator to be raised to the correct message in that case.

Aside from the message generators, the scheme uses two additional generators: `H_s` and `H_d`. The first (`H_s`), is used for the blinding value (`s`) of the signature. The second generator (`H_d`), is used to sign the signature's domain, which binds both signature and proof to a specific context and cryptographically protects any potential application-specific information (for example, messages that must always be disclosed etc.).

### Encoding of elements to be hashed.

To avoid ambiguity, each element passed to the hash or the xof function, including situations when multiple elements are supplied in a concatenated form, must first be encoded to an appropriate format, depending on its type. Specifically,

- Points in G1 or G2 must be encoded using the `point_to_octets` implementation for a particular ciphersuite.
- Non-negative integers must be encoded using `I2OSP` with an output length of 8 bytes.
- Scalars must be zero-extended to a fixed length, defined by a particular ciphersuite.
- Octet strings must be zero-extended to a length that is a multiple of 8 bits. Then, the extended value is encoded directly.
- ASCII strings must be transformed into octet strings using UTF-8 encoding.

After encoding, octet strings MUST be prepended with a value representing the length of their binary representation in the form of the number of bytes. If the octet string represents a DST, then its length must be encoded to octets using I2OSP with ouptut length of 1 byte. If it is a generic octet string (not representing a DST), its length must be encoded to octets using I2OSP with ouptut length of 8 bytes. The combined value (encoded value + length prefix) binary representation is then encoded as a single octet string. For example, the string `0x14d` will be encoded as `0x0000000000000002014d`. DSTs with length larger than 2^8 - 1 MUST be rejected. Other octet-strings (not DSTs) with length larger than 2^64 - 1, MUST also be rejected.

As an example of the above transformations, consider the following. Assume that one wants to hash together the message `"Jane"` and the number `25`. The procedure would be

- Calculate octets of the message `"Jane"` and the number `25` as,
   ```
   message_octets = 0x4a616e65
   number_octets = I2OSP(25, 4) = 0x0000000000000019
   ```
- Calculate the length of the message binary representation (message_octets) and transform it to octets i.e., `len(message_octets) = I2OSP(4, 8) = 0x0000000000000004`.
- Prepend the length calculated in the previous step to the message's binary representation and concatenate the result with the octets representing the number `25`, to get the octets to be hashed,
   ```
   octets_to_hash = len(message_octets) || message_octets || number_octets =
                  = 0x00000000000000044a616e650000000000000019
   ```
- hash the result (i.e., `hash(octets_to_hash)`)

For readability, this document makes these transformations implicitly, but they MUST precede every call to the hash or xof function.

Optional input/parameters to operations that feature in a call to a HASH or XOF function, that are not supplied to the operation should default to an empty octet string. For example, if X is an optional input/parameter that is not supplied, whilst A and B are required, then the procedural step of `HASH(A || X || B)` MUST be evaluated to `HASH(A || "" || B)`.

## Operations

### KeyGen

This operation generates a secret key (SK) deterministically from a secret octet string (IKM).

KeyGen uses an HKDF [@!RFC5869] instantiated with the hash function hash.

For security, IKM MUST be infeasible to guess, e.g. generated by a trusted source of randomness.

IKM MUST be at least 32 bytes long, but it MAY be longer.

Because KeyGen is deterministic, implementations MAY choose either to store the resulting SK or to store IKM and call KeyGen to derive SK when necessary.

KeyGen takes an optional parameter, key\_info. This parameter MAY be used to derive multiple independent keys from the same IKM.  By default, key\_info is the empty string.

```
SK = KeyGen(IKM)

Inputs:

- IKM (REQUIRED), a secret octet string. See requirements above.

Parameters:

- key_info (OPTIONAL), an octet string. if this is not supplied, it MUST default to an empty string.

Definitions:

- HKDF-Extract is as defined in [@!RFC5869], instantiated with hash function hash.
- HKDF-Expand is as defined in [@!RFC5869], instantiated with hash function hash.
- I2OSP and OS2IP are as defined in [@!RFC8017], Section 4.
- L is the integer given by ceil((3 * ceil(log2(r))) / 16).
- INITSALT is the ASCII string "BBS-SIG-KEYGEN-SALT-".

Outputs:

- SK, a uniformly random integer such that 0 < SK < r.

Procedure:

1. salt = INITSALT

2. SK = 0

3. while SK == 0:

4.     salt = hash(salt)

5.     PRK = HKDF-Extract(salt, IKM || I2OSP(0, 1))

6.     OKM = HKDF-Expand(PRK, key_info || I2OSP(L, 2), L)

7.     SK = OS2IP(OKM) mod r

8. return SK
```

**Note** This operation is the RECOMMENDED way of generating a secret key, but its use is not required for compatibility, and implementations MAY use a different KeyGen procedure. For security, such an alternative MUST output a secret key that is statistically close to uniformly random in the range 1 <= SK < r.

### SkToPk

This operation takes a secret key (SK) and outputs a corresponding public key (PK).

```
PK = SkToPk(SK)

Inputs:

- SK (REQUIRED), a secret integer such that 0 < SK < r.

Outputs:

- PK, a public key encoded as an octet string.

Procedure:

1. W = SK * P2

2. PK = W

3. return point_to_octets(PK)
```

### KeyValidate

This operation checks if a public key is valid.

As an optimization, implementations MAY cache the result of KeyValidate in order to avoid unnecessarily repeating validation for known public keys.

```
result = KeyValidate(PK)

Inputs:

- PK (REQUIRED), an octet string of the form outputted by the SkToPk operation.

Outputs:

- result, either VALID or INVALID.

Procedure:

1. W = octets_to_point(PK)

2. if W is INVALID, return INVALID

3. if subgroup_check(A) is INVALID, return INVALID

4. If W == Identity_G2, return INVALID

5. return VALID
```

### Sign

This operation computes a deterministic signature from a secret key (SK) and optionally over a header and or a vector of messages.

```
signature = Sign(SK, PK, header, (msg_1,..., msg_L), (H_1,..., H_L))

Inputs:

- SK (REQUIRED), an octet string of the form outputted by the KeyGen operation.
- PK (REQUIRED), an octet string of the form outputted by the SkToPk operation provided the above SK as input.
- header (OPTIONAL), an octet string containing context and application specific information. If not supplied, it defaults to an empty string.
- msg_1,..., msg_L (OPTIONAL), a vector of octet strings.
- H_1,..., H_L (OPTIONAL), points of G1. Generators used to commit each message.

Parameters:

- Ciphersuite_ID (REQUIRED), ASCII string. The unique ID of the ciphersuite.
- H_s (REQUIRED), point of G1. The generator for the blinding value of the signature.
- H_d (REQUIRED), point of G1. The generator used to sign the signature domain.

Definitions:

- L, is the non-negative integer representing the number of messages to be signed e.g length(msg_1,...,msg_L).  Note if no messages are supplied as an input to this operation, the value of L MUST evaluate to zero (0).

Outputs:

- signature, a signature encoded as an octet string.

Procedure:

1. W = octets_to_point(PK)

2. if W is INVALID, abort

3. generators =  (H_s || H_d || H_1 || ... || H_L)

4. domain = OS2IP(hash(PK || L || generators || Ciphersuite_ID || header)) mod r

5. if domain is 0, abort

6. h = xof(SK  || domain || msg_1 || ... || msg_L)

7. for element in (e, s) do

8.      element = OS2IP(h.read(xof_no_of_bytes)) mod r

9.      if element = 0, go back to step 4

10. B = P1 + H_s * s + H_d * domain + H_1 * msg_1 + ... + H_L * msg_L

11. A = B * (1 / (SK + e))

12. signature_octets = signature_to_octets(A, e, s)

13. return signature_octets
```

### Verify

This operation checks that a signature is valid for a given header and vector of messages against a supplied public key (PK).

```
result = Verify(PK, signature, header, (msg_1,..., msg_L), (H_1,..., H_L))

Inputs:

- PK (REQUIRED), an octet string of the form outputted by the SkToPk operation.
- signature (REQUIRED), an octet string of the form outputted by the Sign operation.
- header (OPTIONAL), an octet string containing context and application specific information. If not supplied, it defaults to an empty string.
- msg_1,..., msg_L (OPTIONAL), an optional vector of octet strings.
- H_1,..., H_L (OPTIONAL), points of G1. Generators used to commit each message.

Parameters:

- Ciphersuite_ID (REQUIRED), ASCII string. The unique ID of the ciphersuite.
- H_s (REQUIRED), point of G1. The generator for the blinding value of the signature.
- H_d (REQUIRED), point of G1. The generator used to sign the signature domain.

Definitions:

- L, is the non-negative integer representing the number of messages to be signed e.g length(msg_1,...,msg_L). Note if no messages are supplied as an input to this operation, the value of L MUST evaluate to zero (0).

Outputs:

- result, either VALID or INVALID.

Procedure:

1. signature_result = octets_to_signature(signature)

2. if signature_result is INVALID, return INVALID

3. (A, e, s) = signature_result

4. if KeyValidate(PK) is INVALID, return INVALID

5. W = octets_to_point(PK)

6. generators =  (H_s || H_d || H_1 || ... || H_L)

7. domain = OS2IP(hash(PK || L || generators || Ciphersuite_ID || header)) mod r

8. B = P1 + H_s * s + H_d * domain + H_1 * msg_1 + ... + H_L * msg_L

9. C1 = e(A, W + P2 * e)

10. C2 = e(B, P2)

11. return C1 == C2
```

### ProofGen

This operation computes a zero-knowledge proof-of-knowledge of a signature, while optionally selectively disclosing from the original set of signed messages. The "prover" may also supply a presentation header, see [presentation header selection](#presentation-header-selection) for more details.

If an application chooses to pass the indexes of the generators instead, then it will also need to pass the indexes of the generators corresponding to the revealed messages.

```
proof = ProofGen(PK, signature, header, ph, (msg_1,..., msg_L), (H_1,..., H_L), RevealedIndexes)

Inputs:

- PK (REQUIRED), an octet string of the form outputted by the SkToPk operation.
- signature (REQUIRED), an octet string of the form outputted by the Sign operation.
- header (OPTIONAL), an octet string containing context and application specific information. If not supplied, it defaults to an empty string.
- ph (OPTIONAL), octet string.
- msg_1,..., msg_L (OPTIONAL), octet strings. Messages in input to Sign.
- H_1,..., H_L (OPTIONAL), points of G1. The generators in input to Sign.
- RevealedIndexes (OPTIONAL), vector of unsigned integers. Indexes of revealed messages.

Parameters:

- Ciphersuite_ID (REQUIRED), ASCII string. The unique ID of the ciphersuite.
- H_s (REQUIRED), point of G1. The generator for the blinding value of the signature.
- H_d (REQUIRED), point of G1. The generator used to sign the signature domain.

Definitions:

- L, is the non-negative integer representing the number of messages to be signed e.g length(msg_1,...,msg_L). Note if no messages are supplied as an input to this operation, the value of L MUST evaluate to zero (0).
- R, is the non-negative integer representing the number of revealed messages e.g length(RevealedIndexes). Note if no revealed messages are supplied as an input to this operation, the value of R MUST evaluate to zero (0).

Outputs:

- proof, octet string; or INVALID.

Procedure:

1. signature_result = octets_to_signature(signature)

2. (i1, i2,..., iR) = RevealedIndexes

3. (j1, j2,..., jU) = [L] \ RevealedIndexes

4. if signature_result is INVALID, return INVALID

5. (A, e, s) = signature_result

6. if KeyValidate(PK) is INVALID, return INVALID

7. generators =  (H_s || H_d || H_1 || ... || H_L)

8. domain = OS2IP(hash(PK || L || generators || Ciphersuite_ID || header)) mod r

9. for element in (r1, r2, e~, r2~, r3~, s~, m~_j1, ..., m~_jU):

10.      element = hash(PRF(8*ceil(log2(r)))) mod r

11.      if element = 0, go back to step 7

12. B = P1 + H_s * s + H_d * domain + H_1 * msg_1 + ... + H_L * msg_L

13. r3 = r1 ^ -1 mod r

14. A' = A * r1

15. Abar = A' * (-e) + B * r1

16. D = B * r1 + H_s * r2

17. s' = s + r2 * r3

18. C1 = A' * e~ + H_s * r2~

19. C2 = D * (-r3~) + H_s * s~ + H_j1 * m~_j1 + ... + H_jU * m~_jU

20. c = hash(PK || Abar || A' || D || C1 || C2 || ph)

21. e^ = e~ + c * e

22. r2^ = r2~ + c * r2

23. r3^ = r3~ + c * r3

24. s^ = s~ + c * s'

25. for j in (j1, j2,..., jU): m^_j = m~_j + c * msg_j

26. proof = (A', Abar, D, c, e^, r2^, r3^, s^, (m^_j1, ..., m^_jU))

27. return proof
```

### ProofVerify

This operation checks that a proof is valid for a header, vector of revealed messages (along side their index corresponding to their original position when signed) and presentation header against a public key (PK).

```
result = ProofVerify(PK, proof, ph, header, (msg_i1,..., msg_iR), RevealedIndexes, (H_1,..., H_L))

Inputs:

- PK (REQUIRED), an octet string of the form outputted by the SkToPk operation.
- proof (REQUIRED), an octet string of the form outputted by the ProofGen operation.
- ph (REQUIRED), octet string.
- header (OPTIONAL), an optional octet string containing context and application specific information. If not supplied, it defaults to an empty string.
- msg_i1,..., msg_iR (OPTIONAL), octet strings. The revealed messages in input to ProofGen.
- RevealedIndexes (OPTIONAL), vector of unsigned integers. Indexes of revealed messages.
- H_1,..., H_L (OPTIONAL), points of G1. The generators in input to Sign.

Parameters:

- Ciphersuite_ID (REQUIRED), ASCII string. The unique ID of the ciphersuite.
- H_s (REQUIRED), point of G1. The generator for the blinding value of the signature.
- H_d (REQUIRED), point of G1. The generator used to sign the signature domain.

Definitions:

- L, is the non-negative integer representing the number of messages to be signed e.g length(msg_1,...,msg_L). Note if no messages are supplied as an input to this operation, the value of L MUST evaluate to zero (0).
- R, is the non-negative integer representing the number of revealed messages e.g length(RevealedIndexes). Note if no revealed messages are supplied as an input to this operation, the value of R MUST evaluate to zero (0).

Outputs:

- result, either VALID or INVALID.

Procedure:

1. if KeyValidate(PK) is INVALID, return INVALID

2. (i1, i2, ..., iR) = RevealedIndexes

3. (j1, j2, ..., jU) = [L]\RevealedIndexes

4. (A', Abar, D, c, e^, r2^, r3^, s^, (m^_j1,...,m^_jU)) = proof

5. generators =  (H_s || H_d || H_1 || ... || H_L)

6. domain = OS2IP(hash(PK || L || generators || Ciphersuite_ID || header)) mod r

7. C1 = (Abar - D) * c + A' * e^ + H_s * r2^

8. T = P1 + H_s * domain + H_i1 * msg_i1 + ... H_iR * msg_iR

9. C2 = T * c + D * (-r3^) + H_s * s^ + H_j1 * m^_j1 + ... + H_jU * m^_jU

10. cv = hash(PK || Abar || A' || D || C1 || C2 || ph)

11. if c != cv, return INVALID

12. if A' == 1, return INVALID

13. if e(A', W) * e(Abar, -P2) != 1, return INVALID

14. return VALID
```

### CreateGenerators

The CreateGenerators operation defines how to create a set of generators that form a part of the public parameters used by the BBS Signature scheme to accomplish operations such as Sign, Verify, ProofGen and ProofVerify.
It is used to compute the set of message generators (`H_1`, `H_2`, etc.,), the signature blinding value generator (`H_s`), and the signature domain generator (`H_d`).

```
generators = CreateGenerators(dst, seed, length);

Inputs:

- dst (REQUIRED), octet string. Domain Separation Tag.
- seed (REQUIRED), octet string.
- length (REQUIRED), unsigned integer. Number of generators to create from the seed and dst.

Outputs:

- generators, an array of generators.

Procedure:

1. h = xof(seed)

2. for i in 0 to length:

3.    generator_i = Identity_G1

4.    while(generator_i == Identity_G1 or generator_i == P1)

5.        candidate = hash_to_curve_g1(h.read(xof_no_of_bytes), dst)

6.        if candidate not in generators: generator_i = candidate

7. return generators
```

### MapMessageToScalar

There are multiple ways in which messages can be mapped to their respective scalar values, which is their required form to be used with the Sign, Verify, ProofGen and ProofVerify operations.

#### MapMessageToScalarAsHash

This operation takes an input message and maps it to a scalar value via a cryptographic hash function for the given curve.

```
result = MapMessageToScalarAsHash(msg, dst)

Inputs:

- msg (REQUIRED), octet string.
- dst (REQUIRED), octet string. Domain separation tag; note this is not defined as a function argument as per [@!I-D.irtf-cfrg-hash-to-curve] instead as a parameter.

Outputs:

- result, a scalar value.

Procedure:

1. If len(dst) > 2^8 - 1 or len(msg) > 2^64 - 1, abort

2. dst_prime = I2OSP(len(dst), 1) || dst

3. msg_prime = I2OSP(len(msg), 8) || msg

4. result = hash_to_scalar(msg_prime || dst_prime, 1)

5. return result
```

### Hash to scalar

This operation describes how to hash an arbitrary octet string to `n` scalar values in the multiplicative group of integers mod r. This procedure acts as a helper function, and it is used internally in various places within the operations described in the spec. To map a message to a scalar that would be passed as input to the [Sign](#sign), [Verify](#verify), [ProofGen](#proofgen) and [ProofVerify](#proofgen) functions, one must use [MapMessageToScalarAsHash](#mapmessagetoscalar) instead.

The `hash_to_scalar` procedure hashes elements using an extendable-output function (xof). Applications not wishing to use an xof may use `hash_to_field` defined in Section 5.3 of [@!I-D.irtf-cfrg-hash-to-curve], combined with `expand_message_xmd` defined in Section 5.4.1 of the same document, in place of `hash_to_scalar`. In that case, every element outputted by `hash_to_field` that is equal to 0 MUST be rejected. If that occurs, one should calculate more field elements (using `hash_to_field`), until they get `n` non-zero elements (for example, if there is only one 0 in the output of `hash_to_field(msg, 2)` one must try to calculate `hash_to_field(msg, 3)` etc.).

```
result = hash_to_scalar(msg_octets, n)

Inputs:

- msg_octets (REQUIRED), octet string. The message to be hashed.
- n (REQUIRED), non-negative integer. The number of scalars to output.

Parameters:

- r (REQUIRED), non-negative integer. The prime order of the G_1 and G_2 groups,
     defined by the ciphersuite.

Outputs:

- (scalar_1, ..., scalar_n), a list of non-zero scalars mod r.

Procedure:

1. h = xof(msg_octets)

2. for i in (1, ..., n):

3.     scalar_i = OS2IP(h.read(64)) mod r

4.     if scalar_i is 0, go back to step 3

5. return (scalar_1, ..., scalar_n)
```

### OctetsToSignature

This operation describes how to decode an octet string, validate it and return the underlying components that make up the signature.

```
(A, e, s) = octets_to_signature(signature_octets)

Inputs:

- signature_octets (REQUIRED), octet string of the form output from signature_to_octets operation.

Outputs:

- A, a valid point in the G1 subgroup which is not equal to the identity point.
- e, an integer representing a valid scalar value within the range of 0 < e < r.
- s, an integer representing a valid scalar value within the range of 0 < e < r.

Procedure:

1. if len(signature_octets) != (octet_point_length + 2 * octet_scalar_length), return INVALID

2. a_octets = signature_octets[0..(octet_point_length - 1)]

3. A = octets_to_point(a_octets)

4. if A is INVALID, return INVALID

5. if A == Identity_G1, return INVALID

5. index = octet_point_length

6. e = OS2IP(signature_octets[index..(index + octet_scalar_length - 1)])

7. if e = 0 OR e >= r, return INVALID

8. index += octet_scalar_length

9. s = OS2IP(signature_octets[index..(index + octet_scalar_length - 1)])

10. if s = 0 OR s >= r, return INVALID

11. return (A, e, s)
```

### SignatureToOctets

This operation describes how to encode a signature to an octet string.

*Note* this operation deliberately does not perform the relevant checks on the inputs `A` `e` and `s`
because its assumed these are done prior to its invocation, e.g as is the case with the Sign operation.

```
signature_octets = signature_to_octets(A, e, s)

Inputs:

- A (REQUIRED), a valid point in the G1 subgroup which is not equal to the identity point.
- e (REQUIRED), an integer representing a valid scalar value within the range of 0 < e < r.
- s (REQUIRED), an integer representing a valid scalar value within the range of 0 < e < r.

Outputs:

- signature_octets, octet string.

Procedure:

1. A_octets = point_to_octets(A)

2. e_octets = I2OSP(e, octet_scalar_length)

3. s_octets = I2OSP(s, octet_scalar_length)

4. return (a_octets || e_octets || s_octets)
```

# Security Considerations

## Validating public keys

It is RECOMMENDED for any operation in (#operations) involving public keys that do not have an explicit invocation to the KeyValidate operation (#keyvalidate) documented in their procedure, that this check be performed prior to executing the operation. An example of where this recommendation applies is the sign (#sign) operation. An example of where an explicit invocation to the KeyValidate operation (#keyvalidate) is already defined and therefore required is the verify (#verify) operation.

## Skipping membership checks

Some existing implementations skip the subgroup\_check invocation in Verify (#verify), whose purpose is ensuring that the signature is an element of a prime-order subgroup.  This check is REQUIRED of conforming implementations, for two reasons.

1.  For most pairing-friendly elliptic curves used in practice, the pairing operation e (#notation) is undefined when its input points are not in the prime-order subgroups of E1 and E2. The resulting behavior is unpredictable, and may enable forgeries.

2.  Even if the pairing operation behaves properly on inputs that are outside the correct subgroups, skipping the subgroup check breaks the strong unforgeability property [@ADR02].

## Side channel attacks

Implementations of the signing algorithm SHOULD protect the secret key from side-channel attacks.  One method for protecting against certain side-channel attacks is ensuring that the implementation executes exactly the same sequence of instructions and performs exactly the same memory accesses, for any value of the secret key. In other words, implementations on the underlying pairing-friendly elliptic curve SHOULD run in constant time.

## Randomness considerations

The IKM input to KeyGen MUST be infeasible to guess and MUST be kept secret. One possibility is to generate IKM from a trusted source of randomness.  Guidelines on constructing such a source are outside the scope of this document.

Secret keys MAY be generated using other methods; in this case they MUST be infeasible to guess and MUST be indistinguishable from uniformly random modulo r.

BBS proofs are nondeterministic, meaning care must be taken against attacks arising from using bad randomness, for example, the nonce reuse attack on ECDSA [@HDWH12]. It is RECOMMENDED that the presentation header used in this specification contain a nonce chosen at random from a trusted source of randomness, see the (#presentation-header-selection) for additional considerations.

BlindSign as discussed in 2.10 uses randomness from two parties so care MUST be taken that both sources of randomness are trusted. If one party uses weak randomness, it could compromise the signature.

When a trusted source of randomness is used, signatures and proofs are much harder to forge or break due to the use of multiple nonces.

## Presentation header selection

The signature proofs of knowledge generated in this specification are created using a specified presentation header. A verifier-specified cryptographically random value (e.g., a nonce) featuring in the presentation header provides strong protections against replay attacks, and is RECOMMENDED in most use cases. In some settings, proofs can be generated in a non-interactive fashion, in which case verifiers MUST be able to verify the uniqueness of the presentation header values.

## Implementing hash\_to\_curve\_g1

The security analysis models hash\_to\_curve\_g1 as random oracles.  It is crucial that these functions are implemented using a cryptographically secure hash function.  For this purpose, implementations MUST meet the requirements of [@!I-D.irtf-cfrg-hash-to-curve].

In addition, ciphersuites MUST specify unique domain separation tags for hash\_to\_curve.  Some guidance around defining this can be found in (#ciphersuites).

## Choice of underlying curve

BBS signatures can be implemented on any pairing-friendly curve. However care MUST be taken when selecting one that is appropriate, this specification defines a ciphersuite for using the BLS12-381 curve in (#ciphersuites) which as a curve achieves around 117 bits of security according to a recent NCC ZCash cryptography review [@ZCASH-REVIEW].

## Security of proofs generated by ProofGen

The proof, as returned by ProofGen, is a zero-knowledge proof-of-knowledge [@CDL16]. This guarantees that no information will be revealed about the signature itself or the undisclosed messages, from the output of ProofGen. Note that the security proofs in [@CDL16] work on type 3 pairing setting. This means that G1 should be different from G2 and with no efficient isomorphism between them.

# Ciphersuites

This section defines the format for a BBS ciphersuite. It also gives concrete ciphersuites based on the BLS12-381 pairing-friendly elliptic curve [@!I-D.irtf-cfrg-pairing-friendly-curves].

## Ciphersuite Format

- hash: a cryptographic hash function.

- point\_to\_octets:
a function that returns the canonical representation of the point P as an octet string.

- octets\_to\_point:
a function that returns the point P corresponding to the canonical representation ostr, or INVALID if ostr is not a valid output of point_to_octets.

- hash\_to\_curve\_g1:
A cryptographic hash function that takes as an arbitrary octet string input and returns a point in G1 as defined in [@!I-D.irtf-cfrg-hash-to-curve].

- hash\_to\_curve\_g1\_dst: Domain separation tag used in the hash\_to\_curve\_g1 operation.

- hash\_to\_field: A cryptographic hash function that follows the procedure outlined in section 5.3 of [@!I-D.irtf-cfrg-hash-to-curve].

- hash\_to\_field\_dst: Domain separation tag used in the hash\_to\_field operation.

- hashing\_elements\_to\_scalars: either hash_to_scalar using hash (in this case hash MUST be an xof), or hash_to_field with the additional check and re-calculation of more elements until the desired number of non-zero field elements is returned (as described in [Hash to scalar](#hash-to-scalar)).

- message\_generator\_seed: The seed used to generate the message generators which form part of the public parameters used by the BBS signature scheme, Note there are multiple possible scopes for this seed including; a globally shared seed (where the resulting message generators are common across all BBS signatures); a signer specific seed (where the message generators are specific to a signer); signature specific seed (where the message generators are specific per signature). The ciphersuite MUST define this seed OR how to compute it as a pre-cursor operations to any others.

- blind\_value\_generator\_seed: The seed used to calculate the signature blinding value generator (H_s). Similar to the message\_generator\_seed, there are multiple scopes for the blind\_value\_generator\_seed, with the choices being a global seed, a signer specific seed or a signature specific seed. Also, the ciphersuite MUST define this seed OR how to compute it as a pre-cursor operations to any others.

- signature\_dst\_generator\_seed: The seed for calculating the generator used to sign the signature domain separation tag. The scopes and requirements for this seed are the same as the scopes and requirements of the message\_generator\_seed and blind\_value\_generator\_seed.

- xof\_no\_of\_bytes: Number of bytes to draw from the xof when performing operations such as creating generators as per the operation documented in (#creategenerators) or computing the e and s components of the signature generated in (#sign). It is RECOMMENDED this value be set to one greater than `ceil(r+k)/8` for the ciphersuite, where `r` and `k` are parameters from the underlying pairing friendly curve being used.

- octet\_scalar\_length: Number of bytes to represent a scalar value, in the multiplicative group of integers mod r, encoded as an octet string. It is RECOMMENDED this value be set to `ceil(log2(r)/8)`.

- octet\_point\_length: Number of bytes to represent a point encoded as an octet string outputted by the point_to_octets function. It is RECOMMENDED that this value is set to `ceil(log2(p)/8)`.

## BLS12-381 Ciphersuite

hash
: SHAKE-256 as defined in [@!SHA3].

point\_to\_octets
: follows the format documented in Appendix C section 1 of [@!I-D.irtf-cfrg-pairing-friendly-curves].

octets\_to\_point
: follows the format documented in Appendix C section 2 of [@!I-D.irtf-cfrg-pairing-friendly-curves].

hash\_to\_curve_g1
: follows the suite defined in (#bls12-381-hash-to-curve-definition-using-shake-256) for the G1 subgroup.

hash\_to\_curve\_g1\_dst
: "BBS\_BLS12381G1\_XOF:SHAKE-256\_SSWU\_RO".

hash\_to\_field
: adopts the required parameters from the suites defined in (#bls12-381-hash-to-curve-definition-using-shake-256) to satisfy those described in section 5.3 [@!I-D.irtf-cfrg-hash-to-curve] along with the defined dst.

hash\_to\_field\_dst
: "BBS\_BLS12381FQ\_XOF:SHAKE-256\_SSWU\_RO".

message\_generator\_seed
: A global seed value of "BBS\_BLS12381G1\_XOF:SHAKE-256\_SSWU\_RO\_MESSAGE\_GENERATOR\_SEED" which is used by the [CreateGenerators](#creategenerators) operation to compute the required set of message generators.

blind\_value\_generator\_seed
: A global seed value of "BBS\_BLS12381G1\_XOF:SHAKE-256\_SSWU\_RO\_SIGNATURE\_BLINDING\_VALUE\_GENERATOR\_SEED" which is used by the [CreateGenerators](#creategenerators) operation to compute the signature blinding value generator (H_s).

signature\_dst\_generator\_seed
: A global seed value of "BBS\_BLS12381G1\_XOF:SHAKE-256\_SSWU\_RO\_SIGNATURE\_DST\_GENERATOR\_SEED" which is used by the [CreateGenerators](#creategenerators) operation to compute the generator used to sign the signature domain separation tag (H_d).

hashing\_elements\_to\_scalars
: hash\_to\_scalar.

xof\_no\_of\_bytes
: 64.

octet\_scalar\_length
: 32, based on the RECOMMENDED approach of `ceil(log2(r)/8)`.

octet\_point\_length
: 48, based on the RECOMMENDED approach of `ceil(log2(p)/8)`.

### Test Vectors

The following section details a basic set of test vectors that can be used to confirm an implementations correctness

**NOTE** All binary data below is represented as octet strings encoded in hexadecimal format

**NOTE** These fixtures are a work in progress and subject to change

Further fixtures are available in (#additional-bls12-381-ciphersuite-test-vectors)

#### Message Generators

Following the procedure defined in (#creategenerators) with an input seed value of

```
BBS_BLS12381G1_XOF:SHAKE-256_SSWU_RO_MESSAGE_GENERATOR_SEED
```

a dst of

```
BBS_BLS12381G1_XOF:SHAKE-256_SSWU_RO_
```

and a length value of `10`

Outputs the following values

```
{{ $generators[0] }}

{{ $generators[1] }}

{{ $generators[2] }}

{{ $generators[3] }}

{{ $generators[4] }}

{{ $generators[5] }}

{{ $generators[6] }}

{{ $generators[7] }}

{{ $generators[8] }}

{{ $generators[9] }}
```

#### Key Pair

Following the procedure defined in (#keygen) with an input IKM value as follows

```
{{ $keyPair.seed }}
```

Outputs the following SK value

```
{{ $keyPair.keyPair.secretKey }}
```

Following the procedure defined in (#sktopk) with an input SK value as above produces the following PK value

```
{{ $keyPair.keyPair.publicKey }}
```

#### Valid Single Message Signature

Using the following message

```
{{ $signatureFixtures.signature001.messages[0] }}
```

Along with the SK value as defined in (#key-pair) as inputs into the Sign operations, yields the following output signature

```
{{ $signatureFixtures.signature001.signature }}
```

#### Valid Multi-Message Signature

Using the following messages (**Note** the ordering of the messages MUST be preserved)

```
{{ $signatureFixtures.signature004.messages[0] }}

{{ $signatureFixtures.signature004.messages[1] }}

{{ $signatureFixtures.signature004.messages[2] }}

{{ $signatureFixtures.signature004.messages[3] }}

{{ $signatureFixtures.signature004.messages[4] }}

{{ $signatureFixtures.signature004.messages[5] }}

{{ $signatureFixtures.signature004.messages[6] }}

{{ $signatureFixtures.signature004.messages[7] }}

{{ $signatureFixtures.signature004.messages[8] }}

{{ $signatureFixtures.signature004.messages[9] }}
```

Along with the SK value as defined in (#key-pair) as inputs into the Sign operations, yields the following output signature

```
{{ $signatureFixtures.signature004.signature }}
```

# IANA Considerations

This document does not make any requests of IANA.

{backmatter}

# Appendix

## BLS12-381 hash\_to\_curve definition using SHAKE-256

The following defines a hash_to_curve suite [@!I-D.irtf-cfrg-hash-to-curve] for the BLS12-381 curve for both the G1 and G2 subgroups using the extendable output function (xof) of SHAKE-256 as per the guidance defined in section 8.9 of [@!I-D.irtf-cfrg-hash-to-curve].

Note the notation used in the below definitions is sourced from [@!I-D.irtf-cfrg-hash-to-curve].

### BLS12-381 G1

The suite of `BLS12381G1_XOF:SHAKE-256_SSWU_R0_` is defined as follows:

```
* encoding type: hash_to_curve (Section 3 of [@!I-D.irtf-cfrg-hash-to-curve])

* E: y^2 = x^3 + 4

* p: 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab

* m: 1

* k: 128

* expand_message: expand_message_xof (Section 5.4.2 of [@!I-D.irtf-cfrg-hash-to-curve])

* hash: SHAKE-256

* L: 64

* f: Simplified SWU for AB == 0 (Section 6.6.3 of [@!I-D.irtf-cfrg-hash-to-curve])

* Z: 11

*  E': y'^2 = x'^3 + A' * x' + B', where

      -  A' = 0x144698a3b8e9433d693a02c96d4982b0ea985383ee66a8d8e8981aef
         d881ac98936f8da0e0f97f5cf428082d584c1d

      -  B' = 0x12e2908d11688030018b12e8753eee3b2016c1f0f24f4070a0b9c14f
         cef35ef55a23215a316ceaa5d1cc48e98e172be0

*  iso_map: the 11-isogeny map from E' to E given in Appendix E.2 of [@!I-D.irtf-cfrg-hash-to-curve]

*  h_eff: 0xd201000000010001
```

Note that the h_eff values for this suite are copied from that defined for the `BLS12381G1_XMD:SHA-256_SSWU_RO_` suite defined in section 8.8.1 of [@!I-D.irtf-cfrg-hash-to-curve].

An optimized example implementation of the Simplified SWU mapping to the curve E' isogenous to BLS12-381 G1 is given in Appendix F.2 [@!I-D.irtf-cfrg-hash-to-curve].

### BLS12-381 G2

The suite of `BLS12381G2_XOF:SHAKE-256_SSWU_R0_` is defined as follows:

```
* encoding type: hash_to_curve (Section 3 of [@!I-D.irtf-cfrg-hash-to-curve])

* E: y^2 = x^3 + 4 * (1 + I)

* base field F is GF(p^m), where

  -  p: 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6
         b0f6241eabfffeb153ffffb9feffffffffaaab

  -  m: 2

  -  (1, I) is the basis for F, where I^2 + 1 == 0 in F

* k: 128

* expand_message: expand_message_xof (Section 5.4.2 of [@!I-D.irtf-cfrg-hash-to-curve])

* hash: SHAKE-256

* L: 64

* f: Simplified SWU for AB == 0 (Section 6.6.3 of [@!I-D.irtf-cfrg-hash-to-curve])

* Z: -(2 + I)

*  E': y'^2 = x'^3 + A' * x' + B', where

      -  A' = 240 * I

      -  B' = 1012 * (1 + I)

*  iso_map: the isogeny map from E' to E given in Appendix E.3 of [@!I-D.irtf-cfrg-hash-to-curve]

*  h_eff: 0xbc69f08f2ee75b3584c6a0ea91b352888e2a8e9145ad7689986ff0315
  08ffe1329c2f178731db956d82bf015d1212b02ec0ec69d7477c1ae954cbc06689
  f6a359894c0adebbf6b4e8020005aaa95551
```

Note that the h_eff values for this suite are copied from that defined for the `BLS12381G2_XMD:SHA-256_SSWU_RO_` suite defined in section 8.8.1 of [@!I-D.irtf-cfrg-hash-to-curve].

An optimized example implementation of the Simplified SWU mapping to the curve E' isogenous to BLS12-381 G2 is given in Appendix F.2 [@!I-D.irtf-cfrg-hash-to-curve].

## Usecases

### Non-correlating Security Token

In the most general sense BBS signatures can be used in any application where a cryptographically secured token is required but correlation caused by usage of the token is un-desirable.

For example in protocols like OAuth2.0 the most commonly used form of the access token leverages the JWT format alongside conventional cryptographic primitives such as traditional digital signatures or HMACs. These access tokens are then used by a relying party to prove authority to a resource server during a request. However, because the access token is most commonly sent by value as it was issued by the authorization server (e.g in a bearer style scheme), the access token can act as a source of strong correlation for the relying party. Relevant prior art can be found [here](https://www.ietf.org/archive/id/draft-private-access-tokens-01.html).

BBS Signatures due to their unique properties removes this source of correlation but maintains the same set of guarantees required by a resource server to validate an access token back to its relevant authority (note that an approach to signing JSON tokens with BBS that may be of relevance is the [JWP](https://json-web-proofs.github.io/json-web-proofs/draft-jmiller-json-web-proof.html) format and serialization). In the context of a protocol like OAuth2.0 the access token issued by the authorization server would feature a BBS Signature, however instead of the relying party providing this access token as issued, in their request to a resource server, they derive a unique proof from the original access token and include that in the request instead, thus removing this vector of correlation.

### Improved Bearer Security Token

Bearer based security tokens such as JWT based access tokens used in the OAuth2.0 protocol are a highly popular format for expressing authorization grants. However their usage has several security limitations. Notably a bearer based authorization scheme often has to rely on a secure transport between the authorized party (client) and the resource server to mitigate the potential for a MITM attack or a malicious interception of the access token. The scheme also has to assume a degree of trust in the resource server it is presenting an access token to, particularly when the access token grants more than just access to the target resource server, because in a bearer based authorization scheme, anyone who possesses the access token has authority to what it grants. Bearer based access tokens also suffer from the threat of replay attacks.

Improved schemes around authorization protocols often involve adding a layer of proof of cryptographic key possession to the presentation of an access token, which mitigates the deficiencies highlighted above as well as providing a way to detect a replay attack. However, approaches that involve proof of cryptographic key possession such as DPoP (https://datatracker.ietf.org/doc/html/draft-ietf-oauth-dpop-04) suffer from an increase in protocol complexity. A party requesting authorization must pre-generate appropriate key material, share the public portion of this with the authorization server alongside proving possession of the private portion of the key material. The authorization server must also be-able to accommodate receiving this information and validating it.

BBS Signatures ofter an alternative model that solves the same problems that proof of cryptographic key possession schemes do for bearer based schemes, but in a way that doesn't introduce new up-front protocol complexity. In the context of a protocol like OAuth2.0 the access token issued by the authorization server would feature a BBS Signature, however instead of the relying party providing this access token as issued, in their request to a resource server, they derive a unique proof from the original access token and include that in the request instead. Because the access token is not shared in a request to a resource server, attacks such as MITM are mitigated. A resource server also obtains the ability to detect a replay attack by ensuring the proof presented is unique.

### Hardware Attestations

TODO

### Selectively Disclosure Enabled Identity Assertions

TODO

### Privacy preserving bound signatures

TODO

## Additional BLS12-381 Ciphersuite Test Vectors

**NOTE** These fixtures are a work in progress and subject to change

### Modified Message Signature

Using the following message

```
{{ $signatureFixtures.signature002.messages[0] }}
```

And the following signature

```
{{ $signatureFixtures.signature002.signature }}
```

Along with the PK value as defined in (#key-pair) as inputs into the Verify operation should fail signature validation due to the message value being different from what was signed

### Extra Unsigned Message Signature

Using the following messages

```
{{ $signatureFixtures.signature003.messages[0] }}

{{ $signatureFixtures.signature003.messages[1] }}
```

And the following signature

```
{{ $signatureFixtures.signature002.signature }}
```

Along with the PK value as defined in (#key-pair) as inputs into the Verify operation should fail signature validation due to an additional message being supplied that was not signed

### Missing Message Signature

Using the following messages

```
{{ $signatureFixtures.signature005.messages[0] }}

{{ $signatureFixtures.signature005.messages[1] }}
```

And the following signature

```
{{ $signatureFixtures.signature005.signature }}
```

Along with the PK value as defined in (#key-pair) as inputs into the Verify operation should fail signature validation due to missing messages that were originally present during the signing

### Reordered Message Signature

Using the following messages

```
{{ $signatureFixtures.signature006.messages[0] }}

{{ $signatureFixtures.signature006.messages[1] }}

{{ $signatureFixtures.signature006.messages[2] }}

{{ $signatureFixtures.signature006.messages[3] }}

{{ $signatureFixtures.signature006.messages[4] }}

{{ $signatureFixtures.signature006.messages[5] }}

{{ $signatureFixtures.signature006.messages[6] }}

{{ $signatureFixtures.signature006.messages[7] }}

{{ $signatureFixtures.signature006.messages[8] }}

{{ $signatureFixtures.signature006.messages[9] }}
```

And the following signature

```
{{ $signatureFixtures.signature006.signature }}
```

Along with the PK value as defined in (#key-pair) as inputs into the Verify operation should fail signature validation due to messages being re-ordered from the order in which they were signed

### Wrong Public Key Signature

Using the following messages

```
{{ $signatureFixtures.signature007.messages[0] }}

{{ $signatureFixtures.signature007.messages[1] }}

{{ $signatureFixtures.signature007.messages[2] }}

{{ $signatureFixtures.signature007.messages[3] }}

{{ $signatureFixtures.signature007.messages[4] }}

{{ $signatureFixtures.signature007.messages[5] }}

{{ $signatureFixtures.signature007.messages[6] }}

{{ $signatureFixtures.signature007.messages[7] }}

{{ $signatureFixtures.signature007.messages[8] }}

{{ $signatureFixtures.signature007.messages[9] }}
```

And the following signature

```
{{ $signatureFixtures.signature007.signature }}
```

Along with the PK value as defined in (#key-pair) as inputs into the Verify operation should fail signature validation due to public key used to verify is in-correct

## Proof Generation and Verification Algorithmic Explanation

The following section provides an explanation of how the ProofGen and ProofVerify operations work.

Let the prover be in possession of a BBS signature `(A, e, s)` with `A = B * (1/(e + Sk))` where `Sk` the signer's secret key and,

    B = P1 + h0 * s + h[1] * msg_1 + ... + h[L] * msg_L

(without loss of generality we assume that the messages and generators are indexed from 0 to L). Let `(i1,...,iR)` be the indexes of generators corresponding to messages the prover wants to disclose and `(j1,...,jU)` be the indexes corresponding to undisclosed messages (i.e., `(j1,...,jU) = [L] \ (i1,...,iR)`). To prove knowledge of a signature on the disclosed messages, work as follows,

- Randomize the signature `(A, e, s)`, by taking uniformly random `r1`, `r2` in [1, r-1], and calculate,

        1.  A' = A * r1,
        2.  Abar = A' * (-e) + B * r1
        3.  D = B * r1 + H0 * r2.

  Also set,

        4.  r3 = r1 ^ -1 mod r
        5.  s' = s + r2 * r3.

  The values `(A', Abar, d)` will be part of the proof and are used to prove possession of a BBS signature, without revealing the signature itself. Note that; `e(A', Pk) = e(Abar, P2)` where `Pk` the signer's public key and P2 the base element in G2 (used to create the signer’s `Pk`, see [SkToPk](#sktopk)). This also serves to bind the proof to the signer's `Pk`.

- Set the following,

        1.  C1 = Abar - D
        2.  C2 = P1 +  H_i1 * msg_i1 + ... + H_iR * msg_iR

  Create a non-interactive zero-knowledge generalized Schnorr proof of knowledge (`nizk`) of the values `e, r2, r3, s'` and `msg_j1,...,msg_jU` (the undisclosed messages) so that both of the following equalities hold,

        EQ1.  C1 = A' * (-e) - H0 * r2
        EQ2.  C2 = D * (-r3) + H0 * s' + H_j1 * msg_j1 + ... + H_jU * msg_jU.

  If both EQ1 and EQ2 hold, and `e(A', Pk) = e(Abar, P2)`, an extractor can return a valid BBS signature from the signers `Sk`, on the disclosed messages. The proof returned is `(A', Abar, d, nizk)`. To validate the proof, a verifier checks that `e(A', Pk) = e(Abar, P2)` and verifies `nizk`.

<reference anchor="Bowe19" target="https://eprint.iacr.org/2019/814">
  <front>
    <title>Faster subgroup checks for BLS12-381</title>
    <author initials="S." surname="Bowe" fullname="Sean Bowe">
      <organization>Electric Coin Company</organization>
    </author>
    <date year="2019" month="July"/>
  </front>
</reference>

<reference anchor="SHA3" target="https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-208.pdf">
 <front>
   <title>Recommendation for Stateful Hash-Based Signature Schemes</title>
   <author><organization>NIST</organization></author>
 </front>
</reference>

<reference anchor="CDL16" target="https://eprint.iacr.org/2016/663.pdf">
 <front>
   <title>Anonymous Attestation Using the Strong Diffie Hellman Assumption Revisited</title>
   <author initials="J." surname="Camenisch" fullname="Jan Camenisch">
      <organization>IBM Research</organization>
    </author>
    <author initials="M." surname="Drijvers" fullname="Manu Drijvers">
      <organization>IBM Research</organization>
      <organization>Department of Computer Science, ETH Zurich</organization>
    </author>
    <author initials="A." surname="Lehmann" fullname="Anja Lehmann">
      <organization>IBM Research</organization>
    </author>
    <date year="2016"/>
 </front>
 <seriesInfo name="In" value="International Conference on Trust and Trustworthy Computing"/>
 <seriesInfo name="pages" value="1-20"/>
 <seriesInfo name="Springer," value="Cham"/>
</reference>

<reference anchor="ZCASH-REVIEW" target="https://research.nccgroup.com/wp-content/uploads/2020/07/NCC_Group_Zcash2018_Public_Report_2019-01-30_v1.3.pdf">
 <front>
   <title>Zcash Overwinter Consensus and Sapling Cryptography Review</title>
   <author><organization>NCC Group</organization></author>
 </front>
</reference>

<reference anchor="HDWH12" target="https://www.usenix.org/system/files/conference/usenixsecurity12/sec12-final228.pdf">
  <front>
    <title>Mining your Ps and Qs: Detection of widespread weak keys in network devices</title>
    <author initials="N." surname="Heninger" fullname="Nadia Heninger">
      <organization>University of California, San Diego</organization>
    </author>
    <author initials="Z." surname="Durumeric" fullname="Zakir Durumeric">
      <organization>The University of Michigan</organization>
    </author>
    <author initials="E." surname="Wustrow" fullname="Eric Wustrow">
      <organization>The University of Michigan</organization>
    </author>
    <author initials="J.A." surname="Halderman" fullname="J. Alex Halderman">
      <organization>The University of Michigan</organization>
    </author>
    <date year="2012" month="August"/>
  </front>
  <seriesInfo name="In" value="USENIX Security"/>
  <seriesInfo name="pages" value="205-220"/>
</reference>

<reference anchor="ADR02" target="https://doi.org/10.1007/3-540-46035-7_6">
  <front>
    <title>On the Security of Joint Signature and Encryption</title>
    <author initials="J. H." surname="An" fullname="Jee Hea An">
      <organization>SoftMax Inc.</organization>
    </author>
    <author initials="Y." surname="Dodis" fullname="Yevgeniy Dodis">
      <organization>New York University</organization>
    </author>
    <author initials="T." surname="Rabin" fullname="Tal Rabin">
      <organization>IBM T.J. Watson Research Center</organization>
    </author>
    <date year="2002" month="April"/>
  </front>
  <seriesInfo name="In" value="EUROCRYPT"/>
  <seriesInfo name="pages" value="83-107"/>
</reference>
